/****************************************************************-*- C++ -*-****
 * Copyright (c) 2022 - 2025 NVIDIA Corporation & Affiliates.                  *
 * All rights reserved.                                                        *
 *                                                                             *
 * This source code and the accompanying materials are made available under    *
 * the terms of the Apache License 2.0 which accompanies this distribution.    *
 ******************************************************************************/

#pragma once

#include "common/ExecutionContext.h"
#include "common/KernelWrapper.h"
#include "common/MeasureCounts.h"
#include "cudaq/algorithms/broadcast.h"
#include "cudaq/concepts.h"
#include "cudaq/host_config.h"

namespace nvqir {
class CircuitSimulator;
}

extern "C" {
void __nvqir__setCircuitSimulator(nvqir::CircuitSimulator *);
void __nvqir__resetCircuitSimulator();
nvqir::CircuitSimulator *__nvqir__getResourceCounterCircuitSimulator();
}

namespace cudaq {
bool kernelHasConditionalFeedback(const std::string &);
namespace __internal__ {
bool isKernelGenerated(const std::string &);
}

/// @overload
/// @brief Sample the given quantum kernel expression and return the
/// mapping of observed bit strings to corresponding number of
/// times observed. Specify the number of shots.
///
/// @param shots The number of samples to collect.
/// @param kernel The kernel expression, must contain final measurements.
/// @param args The variadic concrete arguments for evaluation of the kernel.
/// @returns The counts dictionary.
///
/// @details Given a quantum kernel with void return type, sample
///          the corresponding quantum circuit generated by the kernel
///          expression, returning the mapping of bits observed to number
///          of times it was observed.
#if CUDAQ_USE_STD20
template <typename QuantumKernel, typename... Args>
  requires SampleCallValid<QuantumKernel, Args...>
#else
template <typename QuantumKernel, typename... Args,
          typename = std::enable_if_t<
              std::is_invocable_r_v<void, QuantumKernel, Args...>>>
#endif
auto count_resources(std::function<bool()> choice, QuantumKernel &&kernel,
                     Args &&...args) {
  // Need the code to be lowered to llvm and the kernel to be registered
  // so that we can check for conditional feedback / mid circ measurement
  if constexpr (has_name<QuantumKernel>::value) {
    static_cast<cudaq::details::kernel_builder_base &>(kernel).jitCode();
  }

  auto *resource_counter = __nvqir__getResourceCounterCircuitSimulator();
  __nvqir__setCircuitSimulator(resource_counter);

  // Run this SHOTS times
  auto &platform = cudaq::get_platform();
  auto kernelName = cudaq::getKernelName(kernel);
  auto hasConditionalFeebdback =
      cudaq::kernelHasConditionalFeedback(kernelName);
  // Create the execution context.
  auto ctx = std::make_unique<ExecutionContext>("resourcecount", 1);
  ctx->kernelName = kernelName;
  ctx->hasConditionalsOnMeasureResults = hasConditionalFeebdback;
  ctx->choice = choice;

  // Indicate that this is not an async exec
  ctx->asyncExec = false;

  // Set the platform
  platform.set_exec_ctx(ctx.get());

  cudaq::invokeKernel(std::forward<QuantumKernel>(kernel),
                      std::forward<Args>(args)...);

  __nvqir__resetCircuitSimulator();

  return ctx->resourceCounts;
}
} // namespace cudaq
