/****************************************************************-*- C++ -*-****
 * Copyright (c) 2022 - 2025 NVIDIA Corporation & Affiliates.                  *
 * All rights reserved.                                                        *
 *                                                                             *
 * This source code and the accompanying materials are made available under    *
 * the terms of the Apache License 2.0 which accompanies this distribution.    *
 ******************************************************************************/

#pragma once

#include "cudaq/Optimizer/Dialect/CC/CCOps.h"
#include "cudaq/Optimizer/Dialect/CC/CCTypes.h"
#include "cudaq/qis/state.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/Types.h"
#include <list>
#include <unordered_set>
#include <vector>

namespace cudaq::opt {

class ArgumentConverter {
public:
  /// Build an instance to create argument substitutions for a specified \p
  /// kernelName in \p sourceModule.
  ArgumentConverter(mlir::StringRef kernelName, mlir::ModuleOp sourceModule);

  /// Build an instance to create argument substitutions for a specified \p
  /// kernelName in \p sourceModule. Use \p kernelRegistry to store newly
  /// generated functions.
  ArgumentConverter(std::list<std::string> &kernelRegistry,
                    mlir::StringRef kernelName, mlir::ModuleOp sourceModule);

  /// Generate a substitution ModuleOp for the vector of arguments presented.
  /// The arguments are those presented to the kernel, kernelName.
  void gen(const std::vector<void *> &arguments);

  /// Generate a substitution ModuleOp but include only the arguments that do
  /// not appear in the set of \p exclusions.
  void gen(const std::vector<void *> &arguments,
           const std::unordered_set<unsigned> &exclusions);

  /// Generate a substitution ModuleOp but drop the first \p numDrop arguments
  /// and thereby exclude them from the substitutions.
  void gen_drop_front(const std::vector<void *> &arguments, unsigned numDrop);

  /// Get the list of substitutions that were generated by `gen()`.
  mlir::SmallVector<cudaq::cc::ArgumentSubstitutionOp> &getSubstitutions() {
    return substitutions;
  }

  /// Some substitutions may generate global constant information. Use this
  /// interface to access both the substitutions and any global constants
  /// created.
  mlir::ModuleOp getSubstitutionModule() { return substModule; }

  /// Kernel we are converting the arguments for.
  mlir::StringRef getKernelName() { return kernelName; }

  /// Return child converters for functions created from kernel used in state
  /// arguments.
  std::vector<ArgumentConverter> &getCalleeConverters() {
    return calleeConverters;
  }

  /// Is kernel name already created?
  bool isRegisteredKernel(const std::string &kernelName) {
    return std::find(kernelRegistry.begin(), kernelRegistry.end(),
                     kernelName) != kernelRegistry.end();
  }

  /// Store kernel name in memory for newly created kernels.
  const std::string &registerKernel(const std::string &kernelName) {
    return kernelRegistry.emplace_back(kernelName);
  }

private:
  /// Default registry to use when state synthesis is not needed.
  static std::list<std::string> emptyRegistry;

  /// Create a child converter for the new callee created from a
  /// state argument.
  ArgumentConverter &createCalleeConverter(mlir::StringRef calleeName) {
    assert(&kernelRegistry != &emptyRegistry &&
           "Argument converter is missing a kernel registry");
    return calleeConverters.emplace_back(kernelRegistry, calleeName,
                                         substModule);
  }

  mlir::ModuleOp sourceModule;
  mlir::ModuleOp substModule;
  mlir::OpBuilder builder;
  mlir::StringRef kernelName;
  mlir::SmallVector<cc::ArgumentSubstitutionOp> substitutions;

  /// Converters for functions created during state argument conversion.
  std::vector<ArgumentConverter> calleeConverters;

  /// Keeps new kernel names created during argument conversion in memory.
  /// References to the names are used by the argument converters for
  /// their kernels.
  /// NOTE: use `std::list` to make sure we always return valid references
  /// when registering new kernel names, as the references are taken while
  /// the list is growing.
  std::list<std::string> &kernelRegistry;

  friend ArgumentConverter &createChildConverter(ArgumentConverter &parent,
                                                 std::string &calleeName);
};

ArgumentConverter &createChildConverter(ArgumentConverter &parent,
                                        std::string &calleeName);

} // namespace cudaq::opt
