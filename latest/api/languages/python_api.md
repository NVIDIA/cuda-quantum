::: {.wy-grid-for-nav}
::: {.wy-side-scroll}
::: {.wy-side-nav-search style="background: #76b900"}
[NVIDIA CUDA-Q](../../index.html){.icon .icon-home}

::: {.version}
latest
:::

::: {role="search"}
:::
:::

::: {.wy-menu .wy-menu-vertical spy="affix" role="navigation" aria-label="Navigation menu"}
[Contents]{.caption-text}

-   [Quick Start](../../using/quick_start.html){.reference .internal}
    -   [Install
        CUDA-Q](../../using/quick_start.html#install-cuda-q){.reference
        .internal}
    -   [Validate your
        Installation](../../using/quick_start.html#validate-your-installation){.reference
        .internal}
    -   [CUDA-Q
        Academic](../../using/quick_start.html#cuda-q-academic){.reference
        .internal}
-   [Basics](../../using/basics/basics.html){.reference .internal}
    -   [What is a CUDA-Q
        Kernel?](../../using/basics/kernel_intro.html){.reference
        .internal}
    -   [Building your first CUDA-Q
        Program](../../using/basics/build_kernel.html){.reference
        .internal}
    -   [Running your first CUDA-Q
        Program](../../using/basics/run_kernel.html){.reference
        .internal}
        -   [Sample](../../using/basics/run_kernel.html#sample){.reference
            .internal}
        -   [Run](../../using/basics/run_kernel.html#run){.reference
            .internal}
        -   [Observe](../../using/basics/run_kernel.html#observe){.reference
            .internal}
        -   [Running on a
            GPU](../../using/basics/run_kernel.html#running-on-a-gpu){.reference
            .internal}
    -   [Troubleshooting](../../using/basics/troubleshooting.html){.reference
        .internal}
        -   [Debugging and Verbose Simulation
            Output](../../using/basics/troubleshooting.html#debugging-and-verbose-simulation-output){.reference
            .internal}
-   [Examples](../../using/examples/examples.html){.reference .internal}
    -   [Introduction](../../using/examples/introduction.html){.reference
        .internal}
    -   [Building
        Kernels](../../using/examples/building_kernels.html){.reference
        .internal}
        -   [Defining
            Kernels](../../using/examples/building_kernels.html#defining-kernels){.reference
            .internal}
        -   [Initializing
            states](../../using/examples/building_kernels.html#initializing-states){.reference
            .internal}
        -   [Applying
            Gates](../../using/examples/building_kernels.html#applying-gates){.reference
            .internal}
        -   [Controlled
            Operations](../../using/examples/building_kernels.html#controlled-operations){.reference
            .internal}
        -   [Multi-Controlled
            Operations](../../using/examples/building_kernels.html#multi-controlled-operations){.reference
            .internal}
        -   [Adjoint
            Operations](../../using/examples/building_kernels.html#adjoint-operations){.reference
            .internal}
        -   [Custom
            Operations](../../using/examples/building_kernels.html#custom-operations){.reference
            .internal}
        -   [Building Kernels with
            Kernels](../../using/examples/building_kernels.html#building-kernels-with-kernels){.reference
            .internal}
        -   [Parameterized
            Kernels](../../using/examples/building_kernels.html#parameterized-kernels){.reference
            .internal}
    -   [Quantum
        Operations](../../using/examples/quantum_operations.html){.reference
        .internal}
        -   [Quantum
            States](../../using/examples/quantum_operations.html#quantum-states){.reference
            .internal}
        -   [Quantum
            Gates](../../using/examples/quantum_operations.html#quantum-gates){.reference
            .internal}
        -   [Measurements](../../using/examples/quantum_operations.html#measurements){.reference
            .internal}
    -   [Measuring
        Kernels](../../using/examples/measuring_kernels.html){.reference
        .internal}
        -   [Mid-circuit Measurement and Conditional
            Logic](../../using/examples/measuring_kernels.html#mid-circuit-measurement-and-conditional-logic){.reference
            .internal}
    -   [Visualizing
        Kernels](../../examples/python/visualization.html){.reference
        .internal}
        -   [Qubit
            Visualization](../../examples/python/visualization.html#Qubit-Visualization){.reference
            .internal}
        -   [Kernel
            Visualization](../../examples/python/visualization.html#Kernel-Visualization){.reference
            .internal}
    -   [Executing
        Kernels](../../using/examples/executing_kernels.html){.reference
        .internal}
        -   [Sample](../../using/examples/executing_kernels.html#sample){.reference
            .internal}
            -   [Sample
                Asynchronous](../../using/examples/executing_kernels.html#sample-asynchronous){.reference
                .internal}
        -   [Run](../../using/examples/executing_kernels.html#run){.reference
            .internal}
            -   [Return Custom Data
                Types](../../using/examples/executing_kernels.html#return-custom-data-types){.reference
                .internal}
            -   [Run
                Asynchronous](../../using/examples/executing_kernels.html#run-asynchronous){.reference
                .internal}
        -   [Observe](../../using/examples/executing_kernels.html#observe){.reference
            .internal}
            -   [Observe
                Asynchronous](../../using/examples/executing_kernels.html#observe-asynchronous){.reference
                .internal}
        -   [Get
            State](../../using/examples/executing_kernels.html#get-state){.reference
            .internal}
            -   [Get State
                Asynchronous](../../using/examples/executing_kernels.html#get-state-asynchronous){.reference
                .internal}
    -   [Computing Expectation
        Values](../../using/examples/expectation_values.html){.reference
        .internal}
        -   [Parallelizing across Multiple
            Processors](../../using/examples/expectation_values.html#parallelizing-across-multiple-processors){.reference
            .internal}
    -   [Multi-GPU
        Workflows](../../using/examples/multi_gpu_workflows.html){.reference
        .internal}
        -   [From CPU to
            GPU](../../using/examples/multi_gpu_workflows.html#from-cpu-to-gpu){.reference
            .internal}
        -   [Pooling the memory of multiple GPUs (`mgpu`{.code .docutils
            .literal
            .notranslate})](../../using/examples/multi_gpu_workflows.html#pooling-the-memory-of-multiple-gpus-mgpu){.reference
            .internal}
        -   [Parallel execution over multiple QPUs (`mqpu`{.code
            .docutils .literal
            .notranslate})](../../using/examples/multi_gpu_workflows.html#parallel-execution-over-multiple-qpus-mqpu){.reference
            .internal}
            -   [Batching Hamiltonian
                Terms](../../using/examples/multi_gpu_workflows.html#batching-hamiltonian-terms){.reference
                .internal}
            -   [Circuit
                Batching](../../using/examples/multi_gpu_workflows.html#circuit-batching){.reference
                .internal}
        -   [Multi-QPU + Other Backends (`remote-mqpu`{.code .docutils
            .literal
            .notranslate})](../../using/examples/multi_gpu_workflows.html#multi-qpu-other-backends-remote-mqpu){.reference
            .internal}
    -   [Optimizers &
        Gradients](../../examples/python/optimizers_gradients.html){.reference
        .internal}
        -   [Built in CUDA-Q Optimizers and
            Gradients](../../examples/python/optimizers_gradients.html#Built-in-CUDA-Q-Optimizers-and-Gradients){.reference
            .internal}
        -   [Third-Party
            Optimizers](../../examples/python/optimizers_gradients.html#Third-Party-Optimizers){.reference
            .internal}
        -   [Parallel Parameter Shift
            Gradients](../../examples/python/optimizers_gradients.html#Parallel-Parameter-Shift-Gradients){.reference
            .internal}
    -   [Noisy
        Simulations](../../examples/python/noisy_simulations.html){.reference
        .internal}
    -   [Constructing
        Operators](../../using/examples/operators.html){.reference
        .internal}
        -   [Constructing Spin
            Operators](../../using/examples/operators.html#constructing-spin-operators){.reference
            .internal}
        -   [Pauli Words and Exponentiating Pauli
            Words](../../using/examples/operators.html#pauli-words-and-exponentiating-pauli-words){.reference
            .internal}
    -   [Performance
        Optimizations](../../examples/python/performance_optimizations.html){.reference
        .internal}
        -   [Gate
            Fusion](../../examples/python/performance_optimizations.html#Gate-Fusion){.reference
            .internal}
    -   [Using Quantum Hardware
        Providers](../../using/examples/hardware_providers.html){.reference
        .internal}
        -   [Amazon
            Braket](../../using/examples/hardware_providers.html#amazon-braket){.reference
            .internal}
        -   [Anyon
            Technologies](../../using/examples/hardware_providers.html#anyon-technologies){.reference
            .internal}
        -   [Infleqtion](../../using/examples/hardware_providers.html#infleqtion){.reference
            .internal}
        -   [IonQ](../../using/examples/hardware_providers.html#ionq){.reference
            .internal}
        -   [IQM](../../using/examples/hardware_providers.html#iqm){.reference
            .internal}
        -   [OQC](../../using/examples/hardware_providers.html#oqc){.reference
            .internal}
        -   [ORCA
            Computing](../../using/examples/hardware_providers.html#orca-computing){.reference
            .internal}
        -   [Pasqal](../../using/examples/hardware_providers.html#pasqal){.reference
            .internal}
        -   [Quantinuum](../../using/examples/hardware_providers.html#quantinuum){.reference
            .internal}
        -   [Quantum
            Machines](../../using/examples/hardware_providers.html#quantum-machines){.reference
            .internal}
        -   [QuEra
            Computing](../../using/examples/hardware_providers.html#quera-computing){.reference
            .internal}
    -   [Dynamics
        Examples](../../using/examples/dynamics_examples.html){.reference
        .internal}
        -   [Introduction to CUDA-Q Dynamics (Jaynes-Cummings
            Model)](../../examples/python/dynamics/dynamics_intro_1.html){.reference
            .internal}
            -   [Why dynamics simulations vs. circuit
                simulations?](../../examples/python/dynamics/dynamics_intro_1.html#Why-dynamics-simulations-vs.-circuit-simulations?){.reference
                .internal}
            -   [Functionality](../../examples/python/dynamics/dynamics_intro_1.html#Functionality){.reference
                .internal}
            -   [Performance](../../examples/python/dynamics/dynamics_intro_1.html#Performance){.reference
                .internal}
            -   [Section 1 - Simulating the Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Section-1---Simulating-the-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Exercise 1 - Simulating a many-photon Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-1---Simulating-a-many-photon-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Section 2 - Simulating open quantum systems with the
                `collapse_operators`{.docutils .literal
                .notranslate}](../../examples/python/dynamics/dynamics_intro_1.html#Section-2---Simulating-open-quantum-systems-with-the-collapse_operators){.reference
                .internal}
            -   [Exercise 2 - Adding additional jump operators
                [\\(L\_i\\)]{.math .notranslate
                .nohighlight}](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-2---Adding-additional-jump-operators-L_i){.reference
                .internal}
            -   [Section 3 - Many qubits coupled to the
                resonator](../../examples/python/dynamics/dynamics_intro_1.html#Section-3---Many-qubits-coupled-to-the-resonator){.reference
                .internal}
        -   [Introduction to CUDA-Q Dynamics (Time Dependent
            Hamiltonians)](../../examples/python/dynamics/dynamics_intro_2.html){.reference
            .internal}
            -   [The Landau-Zener
                model](../../examples/python/dynamics/dynamics_intro_2.html#The-Landau-Zener-model){.reference
                .internal}
            -   [Section 1 - Implementing time dependent
                terms](../../examples/python/dynamics/dynamics_intro_2.html#Section-1---Implementing-time-dependent-terms){.reference
                .internal}
            -   [Section 2 - Implementing custom
                operators](../../examples/python/dynamics/dynamics_intro_2.html#Section-2---Implementing-custom-operators){.reference
                .internal}
            -   [Section 3 - Heisenberg Model with a time-varying
                magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Section-3---Heisenberg-Model-with-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 1 - Define a time-varying magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-1---Define-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 2
                (Optional)](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-2-(Optional)){.reference
                .internal}
        -   [Superconducting
            Qubits](../../examples/python/dynamics/superconducting.html){.reference
            .internal}
            -   [Cavity
                QED](../../examples/python/dynamics/superconducting.html#Cavity-QED){.reference
                .internal}
            -   [Cross
                Resonance](../../examples/python/dynamics/superconducting.html#Cross-Resonance){.reference
                .internal}
            -   [Transmon
                Resonator](../../examples/python/dynamics/superconducting.html#Transmon-Resonator){.reference
                .internal}
        -   [Spin
            Qubits](../../examples/python/dynamics/spinqubits.html){.reference
            .internal}
            -   [Silicon Spin
                Qubit](../../examples/python/dynamics/spinqubits.html#Silicon-Spin-Qubit){.reference
                .internal}
            -   [Heisenberg
                Model](../../examples/python/dynamics/spinqubits.html#Heisenberg-Model){.reference
                .internal}
        -   [Trapped Ion
            Qubits](../../examples/python/dynamics/iontrap.html){.reference
            .internal}
            -   [GHZ
                state](../../examples/python/dynamics/iontrap.html#GHZ-state){.reference
                .internal}
        -   [Control](../../examples/python/dynamics/control.html){.reference
            .internal}
            -   [Gate
                Calibration](../../examples/python/dynamics/control.html#Gate-Calibration){.reference
                .internal}
            -   [Pulse](../../examples/python/dynamics/control.html#Pulse){.reference
                .internal}
            -   [Qubit
                Control](../../examples/python/dynamics/control.html#Qubit-Control){.reference
                .internal}
            -   [Qubit
                Dynamics](../../examples/python/dynamics/control.html#Qubit-Dynamics){.reference
                .internal}
            -   [Landau-Zenner](../../examples/python/dynamics/control.html#Landau-Zenner){.reference
                .internal}
-   [Applications](../../using/applications.html){.reference .internal}
    -   [Max-Cut with
        QAOA](../../applications/python/qaoa.html){.reference .internal}
    -   [Molecular docking via
        DC-QAOA](../../applications/python/digitized_counterdiabatic_qaoa.html){.reference
        .internal}
        -   [Setting up the Molecular Docking
            Problem](../../applications/python/digitized_counterdiabatic_qaoa.html#Setting-up-the-Molecular-Docking-Problem){.reference
            .internal}
        -   [CUDA-Q
            Implementation](../../applications/python/digitized_counterdiabatic_qaoa.html#CUDA-Q-Implementation){.reference
            .internal}
    -   [Multi-reference Quantum Krylov Algorithm - [\\(H\_2\\)]{.math
        .notranslate .nohighlight}
        Molecule](../../applications/python/krylov.html){.reference
        .internal}
        -   [Setup](../../applications/python/krylov.html#Setup){.reference
            .internal}
        -   [Computing the matrix
            elements](../../applications/python/krylov.html#Computing-the-matrix-elements){.reference
            .internal}
        -   [Determining the ground state energy of the
            subspace](../../applications/python/krylov.html#Determining-the-ground-state-energy-of-the-subspace){.reference
            .internal}
    -   [Bernstein-Vazirani
        Algorithm](../../applications/python/bernstein_vazirani.html){.reference
        .internal}
        -   [Classical
            case](../../applications/python/bernstein_vazirani.html#Classical-case){.reference
            .internal}
        -   [Quantum
            case](../../applications/python/bernstein_vazirani.html#Quantum-case){.reference
            .internal}
        -   [Implementing in
            CUDA-Q](../../applications/python/bernstein_vazirani.html#Implementing-in-CUDA-Q){.reference
            .internal}
    -   [Cost
        Minimization](../../applications/python/cost_minimization.html){.reference
        .internal}
    -   [Deutsch's
        Algorithm](../../applications/python/deutsch_algorithm.html){.reference
        .internal}
        -   [XOR [\\(\\oplus\\)]{.math .notranslate
            .nohighlight}](../../applications/python/deutsch_algorithm.html#XOR-\oplus){.reference
            .internal}
        -   [Quantum
            oracles](../../applications/python/deutsch_algorithm.html#Quantum-oracles){.reference
            .internal}
        -   [Phase
            oracle](../../applications/python/deutsch_algorithm.html#Phase-oracle){.reference
            .internal}
        -   [Quantum
            parallelism](../../applications/python/deutsch_algorithm.html#Quantum-parallelism){.reference
            .internal}
        -   [Deutsch's
            Algorithm:](../../applications/python/deutsch_algorithm.html#Deutsch's-Algorithm:){.reference
            .internal}
    -   [Divisive Clustering With Coresets Using
        CUDA-Q](../../applications/python/divisive_clustering_coresets.html){.reference
        .internal}
        -   [Data
            preprocessing](../../applications/python/divisive_clustering_coresets.html#Data-preprocessing){.reference
            .internal}
        -   [Quantum
            functions](../../applications/python/divisive_clustering_coresets.html#Quantum-functions){.reference
            .internal}
        -   [Divisive Clustering
            Function](../../applications/python/divisive_clustering_coresets.html#Divisive-Clustering-Function){.reference
            .internal}
        -   [QAOA
            Implementation](../../applications/python/divisive_clustering_coresets.html#QAOA-Implementation){.reference
            .internal}
        -   [Scaling simulations with
            CUDA-Q](../../applications/python/divisive_clustering_coresets.html#Scaling-simulations-with-CUDA-Q){.reference
            .internal}
    -   [Hybrid Quantum Neural
        Networks](../../applications/python/hybrid_quantum_neural_networks.html){.reference
        .internal}
    -   [Using the Hadamard Test to Determine Quantum Krylov Subspace
        Decomposition Matrix
        Elements](../../applications/python/hadamard_test.html){.reference
        .internal}
        -   [Numerical result as a
            reference:](../../applications/python/hadamard_test.html#Numerical-result-as-a-reference:){.reference
            .internal}
        -   [Using `Sample`{.docutils .literal .notranslate} to perform
            the Hadamard
            test](../../applications/python/hadamard_test.html#Using-Sample-to-perform-the-Hadamard-test){.reference
            .internal}
        -   [Multi-GPU evaluation of QKSD matrix elements using the
            Hadamard
            Test](../../applications/python/hadamard_test.html#Multi-GPU-evaluation-of-QKSD-matrix-elements-using-the-Hadamard-Test){.reference
            .internal}
            -   [Classically Diagonalize the Subspace
                Matrix](../../applications/python/hadamard_test.html#Classically-Diagonalize-the-Subspace-Matrix){.reference
                .internal}
    -   [Anderson Impurity Model ground state solver on Infleqtion's
        Sqale](../../applications/python/logical_aim_sqale.html){.reference
        .internal}
        -   [Performing logical Variational Quantum Eigensolver (VQE)
            with
            CUDA-QX](../../applications/python/logical_aim_sqale.html#Performing-logical-Variational-Quantum-Eigensolver-(VQE)-with-CUDA-QX){.reference
            .internal}
        -   [Constructing circuits in the `[[4,2,2]]`{.docutils .literal
            .notranslate}
            encoding](../../applications/python/logical_aim_sqale.html#Constructing-circuits-in-the-%5B%5B4,2,2%5D%5D-encoding){.reference
            .internal}
        -   [Setting up submission and decoding
            workflow](../../applications/python/logical_aim_sqale.html#Setting-up-submission-and-decoding-workflow){.reference
            .internal}
        -   [Running a CUDA-Q noisy
            simulation](../../applications/python/logical_aim_sqale.html#Running-a-CUDA-Q-noisy-simulation){.reference
            .internal}
        -   [Running logical AIM on Infleqtion's
            hardware](../../applications/python/logical_aim_sqale.html#Running-logical-AIM-on-Infleqtion's-hardware){.reference
            .internal}
    -   [Spin-Hamiltonian Simulation Using
        CUDA-Q](../../applications/python/hamiltonian_simulation.html){.reference
        .internal}
        -   [Introduction](../../applications/python/hamiltonian_simulation.html#Introduction){.reference
            .internal}
            -   [Heisenberg
                Hamiltonian](../../applications/python/hamiltonian_simulation.html#Heisenberg-Hamiltonian){.reference
                .internal}
            -   [Transverse Field Ising Model
                (TFIM)](../../applications/python/hamiltonian_simulation.html#Transverse-Field-Ising-Model-(TFIM)){.reference
                .internal}
            -   [Time Evolution and Trotter
                Decomposition](../../applications/python/hamiltonian_simulation.html#Time-Evolution-and-Trotter-Decomposition){.reference
                .internal}
        -   [Key
            steps](../../applications/python/hamiltonian_simulation.html#Key-steps){.reference
            .internal}
            -   [1. Prepare initial
                state](../../applications/python/hamiltonian_simulation.html#1.-Prepare-initial-state){.reference
                .internal}
            -   [2. Hamiltonian
                Trotterization](../../applications/python/hamiltonian_simulation.html#2.-Hamiltonian-Trotterization){.reference
                .internal}
            -   [3. `Compute overlap`{.docutils .literal
                .notranslate}](../../applications/python/hamiltonian_simulation.html#3.-Compute-overlap){.reference
                .internal}
            -   [4. Construct Heisenberg
                Hamiltonian](../../applications/python/hamiltonian_simulation.html#4.-Construct-Heisenberg-Hamiltonian){.reference
                .internal}
            -   [5. Construct TFIM
                Hamiltonian](../../applications/python/hamiltonian_simulation.html#5.-Construct-TFIM-Hamiltonian){.reference
                .internal}
            -   [6. Extract coefficients and Pauli
                words](../../applications/python/hamiltonian_simulation.html#6.-Extract-coefficients-and-Pauli-words){.reference
                .internal}
        -   [Main
            code](../../applications/python/hamiltonian_simulation.html#Main-code){.reference
            .internal}
        -   [Visualization of probablity over
            time](../../applications/python/hamiltonian_simulation.html#Visualization-of-probablity-over-time){.reference
            .internal}
        -   [Expectation value over
            time:](../../applications/python/hamiltonian_simulation.html#Expectation-value-over-time:){.reference
            .internal}
        -   [Visualization of expectation over
            time](../../applications/python/hamiltonian_simulation.html#Visualization-of-expectation-over-time){.reference
            .internal}
        -   [Additional
            information](../../applications/python/hamiltonian_simulation.html#Additional-information){.reference
            .internal}
        -   [Relevant
            references](../../applications/python/hamiltonian_simulation.html#Relevant-references){.reference
            .internal}
    -   [Quantum Fourier
        Transform](../../applications/python/quantum_fourier_transform.html){.reference
        .internal}
        -   [Quantum Fourier Transform
            revisited](../../applications/python/quantum_fourier_transform.html#Quantum-Fourier-Transform-revisited){.reference
            .internal}
    -   [Quantum
        Teleporation](../../applications/python/quantum_teleportation.html){.reference
        .internal}
        -   [Teleportation
            explained](../../applications/python/quantum_teleportation.html#Teleportation-explained){.reference
            .internal}
    -   [Quantum
        Volume](../../applications/python/quantum_volume.html){.reference
        .internal}
    -   [Readout Error
        Mitigation](../../applications/python/readout_error_mitigation.html){.reference
        .internal}
        -   [Inverse confusion matrix from single-qubit noise
            model](../../applications/python/readout_error_mitigation.html#Inverse-confusion-matrix-from-single-qubit-noise-model){.reference
            .internal}
        -   [Inverse confusion matrix from k local confusion
            matrices](../../applications/python/readout_error_mitigation.html#Inverse-confusion-matrix-from-k-local-confusion-matrices){.reference
            .internal}
        -   [Inverse of full confusion
            matrix](../../applications/python/readout_error_mitigation.html#Inverse-of-full-confusion-matrix){.reference
            .internal}
    -   [Compiling Unitaries Using Diffusion
        Models](../../applications/python/unitary_compilation_diffusion_models.html){.reference
        .internal}
        -   [Diffusion model
            pipeline](../../applications/python/unitary_compilation_diffusion_models.html#Diffusion-model-pipeline){.reference
            .internal}
        -   [Setup and load
            models](../../applications/python/unitary_compilation_diffusion_models.html#Setup-and-load-models){.reference
            .internal}
            -   [Load discrete
                model](../../applications/python/unitary_compilation_diffusion_models.html#Load-discrete-model){.reference
                .internal}
            -   [Load continuous
                model](../../applications/python/unitary_compilation_diffusion_models.html#Load-continuous-model){.reference
                .internal}
            -   [Create helper
                functions](../../applications/python/unitary_compilation_diffusion_models.html#Create-helper-functions){.reference
                .internal}
        -   [Unitary
            compilation](../../applications/python/unitary_compilation_diffusion_models.html#Unitary-compilation){.reference
            .internal}
            -   [Random
                unitary](../../applications/python/unitary_compilation_diffusion_models.html#Random-unitary){.reference
                .internal}
            -   [Discrete
                model](../../applications/python/unitary_compilation_diffusion_models.html#Discrete-model){.reference
                .internal}
            -   [Continuous
                model](../../applications/python/unitary_compilation_diffusion_models.html#Continuous-model){.reference
                .internal}
            -   [Quantum Fourier
                transform](../../applications/python/unitary_compilation_diffusion_models.html#Quantum-Fourier-transform){.reference
                .internal}
            -   [XXZ-Hamiltonian
                evolution](../../applications/python/unitary_compilation_diffusion_models.html#XXZ-Hamiltonian-evolution){.reference
                .internal}
        -   [Choosing the circuit you
            need](../../applications/python/unitary_compilation_diffusion_models.html#Choosing-the-circuit-you-need){.reference
            .internal}
    -   [VQE with gradients, active spaces, and gate
        fusion](../../applications/python/vqe_advanced.html){.reference
        .internal}
        -   [The Basics of
            VQE](../../applications/python/vqe_advanced.html#The-Basics-of-VQE){.reference
            .internal}
        -   [Installing/Loading Relevant
            Packages](../../applications/python/vqe_advanced.html#Installing/Loading-Relevant-Packages){.reference
            .internal}
        -   [Implementing VQE in
            CUDA-Q](../../applications/python/vqe_advanced.html#Implementing-VQE-in-CUDA-Q){.reference
            .internal}
        -   [Parallel Parameter Shift
            Gradients](../../applications/python/vqe_advanced.html#Parallel-Parameter-Shift-Gradients){.reference
            .internal}
        -   [Using an Active
            Space](../../applications/python/vqe_advanced.html#Using-an-Active-Space){.reference
            .internal}
        -   [Gate Fusion for Larger
            Circuits](../../applications/python/vqe_advanced.html#Gate-Fusion-for-Larger-Circuits){.reference
            .internal}
    -   [Quantum
        Transformer](../../applications/python/quantum_transformer.html){.reference
        .internal}
        -   [Installation](../../applications/python/quantum_transformer.html#Installation){.reference
            .internal}
        -   [Algorithm and
            Example](../../applications/python/quantum_transformer.html#Algorithm-and-Example){.reference
            .internal}
            -   [Creating the self-attention
                circuits](../../applications/python/quantum_transformer.html#Creating-the-self-attention-circuits){.reference
                .internal}
        -   [Usage](../../applications/python/quantum_transformer.html#Usage){.reference
            .internal}
            -   [Model
                Training](../../applications/python/quantum_transformer.html#Model-Training){.reference
                .internal}
            -   [Generating
                Molecules](../../applications/python/quantum_transformer.html#Generating-Molecules){.reference
                .internal}
            -   [Attention
                Maps](../../applications/python/quantum_transformer.html#Attention-Maps){.reference
                .internal}
    -   [Quantum Enhanced Auxiliary Field Quantum Monte
        Carlo](../../applications/python/afqmc.html){.reference
        .internal}
        -   [Hamiltonian preparation for
            VQE](../../applications/python/afqmc.html#Hamiltonian-preparation-for-VQE){.reference
            .internal}
        -   [Run VQE with
            CUDA-Q](../../applications/python/afqmc.html#Run-VQE-with-CUDA-Q){.reference
            .internal}
        -   [Auxiliary Field Quantum Monte Carlo
            (AFQMC)](../../applications/python/afqmc.html#Auxiliary-Field-Quantum-Monte-Carlo-(AFQMC)){.reference
            .internal}
        -   [Preparation of the molecular
            Hamiltonian](../../applications/python/afqmc.html#Preparation-of-the-molecular-Hamiltonian){.reference
            .internal}
        -   [Preparation of the trial wave
            function](../../applications/python/afqmc.html#Preparation-of-the-trial-wave-function){.reference
            .internal}
        -   [Setup of the AFQMC
            parameters](../../applications/python/afqmc.html#Setup-of-the-AFQMC-parameters){.reference
            .internal}
    -   [ADAPT-QAOA
        algorithm](../../applications/python/adapt_qaoa.html){.reference
        .internal}
        -   [Simulation
            input:](../../applications/python/adapt_qaoa.html#Simulation-input:){.reference
            .internal}
        -   [The problem Hamiltonian [\\(H\_C\\)]{.math .notranslate
            .nohighlight} of the max-cut
            graph:](../../applications/python/adapt_qaoa.html#The-problem-Hamiltonian-H_C-of-the-max-cut-graph:){.reference
            .internal}
        -   [Th operator pool [\\(A\_j\\)]{.math .notranslate
            .nohighlight}:](../../applications/python/adapt_qaoa.html#Th-operator-pool-A_j:){.reference
            .internal}
        -   [The commutator [\\(\[H\_C,A\_j\]\\)]{.math .notranslate
            .nohighlight}:](../../applications/python/adapt_qaoa.html#The-commutator-%5BH_C,A_j%5D:){.reference
            .internal}
        -   [Beginning of ADAPT-QAOA
            iteration:](../../applications/python/adapt_qaoa.html#Beginning-of-ADAPT-QAOA-iteration:){.reference
            .internal}
    -   [ADAPT-VQE
        algorithm](../../applications/python/adapt_vqe.html){.reference
        .internal}
        -   [Classical
            pre-processing](../../applications/python/adapt_vqe.html#Classical-pre-processing){.reference
            .internal}
        -   [Jordan
            Wigner:](../../applications/python/adapt_vqe.html#Jordan-Wigner:){.reference
            .internal}
        -   [UCCSD operator
            pool](../../applications/python/adapt_vqe.html#UCCSD-operator-pool){.reference
            .internal}
            -   [Single
                excitation](../../applications/python/adapt_vqe.html#Single-excitation){.reference
                .internal}
            -   [Double
                excitation](../../applications/python/adapt_vqe.html#Double-excitation){.reference
                .internal}
        -   [Commutator \[[\\(H\\)]{.math .notranslate .nohighlight},
            [\\(A\_i\\)]{.math .notranslate
            .nohighlight}\]](../../applications/python/adapt_vqe.html#Commutator-%5BH,-A_i%5D){.reference
            .internal}
        -   [Reference
            State:](../../applications/python/adapt_vqe.html#Reference-State:){.reference
            .internal}
        -   [Quantum
            kernels:](../../applications/python/adapt_vqe.html#Quantum-kernels:){.reference
            .internal}
        -   [Beginning of
            ADAPT-VQE:](../../applications/python/adapt_vqe.html#Beginning-of-ADAPT-VQE:){.reference
            .internal}
    -   [Quantum edge
        detection](../../applications/python/edge_detection.html){.reference
        .internal}
        -   [Image](../../applications/python/edge_detection.html#Image){.reference
            .internal}
        -   [Quantum Probability Image Encoding
            (QPIE):](../../applications/python/edge_detection.html#Quantum-Probability-Image-Encoding-(QPIE):){.reference
            .internal}
            -   [Below we show how to encode an image using QPIE in
                cudaq.](../../applications/python/edge_detection.html#Below-we-show-how-to-encode-an-image-using-QPIE-in-cudaq.){.reference
                .internal}
        -   [Flexible Representation of Quantum Images
            (FRQI):](../../applications/python/edge_detection.html#Flexible-Representation-of-Quantum-Images-(FRQI):){.reference
            .internal}
            -   [Building the FRQI
                State:](../../applications/python/edge_detection.html#Building-the-FRQI-State:){.reference
                .internal}
        -   [Quantum Hadamard Edge Detection
            (QHED)](../../applications/python/edge_detection.html#Quantum-Hadamard-Edge-Detection-(QHED)){.reference
            .internal}
            -   [Post-processing](../../applications/python/edge_detection.html#Post-processing){.reference
                .internal}
    -   [Factoring Integers With Shor's
        Algorithm](../../applications/python/shors.html){.reference
        .internal}
        -   [Shor's
            algorithm](../../applications/python/shors.html#Shor's-algorithm){.reference
            .internal}
            -   [Solving the order-finding problem
                classically](../../applications/python/shors.html#Solving-the-order-finding-problem-classically){.reference
                .internal}
            -   [Solving the order-finding problem with a quantum
                algorithm](../../applications/python/shors.html#Solving-the-order-finding-problem-with-a-quantum-algorithm){.reference
                .internal}
            -   [Determining the order from the measurement results of
                the phase
                kernel](../../applications/python/shors.html#Determining-the-order-from-the-measurement-results-of-the-phase-kernel){.reference
                .internal}
            -   [Postscript](../../applications/python/shors.html#Postscript){.reference
                .internal}
    -   [Generating the electronic
        Hamiltonian](../../applications/python/generate_fermionic_ham.html){.reference
        .internal}
        -   [Second Quantized
            formulation.](../../applications/python/generate_fermionic_ham.html#Second-Quantized-formulation.){.reference
            .internal}
            -   [Computational
                Implementation](../../applications/python/generate_fermionic_ham.html#Computational-Implementation){.reference
                .internal}
            -   [(a) Generate the molecular Hamiltonian using Restricted
                Hartree Fock molecular
                orbitals](../../applications/python/generate_fermionic_ham.html#(a)-Generate-the-molecular-Hamiltonian-using-Restricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(b) Generate the molecular Hamiltonian using
                Unrestricted Hartree Fock molecular
                orbitals](../../applications/python/generate_fermionic_ham.html#(b)-Generate-the-molecular-Hamiltonian-using-Unrestricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(a) Generate the active space hamiltonian using RHF
                molecular
                orbitals.](../../applications/python/generate_fermionic_ham.html#(a)-Generate-the-active-space-hamiltonian-using-RHF-molecular-orbitals.){.reference
                .internal}
            -   [(b) Generate the active space Hamiltonian using the
                natural orbitals computed from MP2
                simulation](../../applications/python/generate_fermionic_ham.html#(b)-Generate-the-active-space-Hamiltonian-using-the-natural-orbitals-computed-from-MP2-simulation){.reference
                .internal}
            -   [(c) Generate the active space Hamiltonian computed from
                the CASSCF molecular
                orbitals](../../applications/python/generate_fermionic_ham.html#(c)-Generate-the-active-space-Hamiltonian-computed-from-the-CASSCF-molecular-orbitals){.reference
                .internal}
            -   [(d) Generate the electronic Hamiltonian using
                ROHF](../../applications/python/generate_fermionic_ham.html#(d)-Generate-the-electronic-Hamiltonian-using-ROHF){.reference
                .internal}
            -   [(e) Generate electronic Hamiltonian using
                UHF](../../applications/python/generate_fermionic_ham.html#(e)-Generate-electronic-Hamiltonian-using-UHF){.reference
                .internal}
    -   [Grover's
        Algorithm](../../applications/python/grovers.html){.reference
        .internal}
        -   [Overview](../../applications/python/grovers.html#Overview){.reference
            .internal}
        -   [Problem](../../applications/python/grovers.html#Problem){.reference
            .internal}
        -   [Structure of Grover's
            Algorithm](../../applications/python/grovers.html#Structure-of-Grover's-Algorithm){.reference
            .internal}
            -   [Step 1:
                Preparation](../../applications/python/grovers.html#Step-1:-Preparation){.reference
                .internal}
            -   [Good and Bad
                States](../../applications/python/grovers.html#Good-and-Bad-States){.reference
                .internal}
            -   [Step 2: Oracle
                application](../../applications/python/grovers.html#Step-2:-Oracle-application){.reference
                .internal}
            -   [Step 3: Amplitude
                amplification](../../applications/python/grovers.html#Step-3:-Amplitude-amplification){.reference
                .internal}
            -   [Steps 4 and 5: Iteration and
                measurement](../../applications/python/grovers.html#Steps-4-and-5:-Iteration-and-measurement){.reference
                .internal}
    -   [Quantum
        PageRank](../../applications/python/quantum_pagerank.html){.reference
        .internal}
        -   [Problem
            Definition](../../applications/python/quantum_pagerank.html#Problem-Definition){.reference
            .internal}
        -   [Simulating Quantum PageRank by CUDA-Q
            dynamics](../../applications/python/quantum_pagerank.html#Simulating-Quantum-PageRank-by-CUDA-Q-dynamics){.reference
            .internal}
        -   [Breakdown of
            Terms](../../applications/python/quantum_pagerank.html#Breakdown-of-Terms){.reference
            .internal}
    -   [The UCCSD Wavefunction
        ansatz](../../applications/python/uccsd_wf_ansatz.html){.reference
        .internal}
        -   [What is
            UCCSD?](../../applications/python/uccsd_wf_ansatz.html#What-is-UCCSD?){.reference
            .internal}
        -   [Implementation in Quantum
            Computing](../../applications/python/uccsd_wf_ansatz.html#Implementation-in-Quantum-Computing){.reference
            .internal}
        -   [Run
            VQE](../../applications/python/uccsd_wf_ansatz.html#Run-VQE){.reference
            .internal}
        -   [Challenges and
            consideration](../../applications/python/uccsd_wf_ansatz.html#Challenges-and-consideration){.reference
            .internal}
    -   [Approximate State Preparation using MPS Sequential
        Encoding](../../applications/python/mps_encoding.html){.reference
        .internal}
        -   [Ran's
            approach](../../applications/python/mps_encoding.html#Ran's-approach){.reference
            .internal}
    -   [QM/MM simulation: VQE within a Polarizable Embedded
        Framework.](../../applications/python/qm_mm_pe.html){.reference
        .internal}
        -   [Key
            concepts:](../../applications/python/qm_mm_pe.html#Key-concepts:){.reference
            .internal}
        -   [PE-VQE-SCF Algorithm
            Steps](../../applications/python/qm_mm_pe.html#PE-VQE-SCF-Algorithm-Steps){.reference
            .internal}
            -   [Step 1: Initialize (Classical
                pre-processing)](../../applications/python/qm_mm_pe.html#Step-1:-Initialize-(Classical-pre-processing)){.reference
                .internal}
            -   [Step 2: Build the
                Hamiltonian](../../applications/python/qm_mm_pe.html#Step-2:-Build-the-Hamiltonian){.reference
                .internal}
            -   [Step 3: Run
                VQE](../../applications/python/qm_mm_pe.html#Step-3:-Run-VQE){.reference
                .internal}
            -   [Step 4: Update
                Environment](../../applications/python/qm_mm_pe.html#Step-4:-Update-Environment){.reference
                .internal}
            -   [Step 5: Self-Consistency
                Loop](../../applications/python/qm_mm_pe.html#Step-5:-Self-Consistency-Loop){.reference
                .internal}
            -   [Requirments:](../../applications/python/qm_mm_pe.html#Requirments:){.reference
                .internal}
            -   [Example 1: LiH with 2 water
                molecules.](../../applications/python/qm_mm_pe.html#Example-1:-LiH-with-2-water-molecules.){.reference
                .internal}
            -   [VQE, update environment, and scf
                loop.](../../applications/python/qm_mm_pe.html#VQE,-update-environment,-and-scf-loop.){.reference
                .internal}
            -   [Example 2: NH3 with 46 water molecule using active
                space.](../../applications/python/qm_mm_pe.html#Example-2:-NH3-with-46-water-molecule-using-active-space.){.reference
                .internal}
-   [Backends](../../using/backends/backends.html){.reference .internal}
    -   [Circuit
        Simulation](../../using/backends/simulators.html){.reference
        .internal}
        -   [State Vector
            Simulators](../../using/backends/sims/svsims.html){.reference
            .internal}
            -   [CPU](../../using/backends/sims/svsims.html#cpu){.reference
                .internal}
            -   [Single-GPU](../../using/backends/sims/svsims.html#single-gpu){.reference
                .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/svsims.html#multi-gpu-multi-node){.reference
                .internal}
        -   [Tensor Network
            Simulators](../../using/backends/sims/tnsims.html){.reference
            .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/tnsims.html#multi-gpu-multi-node){.reference
                .internal}
            -   [Matrix product
                state](../../using/backends/sims/tnsims.html#matrix-product-state){.reference
                .internal}
            -   [Fermioniq](../../using/backends/sims/tnsims.html#fermioniq){.reference
                .internal}
        -   [Multi-QPU
            Simulators](../../using/backends/sims/mqpusims.html){.reference
            .internal}
            -   [Simulate Multiple QPUs in
                Parallel](../../using/backends/sims/mqpusims.html#simulate-multiple-qpus-in-parallel){.reference
                .internal}
            -   [Multi-QPU + Other
                Backends](../../using/backends/sims/mqpusims.html#multi-qpu-other-backends){.reference
                .internal}
        -   [Noisy
            Simulators](../../using/backends/sims/noisy.html){.reference
            .internal}
            -   [Trajectory Noisy
                Simulation](../../using/backends/sims/noisy.html#trajectory-noisy-simulation){.reference
                .internal}
            -   [Density
                Matrix](../../using/backends/sims/noisy.html#density-matrix){.reference
                .internal}
            -   [Stim](../../using/backends/sims/noisy.html#stim){.reference
                .internal}
        -   [Photonics
            Simulators](../../using/backends/sims/photonics.html){.reference
            .internal}
            -   [orca-photonics](../../using/backends/sims/photonics.html#orca-photonics){.reference
                .internal}
    -   [Quantum Hardware
        (QPUs)](../../using/backends/hardware.html){.reference
        .internal}
        -   [Ion Trap
            QPUs](../../using/backends/hardware/iontrap.html){.reference
            .internal}
            -   [IonQ](../../using/backends/hardware/iontrap.html#ionq){.reference
                .internal}
            -   [Quantinuum](../../using/backends/hardware/iontrap.html#quantinuum){.reference
                .internal}
        -   [Superconducting
            QPUs](../../using/backends/hardware/superconducting.html){.reference
            .internal}
            -   [Anyon Technologies/Anyon
                Computing](../../using/backends/hardware/superconducting.html#anyon-technologies-anyon-computing){.reference
                .internal}
            -   [IQM](../../using/backends/hardware/superconducting.html#iqm){.reference
                .internal}
            -   [OQC](../../using/backends/hardware/superconducting.html#oqc){.reference
                .internal}
        -   [Neutral Atom
            QPUs](../../using/backends/hardware/neutralatom.html){.reference
            .internal}
            -   [Infleqtion](../../using/backends/hardware/neutralatom.html#infleqtion){.reference
                .internal}
            -   [Pasqal](../../using/backends/hardware/neutralatom.html#pasqal){.reference
                .internal}
            -   [QuEra
                Computing](../../using/backends/hardware/neutralatom.html#quera-computing){.reference
                .internal}
        -   [Photonic
            QPUs](../../using/backends/hardware/photonic.html){.reference
            .internal}
            -   [ORCA
                Computing](../../using/backends/hardware/photonic.html#orca-computing){.reference
                .internal}
        -   [Quantum Control
            Systems](../../using/backends/hardware/qcontrol.html){.reference
            .internal}
            -   [Quantum
                Machines](../../using/backends/hardware/qcontrol.html#quantum-machines){.reference
                .internal}
    -   [Dynamics
        Simulation](../../using/backends/dynamics_backends.html){.reference
        .internal}
    -   [Cloud](../../using/backends/cloud.html){.reference .internal}
        -   [Amazon Braket
            (braket)](../../using/backends/cloud/braket.html){.reference
            .internal}
            -   [Setting
                Credentials](../../using/backends/cloud/braket.html#setting-credentials){.reference
                .internal}
            -   [Submission from
                C++](../../using/backends/cloud/braket.html#submission-from-c){.reference
                .internal}
            -   [Submission from
                Python](../../using/backends/cloud/braket.html#submission-from-python){.reference
                .internal}
        -   [NVIDIA Quantum Cloud
            (nvqc)](../../using/backends/cloud/nvqc.html){.reference
            .internal}
            -   [Quick
                Start](../../using/backends/cloud/nvqc.html#quick-start){.reference
                .internal}
            -   [Simulator Backend
                Selection](../../using/backends/cloud/nvqc.html#simulator-backend-selection){.reference
                .internal}
            -   [Multiple
                GPUs](../../using/backends/cloud/nvqc.html#multiple-gpus){.reference
                .internal}
            -   [Multiple QPUs Asynchronous
                Execution](../../using/backends/cloud/nvqc.html#multiple-qpus-asynchronous-execution){.reference
                .internal}
            -   [FAQ](../../using/backends/cloud/nvqc.html#faq){.reference
                .internal}
-   [Dynamics](../../using/dynamics.html){.reference .internal}
    -   [Quick Start](../../using/dynamics.html#quick-start){.reference
        .internal}
    -   [Operator](../../using/dynamics.html#operator){.reference
        .internal}
    -   [Time-Dependent
        Dynamics](../../using/dynamics.html#time-dependent-dynamics){.reference
        .internal}
    -   [Super-operator
        Representation](../../using/dynamics.html#super-operator-representation){.reference
        .internal}
    -   [Numerical
        Integrators](../../using/dynamics.html#numerical-integrators){.reference
        .internal}
    -   [Batch
        simulation](../../using/dynamics.html#batch-simulation){.reference
        .internal}
    -   [Multi-GPU Multi-Node
        Execution](../../using/dynamics.html#multi-gpu-multi-node-execution){.reference
        .internal}
    -   [Examples](../../using/dynamics.html#examples){.reference
        .internal}
-   [CUDA-QX](../../using/cudaqx/cudaqx.html){.reference .internal}
    -   [CUDA-Q
        Solvers](../../using/cudaqx/cudaqx.html#cuda-q-solvers){.reference
        .internal}
    -   [CUDA-Q
        QEC](../../using/cudaqx/cudaqx.html#cuda-q-qec){.reference
        .internal}
-   [Installation](../../using/install/install.html){.reference
    .internal}
    -   [Local
        Installation](../../using/install/local_installation.html){.reference
        .internal}
        -   [Introduction](../../using/install/local_installation.html#introduction){.reference
            .internal}
            -   [Docker](../../using/install/local_installation.html#docker){.reference
                .internal}
            -   [Known Blackwell
                Issues](../../using/install/local_installation.html#known-blackwell-issues){.reference
                .internal}
            -   [Singularity](../../using/install/local_installation.html#singularity){.reference
                .internal}
            -   [Python
                wheels](../../using/install/local_installation.html#python-wheels){.reference
                .internal}
            -   [Pre-built
                binaries](../../using/install/local_installation.html#pre-built-binaries){.reference
                .internal}
        -   [Development with VS
            Code](../../using/install/local_installation.html#development-with-vs-code){.reference
            .internal}
            -   [Using a Docker
                container](../../using/install/local_installation.html#using-a-docker-container){.reference
                .internal}
            -   [Using a Singularity
                container](../../using/install/local_installation.html#using-a-singularity-container){.reference
                .internal}
        -   [Connecting to a Remote
            Host](../../using/install/local_installation.html#connecting-to-a-remote-host){.reference
            .internal}
            -   [Developing with Remote
                Tunnels](../../using/install/local_installation.html#developing-with-remote-tunnels){.reference
                .internal}
            -   [Remote Access via
                SSH](../../using/install/local_installation.html#remote-access-via-ssh){.reference
                .internal}
        -   [DGX
            Cloud](../../using/install/local_installation.html#dgx-cloud){.reference
            .internal}
            -   [Get
                Started](../../using/install/local_installation.html#get-started){.reference
                .internal}
            -   [Use
                JupyterLab](../../using/install/local_installation.html#use-jupyterlab){.reference
                .internal}
            -   [Use VS
                Code](../../using/install/local_installation.html#use-vs-code){.reference
                .internal}
        -   [Additional CUDA
            Tools](../../using/install/local_installation.html#additional-cuda-tools){.reference
            .internal}
            -   [Installation via
                PyPI](../../using/install/local_installation.html#installation-via-pypi){.reference
                .internal}
            -   [Installation In Container
                Images](../../using/install/local_installation.html#installation-in-container-images){.reference
                .internal}
            -   [Installing Pre-built
                Binaries](../../using/install/local_installation.html#installing-pre-built-binaries){.reference
                .internal}
        -   [Distributed Computing with
            MPI](../../using/install/local_installation.html#distributed-computing-with-mpi){.reference
            .internal}
        -   [Updating
            CUDA-Q](../../using/install/local_installation.html#updating-cuda-q){.reference
            .internal}
        -   [Dependencies and
            Compatibility](../../using/install/local_installation.html#dependencies-and-compatibility){.reference
            .internal}
        -   [Next
            Steps](../../using/install/local_installation.html#next-steps){.reference
            .internal}
    -   [Data Center
        Installation](../../using/install/data_center_install.html){.reference
        .internal}
        -   [Prerequisites](../../using/install/data_center_install.html#prerequisites){.reference
            .internal}
        -   [Build
            Dependencies](../../using/install/data_center_install.html#build-dependencies){.reference
            .internal}
            -   [CUDA](../../using/install/data_center_install.html#cuda){.reference
                .internal}
            -   [Toolchain](../../using/install/data_center_install.html#toolchain){.reference
                .internal}
        -   [Building
            CUDA-Q](../../using/install/data_center_install.html#building-cuda-q){.reference
            .internal}
        -   [Python
            Support](../../using/install/data_center_install.html#python-support){.reference
            .internal}
        -   [C++
            Support](../../using/install/data_center_install.html#c-support){.reference
            .internal}
        -   [Installation on the
            Host](../../using/install/data_center_install.html#installation-on-the-host){.reference
            .internal}
            -   [CUDA Runtime
                Libraries](../../using/install/data_center_install.html#cuda-runtime-libraries){.reference
                .internal}
            -   [MPI](../../using/install/data_center_install.html#mpi){.reference
                .internal}
-   [Integration](../../using/integration/integration.html){.reference
    .internal}
    -   [Downstream CMake
        Integration](../../using/integration/cmake_app.html){.reference
        .internal}
    -   [Combining CUDA with
        CUDA-Q](../../using/integration/cuda_gpu.html){.reference
        .internal}
    -   [Integrating with Third-Party
        Libraries](../../using/integration/libraries.html){.reference
        .internal}
        -   [Calling a CUDA-Q library from
            C++](../../using/integration/libraries.html#calling-a-cuda-q-library-from-c){.reference
            .internal}
        -   [Calling an C++ library from
            CUDA-Q](../../using/integration/libraries.html#calling-an-c-library-from-cuda-q){.reference
            .internal}
        -   [Interfacing between binaries compiled with a different
            toolchains](../../using/integration/libraries.html#interfacing-between-binaries-compiled-with-a-different-toolchains){.reference
            .internal}
-   [Extending](../../using/extending/extending.html){.reference
    .internal}
    -   [Add a new Hardware
        Backend](../../using/extending/backend.html){.reference
        .internal}
        -   [Overview](../../using/extending/backend.html#overview){.reference
            .internal}
        -   [Server Helper
            Implementation](../../using/extending/backend.html#server-helper-implementation){.reference
            .internal}
            -   [Directory
                Structure](../../using/extending/backend.html#directory-structure){.reference
                .internal}
            -   [Server Helper
                Class](../../using/extending/backend.html#server-helper-class){.reference
                .internal}
            -   [`CMakeLists.txt`{.docutils .literal
                .notranslate}](../../using/extending/backend.html#cmakelists-txt){.reference
                .internal}
        -   [Target
            Configuration](../../using/extending/backend.html#target-configuration){.reference
            .internal}
            -   [Update Parent `CMakeLists.txt`{.docutils .literal
                .notranslate}](../../using/extending/backend.html#update-parent-cmakelists-txt){.reference
                .internal}
        -   [Testing](../../using/extending/backend.html#testing){.reference
            .internal}
            -   [Unit
                Tests](../../using/extending/backend.html#unit-tests){.reference
                .internal}
            -   [Mock
                Server](../../using/extending/backend.html#mock-server){.reference
                .internal}
            -   [Python
                Tests](../../using/extending/backend.html#python-tests){.reference
                .internal}
            -   [Integration
                Tests](../../using/extending/backend.html#integration-tests){.reference
                .internal}
        -   [Documentation](../../using/extending/backend.html#documentation){.reference
            .internal}
        -   [Example
            Usage](../../using/extending/backend.html#example-usage){.reference
            .internal}
        -   [Code
            Review](../../using/extending/backend.html#code-review){.reference
            .internal}
        -   [Maintaining a
            Backend](../../using/extending/backend.html#maintaining-a-backend){.reference
            .internal}
        -   [Conclusion](../../using/extending/backend.html#conclusion){.reference
            .internal}
    -   [Create a new NVQIR
        Simulator](../../using/extending/nvqir_simulator.html){.reference
        .internal}
        -   [`CircuitSimulator`{.code .docutils .literal
            .notranslate}](../../using/extending/nvqir_simulator.html#circuitsimulator){.reference
            .internal}
        -   [Let's see this in
            action](../../using/extending/nvqir_simulator.html#let-s-see-this-in-action){.reference
            .internal}
    -   [Working with CUDA-Q
        IR](../../using/extending/cudaq_ir.html){.reference .internal}
    -   [Create an MLIR Pass for
        CUDA-Q](../../using/extending/mlir_pass.html){.reference
        .internal}
-   [Specifications](../../specification/index.html){.reference
    .internal}
    -   [Language
        Specification](../../specification/cudaq.html){.reference
        .internal}
        -   [1. Machine
            Model](../../specification/cudaq/machine_model.html){.reference
            .internal}
        -   [2. Namespace and
            Standard](../../specification/cudaq/namespace.html){.reference
            .internal}
        -   [3. Quantum
            Types](../../specification/cudaq/types.html){.reference
            .internal}
            -   [3.1. `cudaq::qudit<Levels>`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/types.html#cudaq-qudit-levels){.reference
                .internal}
            -   [3.2. `cudaq::qubit`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/types.html#cudaq-qubit){.reference
                .internal}
            -   [3.3. Quantum
                Containers](../../specification/cudaq/types.html#quantum-containers){.reference
                .internal}
        -   [4. Quantum
            Operators](../../specification/cudaq/operators.html){.reference
            .internal}
            -   [4.1. `cudaq::spin_op`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/operators.html#cudaq-spin-op){.reference
                .internal}
        -   [5. Quantum
            Operations](../../specification/cudaq/operations.html){.reference
            .internal}
            -   [5.1. Operations on `cudaq::qubit`{.code .docutils
                .literal
                .notranslate}](../../specification/cudaq/operations.html#operations-on-cudaq-qubit){.reference
                .internal}
        -   [6. Quantum
            Kernels](../../specification/cudaq/kernels.html){.reference
            .internal}
        -   [7. Sub-circuit
            Synthesis](../../specification/cudaq/synthesis.html){.reference
            .internal}
        -   [8. Control
            Flow](../../specification/cudaq/control_flow.html){.reference
            .internal}
        -   [9. Just-in-Time Kernel
            Creation](../../specification/cudaq/dynamic_kernels.html){.reference
            .internal}
        -   [10. Quantum
            Patterns](../../specification/cudaq/patterns.html){.reference
            .internal}
            -   [10.1.
                Compute-Action-Uncompute](../../specification/cudaq/patterns.html#compute-action-uncompute){.reference
                .internal}
        -   [11.
            Platform](../../specification/cudaq/platform.html){.reference
            .internal}
        -   [12. Algorithmic
            Primitives](../../specification/cudaq/algorithmic_primitives.html){.reference
            .internal}
            -   [12.1. `cudaq::sample`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/algorithmic_primitives.html#cudaq-sample){.reference
                .internal}
            -   [12.2. `cudaq::run`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/algorithmic_primitives.html#cudaq-run){.reference
                .internal}
            -   [12.3. `cudaq::observe`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/algorithmic_primitives.html#cudaq-observe){.reference
                .internal}
            -   [12.4. `cudaq::optimizer`{.code .docutils .literal
                .notranslate} (deprecated, functionality moved to CUDA-Q
                libraries)](../../specification/cudaq/algorithmic_primitives.html#cudaq-optimizer-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
            -   [12.5. `cudaq::gradient`{.code .docutils .literal
                .notranslate} (deprecated, functionality moved to CUDA-Q
                libraries)](../../specification/cudaq/algorithmic_primitives.html#cudaq-gradient-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
        -   [13. Example
            Programs](../../specification/cudaq/examples.html){.reference
            .internal}
            -   [13.1. Hello World - Simple Bell
                State](../../specification/cudaq/examples.html#hello-world-simple-bell-state){.reference
                .internal}
            -   [13.2. GHZ State Preparation and
                Sampling](../../specification/cudaq/examples.html#ghz-state-preparation-and-sampling){.reference
                .internal}
            -   [13.3. Quantum Phase
                Estimation](../../specification/cudaq/examples.html#quantum-phase-estimation){.reference
                .internal}
            -   [13.4. Deuteron Binding Energy Parameter
                Sweep](../../specification/cudaq/examples.html#deuteron-binding-energy-parameter-sweep){.reference
                .internal}
            -   [13.5. Grover's
                Algorithm](../../specification/cudaq/examples.html#grover-s-algorithm){.reference
                .internal}
            -   [13.6. Iterative Phase
                Estimation](../../specification/cudaq/examples.html#iterative-phase-estimation){.reference
                .internal}
    -   [Quake
        Specification](../../specification/quake-dialect.html){.reference
        .internal}
        -   [General
            Introduction](../../specification/quake-dialect.html#general-introduction){.reference
            .internal}
        -   [Motivation](../../specification/quake-dialect.html#motivation){.reference
            .internal}
-   [API Reference](../api.html){.reference .internal}
    -   [C++ API](cpp_api.html){.reference .internal}
        -   [Operators](cpp_api.html#operators){.reference .internal}
        -   [Quantum](cpp_api.html#quantum){.reference .internal}
        -   [Common](cpp_api.html#common){.reference .internal}
        -   [Noise Modeling](cpp_api.html#noise-modeling){.reference
            .internal}
        -   [Kernel Builder](cpp_api.html#kernel-builder){.reference
            .internal}
        -   [Algorithms](cpp_api.html#algorithms){.reference .internal}
        -   [Platform](cpp_api.html#platform){.reference .internal}
        -   [Utilities](cpp_api.html#utilities){.reference .internal}
        -   [Namespaces](cpp_api.html#namespaces){.reference .internal}
    -   [Python API](#){.current .reference .internal}
        -   [Program Construction](#program-construction){.reference
            .internal}
            -   [`make_kernel()`{.docutils .literal
                .notranslate}](#cudaq.make_kernel){.reference .internal}
            -   [`PyKernel`{.docutils .literal
                .notranslate}](#cudaq.PyKernel){.reference .internal}
            -   [`Kernel`{.docutils .literal
                .notranslate}](#cudaq.Kernel){.reference .internal}
            -   [`PyKernelDecorator`{.docutils .literal
                .notranslate}](#cudaq.PyKernelDecorator){.reference
                .internal}
            -   [`kernel()`{.docutils .literal
                .notranslate}](#cudaq.kernel){.reference .internal}
        -   [Kernel Execution](#kernel-execution){.reference .internal}
            -   [`sample()`{.docutils .literal
                .notranslate}](#cudaq.sample){.reference .internal}
            -   [`sample_async()`{.docutils .literal
                .notranslate}](#cudaq.sample_async){.reference
                .internal}
            -   [`run()`{.docutils .literal
                .notranslate}](#cudaq.run){.reference .internal}
            -   [`run_async()`{.docutils .literal
                .notranslate}](#cudaq.run_async){.reference .internal}
            -   [`observe()`{.docutils .literal
                .notranslate}](#cudaq.observe){.reference .internal}
            -   [`observe_async()`{.docutils .literal
                .notranslate}](#cudaq.observe_async){.reference
                .internal}
            -   [`get_state()`{.docutils .literal
                .notranslate}](#cudaq.get_state){.reference .internal}
            -   [`get_state_async()`{.docutils .literal
                .notranslate}](#cudaq.get_state_async){.reference
                .internal}
            -   [`vqe()`{.docutils .literal
                .notranslate}](#cudaq.vqe){.reference .internal}
            -   [`draw()`{.docutils .literal
                .notranslate}](#cudaq.draw){.reference .internal}
            -   [`translate()`{.docutils .literal
                .notranslate}](#cudaq.translate){.reference .internal}
            -   [`estimate_resources()`{.docutils .literal
                .notranslate}](#cudaq.estimate_resources){.reference
                .internal}
        -   [Backend Configuration](#backend-configuration){.reference
            .internal}
            -   [`has_target()`{.docutils .literal
                .notranslate}](#cudaq.has_target){.reference .internal}
            -   [`get_target()`{.docutils .literal
                .notranslate}](#cudaq.get_target){.reference .internal}
            -   [`get_targets()`{.docutils .literal
                .notranslate}](#cudaq.get_targets){.reference .internal}
            -   [`set_target()`{.docutils .literal
                .notranslate}](#cudaq.set_target){.reference .internal}
            -   [`reset_target()`{.docutils .literal
                .notranslate}](#cudaq.reset_target){.reference
                .internal}
            -   [`set_noise()`{.docutils .literal
                .notranslate}](#cudaq.set_noise){.reference .internal}
            -   [`unset_noise()`{.docutils .literal
                .notranslate}](#cudaq.unset_noise){.reference .internal}
            -   [`cudaq.apply_noise()`{.docutils .literal
                .notranslate}](#cudaq.cudaq.apply_noise){.reference
                .internal}
            -   [`initialize_cudaq()`{.docutils .literal
                .notranslate}](#cudaq.initialize_cudaq){.reference
                .internal}
            -   [`num_available_gpus()`{.docutils .literal
                .notranslate}](#cudaq.num_available_gpus){.reference
                .internal}
            -   [`set_random_seed()`{.docutils .literal
                .notranslate}](#cudaq.set_random_seed){.reference
                .internal}
        -   [Dynamics](#dynamics){.reference .internal}
            -   [`evolve()`{.docutils .literal
                .notranslate}](#cudaq.evolve){.reference .internal}
            -   [`evolve_async()`{.docutils .literal
                .notranslate}](#cudaq.evolve_async){.reference
                .internal}
            -   [`Schedule`{.docutils .literal
                .notranslate}](#cudaq.Schedule){.reference .internal}
            -   [`BaseIntegrator`{.docutils .literal
                .notranslate}](#cudaq.dynamics.integrator.BaseIntegrator){.reference
                .internal}
            -   [`InitialState`{.docutils .literal
                .notranslate}](#cudaq.dynamics.helpers.InitialState){.reference
                .internal}
            -   [`InitialStateType`{.docutils .literal
                .notranslate}](#cudaq.InitialStateType){.reference
                .internal}
            -   [`IntermediateResultSave`{.docutils .literal
                .notranslate}](#cudaq.IntermediateResultSave){.reference
                .internal}
        -   [Operators](#operators){.reference .internal}
            -   [`OperatorSum`{.docutils .literal
                .notranslate}](#cudaq.operators.OperatorSum){.reference
                .internal}
            -   [`ProductOperator`{.docutils .literal
                .notranslate}](#cudaq.operators.ProductOperator){.reference
                .internal}
            -   [`ElementaryOperator`{.docutils .literal
                .notranslate}](#cudaq.operators.ElementaryOperator){.reference
                .internal}
            -   [`ScalarOperator`{.docutils .literal
                .notranslate}](#cudaq.operators.ScalarOperator){.reference
                .internal}
            -   [`RydbergHamiltonian`{.docutils .literal
                .notranslate}](#cudaq.operators.RydbergHamiltonian){.reference
                .internal}
            -   [`SuperOperator`{.docutils .literal
                .notranslate}](#cudaq.SuperOperator){.reference
                .internal}
            -   [`operators.define()`{.docutils .literal
                .notranslate}](#cudaq.operators.define){.reference
                .internal}
            -   [`operators.instantiate()`{.docutils .literal
                .notranslate}](#cudaq.operators.instantiate){.reference
                .internal}
            -   [Spin Operators](#spin-operators){.reference .internal}
            -   [Fermion Operators](#fermion-operators){.reference
                .internal}
            -   [Boson Operators](#boson-operators){.reference
                .internal}
            -   [General Operators](#general-operators){.reference
                .internal}
        -   [Data Types](#data-types){.reference .internal}
            -   [`SimulationPrecision`{.docutils .literal
                .notranslate}](#cudaq.SimulationPrecision){.reference
                .internal}
            -   [`Target`{.docutils .literal
                .notranslate}](#cudaq.Target){.reference .internal}
            -   [`State`{.docutils .literal
                .notranslate}](#cudaq.State){.reference .internal}
            -   [`Tensor`{.docutils .literal
                .notranslate}](#cudaq.Tensor){.reference .internal}
            -   [`QuakeValue`{.docutils .literal
                .notranslate}](#cudaq.QuakeValue){.reference .internal}
            -   [`qubit`{.docutils .literal
                .notranslate}](#cudaq.qubit){.reference .internal}
            -   [`qreg`{.docutils .literal
                .notranslate}](#cudaq.qreg){.reference .internal}
            -   [`qvector`{.docutils .literal
                .notranslate}](#cudaq.qvector){.reference .internal}
            -   [`ComplexMatrix`{.docutils .literal
                .notranslate}](#cudaq.ComplexMatrix){.reference
                .internal}
            -   [`SampleResult`{.docutils .literal
                .notranslate}](#cudaq.SampleResult){.reference
                .internal}
            -   [`AsyncSampleResult`{.docutils .literal
                .notranslate}](#cudaq.AsyncSampleResult){.reference
                .internal}
            -   [`ObserveResult`{.docutils .literal
                .notranslate}](#cudaq.ObserveResult){.reference
                .internal}
            -   [`AsyncObserveResult`{.docutils .literal
                .notranslate}](#cudaq.AsyncObserveResult){.reference
                .internal}
            -   [`AsyncStateResult`{.docutils .literal
                .notranslate}](#cudaq.AsyncStateResult){.reference
                .internal}
            -   [`OptimizationResult`{.docutils .literal
                .notranslate}](#cudaq.OptimizationResult){.reference
                .internal}
            -   [`EvolveResult`{.docutils .literal
                .notranslate}](#cudaq.EvolveResult){.reference
                .internal}
            -   [`AsyncEvolveResult`{.docutils .literal
                .notranslate}](#cudaq.AsyncEvolveResult){.reference
                .internal}
            -   [`Resources`{.docutils .literal
                .notranslate}](#cudaq.Resources){.reference .internal}
            -   [Optimizers](#optimizers){.reference .internal}
            -   [Gradients](#gradients){.reference .internal}
            -   [Noisy Simulation](#noisy-simulation){.reference
                .internal}
        -   [MPI Submodule](#mpi-submodule){.reference .internal}
            -   [`initialize()`{.docutils .literal
                .notranslate}](#cudaq.mpi.initialize){.reference
                .internal}
            -   [`rank()`{.docutils .literal
                .notranslate}](#cudaq.mpi.rank){.reference .internal}
            -   [`num_ranks()`{.docutils .literal
                .notranslate}](#cudaq.mpi.num_ranks){.reference
                .internal}
            -   [`all_gather()`{.docutils .literal
                .notranslate}](#cudaq.mpi.all_gather){.reference
                .internal}
            -   [`broadcast()`{.docutils .literal
                .notranslate}](#cudaq.mpi.broadcast){.reference
                .internal}
            -   [`is_initialized()`{.docutils .literal
                .notranslate}](#cudaq.mpi.is_initialized){.reference
                .internal}
            -   [`finalize()`{.docutils .literal
                .notranslate}](#cudaq.mpi.finalize){.reference
                .internal}
        -   [ORCA Submodule](#orca-submodule){.reference .internal}
            -   [`sample()`{.docutils .literal
                .notranslate}](#cudaq.orca.sample){.reference .internal}
    -   [Quantum Operations](../default_ops.html){.reference .internal}
        -   [Unitary Operations on
            Qubits](../default_ops.html#unitary-operations-on-qubits){.reference
            .internal}
            -   [`x`{.code .docutils .literal
                .notranslate}](../default_ops.html#x){.reference
                .internal}
            -   [`y`{.code .docutils .literal
                .notranslate}](../default_ops.html#y){.reference
                .internal}
            -   [`z`{.code .docutils .literal
                .notranslate}](../default_ops.html#z){.reference
                .internal}
            -   [`h`{.code .docutils .literal
                .notranslate}](../default_ops.html#h){.reference
                .internal}
            -   [`r1`{.code .docutils .literal
                .notranslate}](../default_ops.html#r1){.reference
                .internal}
            -   [`rx`{.code .docutils .literal
                .notranslate}](../default_ops.html#rx){.reference
                .internal}
            -   [`ry`{.code .docutils .literal
                .notranslate}](../default_ops.html#ry){.reference
                .internal}
            -   [`rz`{.code .docutils .literal
                .notranslate}](../default_ops.html#rz){.reference
                .internal}
            -   [`s`{.code .docutils .literal
                .notranslate}](../default_ops.html#s){.reference
                .internal}
            -   [`t`{.code .docutils .literal
                .notranslate}](../default_ops.html#t){.reference
                .internal}
            -   [`swap`{.code .docutils .literal
                .notranslate}](../default_ops.html#swap){.reference
                .internal}
            -   [`u3`{.code .docutils .literal
                .notranslate}](../default_ops.html#u3){.reference
                .internal}
        -   [Adjoint and Controlled
            Operations](../default_ops.html#adjoint-and-controlled-operations){.reference
            .internal}
        -   [Measurements on
            Qubits](../default_ops.html#measurements-on-qubits){.reference
            .internal}
            -   [`mz`{.code .docutils .literal
                .notranslate}](../default_ops.html#mz){.reference
                .internal}
            -   [`mx`{.code .docutils .literal
                .notranslate}](../default_ops.html#mx){.reference
                .internal}
            -   [`my`{.code .docutils .literal
                .notranslate}](../default_ops.html#my){.reference
                .internal}
        -   [User-Defined Custom
            Operations](../default_ops.html#user-defined-custom-operations){.reference
            .internal}
        -   [Photonic Operations on
            Qudits](../default_ops.html#photonic-operations-on-qudits){.reference
            .internal}
            -   [`create`{.code .docutils .literal
                .notranslate}](../default_ops.html#create){.reference
                .internal}
            -   [`annihilate`{.code .docutils .literal
                .notranslate}](../default_ops.html#annihilate){.reference
                .internal}
            -   [`phase_shift`{.code .docutils .literal
                .notranslate}](../default_ops.html#phase-shift){.reference
                .internal}
            -   [`beam_splitter`{.code .docutils .literal
                .notranslate}](../default_ops.html#beam-splitter){.reference
                .internal}
            -   [`mz`{.code .docutils .literal
                .notranslate}](../default_ops.html#id1){.reference
                .internal}
-   [Other Versions](../../versions.html){.reference .internal}
:::
:::

::: {.section .wy-nav-content-wrap toggle="wy-nav-shift"}
[NVIDIA CUDA-Q](../../index.html)

::: {.wy-nav-content}
::: {.rst-content}
::: {role="navigation" aria-label="Page navigation"}
-   [](../../index.html){.icon .icon-home}
-   [Code documentation](../api.html)
-   CUDA-Q Python API
-   

::: {.rst-breadcrumbs-buttons role="navigation" aria-label="Sequential page navigation"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](cpp_api.html "CUDA-Q C++ API"){.btn .btn-neutral .float-left}
[Next []{.fa .fa-arrow-circle-right
aria-hidden="true"}](../default_ops.html "Quantum Operations"){.btn
.btn-neutral .float-right}
:::

------------------------------------------------------------------------
:::

::: {.document role="main" itemscope="itemscope" itemtype="http://schema.org/Article"}
::: {itemprop="articleBody"}
::: {#module-cudaq .section}
[]{#cuda-q-python-api}

CUDA-Q Python API[¶](#module-cudaq "Permalink to this heading"){.headerlink}
============================================================================

::: {#program-construction .section}
Program Construction[¶](#program-construction "Permalink to this heading"){.headerlink}
---------------------------------------------------------------------------------------

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[make\_kernel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.make_kernel "Permalink to this definition"){.headerlink}

:   <div>
    >
    > Create a [`Kernel`{.xref .py .py-class .docutils .literal
    > .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
    > .internal}: An empty kernel function to be used for quantum
    > program construction. This kernel is non-parameterized if it
    > accepts no arguments, else takes the provided types as arguments.
    >
    > Returns a kernel if it is non-parameterized, else a tuple
    > containing the kernel and a [`QuakeValue`{.xref .py .py-class
    > .docutils .literal
    > .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
    > .internal} for each kernel argument.
    >
    > </div>

    ::: {.highlight-python .notranslate}
    ::: {.highlight}
        # Example:
        # Non-parameterized kernel.
        kernel = cudaq.make_kernel()

        # Example:
        # Parameterized kernel that accepts an `int` and `float` as arguments.
        kernel, int_value, float_value = cudaq.make_kernel(int, float)
    :::
    :::

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[PyKernel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[argTypeList]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.PyKernel "Permalink to this definition"){.headerlink}

:   The [`Kernel`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference .internal}
    provides an API for dynamically constructing quantum circuits. The
    [`Kernel`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference .internal}
    programmatically represents the circuit as an MLIR function using
    the Quake dialect.

    [[name]{.pre}]{.sig-name .descname}[¶](#cudaq.PyKernel.name "Permalink to this definition"){.headerlink}

    :   The name of the [`Kernel`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal} function. Read-only.

        Type[:]{.colon}

        :   [`str`{.xref .py .py-obj .docutils .literal
            .notranslate}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
            .external}

    [[arguments]{.pre}]{.sig-name .descname}[¶](#cudaq.PyKernel.arguments "Permalink to this definition"){.headerlink}

    :   The arguments accepted by the [`Kernel`{.xref .py .py-class
        .docutils .literal
        .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal} function. Read-only.

        Type[:]{.colon}

        :   List\[[`QuakeValue`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal}\]

    [[argument\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.PyKernel.argument_count "Permalink to this definition"){.headerlink}

    :   The number of arguments accepted by the [`Kernel`{.xref .py
        .py-class .docutils .literal
        .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal} function. Read-only.

        Type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Kernel]{.pre}]{.sig-name .descname}[¶](#cudaq.Kernel "Permalink to this definition"){.headerlink}

:   alias of [`PyKernel`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.PyKernel "cudaq.kernel.kernel_builder.PyKernel"){.reference
    .internal}

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[PyKernelDecorator]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[function]{.pre}]{.n}*, *[[verbose]{.pre}]{.n}[[=]{.pre}]{.o}[[False]{.pre}]{.default_value}*, *[[module]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[kernelName]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[funcSrc]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[signature]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[location]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[overrideGlobalScopedVars]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[¶](#cudaq.PyKernelDecorator "Permalink to this definition"){.headerlink}

:   The `PyKernelDecorator`{.code .docutils .literal .notranslate}
    serves as a standard Python decorator that takes the decorated
    function as input and optionally lowers its AST representation to
    executable code via MLIR. This decorator enables full JIT
    compilation mode, where the function is lowered to an MLIR
    representation.

    This decorator exposes a call overload that executes the code via
    the MLIR `ExecutionEngine`{.code .docutils .literal .notranslate}
    for the MLIR mode.

    [[\_\_call\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.PyKernelDecorator.__call__ "Permalink to this definition"){.headerlink}

    :   Invoke the CUDA-Q kernel. JIT compilation of the kernel AST to
        MLIR will occur here if it has not already occurred, except when
        the target requires custom handling.

    [[\_\_str\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.PyKernelDecorator.__str__ "Permalink to this definition"){.headerlink}

    :   Return the MLIR Module string representation for this kernel.

    [[compile]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.PyKernelDecorator.compile "Permalink to this definition"){.headerlink}

    :   Compile the Python function AST to MLIR. This is a no-op if the
        kernel is already compiled.

    [[enable\_return\_to\_log]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.PyKernelDecorator.enable_return_to_log "Permalink to this definition"){.headerlink}

    :   Enable translation from `return`{.code .docutils .literal
        .notranslate} statements to QIR output log

    [[extract\_c\_function\_pointer]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[name]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[¶](#cudaq.PyKernelDecorator.extract_c_function_pointer "Permalink to this definition"){.headerlink}

    :   Return the C function pointer for the function with given name,
        or with the name of this kernel if not provided.

    *[static]{.pre}[ ]{.w}*[[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[jStr]{.pre}]{.n}*, *[[overrideDict]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[¶](#cudaq.PyKernelDecorator.from_json "Permalink to this definition"){.headerlink}

    :   Convert a JSON string into a new PyKernelDecorator object.

    [[merge\_kernel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[otherMod]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.PyKernelDecorator.merge_kernel "Permalink to this definition"){.headerlink}

    :   Merge the kernel in this PyKernelDecorator (the ModuleOp) with
        the provided ModuleOp.

    [[synthesize\_callable\_arguments]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[funcNames]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.PyKernelDecorator.synthesize_callable_arguments "Permalink to this definition"){.headerlink}

    :   Given this Kernel has callable block arguments, synthesize away
        these callable arguments with the in-module FuncOps with given
        names. The name at index 0 in the list corresponds to the first
        callable block argument, index 1 to the second callable block
        argument, etc.

    [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.PyKernelDecorator.to_json "Permalink to this definition"){.headerlink}

    :   Convert `self`{.code .docutils .literal .notranslate} to a
        JSON-serialized version of the kernel such that
        `from_json`{.code .docutils .literal .notranslate} can
        reconstruct it elsewhere.

    *[static]{.pre}[ ]{.w}*[[type\_to\_str]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[t]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.PyKernelDecorator.type_to_str "Permalink to this definition"){.headerlink}

    :   This converts types to strings in a clean JSON-compatible way.
        int -\> 'int' list\[float\] -\> 'list\[float\]' List\[float\]
        -\> 'list\[float\]'

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[kernel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[function]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.kernel "Permalink to this definition"){.headerlink}

:   The `cudaq.kernel`{.code .docutils .literal .notranslate} represents
    the CUDA-Q language function attribute that programmers leverage to
    indicate the following function is a CUDA-Q kernel and should be
    compile and executed on an available quantum coprocessor.

    Verbose logging can be enabled via `verbose=True`{.code .docutils
    .literal .notranslate}.
:::

::: {#kernel-execution .section}
Kernel Execution[¶](#kernel-execution "Permalink to this heading"){.headerlink}
-------------------------------------------------------------------------------

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[sample]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[shots\_count]{.pre}]{.n}[[=]{.pre}]{.o}[[1000]{.pre}]{.default_value}*, *[[noise\_model]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[explicit\_measurements]{.pre}]{.n}[[=]{.pre}]{.o}[[False]{.pre}]{.default_value}*[)]{.sig-paren}[¶](#cudaq.sample "Permalink to this definition"){.headerlink}

:   Sample the state generated by the provided `kernel`{.code .docutils
    .literal .notranslate} at the given kernel `arguments`{.code
    .docutils .literal .notranslate} over the specified number of
    circuit executions (`shots_count`{.code .docutils .literal
    .notranslate}). Each argument in `arguments`{.code .docutils
    .literal .notranslate} provided can be a list or `ndarray`{.code
    .docutils .literal .notranslate} of arguments of the specified
    kernel argument type, and in this case, the `sample`{.code .docutils
    .literal .notranslate} functionality will be broadcasted over all
    argument sets and a list of `sample_result`{.code .docutils .literal
    .notranslate} instances will be returned.

    Parameters[:]{.colon}

    :   -   **kernel** ([`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to execute `shots_count`{.code .docutils .literal
            .notranslate} times on the QPU.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments. For example, if the
            kernel takes two `float`{.code .docutils .literal
            .notranslate} values as input, the `sample`{.code .docutils
            .literal .notranslate} call should be structured as
            `cudaq.sample(kernel, firstFloat, secondFloat)`{.code
            .docutils .literal .notranslate}. For broadcasting of the
            `sample`{.code .docutils .literal .notranslate} function,
            the arguments should be structured as a `list`{.code
            .docutils .literal .notranslate} or `ndarray`{.code
            .docutils .literal .notranslate} of argument values of the
            specified kernel argument type.

        -   **shots\_count**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}*\]*) -- The number of kernel executions on the
            QPU. Defaults to 1000. Key-word only.

        -   **noise\_model** (Optional\[`NoiseModel`{.code .docutils
            .literal .notranslate}\]) -- The optional
            [`NoiseModel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference
            .internal} to add noise to the kernel execution on the
            simulator. Defaults to an empty noise model.

        -   **explicit\_measurements**
            (*Optional\[*[*bool*](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference
            .external}*\]*) -- Whether or not to concatenate
            measurements in execution order for the returned sample
            result.

    Returns[:]{.colon}

    :   A dictionary containing the measurement count results for the
        [`Kernel`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal}, or a list of such results in the case of
        `sample`{.code .docutils .literal .notranslate} function
        broadcasting.

    Return type[:]{.colon}

    :   [`SampleResult`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} or `list[SampleResult]`{.code .docutils .literal
        .notranslate}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[sample\_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.sample_async "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[sample\_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel:]{.pre} [object]{.pre}]{.n}*, *[[\\\*args]{.pre}]{.n}*, *[[shots\_count:]{.pre} [int]{.pre} [=]{.pre} [1000]{.pre}]{.n}*, *[[explicit\_measurements:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[qpu\_id:]{.pre} [int]{.pre} [=]{.pre} [0]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[AsyncSampleResult]{.pre}](#cudaq.AsyncSampleResult "cudaq.AsyncSampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Asynchronously sample the state of the provided `kernel`{.code
    .docutils .literal .notranslate} at the specified number of circuit
    executions (`shots_count`{.code .docutils .literal .notranslate}).
    When targeting a quantum platform with more than one QPU, the
    optional `qpu_id`{.code .docutils .literal .notranslate} allows for
    control over which QPU to enable. Will return a future whose results
    can be retrieved via `future.get()`{.code .docutils .literal
    .notranslate}.

    Parameters[:]{.colon}

    :   -   **kernel** ([`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to execute `shots_count`{.code .docutils .literal
            .notranslate} times on the QPU.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

        -   **shots\_count**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}*\]*) -- The number of kernel executions on the
            QPU. Defaults to 1000. Key-word only.

        -   **explicit\_measurements**
            (*Optional\[*[*bool*](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference
            .external}*\]*) -- A flag to indicate whether or not to
            concatenate measurements in execution order for the returned
            sample result.

        -   **qpu\_id**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}*\]*) -- The optional identification for which QPU
            on the platform to target. Defaults to zero. Key-word only.

    Returns[:]{.colon}

    :   A dictionary containing the measurement count results for the
        [`Kernel`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal}.

    Return type[:]{.colon}

    :   [`AsyncSampleResult`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.AsyncSampleResult "cudaq.AsyncSampleResult"){.reference
        .internal}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[run]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.run "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[run]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel:]{.pre} [object]{.pre}]{.n}*, *[[\\\*args]{.pre}]{.n}*, *[[shots\_count:]{.pre} [int]{.pre} [=]{.pre} [100]{.pre}]{.n}*, *[[noise\_model:]{.pre} [Optional\[NoiseModel\]]{.pre} [=]{.pre} [None]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

    :   

    Run the provided `kernel`{.code .docutils .literal .notranslate}
    with the given kernel arguments over the specified number of circuit
    executions (`shots_count`{.code .docutils .literal .notranslate}).

    Parameters[:]{.colon}

    :   -   **kernel** -- The kernel to execute `shots_count`{.code
            .docutils .literal .notranslate} times on the QPU.

        -   **\*arguments** -- The concrete values to evaluate the
            kernel function at.

        -   **shots\_count** -- The number of kernel executions on the
            QPU. Defaults to 100.

        -   **noise\_model** -- The optional noise model to add noise to
            the kernel execution.

    Returns[:]{.colon}

    :   A list of kernel return values from each execution. The length
        equals `shots_count`{.code .docutils .literal .notranslate}.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[run\_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[shots\_count]{.pre}]{.n}[[=]{.pre}]{.o}[[100]{.pre}]{.default_value}*, *[[noise\_model]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[qpu\_id]{.pre}]{.n}[[=]{.pre}]{.o}[[0]{.pre}]{.default_value}*[)]{.sig-paren}[¶](#cudaq.run_async "Permalink to this definition"){.headerlink}

:   Run the provided `kernel`{.code .docutils .literal .notranslate}
    with the given kernel `arguments`{.code .docutils .literal
    .notranslate} over the specified number of circuit executions
    (`shots_count`{.code .docutils .literal .notranslate})
    asynchronously on the specified `qpu_id`{.code .docutils .literal
    .notranslate}.

    Parameters[:]{.colon}

    :   -   **kernel** ([`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to execute `shots_count`{.code .docutils .literal
            .notranslate} times on the QPU.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments. For example, if the
            kernel takes two `float`{.code .docutils .literal
            .notranslate} values as input, the `run`{.code .docutils
            .literal .notranslate} call should be structured as
            `cudaq.run(kernel, firstFloat, secondFloat)`{.code .docutils
            .literal .notranslate}.

        -   **shots\_count**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}*\]*) -- The number of kernel executions on the
            QPU. Defaults to 100. Key-word only.

        -   **noise\_model** (Optional\[`NoiseModel`{.code .docutils
            .literal .notranslate}\]) -- The optional
            [`NoiseModel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference
            .internal} to add noise to the kernel execution on the
            simulator. Defaults to an empty noise model.

        -   **qpu\_id**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}*\]*) -- The id of the QPU. Defaults to 0.
            Key-word only.

    Returns[:]{.colon}

    :   A handle, which can be waited on via a `get()`{.code .docutils
        .literal .notranslate} method, which returns an array of
        `kernel`{.code .docutils .literal .notranslate} return values.
        The length of the list is equal to `shots_count`{.code .docutils
        .literal .notranslate}.

    Return type[:]{.colon}

    :   `AsyncRunResult`{.code .docutils .literal .notranslate}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[observe]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}*, *[[spin\_operator]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[shots\_count]{.pre}]{.n}[[=]{.pre}]{.o}[[0]{.pre}]{.default_value}*, *[[noise\_model]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[num\_trajectories]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[execution]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[¶](#cudaq.observe "Permalink to this definition"){.headerlink}

:   Compute the expected value of the `spin_operator`{.code .docutils
    .literal .notranslate} with respect to the `kernel`{.code .docutils
    .literal .notranslate}. If the input `spin_operator`{.code .docutils
    .literal .notranslate} is a list of `SpinOperator`{.code .docutils
    .literal .notranslate} then compute the expected value of every
    operator in the list and return a list of results. If the kernel
    accepts arguments, it will be evaluated with respect to
    `kernel(*arguments)`{.code .docutils .literal .notranslate}. Each
    argument in `arguments`{.code .docutils .literal .notranslate}
    provided can be a list or `ndarray`{.code .docutils .literal
    .notranslate} of arguments of the specified kernel argument type,
    and in this case, the `observe`{.code .docutils .literal
    .notranslate} functionality will be broadcasted over all argument
    sets and a list of `observe_result`{.code .docutils .literal
    .notranslate} instances will be returned. If both the input
    `spin_operator`{.code .docutils .literal .notranslate} and
    `arguments`{.code .docutils .literal .notranslate} are broadcast
    lists, a nested list of results over `arguments`{.code .docutils
    .literal .notranslate} then `spin_operator`{.code .docutils .literal
    .notranslate} will be returned.

    Parameters[:]{.colon}

    :   -   **kernel** ([`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to evaluate the expectation value with respect
            to.

        -   **spin\_operator** (`SpinOperator`{.code .docutils .literal
            .notranslate} or `list[SpinOperator]`{.code .docutils
            .literal .notranslate}) -- The Hermitian spin operator to
            calculate the expectation of, or a list of such operators.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

        -   **shots\_count**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}*\]*) -- The number of shots to use for QPU
            execution. Defaults to -1 implying no shots-based sampling.
            Key-word only.

        -   **noise\_model** (Optional\[`NoiseModel`{.code .docutils
            .literal .notranslate}\]) -- The optional
            [`NoiseModel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference
            .internal} to add noise to the kernel execution on the
            simulator. Defaults to an empty noise model.

        -   **num\_trajectories**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}*\]*) -- The optional number of trajectories for
            noisy simulation. Only valid if a noise model is provided.
            Key-word only.

    Returns[:]{.colon}

    :   A data-type containing the expectation value of the
        `spin_operator`{.code .docutils .literal .notranslate} with
        respect to the `kernel(*arguments)`{.code .docutils .literal
        .notranslate}, or a list of such results in the case of
        `observe`{.code .docutils .literal .notranslate} function
        broadcasting. If `shots_count`{.code .docutils .literal
        .notranslate} was provided, the [`ObserveResult`{.xref .py
        .py-class .docutils .literal
        .notranslate}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference
        .internal} will also contain a [`SampleResult`{.xref .py
        .py-class .docutils .literal
        .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} dictionary.

    Return type[:]{.colon}

    :   [`ObserveResult`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference
        .internal}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[observe\_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.observe_async "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[observe\_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel:]{.pre} [object]{.pre}]{.n}*, *[[spin\_operator:]{.pre} [object]{.pre}]{.n}*, *[[\\\*args]{.pre}]{.n}*, *[[qpu\_id:]{.pre} [int]{.pre} [=]{.pre} [0]{.pre}]{.n}*, *[[shots\_count:]{.pre} [int]{.pre} [=]{.pre} [-1]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[AsyncObserveResult]{.pre}](#cudaq.AsyncObserveResult "cudaq.AsyncObserveResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Compute the expected value of the `spin_operator`{.code .docutils
    .literal .notranslate} with respect to the `kernel`{.code .docutils
    .literal .notranslate} asynchronously. If the kernel accepts
    arguments, it will be evaluated with respect to
    `kernel(*arguments)`{.code .docutils .literal .notranslate}. When
    targeting a quantum platform with more than one QPU, the optional
    `qpu_id`{.code .docutils .literal .notranslate} allows for control
    over which QPU to enable. Will return a future whose results can be
    retrieved via `future.get()`{.code .docutils .literal .notranslate}.

    Parameters[:]{.colon}

    :   -   **kernel** ([`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to evaluate the expectation value with respect
            to.

        -   **spin\_operator** (`SpinOperator`{.code .docutils .literal
            .notranslate}) -- The Hermitian spin operator to calculate
            the expectation of.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

        -   **qpu\_id**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}*\]*) -- The optional identification for which QPU
            on the platform to target. Defaults to zero. Key-word only.

        -   **shots\_count**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}*\]*) -- The number of shots to use for QPU
            execution. Defaults to -1 implying no shots-based sampling.
            Key-word only.

    Returns[:]{.colon}

    :   A future containing the result of the call to observe.

    Return type[:]{.colon}

    :   [`AsyncObserveResult`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.AsyncObserveResult "cudaq.AsyncObserveResult"){.reference
        .internal}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[get\_state]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.get_state "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[get\_state]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0:]{.pre} [object]{.pre}]{.n}*, *[[\\\*args]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Return the [`State`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.State "cudaq.State"){.reference .internal} of
    the system after execution of the provided `kernel`{.code .docutils
    .literal .notranslate}.

    Parameters[:]{.colon}

    :   -   **kernel** ([`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to execute on the QPU.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

    ::: {.highlight-python .notranslate}
    ::: {.highlight}
        # Example:
        import numpy as np

        # Define a kernel that will produced the all |11...1> state.
        kernel = cudaq.make_kernel()
        qubits = kernel.qalloc(3)
        # Prepare qubits in the 1-state.
        kernel.x(qubits)

        # Get the state of the system. This will execute the provided kernel
        # and, depending on the selected target, will return the state as a
        # vector or matrix.
        state = cudaq.get_state(kernel)
        print(state)
    :::
    :::

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[get\_state\_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.get_state_async "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[get\_state\_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel:]{.pre} [object]{.pre}]{.n}*, *[[\\\*args]{.pre}]{.n}*, *[[qpu\_id:]{.pre} [int]{.pre} [=]{.pre} [0]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[AsyncStateResult]{.pre}](#cudaq.AsyncStateResult "cudaq.AsyncStateResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Asynchronously retrieve the state generated by the given quantum
    kernel. When targeting a quantum platform with more than one QPU,
    the optional `qpu_id`{.code .docutils .literal .notranslate} allows
    for control over which QPU to enable. Will return a future whose
    results can be retrieved via `future.get()`{.code .docutils .literal
    .notranslate}.

    Parameters[:]{.colon}

    :   -   **kernel** ([`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to execute on the QPU.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

        -   **qpu\_id**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}*\]*) -- The optional identification for which QPU
            on the platform to target. Defaults to zero. Key-word only.

    Returns[:]{.colon}

    :   Quantum state (state vector or density matrix) data).

    Return type[:]{.colon}

    :   [`AsyncStateResult`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.AsyncStateResult "cudaq.AsyncStateResult"){.reference
        .internal}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[vqe]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.vqe "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[vqe]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*, *[[spin\_operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*, *[[optimizer]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.optimizer]{.pre}](#cudaq.optimizers.optimizer "cudaq.optimizers.optimizer"){.reference .internal}]{.n}*, *[[parameter\_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[shots]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[-1]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

    2.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[vqe]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*, *[[spin\_operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*, *[[optimizer]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.optimizer]{.pre}](#cudaq.optimizers.optimizer "cudaq.optimizers.optimizer"){.reference .internal}]{.n}*, *[[parameter\_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[argument\_mapper]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*, *[[shots]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[-1]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

    3.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[vqe]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*, *[[gradient\_strategy]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.gradient]{.pre}](#cudaq.gradients.gradient "cudaq.gradients.gradient"){.reference .internal}]{.n}*, *[[spin\_operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*, *[[optimizer]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.optimizer]{.pre}](#cudaq.optimizers.optimizer "cudaq.optimizers.optimizer"){.reference .internal}]{.n}*, *[[parameter\_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[shots]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[-1]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

    4.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[vqe]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*, *[[gradient\_strategy]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.gradient]{.pre}](#cudaq.gradients.gradient "cudaq.gradients.gradient"){.reference .internal}]{.n}*, *[[spin\_operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*, *[[optimizer]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.optimizer]{.pre}](#cudaq.optimizers.optimizer "cudaq.optimizers.optimizer"){.reference .internal}]{.n}*, *[[parameter\_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[argument\_mapper]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*, *[[shots]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[-1]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[draw]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.draw "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[draw]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0:]{.pre} [str]{.pre}]{.n}*, *[[arg1:]{.pre} [object]{.pre}]{.n}*, *[[\\\*args]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

    Return a string representing the drawing of the execution path, in
    the format specified as the first argument. If the format is
    'ascii', the output will be a UTF-8 encoded string. If the format is
    'latex', the output will be a LaTeX string.

    Parameters[:]{.colon}

    :   -   **format**
            ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
            .external}) -- The format of the output. Can be 'ascii' or
            'latex'.

        -   **kernel** ([`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to draw.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

    2.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[draw]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0:]{.pre} [object]{.pre}]{.n}*, *[[\\\*args]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

    Return a UTF-8 encoded string representing drawing of the execution
    path, i.e., the trace, of the provided `kernel`{.code .docutils
    .literal .notranslate}.

    Parameters[:]{.colon}

    :   -   **kernel** ([`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to draw.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

    Returns[:]{.colon}

    :   The UTF-8 encoded string of the circuit, without measurement
        operations.

    ::: {.highlight-python .notranslate}
    ::: {.highlight}
        # Example
        import cudaq
        @cudaq.kernel
        def bell_pair():
            q = cudaq.qvector(2)
            h(q[0])
            cx(q[0], q[1])
            mz(q)
        print(cudaq.draw(bell_pair))
        # Output
        #      ╭───╮
        # q0 : ┤ h ├──●──
        #      ╰───╯╭─┴─╮
        # q1 : ─────┤ x ├
        #           ╰───╯

        # Example with arguments
        import cudaq
        @cudaq.kernel
        def kernel(angle:float):
            q = cudaq.qubit()
            h(q)
            ry(angle, q)
        print(cudaq.draw(kernel, 0.59))
        # Output
        #      ╭───╮╭──────────╮
        # q0 : ┤ h ├┤ ry(0.59) ├
        #      ╰───╯╰──────────╯
    :::
    :::

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[translate]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.translate "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[translate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel:]{.pre} [object]{.pre}]{.n}*, *[[\\\*args]{.pre}]{.n}*, *[[format:]{.pre} [str]{.pre} [=]{.pre} [\'qir:0.1\']{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Return a UTF-8 encoded string representing drawing of the execution
    path, i.e., the trace, of the provided `kernel`{.code .docutils
    .literal .notranslate}.

    Parameters[:]{.colon}

    :   -   **format**
            ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
            .external}) -- format to translate to, \<name\[:version\]\>.
            Available format names: `qir`{.code .docutils .literal
            .notranslate}, `qir-full`{.code .docutils .literal
            .notranslate}, `qir-base`{.code .docutils .literal
            .notranslate}, `qir-adaptive`{.code .docutils .literal
            .notranslate}, `openqasm2`{.code .docutils .literal
            .notranslate}. QIR versions: `0.1`{.code .docutils .literal
            .notranslate} and `0.2`{.code .docutils .literal
            .notranslate}.

        -   **kernel** ([`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to translate.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

        -   **Note** -- Translating functions with arguments to OpenQASM
            2.0 is not supported.

    Returns[:]{.colon}

    :   The UTF-8 encoded string of the circuit, without measurement
        operations.

    ::: {.highlight-python .notranslate}
    ::: {.highlight}
        # Example
        import cudaq
        @cudaq.kernel
        def bell_pair():
            q = cudaq.qvector(2)
            h(q[0])
            cx(q[0], q[1])
            mz(q)
        print(cudaq.translate(bell_pair, format="qir"))

        # Output
        ; ModuleID = 'LLVMDialectModule'
        source_filename = 'LLVMDialectModule'

        %Array = type opaque
        %Result = type opaque
        %Qubit = type opaque

        ...
        ...

        define void @__nvqpp__mlirgen__function_variable_qreg._Z13variable_qregv() local_unnamed_addr {
          %1 = tail call %Array* @__quantum__rt__qubit_allocate_array(i64 2)
          ...
          %8 = tail call %Result* @__quantum__qis__mz(%Qubit* %4)
          %9 = tail call %Result* @__quantum__qis__mz(%Qubit* %7)
          tail call void @__quantum__rt__qubit_release_array(%Array* %1)
          ret void
        }
    :::
    :::

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[estimate\_resources]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.estimate_resources "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[estimate\_resources]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel:]{.pre} [object]{.pre}]{.n}*, *[[\\\*args]{.pre}]{.n}*, *[[choice:]{.pre} [Optional\[Callable\[\[\]]{.pre}]{.n}*, *[[bool\]\]]{.pre} [=]{.pre} [None]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Performs resource counting on the given quantum kernel expression
    and returns an accounting of how many times each gate was applied,
    in addition to the total number of gates and qubits used.

    Parameters[:]{.colon}

    :   -   **choice** (*Any*) -- A choice function called to determine
            the outcome of measurements, in case control flow depends on
            measurements. Should only return either `True`{.code
            .docutils .literal .notranslate} or `False`{.code .docutils
            .literal .notranslate}. Invoking the kernel within the
            choice function is forbidden. Default: returns `True`{.code
            .docutils .literal .notranslate} or `False`{.code .docutils
            .literal .notranslate} with 50% probability.

        -   **kernel** ([`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to count resources on

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

    Returns[:]{.colon}

    :   A dictionary containing the resource count results for the
        [`Kernel`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal}.

    Return type[:]{.colon}

    :   [`Resources`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.Resources "cudaq.Resources"){.reference
        .internal}
:::

::: {#backend-configuration .section}
Backend Configuration[¶](#backend-configuration "Permalink to this heading"){.headerlink}
-----------------------------------------------------------------------------------------

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[has\_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.has_target "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[has\_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Return true if the `cudaq.Target`{.code .docutils .literal
    .notranslate} with the given name exists.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[get\_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.get_target "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[get\_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Return the `cudaq.Target`{.code .docutils .literal .notranslate}
    with the given name. Will raise an exception if the name is not
    valid.

    2.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[get\_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Return the `cudaq.Target`{.code .docutils .literal .notranslate}
    with the given name. Will raise an exception if the name is not
    valid.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[get\_targets]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.get_targets "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[get\_targets]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

    :   

    Return all available `cudaq.Target`{.code .docutils .literal
    .notranslate} instances on the current system.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[set\_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.set_target "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[set\_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0:]{.pre} [Target]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

    Set the `cudaq.Target`{.code .docutils .literal .notranslate} to be
    used for CUDA-Q kernel execution. Can provide optional,
    target-specific configuration data via Python kwargs.

    2.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[set\_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0:]{.pre} [str]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

    Set the `cudaq.Target`{.code .docutils .literal .notranslate} with
    given name to be used for CUDA-Q kernel execution. Can provide
    optional, target-specific configuration data via Python kwargs.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[reset\_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.reset_target "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[reset\_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Reset the current `cudaq.Target`{.code .docutils .literal
    .notranslate} to the default.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[set\_noise]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.set_noise "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[set\_noise]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Set the underlying noise model.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[unset\_noise]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.unset_noise "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[unset\_noise]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Clear backend simulation from any existing noise models.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[apply\_noise]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[error\_type]{.pre}]{.n}*, *[[parameters\...]{.pre}]{.n}*, *[[targets\...]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.cudaq.apply_noise "Permalink to this definition"){.headerlink}

:   This function is a type-safe injection of noise into a quantum
    kernel, occurring precisely at the call site of the function
    invocation. The function should be called inside CUDA-Q kernels
    (those annotated with `@cudaq.kernel`{.code .docutils .literal
    .notranslate}). The functionality is only supported for simulation
    targets, so it is automatically (and silently) stripped from any
    programs submitted to hardware targets.

    Parameters[:]{.colon}

    :   -   **error\_type** --

            A subtype of [`cudaq.KrausChannel`{.xref .py .py-class
            .docutils .literal
            .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
            .internal} that implements/defines the desired noise
            mechanisms as Kraus channels (e.g.
            [`cudaq.Depolarization2`{.xref .py .py-class .docutils
            .literal
            .notranslate}](#cudaq.Depolarization2 "cudaq.Depolarization2"){.reference
            .internal}). If you want to use a custom
            [`cudaq.KrausChannel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
            .internal} (i.e. not built-in to CUDA-Q), it must first be
            registered *outside the kernel* with
            `register_channel`{.code .docutils .literal .notranslate},
            like this:

            ::: {.highlight-python .notranslate}
            ::: {.highlight}
                class CustomNoiseChannel(cudaq.KrausChannel):
                    num_parameters = 1
                    num_targets = 1

                def __init__(self, params: list[float]):
                    cudaq.KrausChannel.__init__(self)
                    # Example: Create Kraus ops based on params
                    p = params[0]
                    k0 = np.array([[np.sqrt(1 - p), 0], [0, np.sqrt(1 - p)]],
                                dtype=np.complex128)
                    k1 = np.array([[0, np.sqrt(p)], [np.sqrt(p), 0]],
                                dtype=np.complex128)

                    # Create KrausOperators and add to channel
                    self.append(cudaq.KrausOperator(k0))
                    self.append(cudaq.KrausOperator(k1))

                    self.noise_type = cudaq.NoiseModelType.Unknown

                noise = cudaq.NoiseModel()
                noise.register_channel(CustomNoiseChannel)
            :::
            :::

        -   **parameters** --

            The precise argument pack depend on the concrete
            [`cudaq.KrausChannel`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
            .internal} being used. The arguments are a concatenated list
            of parameters and targets. For example, to apply a 2-qubit
            depolarization channel, which has `num_parameters = 1`{.code
            .docutils .literal .notranslate} and `num_targets = 2`{.code
            .docutils .literal .notranslate}, one would write the call
            like this:

            ::: {.highlight-python .notranslate}
            ::: {.highlight}
                q, r = cudaq.qubit(), cudaq.qubit()
                cudaq.apply_noise(cudaq.Depolarization2, 0.1, q, r)
            :::
            :::

        -   **targets** -- The target qubits on which to apply the noise

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[initialize\_cudaq]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.initialize_cudaq "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[initialize\_cudaq]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Initialize the CUDA-Q environment.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[num\_available\_gpus]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.num_available_gpus "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[num\_available\_gpus]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    The number of available GPUs detected on the system.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[set\_random\_seed]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.set_random_seed "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[set\_random\_seed]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Provide the seed for backend quantum kernel simulation.
:::

::: {#dynamics .section}
Dynamics[¶](#dynamics "Permalink to this heading"){.headerlink}
---------------------------------------------------------------

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[evolve]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[hamiltonian]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SuperOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SuperOperator"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Mapping]{.pre}](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[schedule]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Schedule]{.pre}](#cudaq.Schedule "cudaq.dynamics.schedule.Schedule"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[initial\_state]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[State]{.pre}](#cudaq.State "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.State"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[InitialStateType]{.pre}](#cudaq.InitialStateType "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.InitialStateType"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.State]{.pre}](#cudaq.State "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.State"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.InitialStateType]{.pre}](#cudaq.InitialStateType "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.InitialStateType"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[collapse\_operators]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[observables]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[store\_intermediate\_results]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.dynamics.helpers.IntermediateResultSave]{.pre}](#cudaq.IntermediateResultSave "cudaq.dynamics.helpers.IntermediateResultSave"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[IntermediateResultSave.NONE]{.pre}]{.default_value}*, *[[integrator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[BaseIntegrator]{.pre}](#cudaq.dynamics.integrator.BaseIntegrator "cudaq.dynamics.integrator.BaseIntegrator"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[shots\_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[max\_batch\_size]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.EvolveResult"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.EvolveResult"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}[¶](#cudaq.evolve "Permalink to this definition"){.headerlink}

:   Computes the time evolution of one or more initial state(s) under
    the defined operator(s).

    Parameters[:]{.colon}

    :   -   **hamiltonian** -- Operator that describes the behavior of a
            quantum system without noise.

        -   **dimensions** -- A mapping that specifies the number of
            levels, that is the dimension, of each degree of freedom
            that any of the operator arguments acts on.

        -   **schedule** -- A sequence that generates a mapping of
            keyword arguments to their respective value. The keyword
            arguments are the parameters needed to evaluate any of the
            operators passed to `evolve`{.code .docutils .literal
            .notranslate}. All required parameters for evaluating an
            operator and their documentation, if available, can be
            queried by accessing the `parameter`{.code .docutils
            .literal .notranslate} property of the operator.

        -   **initial\_state** -- A single state or a sequence of states
            of a quantum system.

        -   **collapse\_operators** -- A sequence of operators that
            describe the influence of noise on the quantum system.

        -   **observables** -- A sequence of operators for which to
            compute their expectation value during evolution. If
            `store_intermediate_results`{.code .docutils .literal
            .notranslate} is not None, the expectation values are
            computed after each step in the schedule, and otherwise only
            the final expectation values at the end of the evolution are
            computed.

        -   **shots\_count** -- Optional integer, if provided, it is the
            number of shots to use for QPU execution.

    Returns[:]{.colon}

    :   A single evolution result if a single initial state is provided,
        or a sequence of evolution results representing the data
        computed during the evolution of each initial state. See
        `EvolveResult`{.code .docutils .literal .notranslate} for more
        information about the data computed during evolution.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[evolve\_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[hamiltonian]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Mapping]{.pre}](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[schedule]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Schedule]{.pre}](#cudaq.Schedule "cudaq.dynamics.schedule.Schedule"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[initial\_state]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[State]{.pre}](#cudaq.State "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.State"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[InitialStateType]{.pre}](#cudaq.InitialStateType "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.InitialStateType"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.State]{.pre}](#cudaq.State "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.State"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.InitialStateType]{.pre}](#cudaq.InitialStateType "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.InitialStateType"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[collapse\_operators]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[observables]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[store\_intermediate\_results]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.dynamics.helpers.IntermediateResultSave]{.pre}](#cudaq.IntermediateResultSave "cudaq.dynamics.helpers.IntermediateResultSave"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[IntermediateResultSave.NONE]{.pre}]{.default_value}*, *[[integrator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[BaseIntegrator]{.pre}](#cudaq.dynamics.integrator.BaseIntegrator "cudaq.dynamics.integrator.BaseIntegrator"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[shots\_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[AsyncEvolveResult]{.pre}](#cudaq.AsyncEvolveResult "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.AsyncEvolveResult"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[AsyncEvolveResult]{.pre}](#cudaq.AsyncEvolveResult "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.AsyncEvolveResult"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}[¶](#cudaq.evolve_async "Permalink to this definition"){.headerlink}

:   Asynchronously computes the time evolution of one or more initial
    state(s) under the defined operator(s). See `cudaq.evolve`{.code
    .docutils .literal .notranslate} for more details about the
    parameters passed here.

    Returns[:]{.colon}

    :   The handle to a single evolution result if a single initial
        state is provided, or a sequence of handles to the evolution
        results representing the data computed during the evolution of
        each initial state. See the `EvolveResult`{.code .docutils
        .literal .notranslate} for more information about the data
        computed during evolution.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Schedule]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[steps]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[get\_value]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Callable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[numpy.complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.3)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[¶](#cudaq.Schedule "Permalink to this definition"){.headerlink}

:   Represents an iterator that produces all values needed for
    evaluating an operator expression at different time steps.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.dynamics.integrator.]{.pre}]{.sig-prename .descclassname}[[BaseIntegrator]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.dynamics.integrator.BaseIntegrator "Permalink to this definition"){.headerlink}

:   An abstract wrapper around ODE integrator to ensure a common
    interface for master equation solver usage.

```{=html}
<!-- -->
```

[[cudaq.dynamics.helpers.]{.pre}]{.sig-prename .descclassname}[[InitialState]{.pre}]{.sig-name .descname}[¶](#cudaq.dynamics.helpers.InitialState "Permalink to this definition"){.headerlink}

:   alias of [`InitialStateType`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.InitialStateType "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.InitialStateType"){.reference
    .internal}

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[InitialStateType]{.pre}]{.sig-name .descname}[¶](#cudaq.InitialStateType "Permalink to this definition"){.headerlink}

:   Enumeration describing the initial state type to be created in the
    backend

    Members:

    > <div>
    >
    > ZERO
    >
    > UNIFORM
    >
    > </div>

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[IntermediateResultSave]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[value]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.IntermediateResultSave "Permalink to this definition"){.headerlink}

:   Enum to specify how intermediate results should be saved during the
    dynamics evolution.
:::

::: {#operators .section}
Operators[¶](#operators "Permalink to this heading"){.headerlink}
-----------------------------------------------------------------

[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[OperatorSum]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.OperatorSum "Permalink to this definition"){.headerlink}

:   alias of [`MatrixOperator`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference
    .internal} \| [`SpinOperator`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference
    .internal} \| [`BosonOperator`{.xref .py .py-class .docutils
    .literal
    .notranslate}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference
    .internal} \| [`FermionOperator`{.xref .py .py-class .docutils
    .literal
    .notranslate}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference
    .internal}

```{=html}
<!-- -->
```

[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[ProductOperator]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.ProductOperator "Permalink to this definition"){.headerlink}

:   alias of [`MatrixOperatorTerm`{.xref .py .py-class .docutils
    .literal
    .notranslate}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference
    .internal} \| [`SpinOperatorTerm`{.xref .py .py-class .docutils
    .literal
    .notranslate}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference
    .internal} \| [`BosonOperatorTerm`{.xref .py .py-class .docutils
    .literal
    .notranslate}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference
    .internal} \| [`FermionOperatorTerm`{.xref .py .py-class .docutils
    .literal
    .notranslate}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference
    .internal}

```{=html}
<!-- -->
```

[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[ElementaryOperator]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.ElementaryOperator "Permalink to this definition"){.headerlink}

:   alias of [`SpinOperatorElement`{.xref .py .py-class .docutils
    .literal
    .notranslate}](#cudaq.operators.spin.SpinOperatorElement "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorElement"){.reference
    .internal} \| [`BosonOperatorElement`{.xref .py .py-class .docutils
    .literal
    .notranslate}](#cudaq.operators.boson.BosonOperatorElement "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorElement"){.reference
    .internal} \| [`FermionOperatorElement`{.xref .py .py-class
    .docutils .literal
    .notranslate}](#cudaq.operators.fermion.FermionOperatorElement "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorElement"){.reference
    .internal} \| [`MatrixOperatorElement`{.xref .py .py-class .docutils
    .literal
    .notranslate}](#cudaq.operators.MatrixOperatorElement "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorElement"){.reference
    .internal}

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[ScalarOperator]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[generator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.3)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[\...]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[numpy.complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.3)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[parameter\_info]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Mapping]{.pre}](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[¶](#cudaq.operators.ScalarOperator "Permalink to this definition"){.headerlink}

:   

    *[classmethod]{.pre}[ ]{.w}*[[const]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[constant\_value]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[numpy.complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.3)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}[¶](#cudaq.operators.ScalarOperator.const "Permalink to this definition"){.headerlink}

    :   Creates a scalar operator that has a constant value.

    [[evaluate]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.ScalarOperator.evaluate "Permalink to this definition"){.headerlink}

    :   

        [[evaluate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [ScalarOperator]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Evaluated value of the operator.

    [[is\_constant]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.ScalarOperator.is_constant "Permalink to this definition"){.headerlink}

    :   

        [[is\_constant]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.operators.ScalarOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns true if the scalar is a constant value.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.ScalarOperator.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Mapping]{.pre}](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[numpy.complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.3)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.3)"){.reference .external}[[\[]{.pre}]{.p}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[dtype]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.3)"){.reference .external}[[\[]{.pre}]{.p}[[complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.3)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}[¶](#cudaq.operators.ScalarOperator.to_matrix "Permalink to this definition"){.headerlink}

    :   Class method for consistency with other operator classes.
        Invokes the generator with the given keyword arguments.

        Parameters[:]{.colon}

        :   -   **dimensions** -- (unused, passed for consistency) A
                mapping that specifies the number of levels, that is the
                dimension, of each degree of freedom that the operator
                acts on.

            -   **kwargs** -- Keyword arguments needed to evaluate the
                generator. All required parameters and their
                documentation, if available, can be queried by accessing
                the `parameter`{.code .docutils .literal .notranslate}
                property.

        Returns[:]{.colon}

        :   An array with a single element corresponding to the value of
            the operator for the given keyword arguments.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[RydbergHamiltonian]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[atom\_sites]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[amplitude]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[phase]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[delta\_global]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[atom\_filling]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[delta\_local]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[¶](#cudaq.operators.RydbergHamiltonian "Permalink to this definition"){.headerlink}

:   Representation for the time-dependent Hamiltonian which is simulated
    by analog neutral-atom machines such as QuEra's Aquila and Pasqal's
    Fresnel. Ref:
    <https://docs.aws.amazon.com/braket/latest/developerguide/braket-quera-submitting-analog-program-aquila.html#braket-quera-ahs-program-schema>

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[atom\_sites]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[amplitude]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[phase]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[delta\_global]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[atom\_filling]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[delta\_local]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir\_libs.\_quakeDialects.cudaq\_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[¶](#cudaq.operators.RydbergHamiltonian.__init__ "Permalink to this definition"){.headerlink}

    :   Instantiate an operator consumable by `evolve`{.code .docutils
        .literal .notranslate} API using the supplied parameters.

        Parameters[:]{.colon}

        :   -   **atom\_sites** -- List of 2-d coordinates where the
                tweezers trap atoms.

            -   **amplitude** -- time and value points of driving
                amplitude, Omega(t).

            -   **phase** -- time and value points of driving phase,
                phi(t).

            -   **delta\_global** -- time and value points of driving
                detuning, Delta\_global(t).

            -   **atom\_filling** -- typing.Optional. Marks atoms that
                occupy the trap sites with 1, and empty sites with 0. If
                not provided, all are set to 1, i.e. filled.

            -   **delta\_local** -- typing.Optional. A tuple of time and
                value points of the time-dependent factor of the local
                detuning magnitude, Delta\_local(t), and site-dependent
                factor of the local detuning magnitude, h\_k, a
                dimensionless number between 0.0 and 1.0

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[SuperOperator]{.pre}]{.sig-name .descname}[¶](#cudaq.SuperOperator "Permalink to this definition"){.headerlink}

:   

    *[static]{.pre}[ ]{.w}*[[left\_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.SuperOperator.left_multiply "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[left\_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a left multiplication of
        the operator to the density matrix.

        2.  

            [[left\_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a left multiplication of
        the operator to the density matrix. The sum is distributed into
        a linear combination of super-operator actions.

    *[static]{.pre}[ ]{.w}*[[left\_right\_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.SuperOperator.left_right_multiply "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[left\_right\_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a simultaneous left
        multiplication of the first operator operand and right
        multiplication of the second operator operand to the density
        matrix.

        2.  

            [[left\_right\_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a simultaneous left
        multiplication of the first operator operand and right
        multiplication of the second operator operand to the density
        matrix. The sum is distributed into a linear combination of
        super-operator actions.

    *[static]{.pre}[ ]{.w}*[[right\_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.SuperOperator.right_multiply "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[right\_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a right multiplication of
        the operator to the density matrix.

        2.  

            [[right\_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a right multiplication of
        the operator to the density matrix. The sum is distributed into
        a linear combination of super-operator actions.

```{=html}
<!-- -->
```

[[operators.]{.pre}]{.sig-prename .descclassname}[[define]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[expected\_dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[create]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Callable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[\...]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.3)"){.reference .external}[[\[]{.pre}]{.p}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[dtype]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.3)"){.reference .external}[[\[]{.pre}]{.p}[[complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.3)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[override]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}[¶](#cudaq.operators.define "Permalink to this definition"){.headerlink}

:   Defines a matrix operator element with the given id. After
    definition, an the defined elementary operator can be instantiated
    by providing the operator id as well as the degree(s) of freedom
    that it acts on. A matrix operator element is a parameterized object
    acting on certain degrees of freedom. To evaluate an operator, for
    example to compute its matrix, the level, that is the dimension, for
    each degree of freedom it acts on must be provided, as well as all
    additional parameters. Additional parameters must be provided in the
    form of keyword arguments.

    Note: The dimensions passed during operator evaluation are
    automatically validated against the expected dimensions specified
    during definition - the `create`{.code .docutils .literal
    .notranslate} function does not need to do this.

    Parameters[:]{.colon}

    :   -   **op\_id** -- A string that uniquely identifies the defined
            operator.

        -   **expected\_dimensions** -- defines the number of levels,
            that is the dimension, for each degree of freedom in
            canonical (that is sorted) order. A negative or zero value
            for one (or more) of the expected dimensions indicates that
            the operator is defined for any dimension of the
            corresponding degree of freedom.

        -   **create** -- Takes any number of complex-valued arguments
            and returns the matrix representing the operator in
            canonical order. If the matrix can be defined for any number
            of levels for one or more degree of freedom, the
            `create`{.code .docutils .literal .notranslate} function
            must take an argument called `dimension`{.code .docutils
            .literal .notranslate} (or `dim`{.code .docutils .literal
            .notranslate} for short), if the operator acts on a single
            degree of freedom, and an argument called `dimensions`{.code
            .docutils .literal .notranslate} (or `dims`{.code .docutils
            .literal .notranslate} for short), if the operator acts on
            multiple degrees of freedom.

        -   **override** -- if True it allows override the definition.
            (default: False)

```{=html}
<!-- -->
```

[[operators.]{.pre}]{.sig-prename .descclassname}[[instantiate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}[¶](#cudaq.operators.instantiate "Permalink to this definition"){.headerlink}

:   Instantiates a product operator containing a previously defined
    operator element.

    Parameters[:]{.colon}

    :   -   **operator\_id** -- The id of the operator element as
            specified when it was defined.

        -   **degrees** -- The degree(s) of freedom that the operator
            acts on.

::: {#spin-operators .section}
### Spin Operators[¶](#spin-operators "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.operators.spin.]{.pre}]{.sig-prename .descclassname}[[SpinOperator]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperator "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. If an empty set is passed, canonicalizes
        all terms in the sum to act on the same degrees of freedom.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperator.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        `to_matrix`{.code .docutils .literal .notranslate}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[distribute\_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.distribute_terms "Permalink to this definition"){.headerlink}

    :   

        [[distribute\_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Partitions the terms of the sums into the given number of
        separate sums.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    *[static]{.pre}[ ]{.w}*[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.empty "Permalink to this definition"){.headerlink}

    :   

        [[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a sum operator with no terms. And empty sum is the
        neutral element for addition; multiplying an empty sum with
        anything will still result in an empty sum.

    *[static]{.pre}[ ]{.w}*[[empty\_op]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.empty_op "Permalink to this definition"){.headerlink}

    :   

        [[empty\_op]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use `empty`{.code .docutils .literal .notranslate}
        instead.

    [[for\_each\_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.for_each_pauli "Permalink to this definition"){.headerlink}

    :   

        [[for\_each\_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - iterator over sum and then iterator over term
        instead.

    [[for\_each\_term]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.for_each_term "Permalink to this definition"){.headerlink}

    :   

        [[for\_each\_term]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use standard iteration instead.

    *[static]{.pre}[ ]{.w}*[[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string ('\[d1, d2, d3, ...\]') to spin\_op

    *[static]{.pre}[ ]{.w}*[[from\_word]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.from_word "Permalink to this definition"){.headerlink}

    :   

        [[from\_word]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates an operator from a Pauli word string.

    [[get\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.get_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[get\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use `evaluate_coefficient`{.code .docutils .literal
        .notranslate} on each term (product operator) instead.

    [[get\_qubit\_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.get_qubit_count "Permalink to this definition"){.headerlink}

    :   

        [[get\_qubit\_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use `qubit_count`{.code .docutils .literal
        .notranslate} instead.

    [[get\_raw\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.get_raw_data "Permalink to this definition"){.headerlink}

    :   

        [[get\_raw\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated.

    [[get\_term\_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.get_term_count "Permalink to this definition"){.headerlink}

    :   

        [[get\_term\_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use `term_count`{.code .docutils .literal
        .notranslate} instead.

    *[static]{.pre}[ ]{.w}*[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.identity "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator with constant value 1. The identity
        operator is the neutral element for multiplication.

        2.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator that applies the identity to the
        given target index.

    [[is\_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.is_identity "Permalink to this definition"){.headerlink}

    :   

        [[is\_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - is\_identity will only be supported on each term
        (product operator) in future releases.

    *[property]{.pre}[ ]{.w}*[[max\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperator.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperator.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperator.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[qubit\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperator.qubit_count "Permalink to this definition"){.headerlink}

    :   Return the number of qubits this operator acts on.

    *[static]{.pre}[ ]{.w}*[[random]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.random "Permalink to this definition"){.headerlink}

    :   

        [[random]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[qubit\_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[term\_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[seed]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[3450578604]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Return a random spin operator with the given number of terms
        (`term_count`{.code .docutils .literal .notranslate}) where each
        term acts on all targets in the open range \[0, qubit\_count).
        An optional seed value may also be provided.

    [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.serialize "Permalink to this definition"){.headerlink}

    :   

        [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the serialized data representation of the operator.

    *[property]{.pre}[ ]{.w}*[[term\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperator.term_count "Permalink to this definition"){.headerlink}

    :   Returns the number of terms in the operator.

    [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert spin\_op to JSON string: '\[d1, d2, d3, ...\]'

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

    [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

        2.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

    [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[print\_coefficient]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[True]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use the standard `str`{.code .docutils .literal
        .notranslate} conversion or `get_pauli_word`{.code .docutils
        .literal .notranslate} on each term instead.

    [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperator.trim "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[tol]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0.0]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

        2.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperator]{.pre}]{.n}*, *[[tol:]{.pre} [float]{.pre} [=]{.pre} [0.0]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.spin.]{.pre}]{.sig-prename .descclassname}[[SpinOperatorTerm]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorTerm "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. The canonicalization will throw a runtime
        exception if the operator acts on any degrees of freedom that
        are not included in the given set.

    *[property]{.pre}[ ]{.w}*[[coefficient]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorTerm.coefficient "Permalink to this definition"){.headerlink}

    :   Returns the unevaluated coefficient of the operator. The
        coefficient is a callback function that can be invoked with the
        `evaluate`{.code .docutils .literal .notranslate} method.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorTerm.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        `to_matrix`{.code .docutils .literal .notranslate}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[distribute\_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.distribute_terms "Permalink to this definition"){.headerlink}

    :   

        [[distribute\_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[chunk\_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - instantiate a `SpinOperator`{.code .docutils
        .literal .notranslate} from this `SpinOperatorTerm`{.code
        .docutils .literal .notranslate} and call distribute\_terms on
        that.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    [[evaluate\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.evaluate_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[evaluate\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the evaluated coefficient of the product operator. The
        parameters is a map of parameter names to their concrete,
        complex values.

    [[for\_each\_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.for_each_pauli "Permalink to this definition"){.headerlink}

    :   

        [[for\_each\_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use standard iteration instead.

    *[static]{.pre}[ ]{.w}*[[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string ('\[d1, d2, d3, ...\]') to spin\_op

    [[get\_binary\_symplectic\_form]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.get_binary_symplectic_form "Permalink to this definition"){.headerlink}

    :   

        [[get\_binary\_symplectic\_form]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Gets the binary symplectic representation of this operator.

    [[get\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.get_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[get\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use `evaluate_coefficient`{.code .docutils .literal
        .notranslate} instead.

    [[get\_pauli\_word]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.get_pauli_word "Permalink to this definition"){.headerlink}

    :   

        [[get\_pauli\_word]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[pad\_identities]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Gets the Pauli word representation of this product operator.

    [[get\_qubit\_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.get_qubit_count "Permalink to this definition"){.headerlink}

    :   

        [[get\_qubit\_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use `qubit_count`{.code .docutils .literal
        .notranslate} instead.

    [[get\_raw\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.get_raw_data "Permalink to this definition"){.headerlink}

    :   

        [[get\_raw\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated.

    [[is\_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.is_identity "Permalink to this definition"){.headerlink}

    :   

        [[is\_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Checks if all operators in the product are the identity. Note:
        this function returns true regardless of the value of the
        coefficient.

    *[property]{.pre}[ ]{.w}*[[max\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorTerm.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorTerm.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[ops\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorTerm.ops_count "Permalink to this definition"){.headerlink}

    :   Returns the number of operators in the product.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorTerm.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[qubit\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorTerm.qubit_count "Permalink to this definition"){.headerlink}

    :   Return the number of qubits this operator acts on.

    [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.serialize "Permalink to this definition"){.headerlink}

    :   

        [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the serialized data representation of the operator.

    *[property]{.pre}[ ]{.w}*[[term\_id]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorTerm.term_id "Permalink to this definition"){.headerlink}

    :   The term id uniquely identifies the operators and targets
        (degrees) that they act on, but does not include information
        about the coefficient.

    [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert spin\_op to JSON string: '\[d1, d2, d3, ...\]'

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

    [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

        2.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

    [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorTerm.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[print\_coefficient]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[True]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use the standard `str`{.code .docutils .literal
        .notranslate} conversion or use `get_pauli_word`{.code .docutils
        .literal .notranslate} instead.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.spin.]{.pre}]{.sig-prename .descclassname}[[SpinOperatorElement]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorElement "Permalink to this definition"){.headerlink}

:   

    [[as\_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorElement.as_pauli "Permalink to this definition"){.headerlink}

    :   

        [[as\_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorElement]{.pre}](#cudaq.operators.spin.SpinOperatorElement "cudaq.operators.spin.SpinOperatorElement"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[Pauli]{.pre}](#cudaq.spin.Pauli "cudaq.spin.Pauli"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the Pauli representation of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorElement.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[target]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.spin.SpinOperatorElement.target "Permalink to this definition"){.headerlink}

    :   Returns the degree of freedom that the operator targets.

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorElement.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorElement]{.pre}](#cudaq.operators.spin.SpinOperatorElement "cudaq.operators.spin.SpinOperatorElement"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperatorElement]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

    [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.spin.SpinOperatorElement.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorElement]{.pre}](#cudaq.operators.spin.SpinOperatorElement "cudaq.operators.spin.SpinOperatorElement"){.reference .internal}]{.n}*, *[[include\_degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the string representation of the operator.

[]{#module-cudaq.spin .target}

*[class]{.pre}[ ]{.w}*[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[Pauli]{.pre}]{.sig-name .descname}[¶](#cudaq.spin.Pauli "Permalink to this definition"){.headerlink}

:   An enumeration representing the types of Pauli matrices.

    Members:

    > <div>
    >
    > X
    >
    > Y
    >
    > Z
    >
    > I
    >
    > </div>

    *[property]{.pre}[ ]{.w}*[[name]{.pre}]{.sig-name .descname}[¶](#cudaq.spin.Pauli.name "Permalink to this definition"){.headerlink}

    :   object) -\> str :noindex:

        Type[:]{.colon}

        :   

            [[name(self]{.pre}]{.sig-name .descname}

            :   

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.spin.canonicalized "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    2.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. The canonicalization will throw a runtime
    exception if the operator acts on any degrees of freedom that are
    not included in the given set.

    3.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    4.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. If an empty set is passed, canonicalizes all
    terms in the sum to act on the same degrees of freedom.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.spin.empty "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns sum operator with no terms. Note that a sum with no terms
    multiplied by anything still is a sum with no terms.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[i]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.spin.i "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[i]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a Pauli I spin operator on the given target qubit index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.spin.identities "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[first]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[last]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Creates a product operator that applies an identity operation to all
    degrees of freedom in the open range \[first, last).

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.spin.identity "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns product operator with constant value 1.

    2.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns an identity operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[minus]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.spin.minus "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[minus]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Return a sigma minus spin operator on the given target qubit index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[plus]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.spin.plus "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[plus]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Return a sigma plus spin operator on the given target qubit index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[x]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.spin.x "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[x]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a Pauli X spin operator on the given target qubit index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[y]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.spin.y "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[y]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a Pauli Y spin operator on the given target qubit index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[z]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.spin.z "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[z]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a Pauli Z spin operator on the given target qubit index.
:::

::: {#fermion-operators .section}
### Fermion Operators[¶](#fermion-operators "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.operators.fermion.]{.pre}]{.sig-prename .descclassname}[[FermionOperator]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperator "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperator.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. If an empty set is passed, canonicalizes
        all terms in the sum to act on the same degrees of freedom.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperator.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperator.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        `to_matrix`{.code .docutils .literal .notranslate}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[distribute\_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperator.distribute_terms "Permalink to this definition"){.headerlink}

    :   

        [[distribute\_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Partitions the terms of the sums into the given number of
        separate sums.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperator.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    *[static]{.pre}[ ]{.w}*[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperator.empty "Permalink to this definition"){.headerlink}

    :   

        [[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a sum operator with no terms. And empty sum is the
        neutral element for addition; multiplying an empty sum with
        anything will still result in an empty sum.

    *[static]{.pre}[ ]{.w}*[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperator.identity "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator with constant value 1. The identity
        operator is the neutral element for multiplication.

        2.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator that applies the identity to the
        given target index.

    *[property]{.pre}[ ]{.w}*[[max\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperator.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperator.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperator.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperator.term_count "Permalink to this definition"){.headerlink}

    :   Returns the number of terms in the operator.

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperator.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

    [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperator.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

        2.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

    [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperator.trim "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[tol]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0.0]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

        2.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperator]{.pre}]{.n}*, *[[tol:]{.pre} [float]{.pre} [=]{.pre} [0.0]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.fermion.]{.pre}]{.sig-prename .descclassname}[[FermionOperatorTerm]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperatorTerm "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperatorTerm.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. The canonicalization will throw a runtime
        exception if the operator acts on any degrees of freedom that
        are not included in the given set.

    *[property]{.pre}[ ]{.w}*[[coefficient]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperatorTerm.coefficient "Permalink to this definition"){.headerlink}

    :   Returns the unevaluated coefficient of the operator. The
        coefficient is a callback function that can be invoked with the
        `evaluate`{.code .docutils .literal .notranslate} method.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperatorTerm.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperatorTerm.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        `to_matrix`{.code .docutils .literal .notranslate}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperatorTerm.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    [[evaluate\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperatorTerm.evaluate_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[evaluate\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the evaluated coefficient of the product operator. The
        parameters is a map of parameter names to their concrete,
        complex values.

    [[is\_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperatorTerm.is_identity "Permalink to this definition"){.headerlink}

    :   

        [[is\_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Checks if all operators in the product are the identity. Note:
        this function returns true regardless of the value of the
        coefficient.

    *[property]{.pre}[ ]{.w}*[[max\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperatorTerm.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperatorTerm.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[ops\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperatorTerm.ops_count "Permalink to this definition"){.headerlink}

    :   Returns the number of operators in the product.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperatorTerm.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term\_id]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperatorTerm.term_id "Permalink to this definition"){.headerlink}

    :   The term id uniquely identifies the operators and targets
        (degrees) that they act on, but does not include information
        about the coefficient.

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperatorTerm.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

    [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperatorTerm.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

        2.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.fermion.]{.pre}]{.sig-prename .descclassname}[[FermionOperatorElement]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperatorElement "Permalink to this definition"){.headerlink}

:   

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperatorElement.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[target]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.fermion.FermionOperatorElement.target "Permalink to this definition"){.headerlink}

    :   Returns the degree of freedom that the operator targets.

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperatorElement.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorElement]{.pre}](#cudaq.operators.fermion.FermionOperatorElement "cudaq.operators.fermion.FermionOperatorElement"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperatorElement]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

    [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.fermion.FermionOperatorElement.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorElement]{.pre}](#cudaq.operators.fermion.FermionOperatorElement "cudaq.operators.fermion.FermionOperatorElement"){.reference .internal}]{.n}*, *[[include\_degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the string representation of the operator.

[]{#module-cudaq.fermion .target}

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[annihilate]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.fermion.annihilate "Permalink to this definition"){.headerlink}

:   

    [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[annihilate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a fermionic annihilation operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.fermion.canonicalized "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    2.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. The canonicalization will throw a runtime
    exception if the operator acts on any degrees of freedom that are
    not included in the given set.

    3.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    4.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. If an empty set is passed, canonicalizes all
    terms in the sum to act on the same degrees of freedom.

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[create]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.fermion.create "Permalink to this definition"){.headerlink}

:   

    [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[create]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a fermionic creation operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.fermion.empty "Permalink to this definition"){.headerlink}

:   

    [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns sum operator with no terms. Note that a sum with no terms
    multiplied by anything still is a sum with no terms.

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.fermion.identities "Permalink to this definition"){.headerlink}

:   

    [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[first]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[last]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Creates a product operator that applies an identity operation to all
    degrees of freedom in the open range \[first, last).

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.fermion.identity "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns product operator with constant value 1.

    2.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns an identity operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.fermion.number "Permalink to this definition"){.headerlink}

:   

    [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a fermionic number operator on the given target index.
:::

::: {#boson-operators .section}
### Boson Operators[¶](#boson-operators "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.operators.boson.]{.pre}]{.sig-prename .descclassname}[[BosonOperator]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperator "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperator.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. If an empty set is passed, canonicalizes
        all terms in the sum to act on the same degrees of freedom.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperator.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperator.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        `to_matrix`{.code .docutils .literal .notranslate}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[distribute\_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperator.distribute_terms "Permalink to this definition"){.headerlink}

    :   

        [[distribute\_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Partitions the terms of the sums into the given number of
        separate sums.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperator.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    *[static]{.pre}[ ]{.w}*[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperator.empty "Permalink to this definition"){.headerlink}

    :   

        [[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a sum operator with no terms. And empty sum is the
        neutral element for addition; multiplying an empty sum with
        anything will still result in an empty sum.

    *[static]{.pre}[ ]{.w}*[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperator.identity "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator with constant value 1. The identity
        operator is the neutral element for multiplication.

        2.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator that applies the identity to the
        given target index.

    *[property]{.pre}[ ]{.w}*[[max\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperator.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperator.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperator.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperator.term_count "Permalink to this definition"){.headerlink}

    :   Returns the number of terms in the operator.

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperator.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

    [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperator.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

        2.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

    [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperator.trim "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[tol]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0.0]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

        2.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperator]{.pre}]{.n}*, *[[tol:]{.pre} [float]{.pre} [=]{.pre} [0.0]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.boson.]{.pre}]{.sig-prename .descclassname}[[BosonOperatorTerm]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperatorTerm "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperatorTerm.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. The canonicalization will throw a runtime
        exception if the operator acts on any degrees of freedom that
        are not included in the given set.

    *[property]{.pre}[ ]{.w}*[[coefficient]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperatorTerm.coefficient "Permalink to this definition"){.headerlink}

    :   Returns the unevaluated coefficient of the operator. The
        coefficient is a callback function that can be invoked with the
        `evaluate`{.code .docutils .literal .notranslate} method.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperatorTerm.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperatorTerm.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        `to_matrix`{.code .docutils .literal .notranslate}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperatorTerm.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    [[evaluate\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperatorTerm.evaluate_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[evaluate\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the evaluated coefficient of the product operator. The
        parameters is a map of parameter names to their concrete,
        complex values.

    [[is\_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperatorTerm.is_identity "Permalink to this definition"){.headerlink}

    :   

        [[is\_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Checks if all operators in the product are the identity. Note:
        this function returns true regardless of the value of the
        coefficient.

    *[property]{.pre}[ ]{.w}*[[max\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperatorTerm.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperatorTerm.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[ops\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperatorTerm.ops_count "Permalink to this definition"){.headerlink}

    :   Returns the number of operators in the product.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperatorTerm.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term\_id]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperatorTerm.term_id "Permalink to this definition"){.headerlink}

    :   The term id uniquely identifies the operators and targets
        (degrees) that they act on, but does not include information
        about the coefficient.

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperatorTerm.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

    [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperatorTerm.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

        2.  

            [[to\_sparse\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a
        `Tuple[list[complex], list[int], list[int]]`{.code .docutils
        .literal .notranslate}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        `scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}.The matrix is ordered according to the convention
        (endianness) used in CUDA-Q, and the ordering returned by
        `degrees`{.code .docutils .literal .notranslate}. This order can
        be inverted by setting the optional `invert_order`{.code
        .docutils .literal .notranslate} argument to `True`{.code
        .docutils .literal .notranslate}. See also the documentation for
        `degrees`{.code .docutils .literal .notranslate} for more
        detail.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.boson.]{.pre}]{.sig-prename .descclassname}[[BosonOperatorElement]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperatorElement "Permalink to this definition"){.headerlink}

:   

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperatorElement.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[target]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.boson.BosonOperatorElement.target "Permalink to this definition"){.headerlink}

    :   Returns the degree of freedom that the operator targets.

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperatorElement.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorElement]{.pre}](#cudaq.operators.boson.BosonOperatorElement "cudaq.operators.boson.BosonOperatorElement"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperatorElement]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

    [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.boson.BosonOperatorElement.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorElement]{.pre}](#cudaq.operators.boson.BosonOperatorElement "cudaq.operators.boson.BosonOperatorElement"){.reference .internal}]{.n}*, *[[include\_degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the string representation of the operator.

[]{#module-cudaq.boson .target}

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[annihilate]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.boson.annihilate "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[annihilate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a bosonic annihilation operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.boson.canonicalized "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    2.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. The canonicalization will throw a runtime
    exception if the operator acts on any degrees of freedom that are
    not included in the given set.

    3.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    4.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. If an empty set is passed, canonicalizes all
    terms in the sum to act on the same degrees of freedom.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[create]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.boson.create "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[create]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a bosonic creation operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.boson.empty "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns sum operator with no terms. Note that a sum with no terms
    multiplied by anything still is a sum with no terms.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.boson.identities "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[first]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[last]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Creates a product operator that applies an identity operation to all
    degrees of freedom in the open range \[first, last).

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.boson.identity "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns product operator with constant value 1.

    2.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns an identity operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[momentum]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.boson.momentum "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[momentum]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a bosonic momentum operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.boson.number "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a bosonic number operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[position]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.boson.position "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[position]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a bosonic position operator on the given target index.
:::

::: {#general-operators .section}
### General Operators[¶](#general-operators "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[MatrixOperator]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperator "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperator.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. If an empty set is passed, canonicalizes
        all terms in the sum to act on the same degrees of freedom.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperator.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperator.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets.

    [[distribute\_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperator.distribute_terms "Permalink to this definition"){.headerlink}

    :   

        [[distribute\_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Partitions the terms of the sums into the given number of
        separate sums.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperator.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    *[static]{.pre}[ ]{.w}*[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperator.empty "Permalink to this definition"){.headerlink}

    :   

        [[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a sum operator with no terms. And empty sum is the
        neutral element for addition; multiplying an empty sum with
        anything will still result in an empty sum.

    *[static]{.pre}[ ]{.w}*[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperator.identity "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator with constant value 1. The identity
        operator is the neutral element for multiplication.

        2.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator that applies the identity to the
        given target index.

    *[property]{.pre}[ ]{.w}*[[max\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperator.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperator.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperator.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperator.term_count "Permalink to this definition"){.headerlink}

    :   Returns the number of terms in the operator.

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperator.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [MatrixOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

    [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperator.trim "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[tol]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0.0]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

        2.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [MatrixOperator]{.pre}]{.n}*, *[[tol:]{.pre} [float]{.pre} [=]{.pre} [0.0]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[MatrixOperatorTerm]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorTerm "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperatorTerm.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. The canonicalization will throw a runtime
        exception if the operator acts on any degrees of freedom that
        are not included in the given set.

    *[property]{.pre}[ ]{.w}*[[coefficient]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorTerm.coefficient "Permalink to this definition"){.headerlink}

    :   Returns the unevaluated coefficient of the operator. The
        coefficient is a callback function that can be invoked with the
        `evaluate`{.code .docutils .literal .notranslate} method.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperatorTerm.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorTerm.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        `to_matrix`{.code .docutils .literal .notranslate}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperatorTerm.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    [[evaluate\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperatorTerm.evaluate_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[evaluate\_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the evaluated coefficient of the product operator. The
        parameters is a map of parameter names to their concrete,
        complex values.

    [[is\_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperatorTerm.is_identity "Permalink to this definition"){.headerlink}

    :   

        [[is\_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Checks if all operators in the product are the identity. Note:
        this function returns true regardless of the value of the
        coefficient.

    *[property]{.pre}[ ]{.w}*[[max\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorTerm.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min\_degree]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorTerm.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[ops\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorTerm.ops_count "Permalink to this definition"){.headerlink}

    :   Returns the number of operators in the product.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorTerm.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term\_id]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorTerm.term_id "Permalink to this definition"){.headerlink}

    :   The term id uniquely identifies the operators and targets
        (degrees) that they act on, but does not include information
        about the coefficient.

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperatorTerm.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert\_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [MatrixOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert\_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by `degrees`{.code .docutils .literal
        .notranslate}. This order can be inverted by setting the
        optional `invert_order`{.code .docutils .literal .notranslate}
        argument to `True`{.code .docutils .literal .notranslate}. See
        also the documentation for `degrees`{.code .docutils .literal
        .notranslate} for more detail.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[MatrixOperatorElement]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorElement "Permalink to this definition"){.headerlink}

:   

    *[classmethod]{.pre}[ ]{.w}*[[define]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[id]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*, *[[expected\_dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[create]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Callable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[\...]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.3)"){.reference .external}[[\[]{.pre}]{.p}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[dtype]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.3)"){.reference .external}[[\[]{.pre}]{.p}[[complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.3)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[override]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}[¶](#cudaq.operators.MatrixOperatorElement.define "Permalink to this definition"){.headerlink}

    :   Creates the definition of an elementary operator with the given
        id.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorElement.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[expected\_dimensions]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorElement.expected_dimensions "Permalink to this definition"){.headerlink}

    :   The number of levels, that is the dimension, for each degree of
        freedom in canonical order that the operator acts on. A value of
        zero or less indicates that the operator is defined for any
        dimension of that degree.

    *[property]{.pre}[ ]{.w}*[[id]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorElement.id "Permalink to this definition"){.headerlink}

    :   Returns the id used to define and instantiate the operator.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.operators.MatrixOperatorElement.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperatorElement.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorElement]{.pre}](#cudaq.operators.MatrixOperatorElement "cudaq.operators.MatrixOperatorElement"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

        2.  

            [[to\_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [MatrixOperatorElement]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

    [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.MatrixOperatorElement.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to\_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorElement]{.pre}](#cudaq.operators.MatrixOperatorElement "cudaq.operators.MatrixOperatorElement"){.reference .internal}]{.n}*, *[[include\_degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the string representation of the operator.

[]{#module-cudaq.operators.custom .target}

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.operators.custom.canonicalized "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    2.  

        [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. The canonicalization will throw a runtime
    exception if the operator acts on any degrees of freedom that are
    not included in the given set.

    3.  

        [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    4.  

        [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. If an empty set is passed, canonicalizes all
    terms in the sum to act on the same degrees of freedom.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[define]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[id]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*, *[[expected\_dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[create]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Callable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[\...]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.3)"){.reference .external}[[\[]{.pre}]{.p}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[dtype]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.3)"){.reference .external}[[\[]{.pre}]{.p}[[complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.3)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[override]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}[¶](#cudaq.operators.custom.define "Permalink to this definition"){.headerlink}

:   Defines a matrix operator element with the given id. After
    definition, an the defined elementary operator can be instantiated
    by providing the operator id as well as the degree(s) of freedom
    that it acts on. A matrix operator element is a parameterized object
    acting on certain degrees of freedom. To evaluate an operator, for
    example to compute its matrix, the level, that is the dimension, for
    each degree of freedom it acts on must be provided, as well as all
    additional parameters. Additional parameters must be provided in the
    form of keyword arguments.

    Note: The dimensions passed during operator evaluation are
    automatically validated against the expected dimensions specified
    during definition - the `create`{.code .docutils .literal
    .notranslate} function does not need to do this.

    Parameters[:]{.colon}

    :   -   **op\_id** -- A string that uniquely identifies the defined
            operator.

        -   **expected\_dimensions** -- defines the number of levels,
            that is the dimension, for each degree of freedom in
            canonical (that is sorted) order. A negative or zero value
            for one (or more) of the expected dimensions indicates that
            the operator is defined for any dimension of the
            corresponding degree of freedom.

        -   **create** -- Takes any number of complex-valued arguments
            and returns the matrix representing the operator in
            canonical order. If the matrix can be defined for any number
            of levels for one or more degree of freedom, the
            `create`{.code .docutils .literal .notranslate} function
            must take an argument called `dimension`{.code .docutils
            .literal .notranslate} (or `dim`{.code .docutils .literal
            .notranslate} for short), if the operator acts on a single
            degree of freedom, and an argument called `dimensions`{.code
            .docutils .literal .notranslate} (or `dims`{.code .docutils
            .literal .notranslate} for short), if the operator acts on
            multiple degrees of freedom.

        -   **override** -- if True it allows override the definition.
            (default: False)

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[displace]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.custom.displace "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[displace]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a displacement operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.custom.empty "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns sum operator with no terms. Note that a sum with no terms
    multiplied by anything still is a sum with no terms.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.custom.identities "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[first]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[last]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Creates a product operator that applies an identity operation to all
    degrees of freedom in the open range \[first, last).

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[instantiate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[op\_id]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*, *[[degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}[¶](#cudaq.operators.custom.instantiate "Permalink to this definition"){.headerlink}

:   Instantiates a product operator containing a previously defined
    operator element.

    Parameters[:]{.colon}

    :   -   **operator\_id** -- The id of the operator element as
            specified when it was defined.

        -   **degrees** -- The degree(s) of freedom that the operator
            acts on.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[momentum]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.custom.momentum "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[momentum]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a momentum operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.custom.number "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a number operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[parity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.custom.parity "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[parity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a parity operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[position]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.custom.position "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[position]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a position operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[squeeze]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.operators.custom.squeeze "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[squeeze]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a squeezing operator on the given target index.
:::
:::

::: {#data-types .section}
Data Types[¶](#data-types "Permalink to this heading"){.headerlink}
-------------------------------------------------------------------

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[SimulationPrecision]{.pre}]{.sig-name .descname}[¶](#cudaq.SimulationPrecision "Permalink to this definition"){.headerlink}

:   Enumeration describing the precision of the underyling simulation.

    Members:

    > <div>
    >
    > fp32
    >
    > fp64
    >
    > </div>

    *[property]{.pre}[ ]{.w}*[[name]{.pre}]{.sig-name .descname}[¶](#cudaq.SimulationPrecision.name "Permalink to this definition"){.headerlink}

    :   object) -\> str :noindex:

        Type[:]{.colon}

        :   

            [[name(self]{.pre}]{.sig-name .descname}

            :   

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Target]{.pre}]{.sig-name .descname}[¶](#cudaq.Target "Permalink to this definition"){.headerlink}

:   The `cudaq.Target`{.code .docutils .literal .notranslate} represents
    the underlying infrastructure that CUDA-Q kernels will execute on.
    Instances of `cudaq.Target`{.code .docutils .literal .notranslate}
    describe what simulator they may leverage, the quantum\_platform
    required for execution, and a description for the target.

    *[property]{.pre}[ ]{.w}*[[description]{.pre}]{.sig-name .descname}[¶](#cudaq.Target.description "Permalink to this definition"){.headerlink}

    :   A string describing the features for this `cudaq.Target`{.code
        .docutils .literal .notranslate}.

    [[get\_precision]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.Target.get_precision "Permalink to this definition"){.headerlink}

    :   

        [[get\_precision]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SimulationPrecision]{.pre}](#cudaq.SimulationPrecision "cudaq.SimulationPrecision"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the simulation precision for the current target.

    [[is\_emulated]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.Target.is_emulated "Permalink to this definition"){.headerlink}

    :   

        [[is\_emulated]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns true if the emulation mode for the target has been
        activated.

    [[is\_remote]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.Target.is_remote "Permalink to this definition"){.headerlink}

    :   

        [[is\_remote]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns true if the target consists of a remote REST QPU.

    [[is\_remote\_simulator]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.Target.is_remote_simulator "Permalink to this definition"){.headerlink}

    :   

        [[is\_remote\_simulator]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns true if the target consists of a remote REST Simulator
        QPU.

    *[property]{.pre}[ ]{.w}*[[name]{.pre}]{.sig-name .descname}[¶](#cudaq.Target.name "Permalink to this definition"){.headerlink}

    :   The name of the `cudaq.Target`{.code .docutils .literal
        .notranslate}.

    [[num\_qpus]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.Target.num_qpus "Permalink to this definition"){.headerlink}

    :   

        [[num\_qpus]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the number of QPUs available in this `cudaq.Target`{.code
        .docutils .literal .notranslate}.

    *[property]{.pre}[ ]{.w}*[[platform]{.pre}]{.sig-name .descname}[¶](#cudaq.Target.platform "Permalink to this definition"){.headerlink}

    :   The name of the quantum\_platform implementation this
        `cudaq.Target`{.code .docutils .literal .notranslate} leverages.

    *[property]{.pre}[ ]{.w}*[[simulator]{.pre}]{.sig-name .descname}[¶](#cudaq.Target.simulator "Permalink to this definition"){.headerlink}

    :   The name of the simulator this `cudaq.Target`{.code .docutils
        .literal .notranslate} leverages. This will be empty for
        physical QPUs.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[State]{.pre}]{.sig-name .descname}[¶](#cudaq.State "Permalink to this definition"){.headerlink}

:   A data-type representing the quantum state of the internal
    simulator. This type is not user-constructible and instances can
    only be retrieved via the `cudaq.get_state(...)`{.code .docutils
    .literal .notranslate} function or the static
    cudaq.State.from\_data() method.

    [[amplitude]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.State.amplitude "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[amplitude]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the amplitude of a state in computational basis.

        ::: {.highlight-python .notranslate}
        ::: {.highlight}
            # Example:
            # Create a simulation state.
            state = cudaq.get_state(kernel)
            # Return the amplitude of |0101>, assuming this is a 4-qubit state.
            amplitude = state.amplitude([0,1,0,1])
        :::
        :::

        2.  

            [[amplitude]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the amplitude of a state in computational basis.

        ::: {.highlight-python .notranslate}
        ::: {.highlight}
            # Example:
            # Create a simulation state.
            state = cudaq.get_state(kernel)
            # Return the amplitude of |0101>, assuming this is a 4-qubit state.
            amplitude = state.amplitude('0101')
        :::
        :::

    [[amplitudes]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.State.amplitudes "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[amplitudes]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the amplitude of a list of states in computational basis.

        ::: {.highlight-python .notranslate}
        ::: {.highlight}
            # Example:
            # Create a simulation state.
            state = cudaq.get_state(kernel)
            # Return the amplitude of |0101> and |1010>, assuming this is a 4-qubit state.
            amplitudes = state.amplitudes([[0,1,0,1], [1,0,1,0]])
        :::
        :::

        2.  

            [[amplitudes]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the amplitudes of a list of states in computational
        basis.

        ::: {.highlight-python .notranslate}
        ::: {.highlight}
            # Example:
            # Create a simulation state.
            state = cudaq.get_state(kernel)
            # Return the amplitudes of |0101> and |1010>, assuming this is a 4-qubit state.
            amplitudes = state.amplitudes(['0101', '1010'])
        :::
        :::

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.State.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Print the state to the console.

    *[static]{.pre}[ ]{.w}*[[from\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.State.from_data "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[from\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[numpy.ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.3)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Return a state from data.

        2.  

            [[from\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[numpy.ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.3)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Return a state from matrix product state tensor data.

        3.  

            [[from\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Tensor]{.pre}](#cudaq.Tensor "cudaq.Tensor"){.reference .internal}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Return a state from matrix product state tensor data.

        4.  

            [[from\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Return a state from matrix product state tensor data (as CuPy
        ndarray).

        5.  

            [[from\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Return a state from CuPy device array.

    [[getTensor]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.State.getTensor "Permalink to this definition"){.headerlink}

    :   

        [[getTensor]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[idx]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[Tensor]{.pre}](#cudaq.Tensor "cudaq.Tensor"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the `idx`{.code .docutils .literal .notranslate} tensor
        making up this state representation.

    [[getTensors]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.State.getTensors "Permalink to this definition"){.headerlink}

    :   

        [[getTensors]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[Tensor]{.pre}](#cudaq.Tensor "cudaq.Tensor"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Return all the tensors that comprise this state representation.

    [[is\_on\_gpu]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.State.is_on_gpu "Permalink to this definition"){.headerlink}

    :   

        [[is\_on\_gpu]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return True if this state is on the GPU.

    [[num\_qubits]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.State.num_qubits "Permalink to this definition"){.headerlink}

    :   

        [[num\_qubits]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the number of qubits represented by this state.

    [[overlap]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.State.overlap "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[overlap]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Compute the overlap between the provided [`State`{.xref .py
        .py-class .docutils .literal
        .notranslate}](#cudaq.State "cudaq.State"){.reference
        .internal}'s.

        2.  

            [[overlap]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[numpy.ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.3)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Compute the overlap between the provided [`State`{.xref .py
        .py-class .docutils .literal
        .notranslate}](#cudaq.State "cudaq.State"){.reference
        .internal}'s.

        3.  

            [[overlap]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Compute overlap with general CuPy device array.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Tensor]{.pre}]{.sig-name .descname}[¶](#cudaq.Tensor "Permalink to this definition"){.headerlink}

:   The `Tensor`{.code .docutils .literal .notranslate} describes a
    pointer to simulation data as well as the rank and extents for that
    tensorial data it represents.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[QuakeValue]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[mlirValue]{.pre}]{.n}*, *[[pyKernel]{.pre}]{.n}*, *[[size]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[¶](#cudaq.QuakeValue "Permalink to this definition"){.headerlink}

:   A [`QuakeValue`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
    .internal} represents a handle to an individual function argument of
    a [`Kernel`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference .internal},
    or a return value from an operation within it. As documented in
    [`make_kernel()`{.xref .py .py-func .docutils .literal
    .notranslate}](#cudaq.make_kernel "cudaq.make_kernel"){.reference
    .internal}, a [`QuakeValue`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
    .internal} can hold values of the following types: int, float,
    list/List, [`qubit`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.qubit "cudaq.qubit"){.reference .internal}, or
    [`qvector`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.qvector "cudaq.qvector"){.reference
    .internal}. The [`QuakeValue`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
    .internal} can also hold kernel operations such as qubit allocations
    and measurements.

    [[\_\_add\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.QuakeValue.__add__ "Permalink to this definition"){.headerlink}

    :   Return the sum of `self`{.code .docutils .literal .notranslate}
        ([`QuakeValue`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}) and `other`{.code .docutils .literal .notranslate}
        (float).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.13)"){.reference
            .external} -- if the underlying [`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: {.highlight}
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = value + 5.0
        :::
        :::

    [[\_\_radd\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.QuakeValue.__radd__ "Permalink to this definition"){.headerlink}

    :   Return the sum of `other`{.code .docutils .literal .notranslate}
        (float) and `self`{.code .docutils .literal .notranslate}
        ([`QuakeValue`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.13)"){.reference
            .external} -- if the underlying [`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: {.highlight}
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = 5.0 + value
        :::
        :::

    [[\_\_sub\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.QuakeValue.__sub__ "Permalink to this definition"){.headerlink}

    :   Return the difference of `self`{.code .docutils .literal
        .notranslate} ([`QuakeValue`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}) and `other`{.code .docutils .literal .notranslate}
        (float).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.13)"){.reference
            .external} -- if the underlying [`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: {.highlight}
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = value - 5.0
        :::
        :::

    [[\_\_rsub\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.QuakeValue.__rsub__ "Permalink to this definition"){.headerlink}

    :   Return the difference of `other`{.code .docutils .literal
        .notranslate} (float) and `self`{.code .docutils .literal
        .notranslate} ([`QuakeValue`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.13)"){.reference
            .external} -- if the underlying [`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: {.highlight}
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = 5.0 - value
        :::
        :::

    [[\_\_neg\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.QuakeValue.__neg__ "Permalink to this definition"){.headerlink}

    :   Return the negation of `self`{.code .docutils .literal
        .notranslate} ([`QuakeValue`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.13)"){.reference
            .external} -- if the underlying [`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: {.highlight}
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = -value
        :::
        :::

    [[\_\_mul\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.QuakeValue.__mul__ "Permalink to this definition"){.headerlink}

    :   Return the product of `self`{.code .docutils .literal
        .notranslate} ([`QuakeValue`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}) with `other`{.code .docutils .literal .notranslate}
        (float).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.13)"){.reference
            .external} -- if the underlying [`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: {.highlight}
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = value * 5.0
        :::
        :::

    [[\_\_rmul\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.QuakeValue.__rmul__ "Permalink to this definition"){.headerlink}

    :   Return the product of `other`{.code .docutils .literal
        .notranslate} (float) with `self`{.code .docutils .literal
        .notranslate} ([`QuakeValue`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.13)"){.reference
            .external} -- if the underlying [`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: {.highlight}
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = 5.0 * value
        :::
        :::

    [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[idx]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.QuakeValue.__getitem__ "Permalink to this definition"){.headerlink}

    :   Return the element of `self`{.code .docutils .literal
        .notranslate} at the provided `index`{.code .docutils .literal
        .notranslate}.

        ::: {.admonition .note}
        Note

        Only `list`{.code .docutils .literal .notranslate} or
        [`qvector`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.qvector "cudaq.qvector"){.reference
        .internal} type [`QuakeValue`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}'s may be indexed.
        :::

        Parameters[:]{.colon}

        :   **index**
            ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}) -- The element of `self`{.code .docutils
            .literal .notranslate} that you'd like to return.

        Returns[:]{.colon}

        :   A new [`QuakeValue`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} for the `index`{.code .docutils .literal
            .notranslate} element of `self`{.code .docutils .literal
            .notranslate}.

        Return type[:]{.colon}

        :   [`QuakeValue`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal}

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.13)"){.reference
            .external} -- if `self`{.code .docutils .literal
            .notranslate} is a non-subscriptable [`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal}.

    [[slice]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[startIdx]{.pre}]{.n}*, *[[count]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.QuakeValue.slice "Permalink to this definition"){.headerlink}

    :   Return a slice of the given [`QuakeValue`{.xref .py .py-class
        .docutils .literal
        .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal} as a new [`QuakeValue`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}.

        ::: {.admonition .note}
        Note

        The underlying [`QuakeValue`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal} must be a `list`{.code .docutils .literal
        .notranslate} or `veq`{.code .docutils .literal .notranslate}.
        :::

        Parameters[:]{.colon}

        :   -   **start**
                ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
                .external}) -- The index to begin the slice from.

            -   **count**
                ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
                .external}) -- The number of elements to extract after
                the `start`{.code .docutils .literal .notranslate}
                index.

        Returns[:]{.colon}

        :   A new `QuakeValue`{.code .docutils .literal .notranslate}
            containing a slice of `self`{.code .docutils .literal
            .notranslate} from the `start`{.code .docutils .literal
            .notranslate} element to the `start + count`{.code .docutils
            .literal .notranslate} element.

        Return type[:]{.colon}

        :   [`QuakeValue`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal}

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[qubit]{.pre}]{.sig-name .descname}[¶](#cudaq.qubit "Permalink to this definition"){.headerlink}

:   The qubit is the primary unit of information in a quantum computer.
    Qubits can be created individually or as part of larger registers.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[qreg]{.pre}]{.sig-name .descname}[¶](#cudaq.qreg "Permalink to this definition"){.headerlink}

:   alias of [`qvector`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.qvector "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.qvector"){.reference
    .internal}

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[qvector]{.pre}]{.sig-name .descname}[¶](#cudaq.qvector "Permalink to this definition"){.headerlink}

:   An owning, dynamically sized container for qubits. The semantics of
    the `qvector`{.code .docutils .literal .notranslate} follows that of
    a `std::vector`{.code .docutils .literal .notranslate} or
    `list`{.code .docutils .literal .notranslate} for qubits.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[ComplexMatrix]{.pre}]{.sig-name .descname}[¶](#cudaq.ComplexMatrix "Permalink to this definition"){.headerlink}

:   The [`ComplexMatrix`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference
    .internal} is a thin wrapper around a matrix of complex\<double\>
    elements.

    [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.ComplexMatrix.__getitem__ "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the matrix element at i, j.

        2.  

            [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the matrix element at i, j.

    [[\_\_str\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.ComplexMatrix.__str__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_str\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the string representation of the matrix.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.ComplexMatrix.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the matrix to the standard output.

    [[minimal\_eigenvalue]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.ComplexMatrix.minimal_eigenvalue "Permalink to this definition"){.headerlink}

    :   

        [[minimal\_eigenvalue]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the lowest eigenvalue for this [`ComplexMatrix`{.xref .py
        .py-class .docutils .literal
        .notranslate}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference
        .internal}.

    [[num\_columns]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.ComplexMatrix.num_columns "Permalink to this definition"){.headerlink}

    :   

        [[num\_columns]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the number of columns in the matrix.

    [[num\_rows]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.ComplexMatrix.num_rows "Permalink to this definition"){.headerlink}

    :   

        [[num\_rows]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the number of rows in the matrix.

    [[to\_numpy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.ComplexMatrix.to_numpy "Permalink to this definition"){.headerlink}

    :   

        [[to\_numpy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert [`ComplexMatrix`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference
        .internal} to numpy.ndarray.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[SampleResult]{.pre}]{.sig-name .descname}[¶](#cudaq.SampleResult "Permalink to this definition"){.headerlink}

:   A data-type containing the results of a call to [`sample()`{.xref
    .py .py-func .docutils .literal
    .notranslate}](#cudaq.sample "cudaq.sample"){.reference .internal}.
    This includes all measurement counts data from both mid-circuit and
    terminal measurements.

    ::: {.admonition .note}
    Note

    At this time, mid-circuit measurements are not directly supported.
    Mid-circuit measurements may only be used if they are passed through
    to `c_if`{.code .docutils .literal .notranslate}.
    :::

    [[register\_names]{.pre}]{.sig-name .descname}[¶](#cudaq.SampleResult.register_names "Permalink to this definition"){.headerlink}

    :   A list of the names of each measurement register that are stored
        in `self`{.code .docutils .literal .notranslate}.

        Type[:]{.colon}

        :   List\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
            .external}\]

    [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.__getitem__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[bitstring]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the measurement counts for the given `bitstring`{.code
        .docutils .literal .notranslate}.

        Parameters[:]{.colon}

        :   **bitstring**
            ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
            .external}) -- The binary string to return the measurement
            data of.

        Returns[:]{.colon}

        :   The number of times the given `bitstring`{.code .docutils
            .literal .notranslate} was measured during the
            `shots_count`{.code .docutils .literal .notranslate} number
            of executions on the QPU.

        Return type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference
            .external}

    [[\_\_iter\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.__iter__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_iter\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[Iterator]{.pre}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Iterate through the [`SampleResult`{.xref .py .py-class
        .docutils .literal
        .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} dictionary.

    [[\_\_len\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.__len__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_len\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the number of elements in `self`{.code .docutils .literal
        .notranslate}. Equivalent to the number of uniquely measured
        bitstrings.

    [[clear]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.clear "Permalink to this definition"){.headerlink}

    :   

        [[clear]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Clear out all metadata from `self`{.code .docutils .literal
        .notranslate}.

    [[count]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.count "Permalink to this definition"){.headerlink}

    :   

        [[count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[bitstring]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*, *[[register\_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the number of times the given bitstring was observed.

        Parameters[:]{.colon}

        :   -   **bitstring**
                ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
                .external}) -- The binary string to return the
                measurement counts for.

            -   **register\_name**
                (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
                .external}*\]*) -- The optional measurement register
                name to extract the probability from. Defaults to the
                '\_\_global\_\_' register.

        Returns[:]{.colon}

        :   The number of times the given bitstring was measured during
            the experiment.

        Return type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
            .external}

    [[deserialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.deserialize "Permalink to this definition"){.headerlink}

    :   

        [[deserialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deserialize this SampleResult from an existing vector of
        integers adhering to the implicit encoding.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Print a string of the raw measurement counts data to the
        terminal.

    [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.expectation "Permalink to this definition"){.headerlink}

    :   

        [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[register\_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the expectation value in the Z-basis of the
        [`Kernel`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal} that was sampled.

    [[expectation\_z]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.expectation_z "Permalink to this definition"){.headerlink}

    :   

        [[expectation\_z]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[register\_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the expectation value in the Z-basis of the
        [`Kernel`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal} that was sampled.

    [[get\_marginal\_counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.get_marginal_counts "Permalink to this definition"){.headerlink}

    :   

        [[get\_marginal\_counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[self:]{.pre} [SampleResult,]{.pre} [marginal\_indices:]{.pre} [list\[int\],]{.pre} [\\\*,]{.pre} [register\_name:]{.pre} [str]{.pre} [=]{.pre} [\'\_\_global\_\_\']{.pre}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Extract the measurement counts data for the provided subset of
        qubits (`marginal_indices`{.code .docutils .literal
        .notranslate}).

        Parameters[:]{.colon}

        :   -   **marginal\_indices**
                ([*list*](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference
                .external}*\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
                .external}*\]*) -- A list of the qubit indices to
                extract the measurement data from.

            -   **register\_name**
                (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
                .external}*\]*) -- The optional measurement register
                name to extract the counts data from. Defaults to the
                '\_\_global\_\_' register.

        Returns[:]{.colon}

        :   A new `SampleResult`{.code .docutils .literal .notranslate}
            dictionary containing the extracted measurement data.

        Return type[:]{.colon}

        :   [`SampleResult`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
            .internal}

    [[get\_register\_counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.get_register_counts "Permalink to this definition"){.headerlink}

    :   

        [[get\_register\_counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[register\_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Extract the provided sub-register (`register_name`{.code
        .docutils .literal .notranslate}) as a new [`SampleResult`{.xref
        .py .py-class .docutils .literal
        .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal}.

    [[get\_sequential\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.get_sequential_data "Permalink to this definition"){.headerlink}

    :   

        [[get\_sequential\_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[register\_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the data from the given register (`register_name`{.code
        .docutils .literal .notranslate}) as it was collected
        sequentially. A list of measurement results, not collated into a
        map.

    [[get\_total\_shots]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.get_total_shots "Permalink to this definition"){.headerlink}

    :   

        [[get\_total\_shots]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Get the total number of shots in the sample result

    [[items]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.items "Permalink to this definition"){.headerlink}

    :   

        [[items]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[Iterator]{.pre}[[\[]{.pre}]{.p}[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the key/value pairs in this [`SampleResult`{.xref .py
        .py-class .docutils .literal
        .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} dictionary.

    [[most\_probable]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.most_probable "Permalink to this definition"){.headerlink}

    :   

        [[most\_probable]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[register\_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the bitstring that was measured most frequently in the
        experiment.

        Parameters[:]{.colon}

        :   **register\_name**
            (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
            .external}*\]*) -- The optional measurement register name to
            extract the most probable bitstring from. Defaults to the
            '\_\_global\_\_' register.

        Returns[:]{.colon}

        :   The most frequently measured binary string during the
            experiment.

        Return type[:]{.colon}

        :   [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
            .external}

    [[probability]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.probability "Permalink to this definition"){.headerlink}

    :   

        [[probability]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[bitstring]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*, *[[register\_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the probability of measuring the given `bitstring`{.code
        .docutils .literal .notranslate}.

        Parameters[:]{.colon}

        :   -   **bitstring**
                ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
                .external}) -- The binary string to return the
                measurement probability of.

            -   **register\_name**
                (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
                .external}*\]*) -- The optional measurement register
                name to extract the probability from. Defaults to the
                '\_\_global\_\_' register.

        Returns[:]{.colon}

        :   The probability of measuring the given `bitstring`{.code
            .docutils .literal .notranslate}. Equivalent to the
            proportion of the total times the bitstring was measured vs.
            the number of experiments (`shots_count`{.code .docutils
            .literal .notranslate}).

        Return type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference
            .external}

    [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.serialize "Permalink to this definition"){.headerlink}

    :   

        [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Serialize this SampleResult to a vector of integer encoding.

    [[values]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.SampleResult.values "Permalink to this definition"){.headerlink}

    :   

        [[values]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[Iterator]{.pre}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Return all values (the counts) in this [`SampleResult`{.xref .py
        .py-class .docutils .literal
        .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} dictionary.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[AsyncSampleResult]{.pre}]{.sig-name .descname}[¶](#cudaq.AsyncSampleResult "Permalink to this definition"){.headerlink}

:   A data-type containing the results of a call to
    [`sample_async()`{.xref .py .py-func .docutils .literal
    .notranslate}](#cudaq.sample_async "cudaq.sample_async"){.reference
    .internal}. The `AsyncSampleResult`{.code .docutils .literal
    .notranslate} models a future-like type, whose [`SampleResult`{.xref
    .py .py-class .docutils .literal
    .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
    .internal} may be returned via an invocation of the `get`{.code
    .docutils .literal .notranslate} method. This kicks off a wait on
    the current thread until the results are available. See
    [future](https://en.cppreference.com/w/cpp/thread/future){.reference
    .external} for more information on this programming pattern.

    [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.AsyncSampleResult.get "Permalink to this definition"){.headerlink}

    :   

        [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[AsyncSampleResult]{.pre}](#cudaq.AsyncSampleResult "cudaq.AsyncSampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the [`SampleResult`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} from the asynchronous sample execution.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[ObserveResult]{.pre}]{.sig-name .descname}[¶](#cudaq.ObserveResult "Permalink to this definition"){.headerlink}

:   A data-type containing the results of a call to [`observe()`{.xref
    .py .py-func .docutils .literal
    .notranslate}](#cudaq.observe "cudaq.observe"){.reference
    .internal}. This includes any measurement counts data, as well as
    the global expectation value of the user-defined
    `spin_operator`{.code .docutils .literal .notranslate}.

    [[counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.ObserveResult.counts "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns a [`SampleResult`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} dictionary with the measurement results from the
        experiment. The result for each individual term of the
        `spin_operator`{.code .docutils .literal .notranslate} is stored
        in its own measurement register. Each register name corresponds
        to the string representation of the spin term (without any
        coefficients).

        2.  

            [[counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [ObserveResult]{.pre}]{.n}*, *[[sub\_term:]{.pre} [cudaq::product\_op\<cudaq::spin\_handler\>]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        3.  

            [[counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*, *[[sub\_term]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Given a `sub_term`{.code .docutils .literal .notranslate} of the
        global `spin_operator`{.code .docutils .literal .notranslate}
        that was passed to [`observe()`{.xref .py .py-func .docutils
        .literal
        .notranslate}](#cudaq.observe "cudaq.observe"){.reference
        .internal}, return its measurement counts.

        Parameters[:]{.colon}

        :   **sub\_term** (`SpinOperator`{.code .docutils .literal
            .notranslate}) -- An individual sub-term of the
            `spin_operator`{.code .docutils .literal .notranslate}.

        Returns[:]{.colon}

        :   The measurement counts data for the individual
            `sub_term`{.code .docutils .literal .notranslate}.

        Return type[:]{.colon}

        :   [`SampleResult`{.xref .py .py-class .docutils .literal
            .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
            .internal}

        4.  

            [[counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [ObserveResult]{.pre}]{.n}*, *[[sub\_term:]{.pre} [cudaq::sum\_op\<cudaq::spin\_handler\>]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Deprecated - ensure to pass a SpinOperatorTerm instead of a
        SpinOperator

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.ObserveResult.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Dump the raw data from the [`SampleResult`{.xref .py .py-class
        .docutils .literal
        .notranslate}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} that are stored in [`ObserveResult`{.xref .py
        .py-class .docutils .literal
        .notranslate}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference
        .internal} to the terminal.

    [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.ObserveResult.expectation "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the expectation value of the `spin_operator`{.code
        .docutils .literal .notranslate} that was provided in
        [`observe()`{.xref .py .py-func .docutils .literal
        .notranslate}](#cudaq.observe "cudaq.observe"){.reference
        .internal}.

        2.  

            [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [ObserveResult]{.pre}]{.n}*, *[[sub\_term:]{.pre} [cudaq::product\_op\<cudaq::spin\_handler\>]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        3.  

            [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*, *[[sub\_term]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the expectation value of an individual `sub_term`{.code
        .docutils .literal .notranslate} of the global
        `spin_operator`{.code .docutils .literal .notranslate} that was
        passed to [`observe()`{.xref .py .py-func .docutils .literal
        .notranslate}](#cudaq.observe "cudaq.observe"){.reference
        .internal}.

        Parameters[:]{.colon}

        :   **sub\_term** (`SpinOperatorTerm`{.xref .py .py-class
            .docutils .literal .notranslate}) -- An individual sub-term
            of the `spin_operator`{.code .docutils .literal
            .notranslate}.

        Returns[:]{.colon}

        :   The expectation value of the `sub_term`{.code .docutils
            .literal .notranslate} with respect to the [`Kernel`{.xref
            .py .py-class .docutils .literal
            .notranslate}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} that was passed to [`observe()`{.xref .py
            .py-func .docutils .literal
            .notranslate}](#cudaq.observe "cudaq.observe"){.reference
            .internal}.

        Return type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference
            .external}

        4.  

            [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [ObserveResult]{.pre}]{.n}*, *[[sub\_term:]{.pre} [cudaq::sum\_op\<cudaq::spin\_handler\>]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Deprecated - ensure to pass a SpinOperatorTerm instead of a
        SpinOperator

    [[get\_spin]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.ObserveResult.get_spin "Permalink to this definition"){.headerlink}

    :   

        [[get\_spin]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[cudaq::sum\_op\<cudaq::spin\_handler\>]{.pre}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the `SpinOperator`{.code .docutils .literal .notranslate}
        corresponding to this `ObserveResult`{.code .docutils .literal
        .notranslate}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[AsyncObserveResult]{.pre}]{.sig-name .descname}[¶](#cudaq.AsyncObserveResult "Permalink to this definition"){.headerlink}

:   A data-type containing the results of a call to
    [`observe_async()`{.xref .py .py-func .docutils .literal
    .notranslate}](#cudaq.observe_async "cudaq.observe_async"){.reference
    .internal}.

    The `AsyncObserveResult`{.code .docutils .literal .notranslate}
    contains a future, whose [`ObserveResult`{.xref .py .py-class
    .docutils .literal
    .notranslate}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference
    .internal} may be returned via an invocation of the `get`{.code
    .docutils .literal .notranslate} method.

    This kicks off a wait on the current thread until the results are
    available.

    See
    [future](https://en.cppreference.com/w/cpp/thread/future){.reference
    .external} for more information on this programming pattern.

    [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.AsyncObserveResult.get "Permalink to this definition"){.headerlink}

    :   

        [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[AsyncObserveResult]{.pre}](#cudaq.AsyncObserveResult "cudaq.AsyncObserveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the [`ObserveResult`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference
        .internal} from the asynchronous observe execution.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[AsyncStateResult]{.pre}]{.sig-name .descname}[¶](#cudaq.AsyncStateResult "Permalink to this definition"){.headerlink}

:   A data-type containing the results of a call to
    [`get_state_async()`{.xref .py .py-func .docutils .literal
    .notranslate}](#cudaq.get_state_async "cudaq.get_state_async"){.reference
    .internal}. The `AsyncStateResult`{.code .docutils .literal
    .notranslate} models a future-like type, whose [`State`{.xref .py
    .py-class .docutils .literal
    .notranslate}](#cudaq.State "cudaq.State"){.reference .internal} may
    be returned via an invocation of the `get`{.code .docutils .literal
    .notranslate} method. This kicks off a wait on the current thread
    until the results are available. See
    [future](https://en.cppreference.com/w/cpp/thread/future){.reference
    .external} for more information on this programming pattern.

    [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.AsyncStateResult.get "Permalink to this definition"){.headerlink}

    :   

        [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[AsyncStateResult]{.pre}](#cudaq.AsyncStateResult "cudaq.AsyncStateResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the [`State`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.State "cudaq.State"){.reference .internal}
        from the asynchronous `get_state`{.code .docutils .literal
        .notranslate} accessor execution.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[OptimizationResult]{.pre}]{.sig-name .descname}[¶](#cudaq.OptimizationResult "Permalink to this definition"){.headerlink}

:   

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[EvolveResult]{.pre}]{.sig-name .descname}[¶](#cudaq.EvolveResult "Permalink to this definition"){.headerlink}

:   Stores the execution data from an invocation of [`evolve()`{.xref
    .py .py-func .docutils .literal
    .notranslate}](#cudaq.evolve "cudaq.evolve"){.reference .internal}.

    [[expectation\_values]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.EvolveResult.expectation_values "Permalink to this definition"){.headerlink}

    :   

        [[expectation\_values]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.EvolveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[Optional]{.pre}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Stores the expectation values, that is the results from the
        calls to [`observe()`{.xref .py .py-func .docutils .literal
        .notranslate}](#cudaq.observe "cudaq.observe"){.reference
        .internal}, at each step in the schedule produced by a call to
        [`evolve()`{.xref .py .py-func .docutils .literal
        .notranslate}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}, including the final expectation values. Each entry
        corresponds to one observable provided in the [`evolve()`{.xref
        .py .py-func .docutils .literal
        .notranslate}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal} call. This property is only populated saving
        intermediate results was requested in the call to
        [`evolve()`{.xref .py .py-func .docutils .literal
        .notranslate}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}. This value will be None if no intermediate results
        were requested, or if no observables were specified in the call.

    [[final\_expectation\_values]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.EvolveResult.final_expectation_values "Permalink to this definition"){.headerlink}

    :   

        [[final\_expectation\_values]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.EvolveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Stores the final expectation values, that is the results
        produced by calls to [`observe()`{.xref .py .py-func .docutils
        .literal
        .notranslate}](#cudaq.observe "cudaq.observe"){.reference
        .internal}, triggered by a call to [`evolve()`{.xref .py
        .py-func .docutils .literal
        .notranslate}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}. Each entry corresponds to one observable provided in
        the [`evolve()`{.xref .py .py-func .docutils .literal
        .notranslate}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal} call. This value will be None if no observables were
        specified in the call.

    [[final\_state]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.EvolveResult.final_state "Permalink to this definition"){.headerlink}

    :   

        [[final\_state]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.EvolveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Stores the final state produced by a call to [`evolve()`{.xref
        .py .py-func .docutils .literal
        .notranslate}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}. Represent the state of a quantum system after time
        evolution under a set of operators, see the [`evolve()`{.xref
        .py .py-func .docutils .literal
        .notranslate}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal} documentation for more detail.

    [[intermediate\_states]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.EvolveResult.intermediate_states "Permalink to this definition"){.headerlink}

    :   

        [[intermediate\_states]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.EvolveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[Optional]{.pre}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Stores all intermediate states, meaning the state after each
        step in a defined schedule, produced by a call to
        [`evolve()`{.xref .py .py-func .docutils .literal
        .notranslate}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}, including the final state. This property is only
        populated if saving intermediate results was requested in the
        call to [`evolve()`{.xref .py .py-func .docutils .literal
        .notranslate}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[AsyncEvolveResult]{.pre}]{.sig-name .descname}[¶](#cudaq.AsyncEvolveResult "Permalink to this definition"){.headerlink}

:   Stores the execution data from an invocation of
    [`evolve_async()`{.xref .py .py-func .docutils .literal
    .notranslate}](#cudaq.evolve_async "cudaq.evolve_async"){.reference
    .internal}.

    [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.AsyncEvolveResult.get "Permalink to this definition"){.headerlink}

    :   

        [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[AsyncEvolveResult]{.pre}](#cudaq.AsyncEvolveResult "cudaq.AsyncEvolveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.EvolveResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Retrieve the evolution result from the asynchronous evolve
        execution .

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Resources]{.pre}]{.sig-name .descname}[¶](#cudaq.Resources "Permalink to this definition"){.headerlink}

:   A data-type containing the results of a call to
    [`estimate_resources()`{.xref .py .py-func .docutils .literal
    .notranslate}](#cudaq.estimate_resources "cudaq.estimate_resources"){.reference
    .internal}. This includes all gate counts.

    [[clear]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.Resources.clear "Permalink to this definition"){.headerlink}

    :   

        [[clear]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Clear out all metadata from `self`{.code .docutils .literal
        .notranslate}.

    [[count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.Resources.count "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Get the number of occurrences of a given gate with any number of
        controls

        2.  

            [[count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Get the total number of occurrences of all gates

    [[count\_controls]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.Resources.count_controls "Permalink to this definition"){.headerlink}

    :   

        [[count\_controls]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Get the number of occurrences of a given gate with the given
        number of controls

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.Resources.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Print a string of the raw resource counts data to the terminal.

::: {#optimizers .section}
### Optimizers[¶](#optimizers "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[optimizer]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.optimizer "Permalink to this definition"){.headerlink}

:   

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[GradientDescent]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.GradientDescent "Permalink to this definition"){.headerlink}

:   

    *[static]{.pre}[ ]{.w}*[[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.GradientDescent.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[optimizers.GradientDescent]{.pre}](#cudaq.optimizers.GradientDescent "cudaq.optimizers.GradientDescent"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to optimizer

    *[property]{.pre}[ ]{.w}*[[initial\_parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.GradientDescent.initial_parameters "Permalink to this definition"){.headerlink}

    :   Set the initial parameter values for the optimization.

    *[property]{.pre}[ ]{.w}*[[lower\_bounds]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.GradientDescent.lower_bounds "Permalink to this definition"){.headerlink}

    :   Set the lower value bound for the optimization parameters.

    *[property]{.pre}[ ]{.w}*[[max\_iterations]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.GradientDescent.max_iterations "Permalink to this definition"){.headerlink}

    :   Set the maximum number of optimizer iterations.

    [[optimize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.GradientDescent.optimize "Permalink to this definition"){.headerlink}

    :   

        [[optimize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.GradientDescent]{.pre}](#cudaq.optimizers.GradientDescent "cudaq.optimizers.GradientDescent"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Run `cudaq.optimize()`{.code .docutils .literal .notranslate} on
        the provided objective function.

    [[requires\_gradients]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.GradientDescent.requires_gradients "Permalink to this definition"){.headerlink}

    :   

        [[requires\_gradients]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.GradientDescent]{.pre}](#cudaq.optimizers.GradientDescent "cudaq.optimizers.GradientDescent"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns whether the optimizer requires gradient.

    [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.GradientDescent.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.GradientDescent]{.pre}](#cudaq.optimizers.GradientDescent "cudaq.optimizers.GradientDescent"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert optimizer to JSON string

    *[property]{.pre}[ ]{.w}*[[upper\_bounds]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.GradientDescent.upper_bounds "Permalink to this definition"){.headerlink}

    :   Set the upper value bound for the optimization parameters.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[COBYLA]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.COBYLA "Permalink to this definition"){.headerlink}

:   

    *[static]{.pre}[ ]{.w}*[[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.COBYLA.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[optimizers.COBYLA]{.pre}](#cudaq.optimizers.COBYLA "cudaq.optimizers.COBYLA"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to optimizer

    *[property]{.pre}[ ]{.w}*[[initial\_parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.COBYLA.initial_parameters "Permalink to this definition"){.headerlink}

    :   Set the initial parameter values for the optimization.

    *[property]{.pre}[ ]{.w}*[[lower\_bounds]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.COBYLA.lower_bounds "Permalink to this definition"){.headerlink}

    :   Set the lower value bound for the optimization parameters.

    *[property]{.pre}[ ]{.w}*[[max\_iterations]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.COBYLA.max_iterations "Permalink to this definition"){.headerlink}

    :   Set the maximum number of optimizer iterations.

    [[optimize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.COBYLA.optimize "Permalink to this definition"){.headerlink}

    :   

        [[optimize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.COBYLA]{.pre}](#cudaq.optimizers.COBYLA "cudaq.optimizers.COBYLA"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Run `cudaq.optimize()`{.code .docutils .literal .notranslate} on
        the provided objective function.

    [[requires\_gradients]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.COBYLA.requires_gradients "Permalink to this definition"){.headerlink}

    :   

        [[requires\_gradients]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.COBYLA]{.pre}](#cudaq.optimizers.COBYLA "cudaq.optimizers.COBYLA"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns whether the optimizer requires gradient.

    [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.COBYLA.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.COBYLA]{.pre}](#cudaq.optimizers.COBYLA "cudaq.optimizers.COBYLA"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert optimizer to JSON string

    *[property]{.pre}[ ]{.w}*[[upper\_bounds]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.COBYLA.upper_bounds "Permalink to this definition"){.headerlink}

    :   Set the upper value bound for the optimization parameters.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[NelderMead]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.NelderMead "Permalink to this definition"){.headerlink}

:   

    *[static]{.pre}[ ]{.w}*[[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.NelderMead.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[optimizers.NelderMead]{.pre}](#cudaq.optimizers.NelderMead "cudaq.optimizers.NelderMead"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to optimizer

    *[property]{.pre}[ ]{.w}*[[initial\_parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.NelderMead.initial_parameters "Permalink to this definition"){.headerlink}

    :   Set the initial parameter values for the optimization.

    *[property]{.pre}[ ]{.w}*[[lower\_bounds]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.NelderMead.lower_bounds "Permalink to this definition"){.headerlink}

    :   Set the lower value bound for the optimization parameters.

    *[property]{.pre}[ ]{.w}*[[max\_iterations]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.NelderMead.max_iterations "Permalink to this definition"){.headerlink}

    :   Set the maximum number of optimizer iterations.

    [[optimize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.NelderMead.optimize "Permalink to this definition"){.headerlink}

    :   

        [[optimize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.NelderMead]{.pre}](#cudaq.optimizers.NelderMead "cudaq.optimizers.NelderMead"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Run `cudaq.optimize()`{.code .docutils .literal .notranslate} on
        the provided objective function.

    [[requires\_gradients]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.NelderMead.requires_gradients "Permalink to this definition"){.headerlink}

    :   

        [[requires\_gradients]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.NelderMead]{.pre}](#cudaq.optimizers.NelderMead "cudaq.optimizers.NelderMead"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns whether the optimizer requires gradient.

    [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.NelderMead.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.NelderMead]{.pre}](#cudaq.optimizers.NelderMead "cudaq.optimizers.NelderMead"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert optimizer to JSON string

    *[property]{.pre}[ ]{.w}*[[upper\_bounds]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.NelderMead.upper_bounds "Permalink to this definition"){.headerlink}

    :   Set the upper value bound for the optimization parameters.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[LBFGS]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.LBFGS "Permalink to this definition"){.headerlink}

:   

    *[static]{.pre}[ ]{.w}*[[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.LBFGS.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[optimizers.LBFGS]{.pre}](#cudaq.optimizers.LBFGS "cudaq.optimizers.LBFGS"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to optimizer

    *[property]{.pre}[ ]{.w}*[[initial\_parameters]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.LBFGS.initial_parameters "Permalink to this definition"){.headerlink}

    :   Set the initial parameter values for the optimization.

    *[property]{.pre}[ ]{.w}*[[lower\_bounds]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.LBFGS.lower_bounds "Permalink to this definition"){.headerlink}

    :   Set the lower value bound for the optimization parameters.

    *[property]{.pre}[ ]{.w}*[[max\_iterations]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.LBFGS.max_iterations "Permalink to this definition"){.headerlink}

    :   Set the maximum number of optimizer iterations.

    [[optimize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.LBFGS.optimize "Permalink to this definition"){.headerlink}

    :   

        [[optimize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.LBFGS]{.pre}](#cudaq.optimizers.LBFGS "cudaq.optimizers.LBFGS"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Run `cudaq.optimize()`{.code .docutils .literal .notranslate} on
        the provided objective function.

    [[requires\_gradients]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.LBFGS.requires_gradients "Permalink to this definition"){.headerlink}

    :   

        [[requires\_gradients]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.LBFGS]{.pre}](#cudaq.optimizers.LBFGS "cudaq.optimizers.LBFGS"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns whether the optimizer requires gradient.

    [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.optimizers.LBFGS.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.LBFGS]{.pre}](#cudaq.optimizers.LBFGS "cudaq.optimizers.LBFGS"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert optimizer to JSON string

    *[property]{.pre}[ ]{.w}*[[upper\_bounds]{.pre}]{.sig-name .descname}[¶](#cudaq.optimizers.LBFGS.upper_bounds "Permalink to this definition"){.headerlink}

    :   Set the upper value bound for the optimization parameters.
:::

::: {#gradients .section}
### Gradients[¶](#gradients "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.gradients.]{.pre}]{.sig-prename .descclassname}[[gradient]{.pre}]{.sig-name .descname}[¶](#cudaq.gradients.gradient "Permalink to this definition"){.headerlink}

:   

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.gradients.]{.pre}]{.sig-prename .descclassname}[[CentralDifference]{.pre}]{.sig-name .descname}[¶](#cudaq.gradients.CentralDifference "Permalink to this definition"){.headerlink}

:   

    [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.gradients.CentralDifference.compute "Permalink to this definition"){.headerlink}

    :   

        [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.gradient]{.pre}](#cudaq.gradients.gradient "cudaq.gradients.gradient"){.reference .internal}]{.n}*, *[[parameter\_vector]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*, *[[funcAtX]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Compute the gradient of the provided `parameter_vector`{.code
        .docutils .literal .notranslate} with respect to its loss
        function, using the `CentralDifference`{.code .docutils .literal
        .notranslate} method.

    *[static]{.pre}[ ]{.w}*[[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.gradients.CentralDifference.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[gradients.CentralDifference]{.pre}](#cudaq.gradients.CentralDifference "cudaq.gradients.CentralDifference"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to gradient

    [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.gradients.CentralDifference.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.CentralDifference]{.pre}](#cudaq.gradients.CentralDifference "cudaq.gradients.CentralDifference"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert gradient to JSON string

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.gradients.]{.pre}]{.sig-prename .descclassname}[[ForwardDifference]{.pre}]{.sig-name .descname}[¶](#cudaq.gradients.ForwardDifference "Permalink to this definition"){.headerlink}

:   

    [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.gradients.ForwardDifference.compute "Permalink to this definition"){.headerlink}

    :   

        [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.gradient]{.pre}](#cudaq.gradients.gradient "cudaq.gradients.gradient"){.reference .internal}]{.n}*, *[[parameter\_vector]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*, *[[funcAtX]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Compute the gradient of the provided `parameter_vector`{.code
        .docutils .literal .notranslate} with respect to its loss
        function, using the `ForwardDifference`{.code .docutils .literal
        .notranslate} method.

    *[static]{.pre}[ ]{.w}*[[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.gradients.ForwardDifference.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[gradients.ForwardDifference]{.pre}](#cudaq.gradients.ForwardDifference "cudaq.gradients.ForwardDifference"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to gradient

    [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.gradients.ForwardDifference.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.ForwardDifference]{.pre}](#cudaq.gradients.ForwardDifference "cudaq.gradients.ForwardDifference"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert gradient to JSON string

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.gradients.]{.pre}]{.sig-prename .descclassname}[[ParameterShift]{.pre}]{.sig-name .descname}[¶](#cudaq.gradients.ParameterShift "Permalink to this definition"){.headerlink}

:   

    [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.gradients.ParameterShift.compute "Permalink to this definition"){.headerlink}

    :   

        [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.gradient]{.pre}](#cudaq.gradients.gradient "cudaq.gradients.gradient"){.reference .internal}]{.n}*, *[[parameter\_vector]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*, *[[funcAtX]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Compute the gradient of the provided `parameter_vector`{.code
        .docutils .literal .notranslate} with respect to its loss
        function, using the `ParameterShift`{.code .docutils .literal
        .notranslate} method.

    *[static]{.pre}[ ]{.w}*[[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.gradients.ParameterShift.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[gradients.ParameterShift]{.pre}](#cudaq.gradients.ParameterShift "cudaq.gradients.ParameterShift"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to gradient

    [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.gradients.ParameterShift.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to\_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.ParameterShift]{.pre}](#cudaq.gradients.ParameterShift "cudaq.gradients.ParameterShift"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert gradient to JSON string
:::

::: {#noisy-simulation .section}
### Noisy Simulation[¶](#noisy-simulation "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[NoiseModel]{.pre}]{.sig-name .descname}[¶](#cudaq.NoiseModel "Permalink to this definition"){.headerlink}

:   The `NoiseModel`{.code .docutils .literal .notranslate} defines a
    set of [`KrausChannel`{.xref .py .py-class .docutils .literal
    .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
    .internal}'s applied to specific qubits after the invocation of
    specified quantum operations.

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.NoiseModel.__init__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Construct a noise model with all built-in channels
        pre-registered.

    [[add\_all\_qubit\_channel]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.NoiseModel.add_all_qubit_channel "Permalink to this definition"){.headerlink}

    :   

        [[add\_all\_qubit\_channel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*, *[[operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*, *[[channel]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}]{.n}*, *[[num\_controls]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Add the given [`KrausChannel`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal} to be applied after invocation of the specified
        quantum operation on arbitrary qubits.

        Parameters[:]{.colon}

        :   -   **operator**
                ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
                .external}) -- The quantum operator to apply the noise
                channel to.

            -   **channel**
                ([*cudaq.KrausChannel*](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
                .internal}) -- The [`KrausChannel`{.xref .py .py-class
                .docutils .literal
                .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
                .internal} to apply to the specified `operator`{.code
                .docutils .literal .notranslate} on any arbitrary
                qubits.

            -   **num\_controls** -- Number of control bits. Default is
                0 (no control bits).

    [[add\_channel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.NoiseModel.add_channel "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[add\_channel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*, *[[operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*, *[[qubits]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[channel]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Add the given [`KrausChannel`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal} to be applied after invocation of the specified
        quantum operation.

        Parameters[:]{.colon}

        :   -   **operator**
                ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
                .external}) -- The quantum operator to apply the noise
                channel to.

            -   **qubits**
                (*List\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference
                .external}*\]*) -- The qubit/s to apply the noise
                channel to.

            -   **channel**
                ([*cudaq.KrausChannel*](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
                .internal}) -- The [`KrausChannel`{.xref .py .py-class
                .docutils .literal
                .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
                .internal} to apply to the specified `operator`{.code
                .docutils .literal .notranslate} on the specified
                `qubits`{.code .docutils .literal .notranslate}.

        2.  

            [[add\_channel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*, *[[operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*, *[[pre]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[cudaq.KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Add the given [`KrausChannel`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal} generator callback to be applied after invocation of
        the specified quantum operation.

        Parameters[:]{.colon}

        :   -   **operator**
                ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference
                .external}) -- The quantum operator to apply the noise
                channel to.

            -   **pre** (*Callable*) -- The callback which takes qubits
                operands and gate parameters and returns a concrete
                [`KrausChannel`{.xref .py .py-class .docutils .literal
                .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
                .internal} to apply to the specified `operator`{.code
                .docutils .literal .notranslate}.

    [[get\_channels]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.NoiseModel.get_channels "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[get\_channels]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*, *[[operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*, *[[qubits]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the [`KrausChannel`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal}'s that make up this noise model.

        2.  

            [[get\_channels]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*, *[[operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.13)"){.reference .external}]{.n}*, *[[qubits]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[controls]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the [`KrausChannel`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal}'s that make up this noise model.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[BitFlipChannel]{.pre}]{.sig-name .descname}[¶](#cudaq.BitFlipChannel "Permalink to this definition"){.headerlink}

:   Models the decoherence of the qubit state. Its constructor expects a
    float value, `probability`{.code .docutils .literal .notranslate},
    representing the probability that the qubit flips from the 1-state
    to the 0-state, or vice versa. E.g, the probability of a random
    X-180 rotation being applied to the qubit.

    The Kraus Channels are thereby defined to be:

    K\_0 = sqrt(1 - probability) \* I

    K\_1 = sqrt(probability ) \* X

    The probability of the qubit remaining in the same state is
    therefore `1 - probability`{.code .docutils .literal .notranslate}.

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.BitFlipChannel.__init__ "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BitFlipChannel]{.pre}](#cudaq.BitFlipChannel "cudaq.BitFlipChannel"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        2.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BitFlipChannel]{.pre}](#cudaq.BitFlipChannel "cudaq.BitFlipChannel"){.reference .internal}]{.n}*, *[[probability]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Initialize the `BitFlipChannel`{.code .docutils .literal
        .notranslate} with the provided `probability`{.code .docutils
        .literal .notranslate}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[PhaseFlipChannel]{.pre}]{.sig-name .descname}[¶](#cudaq.PhaseFlipChannel "Permalink to this definition"){.headerlink}

:   Models the decoherence of the qubit phase. Its constructor expects a
    float value, `probability`{.code .docutils .literal .notranslate},
    representing the probability of a random Z-180 rotation being
    applied to the qubit.

    The Kraus Channels are thereby defined to be:

    K\_0 = sqrt(1 - probability) \* I

    K\_1 = sqrt(probability ) \* Z

    The probability of the qubit phase remaining untouched is therefore
    `1 - probability`{.code .docutils .literal .notranslate}.

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.PhaseFlipChannel.__init__ "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[PhaseFlipChannel]{.pre}](#cudaq.PhaseFlipChannel "cudaq.PhaseFlipChannel"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        2.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[PhaseFlipChannel]{.pre}](#cudaq.PhaseFlipChannel "cudaq.PhaseFlipChannel"){.reference .internal}]{.n}*, *[[probability]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Initialize the `PhaseFlipChannel`{.code .docutils .literal
        .notranslate} with the provided `probability`{.code .docutils
        .literal .notranslate}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[DepolarizationChannel]{.pre}]{.sig-name .descname}[¶](#cudaq.DepolarizationChannel "Permalink to this definition"){.headerlink}

:   Models the decoherence of the qubit state and phase into a mixture "
    of the computational basis states, `|0>`{.code .docutils .literal
    .notranslate} and `|1>`{.code .docutils .literal .notranslate}.

    The Kraus Channels are thereby defined to be:

    K\_0 = sqrt(1 - probability) \* I

    K\_1 = sqrt(probability / 3) \* X

    K\_2 = sqrt(probability / 3) \* Y

    K\_3 = sqrt(probability / 3) \* Z

    where I, X, Y, Z are the 2x2 Pauli matrices.

    The constructor expects a float value, `probability`{.code .docutils
    .literal .notranslate}, representing the probability the state decay
    will occur. The qubit will remain untouched, therefore, with a
    probability of `1 - probability`{.code .docutils .literal
    .notranslate}. And the X,Y,Z operators will be applied with a
    probability of `probability / 3`{.code .docutils .literal
    .notranslate}.

    For `probability = 0.0`{.code .docutils .literal .notranslate}, the
    channel will behave noise-free. For `probability = 0.75`{.code
    .docutils .literal .notranslate}, the channel will fully depolarize
    the state. For `probability = 1.0`{.code .docutils .literal
    .notranslate}, the channel will be uniform.

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.DepolarizationChannel.__init__ "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[DepolarizationChannel]{.pre}](#cudaq.DepolarizationChannel "cudaq.DepolarizationChannel"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        2.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[DepolarizationChannel]{.pre}](#cudaq.DepolarizationChannel "cudaq.DepolarizationChannel"){.reference .internal}]{.n}*, *[[probability]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Initialize the `DepolarizationChannel`{.code .docutils .literal
        .notranslate} with the provided `probability`{.code .docutils
        .literal .notranslate}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[AmplitudeDampingChannel]{.pre}]{.sig-name .descname}[¶](#cudaq.AmplitudeDampingChannel "Permalink to this definition"){.headerlink}

:   Models the dissipation of energy due to system interactions with the
    environment.

    The Kraus Channels are thereby defined to be:

    K\_0 = sqrt(1 - probability) \* I

    K\_1 = sqrt(probability) \* 0.5 \* (X + iY)

    Its constructor expects a float value, `probability`{.code .docutils
    .literal .notranslate}, representing the probablity that the qubit
    will decay to its ground state. The probability of the qubit
    remaining in the same state is therefore `1 - probability`{.code
    .docutils .literal .notranslate}.

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.AmplitudeDampingChannel.__init__ "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[AmplitudeDampingChannel]{.pre}](#cudaq.AmplitudeDampingChannel "cudaq.AmplitudeDampingChannel"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        2.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[AmplitudeDampingChannel]{.pre}](#cudaq.AmplitudeDampingChannel "cudaq.AmplitudeDampingChannel"){.reference .internal}]{.n}*, *[[probability]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Initialize the `AmplitudeDampingChannel`{.code .docutils
        .literal .notranslate} with the provided `probability`{.code
        .docutils .literal .notranslate}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[PhaseDamping]{.pre}]{.sig-name .descname}[¶](#cudaq.PhaseDamping "Permalink to this definition"){.headerlink}

:   A Kraus channel that models the single-qubit phase damping error.
    This is similar to AmplitudeDamping, but for phase.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[XError]{.pre}]{.sig-name .descname}[¶](#cudaq.XError "Permalink to this definition"){.headerlink}

:   A Pauli error that applies the X operator when an error occurs. It
    is the same as BitFlipChannel.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[YError]{.pre}]{.sig-name .descname}[¶](#cudaq.YError "Permalink to this definition"){.headerlink}

:   A Pauli error that applies the Y operator when an error occurs.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[ZError]{.pre}]{.sig-name .descname}[¶](#cudaq.ZError "Permalink to this definition"){.headerlink}

:   A Pauli error that applies the Z operator when an error occurs. It
    is the same as PhaseFlipChannel.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Pauli1]{.pre}]{.sig-name .descname}[¶](#cudaq.Pauli1 "Permalink to this definition"){.headerlink}

:   A single-qubit Pauli error that applies either an X error, Y error,
    or Z error. The probability of each X, Y, or Z error is supplied as
    a parameter.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Pauli2]{.pre}]{.sig-name .descname}[¶](#cudaq.Pauli2 "Permalink to this definition"){.headerlink}

:   A 2-qubit Pauli error that applies one of the following errors, with
    the probabilities specified as a vector. Possible errors: IX, IY,
    IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, and ZZ.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Depolarization1]{.pre}]{.sig-name .descname}[¶](#cudaq.Depolarization1 "Permalink to this definition"){.headerlink}

:   The same as DepolarizationChannel (single qubit depolarization)

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Depolarization2]{.pre}]{.sig-name .descname}[¶](#cudaq.Depolarization2 "Permalink to this definition"){.headerlink}

:   A 2-qubit depolarization error that applies one of the following
    errors. Possible errors: IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ,
    ZI, ZX, ZY, and ZZ.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[KrausChannel]{.pre}]{.sig-name .descname}[¶](#cudaq.KrausChannel "Permalink to this definition"){.headerlink}

:   The `KrausChannel`{.code .docutils .literal .notranslate} is
    composed of a list of [`KrausOperator`{.xref .py .py-class .docutils
    .literal
    .notranslate}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference
    .internal}'s and is applied to a specific qubit or set of qubits.

    [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.KrausChannel.__getitem__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}]{.n}*, *[[index]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[KrausOperator]{.pre}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the [`KrausOperator`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference
        .internal} at the given index in this [`KrausChannel`{.xref .py
        .py-class .docutils .literal
        .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal}.

    [[append]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.KrausChannel.append "Permalink to this definition"){.headerlink}

    :   

        [[append]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[KrausOperator]{.pre}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Add a [`KrausOperator`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference
        .internal} to this [`KrausChannel`{.xref .py .py-class .docutils
        .literal
        .notranslate}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[KrausOperator]{.pre}]{.sig-name .descname}[¶](#cudaq.KrausOperator "Permalink to this definition"){.headerlink}

:   The `KrausOperator`{.code .docutils .literal .notranslate} is
    represented by a matrix and serves as an element of a quantum
    channel such that `Sum Ki Ki^dag = I.`{.code .docutils .literal
    .notranslate}

    *[property]{.pre}[ ]{.w}*[[col\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.KrausOperator.col_count "Permalink to this definition"){.headerlink}

    :   The number of columns in the matrix representation of this
        [`KrausOperator`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference
        .internal}.

    *[property]{.pre}[ ]{.w}*[[row\_count]{.pre}]{.sig-name .descname}[¶](#cudaq.KrausOperator.row_count "Permalink to this definition"){.headerlink}

    :   The number of rows in the matrix representation of this
        [`KrausOperator`{.xref .py .py-class .docutils .literal
        .notranslate}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference
        .internal}.
:::
:::

::: {#mpi-submodule .section}
MPI Submodule[¶](#mpi-submodule "Permalink to this heading"){.headerlink}
-------------------------------------------------------------------------

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[initialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.mpi.initialize "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[initialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Initialize MPI if available.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[rank]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.mpi.rank "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[rank]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Return the rank of this process.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[num\_ranks]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.mpi.num_ranks "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[num\_ranks]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Return the total number of ranks.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[all\_gather]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.mpi.all_gather "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[all\_gather]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

    Gather and scatter the `local`{.code .docutils .literal
    .notranslate} list of floating-point numbers, returning a
    concatenation of all lists across all ranks. The total global list
    size must be provided.

    2.  

        [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[all\_gather]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

    Gather and scatter the `local`{.code .docutils .literal
    .notranslate} list of integers, returning a concatenation of all
    lists across all ranks. The total global list size must be provided.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[broadcast]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.mpi.broadcast "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[broadcast]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*, *[[arg2]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

    :   

    Broadcast an array from a process (rootRank) to all other processes.
    The size of broadcast array must be provided.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[is\_initialized]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.mpi.is_initialized "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[is\_initialized]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns true if MPI has already been initialized.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[finalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[¶](#cudaq.mpi.finalize "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[finalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[→]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.13)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Finalize MPI.
:::

::: {#orca-submodule .section}
ORCA Submodule[¶](#orca-submodule "Permalink to this heading"){.headerlink}
---------------------------------------------------------------------------

[[cudaq.orca.]{.pre}]{.sig-prename .descclassname}[[sample]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[¶](#cudaq.orca.sample "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.orca.]{.pre}]{.sig-prename .descclassname}[[sample]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[input\_state]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[loop\_lengths]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[bs\_angles]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[ps\_angles]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[n\_samples]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[10000]{.pre}]{.default_value}*, *[[qpu\_id]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Performs Time Bin Interferometer (TBI) boson sampling experiments on
    ORCA's backends

    2.  

        [[cudaq.orca.]{.pre}]{.sig-prename .descclassname}[[sample]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[input\_state]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[loop\_lengths]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[bs\_angles]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.13)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.13)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[n\_samples]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[10000]{.pre}]{.default_value}*, *[[qpu\_id]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.13)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0]{.pre}]{.default_value}*[)]{.sig-paren} [[→]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Performs Time Bin Interferometer (TBI) boson sampling experiments on
    ORCA's backends
:::
:::
:::
:::

::: {.rst-footer-buttons role="navigation" aria-label="Footer"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](cpp_api.html "CUDA-Q C++ API"){.btn .btn-neutral .float-left}
[Next []{.fa .fa-arrow-circle-right
aria-hidden="true"}](../default_ops.html "Quantum Operations"){.btn
.btn-neutral .float-right}
:::

------------------------------------------------------------------------

::: {role="contentinfo"}
© Copyright 2025, NVIDIA Corporation & Affiliates.
:::

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme) provided by
[Read the Docs](https://readthedocs.org).
:::
:::
:::
:::
