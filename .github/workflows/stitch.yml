name: Stitch Multi-Arch Manifests

on: push

# on:
#   workflow_call:
#     inputs:
#       digests_json:
#         required: true
#         type: string
#       ext_json:
#         required: true
#         type: string
#     outputs:
#       stitched_json:
#         description: "JSON mapping of stitched manifest digests"
#         value: ${{ jobs.stitch.outputs.stitched_json }}

jobs:
  stitch:
    name: Stitch Manifests
    runs-on: ubuntu-latest

    environment: ghcr-deployment

    outputs:
      stitched_json: ${{ steps.stitch.outputs.stitched_json }}

    steps:
      - name: Login to GitHub CR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Log in to NGC
        uses: docker/login-action@v3
        with:
          registry: nvcr.io
          username: '$oauthtoken'
          password: ${{ secrets.NGC_CREDENTIALS }}

      - name: Set up context for buildx
        run: docker context create builder_context || echo "Context already exists"

      - name: Set up buildx runner
        uses: docker/setup-buildx-action@v3
        with:
          endpoint: builder_context
          version: v0.19.0
          driver-opts: |
            image=moby/buildkit:v0.19.0

      - name: Create multi-arch images
        id: stitch
        run: |
          set -euo pipefail

          DIGESTS_JSON='${{ inputs.digests_json }}'
          EXT_JSON='${{ inputs.ext_json }}'

          echo "EXT_JSON:"
          echo "$EXT_JSON" | jq .

          # Grab the first tag that starts with ghcr.io/nvidia/cuda-quantum-dev:ext-
          tag_sample=$(echo "$DIGESTS_JSON" | jq -r '.image_tag[]' | grep '^ghcr.io/nvidia/cuda-quantum-dev:ext-' | head -n1)

          # Extract the tag portion after the colon
          full_tag=$(echo "$tag_sample" | cut -d ':' -f2)

          # Strip prefix pattern to get branch
          branch=$(echo "$full_tag" | sed -E 's/^ext-[^-]+-cu[0-9.]+-gcc[0-9]+-//')

          echo "branch: $branch"

          stitched_output="{}"

          echo "Creating stitched manifest for cuda-quantum-devdeps..."
          for cuda in 11.8 12.0; do
            cuda_major="${cuda%%.*}"
            key_arm64="arm64-cu${cuda}-ext"
            key_amd64="amd64-cu${cuda}-ext"

            arm64_image=$(echo "$EXT_JSON" | jq -r ".image_hash[\"$key_arm64\"]")
            amd64_image=$(echo "$EXT_JSON" | jq -r ".image_hash[\"$key_amd64\"]")

            refs="$amd64_image $arm64_image"

            echo "CUDA $cuda arm64 image: $arm64_image"
            echo "CUDA $cuda amd64 image: $amd64_image"

            # Extract registry name (e.g., ghcr.io/nvidia/cuda-quantum-devdeps)
            registry=$(echo "$arm64_image" | cut -d'@' -f1)

            # Find matching build_cache entry and extract gcc version suffix (e.g., gcc11 or gcc12)
            gcc_cache_key="$key_arm64"
            gcc_version=$(echo "$EXT_JSON" | jq -r ".build_cache[\"$gcc_cache_key\"]" | grep -o 'gcc[0-9]\+' || echo "gccXX")

            stitched_tag="${registry}:ext-cu${cuda}-${gcc_version}-${branch}"
            echo "Stitching as: $stitched_tag"

            docker buildx imagetools create --tag "$stitched_tag" $refs

            stitched_key="devdeps-cu${cuda_major}"

            digest=$(docker buildx imagetools inspect "$stitched_tag" | awk '/^Digest:/ { print $2 }')
            reference="${registry}@${digest}"

            stitched_output=$(echo "$stitched_output" | jq --arg key "$stitched_key" --arg val "$reference" '. + {($key): $val}')
          done

          echo "Creating stitched manifest for cuda-quantum and cuda-quantum-dev..."
          for image in image dev-image; do
            for cuda in 11.8 12.0; do
              echo "Processing CUDA $cuda..."
              refs=""
              for arch in amd64 arm64; do
                key="${arch}-cu${cuda}-${image}"
                echo "Looking up key: $key"

                digest=$(echo "$DIGESTS_JSON" | jq -r ".digest[\"$key\"]")

                arch_reference=$(echo "$DIGESTS_JSON" | jq -r ".image_tag[\"$key\"]")
                registry=$(echo "$arch_reference" | cut -d':' -f1)

                refs="$refs $registry@$digest"
              done

              cuda_major="${cuda%%.*}"

              if [[ "$image" == "dev-image" ]]; then
                stitched_tag="$registry:cu${cuda_major}-${branch}-base"
                stitched_key="dev-cu${cuda_major}"
              else
                # Determine if we push to NGC
                is_versioned=${{ github.ref_type == 'tag' || startsWith(github.ref_name, 'releases/') || startsWith(github.ref_name, 'staging/') }}
                has_continuous_deployment=${{ startsWith(github.ref_name, 'experimental/') || github.ref_name == 'main' }}
                push_to_ngc=`($is_versioned || $has_continuous_deployment) && echo true || echo`

                # Replace registry if pushing to NGC
                if [[ "$push_to_ngc" == "true" ]]; then
                  registry=${registry/ghcr.io\/nvidia/nvcr.io\/nvidia\/nightly}
                fi

                # Start tag with CUDA major if present
                image_tag="${cuda_major:+cu${cuda_major}-}"

                # Append PR/version/branch info
                if ${{ github.event.pull_request.number != '' }} || [ -n "$(echo ${{ github.ref_name }} | grep pull-request/)" ]; then
                  pr_number=`echo ${{ github.ref_name }} | grep -o [0-9]*`
                  image_tag+=pr-${pr_number:-${{ github.event.pull_request.number }}}
                elif [[ "${{ github.ref_type }}" == "branch" && "${{ github.ref_name }}" == "main" ]]; then
                  image_tag+="latest"
                elif [[ "$is_versioned" == "true" ]]; then
                  image_tag+="$(echo "${{ github.ref_name }}" | grep -oE '([0-9]{1,}\.)+[0-9]{1,}')"
                else
                  image_tag+="$(echo "${{ github.ref_name }}" | tr '/' '-')"
                fi

                stitched_tag="${registry}:${image_tag}"
                stitched_key="base-cu${cuda_major}"
              fi

              echo "Creating manifest for $stitched_tag"
              echo "Refs: $refs"
              docker buildx imagetools create --tag "$stitched_tag" "$refs"

              digest=$(docker buildx imagetools inspect "$stitched_tag" | awk '/^Digest:/ { print $2 }')
              reference="${registry}@${digest}"
              
              stitched_output=$(echo "$stitched_output" | jq --arg key "$stitched_key" --arg val "$digest" '. + {($key): $val}')
            done
          done

          echo "$stitched_output" > stitched_digests.json
          stitched_json=$(jq -c . stitched_digests.json)
          echo "stitched_json=$stitched_json" | tee -a $GITHUB_OUTPUT
