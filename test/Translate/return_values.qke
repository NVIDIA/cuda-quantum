// ========================================================================== //
// Copyright (c) 2022 - 2025 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt -add-dealloc -kernel-execution -canonicalize %s | \
// RUN: cudaq-translate --convert-to=qir | FileCheck %s

// NB: the mangled name map is required for the kernel-execution pass.
// QIR codegen requires the target triple.
module attributes{ quake.mangled_name_map = {
  __nvqpp__mlirgen__test_0 = "test_0",
  __nvqpp__mlirgen__test_1 = "test_1",
  __nvqpp__mlirgen__test_2 = "test_2",
  __nvqpp__mlirgen__test_3 = "test_3",
  __nvqpp__mlirgen__test_4 = "test_4",
  __nvqpp__mlirgen__test_5 = "test_5" },
  llvm.triple = "x86_64-unknown-linux-gnu"} {

func.func private @__nvqpp_vectorCopyCtor(%arg0: !cc.ptr<i8> , %arg1: i64 , %arg2: i64 ) -> !cc.ptr<i8>

// vector<bool> -> struct ptr sret
func.func @__nvqpp__mlirgen__test_0(%arg0: i32) -> !cc.stdvec<i1> {
  %c1_i64 = arith.constant 1 : i64
  %c1 = arith.constant 1 : i64
  %c0 = arith.constant 0 : i64
  %0 = cc.alloca i32
  cc.store %arg0, %0 : !cc.ptr<i32>
  %1 = cc.load %0 : !cc.ptr<i32>
  %2 = arith.extsi %1 : i32 to i64
  %3 = quake.alloca !quake.veq<?>[%2 : i64]
  %4 = quake.veq_size %3 : (!quake.veq<?>) -> i64
  %6 = cc.loop while ((%arg1 = %c0) -> (i64)) {
    %12 = arith.cmpi slt, %arg1, %4 : i64
    cc.condition %12(%arg1 : i64)
  } do {
  ^bb0(%arg1: i64):
    %12 = quake.extract_ref %3[%arg1] : (!quake.veq<?>, i64) -> !quake.ref
    quake.h %12 : (!quake.ref) -> ()
    cc.continue %arg1 : i64
  } step {
  ^bb0(%arg1: i64):
    %12 = arith.addi %arg1, %c1 : i64
    cc.continue %12 : i64
  } {invariant}
  %measOut = quake.mz %3 : (!quake.veq<?>) -> !cc.stdvec<!quake.measure>
  %7 = quake.discriminate %measOut : (!cc.stdvec<!quake.measure>) -> !cc.stdvec<i1>
  %8 = cc.stdvec_data %7 : (!cc.stdvec<i1>) -> !cc.ptr<i8>
  %9 = cc.stdvec_size %7 : (!cc.stdvec<i1>) -> i64
  %10 = call @__nvqpp_vectorCopyCtor(%8, %9, %c1_i64) : (!cc.ptr<i8>, i64, i64) -> !cc.ptr<i8>
  %11 = cc.stdvec_init %10, %9 : (!cc.ptr<i8>, i64) -> !cc.stdvec<i1>
  return %11 : !cc.stdvec<i1>
}

func.func @test_0(%1: !cc.ptr<!cc.struct<{!cc.ptr<i8>, !cc.ptr<i8>, !cc.ptr<i8>}>> {llvm.sret = !cc.struct<{!cc.ptr<i8>, !cc.ptr<i8>, !cc.ptr<i8>}>}, %this: !cc.ptr<i8>, %2: i32) {
  return
}

// CHECK-LABEL: define { ptr, i64 } @__nvqpp__mlirgen__test_0(i32
// CHECK-SAME:                                                    %[[VAL_0:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_2:.*]] = sext i32 %[[VAL_0]] to i64
// CHECK:         %[[VAL_3:.*]] = tail call ptr @__quantum__rt__qubit_allocate_array(i64 %[[VAL_2]])
// CHECK:         %[[VAL_4:.*]] = tail call i64 @__quantum__rt__array_get_size_1d(ptr %[[VAL_3]])
// CHECK:         %[[VAL_5:.*]] = icmp sgt i64 %[[VAL_4]], 0
// CHECK:         br i1 %[[VAL_5]], label %.lr.ph, label %._crit_edge
// CHECK:       .lr.ph:                                           ; preds = %[[VAL_1:.*]], %.lr.ph
// CHECK:         %[[VAL_6:.*]] = phi i64 [ %[[VAL_9:.*]], %.lr.ph ], [ 0, %[[VAL_1]] ]
// CHECK:         %[[VAL_7:.*]] = tail call ptr @__quantum__rt__array_get_element_ptr_1d(ptr %[[VAL_3]], i64 %[[VAL_6]])
// CHECK:         %[[VAL_8:.*]] = load ptr, ptr %[[VAL_7]], align 8
// CHECK:         tail call void @__quantum__qis__h(ptr %[[VAL_8]])
// CHECK:         %[[VAL_9]] = add nuw nsw i64 %[[VAL_6]], 1
// CHECK:         %exitcond.not = icmp eq i64 %[[VAL_9]], %[[VAL_4]]
// CHECK:         br i1 %exitcond.not, label %.lr.ph4.preheader, label %.lr.ph
// CHECK:       ._crit_edge:                                      ; preds = %[[VAL_1]]
// CHECK:         %[[VAL_10:.*]] = alloca i8, i64 %[[VAL_4]], align 1
// CHECK:         br label %._crit_edge5
// CHECK:       .lr.ph4.preheader:                                ; preds = %.lr.ph
// CHECK:         %[[VAL_11:.*]] = alloca i8, i64 %[[VAL_4]], align 1
// CHECK:         br label %.lr.ph4
// CHECK:       .lr.ph4:                                          ; preds = %.lr.ph4.preheader, %.lr.ph4
// CHECK:         %[[VAL_12:.*]] = phi i64 [ %[[VAL_19:.*]], %.lr.ph4 ], [ 0, %.lr.ph4.preheader ]
// CHECK:         %[[VAL_13:.*]] = tail call ptr @__quantum__rt__array_get_element_ptr_1d(ptr %[[VAL_3]], i64 %[[VAL_12]])
// CHECK:         %[[VAL_14:.*]] = load ptr, ptr %[[VAL_13]], align 8
// CHECK:         %[[VAL_15:.*]] = tail call ptr @__quantum__qis__mz(ptr %[[VAL_14]])
// CHECK:         %[[VAL_16:.*]] = load i1, ptr %[[VAL_15]], align 1
// CHECK:         %[[VAL_17:.*]] = getelementptr i8, ptr %[[VAL_11]], i64 %[[VAL_12]]
// CHECK:         %[[VAL_18:.*]] = zext i1 %[[VAL_16]] to i8
// CHECK:         store i8 %[[VAL_18]], ptr %[[VAL_17]], align 1
// CHECK:         %[[VAL_19]] = add nuw nsw i64 %[[VAL_12]], 1
// CHECK:         %exitcond6.not = icmp eq i64 %[[VAL_19]], %[[VAL_4]]
// CHECK:         br i1 %exitcond6.not, label %._crit_edge5, label %.lr.ph4
// CHECK:       ._crit_edge5:                                     ; preds = %.lr.ph4, %._crit_edge
// CHECK:         %[[VAL_20:.*]] = phi ptr [ %[[VAL_10]], %._crit_edge ], [ %[[VAL_11]], %.lr.ph4 ]
// CHECK:         %[[VAL_21:.*]] = call ptr @__nvqpp_vectorCopyCtor(ptr nonnull %[[VAL_20]], i64 %[[VAL_4]], i64 1)
// CHECK:         %[[VAL_22:.*]] = insertvalue { ptr, i64 } undef, ptr %[[VAL_21]], 0
// CHECK:         %[[VAL_23:.*]] = insertvalue { ptr, i64 } %[[VAL_22]], i64 %[[VAL_4]], 1
// CHECK:         call void @__quantum__rt__qubit_release_array(ptr %[[VAL_3]])
// CHECK:         ret { ptr, i64 } %[[VAL_23]]
// CHECK:       }

// CHECK-LABEL: define void @test_0(ptr sret({ ptr, ptr, ptr })
// CHECK-SAME:                                                                 %[[VAL_0:.*]], ptr readnone captures(none)
// CHECK-SAME:                                                                 %[[VAL_1:.*]], i32
// CHECK-SAME:                                                                 %[[VAL_2:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_3:.*]] = alloca [24 x i8], align 1
// CHECK:         store i32 %[[VAL_2]], ptr %[[VAL_3]], align 4
// CHECK:         %[[VAL_5:.*]] = alloca { ptr, ptr, ptr }, align 8
// CHECK:         %[[VAL_6:.*]] = alloca [1 x ptr], align 8
// CHECK:         store ptr %[[VAL_6]], ptr %[[VAL_5]], align 8
// CHECK:         %[[VAL_7:.*]] = ptrtoint ptr %[[VAL_6]] to i64
// CHECK:         %[[VAL_8:.*]] = add i64 %[[VAL_7]], 8
// CHECK:         %[[VAL_9:.*]] = inttoptr i64 %[[VAL_8]] to ptr
// CHECK:         %[[VAL_10:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_5]], i64 8
// CHECK:         store ptr %[[VAL_9]], ptr %[[VAL_10]], align 8
// CHECK:         %[[VAL_11:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_5]], i64 16
// CHECK:         store ptr %[[VAL_9]], ptr %[[VAL_11]], align 8
// CHECK:         %[[VAL_12:.*]] = alloca i32, align 4
// CHECK:         store i32 %[[VAL_2]], ptr %[[VAL_12]], align 4
// CHECK:         store ptr %[[VAL_12]], ptr %[[VAL_6]], align 8
// CHECK:         %[[VAL_13:.*]] = call { ptr, i64 } @hybridLaunchKernel(ptr nonnull @test_0.kernelName, ptr nonnull @test_0.thunk, ptr nonnull %[[VAL_3]], i64 24, i64 8, ptr nonnull %[[VAL_5]])
// CHECK:         %[[VAL_14:.*]] = extractvalue { ptr, i64 } %[[VAL_13]], 0
// CHECK:         %.not = icmp eq ptr %[[VAL_14]], null
// CHECK:         %.v.sroa.sel.v.sroa.sel.v.sroa.sel.v = select i1 %.not, ptr %[[VAL_3]], ptr %[[VAL_14]]
// CHECK:         %.v.sroa.sel.v.sroa.sel.v.sroa.sel = getelementptr i8, ptr %.v.sroa.sel.v.sroa.sel.v.sroa.sel.v, i64 8
// CHECK:         %[[VAL_15:.*]] = load ptr, ptr %.v.sroa.sel.v.sroa.sel.v.sroa.sel, align 8
// CHECK:         %.v.sroa.sel4.v.sroa.sel.v.sroa.sel.v = select i1 %.not, ptr %[[VAL_3]], ptr %[[VAL_14]]
// CHECK:         %.v.sroa.sel4.v.sroa.sel.v.sroa.sel = getelementptr i8, ptr %.v.sroa.sel4.v.sroa.sel.v.sroa.sel.v, i64 16
// CHECK:         %[[VAL_16:.*]] = load i64, ptr %.v.sroa.sel4.v.sroa.sel.v.sroa.sel, align 4
// CHECK:         call void @__nvqpp_initializer_list_to_vector_bool(ptr %[[VAL_0]], ptr %[[VAL_15]], i64 %[[VAL_16]])
// CHECK:         call void @free(ptr %[[VAL_14]])
// CHECK:         ret void
// CHECK:       }

// struct{bool, bool} -> i16
func.func @__nvqpp__mlirgen__test_1() -> !cc.struct<{i1, i1}> {
  %qubits = quake.alloca !quake.veq<2>
  %q0 = quake.extract_ref %qubits[0] : (!quake.veq<2>) -> !quake.ref
  %q1 = quake.extract_ref %qubits[1] : (!quake.veq<2>) -> !quake.ref
  quake.h %q0 : (!quake.ref) -> ()
  quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  %m0 = quake.mz %q0 : (!quake.ref) -> !quake.measure
  %m1 = quake.mz %q1 : (!quake.ref) -> !quake.measure
  %rv = cc.undef !cc.struct<{i1, i1}>
  %d1 = quake.discriminate %m0 : (!quake.measure) -> i1
  %rv1 = cc.insert_value %rv[0], %d1 : (!cc.struct<{i1, i1}>, i1) -> !cc.struct<{i1, i1}>
  %d2 = quake.discriminate %m1 : (!quake.measure) -> i1
  %rv2 = cc.insert_value %rv1[1], %d2 : (!cc.struct<{i1, i1}>, i1) -> !cc.struct<{i1, i1}>
  return %rv2 : !cc.struct<{i1, i1}>
}

func.func @test_1(%this: !cc.ptr<i8>) -> i16 {
  %0 = cc.undef i16
  return %0 : i16
}


// CHECK-LABEL: define { i1, i1 } @__nvqpp__mlirgen__test_1() local_unnamed_addr {
// CHECK:         %[[VAL_0:.*]] = tail call ptr @__quantum__rt__qubit_allocate_array(i64 2)
// CHECK:         %[[VAL_2:.*]] = tail call ptr @__quantum__rt__array_get_element_ptr_1d(ptr %[[VAL_0]], i64 0)
// CHECK:         %[[VAL_4:.*]] = load ptr, ptr %[[VAL_2]], align 8
// CHECK:         %[[VAL_5:.*]] = tail call ptr @__quantum__rt__array_get_element_ptr_1d(ptr %[[VAL_0]], i64 1)
// CHECK:         %[[VAL_6:.*]] = load ptr, ptr %[[VAL_5]], align 8
// CHECK:         tail call void @__quantum__qis__h(ptr %[[VAL_4]])
// CHECK:         tail call void (i64, i64, i64, i64, ptr, ...) @generalizedInvokeWithRotationsControlsTargets(i64 0, i64 0, i64 1, i64 1, ptr nonnull @__quantum__qis__x__ctl, ptr %[[VAL_4]], ptr %[[VAL_6]])
// CHECK:         %[[VAL_7:.*]] = tail call ptr @__quantum__qis__mz(ptr %[[VAL_4]])
// CHECK:         %[[VAL_9:.*]] = tail call ptr @__quantum__qis__mz(ptr %[[VAL_6]])
// CHECK:         %[[VAL_11:.*]] = load i1, ptr %[[VAL_7]], align 1
// CHECK:         %[[VAL_12:.*]] = insertvalue { i1, i1 } undef, i1 %[[VAL_11]], 0
// CHECK:         %[[VAL_14:.*]] = load i1, ptr %[[VAL_9]], align 1
// CHECK:         %[[VAL_15:.*]] = insertvalue { i1, i1 } %[[VAL_12]], i1 %[[VAL_14]], 1
// CHECK:         tail call void @__quantum__rt__qubit_release_array(ptr %[[VAL_0]])
// CHECK:         ret { i1, i1 } %[[VAL_15]]
// CHECK:       }

// CHECK-LABEL: define i16 @test_1(ptr readnone captures(none)
// CHECK-SAME:        %[[VAL_0:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_2:.*]] = alloca [0 x ptr], align 8
// CHECK:         %[[VAL_3:.*]] = alloca [2 x i8], align 1
// CHECK:         %[[VAL_4:.*]] = alloca { ptr, ptr, ptr }, align 8
// CHECK:         store ptr %[[VAL_2]], ptr %[[VAL_4]], align 8
// CHECK:         %[[VAL_5:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_4]], i64 8
// CHECK:         store ptr %[[VAL_2]], ptr %[[VAL_5]], align 8
// CHECK:         %[[VAL_6:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_4]], i64 16
// CHECK:         store ptr %[[VAL_2]], ptr %[[VAL_6]], align 8
// CHECK:         %[[VAL_7:.*]] = call { ptr, i64 } @hybridLaunchKernel(ptr nonnull @test_1.kernelName, ptr nonnull @test_1.thunk, ptr nonnull %[[VAL_3]], i64 2, i64 0, ptr nonnull %[[VAL_4]])
// CHECK:         %[[VAL_8:.*]] = load i16, ptr %[[VAL_3]], align 2
// CHECK:         ret i16 %[[VAL_8]]
// CHECK:       }

// struct{i16, f32, f64, i64} -> sret ptr
func.func @__nvqpp__mlirgen__test_2() -> !cc.struct<{i16, f32, f64, i64}> {
  %rv = cc.undef !cc.struct<{i16, f32, f64, i64}>
  %c1 = arith.constant 8 : i16
  %rv1 = cc.insert_value %rv[0], %c1 : (!cc.struct<{i16, f32, f64, i64}>, i16) -> !cc.struct<{i16, f32, f64, i64}>
  %c2 = arith.constant 5.4 : f32
  %rv2 = cc.insert_value %rv1[1], %c2 : (!cc.struct<{i16, f32, f64, i64}>, f32) -> !cc.struct<{i16, f32, f64, i64}>
  %c3 = arith.constant 37.83 : f64
  %rv3 = cc.insert_value %rv2[2], %c3 : (!cc.struct<{i16, f32, f64, i64}>, f64) -> !cc.struct<{i16, f32, f64, i64}>
  %c4 = arith.constant 1479 : i64
  %rv4 = cc.insert_value %rv3[3], %c4 : (!cc.struct<{i16, f32, f64, i64}>, i64) -> !cc.struct<{i16, f32, f64, i64}>
  return %rv4 : !cc.struct<{i16, f32, f64, i64}>
}

func.func @test_2(%1: !cc.ptr<!cc.struct<{i16, f32, f64, i64}>> {llvm.sret = !cc.struct<{i16, f32, f64, i64}>}, %this: !cc.ptr<i8>) {
  return
}

// CHECK-LABEL: define { i16, float, double, i64 } @__nvqpp__mlirgen__test_2() local_unnamed_addr {{.*}} {
// CHECK:         ret { i16, float, double, i64 } { i16 8, float 0x40159999A0000000, double 3.783000e+01, i64 1479 }
// CHECK:       }

// CHECK-LABEL: define void @test_2(ptr writeonly sret({ i16, float, double, i64 }) captures(none) initializes((0, 24))
// CHECK-SAME:      %[[VAL_0:.*]], ptr readnone captures(none)
// CHECK-SAME:      %[[VAL_1:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_3:.*]] = alloca [0 x ptr], align 8
// CHECK:         %[[VAL_4:.*]] = alloca [24 x i8], align 1
// CHECK:         %[[VAL_5:.*]] = alloca { ptr, ptr, ptr }, align 8
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_5]], align 8
// CHECK:         %[[VAL_6:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_5]], i64 8
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_6]], align 8
// CHECK:         %[[VAL_7:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_5]], i64 16
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_7]], align 8
// CHECK:         %[[VAL_8:.*]] = call { ptr, i64 } @hybridLaunchKernel(ptr nonnull @test_2.kernelName, ptr nonnull @test_2.thunk, ptr nonnull %[[VAL_4]], i64 24, i64 0, ptr nonnull %[[VAL_5]])
// CHECK:         call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %[[VAL_0]], ptr noundef nonnull align 1 dereferenceable(24) %[[VAL_4]], i64 24, i1 false)
// CHECK:         ret void
// CHECK:       }


// array<T x n> -> sret ptr
func.func @__nvqpp__mlirgen__test_3() -> !cc.array<i64 x 5> {
  %rv = cc.undef !cc.array<i64 x 5>
  %c1 = arith.constant 5 : i64
  %rv1 = cc.insert_value %rv[0], %c1 : (!cc.array<i64 x 5>, i64) -> !cc.array<i64 x 5>
  %c2 = arith.constant 74 : i64
  %rv2 = cc.insert_value %rv1[1], %c2 : (!cc.array<i64 x 5>, i64) -> !cc.array<i64 x 5>
  %c3 = arith.constant 299 : i64
  %rv3 = cc.insert_value %rv2[2], %c3 : (!cc.array<i64 x 5>, i64) -> !cc.array<i64 x 5>
  %c4 = arith.constant 1659 : i64
  %rv4 = cc.insert_value %rv3[3], %c4 : (!cc.array<i64 x 5>, i64) -> !cc.array<i64 x 5>
  %c5 = arith.constant 61234 : i64
  %rv5 = cc.insert_value %rv4[4], %c5 : (!cc.array<i64 x 5>, i64) -> !cc.array<i64 x 5>
  return %rv5 : !cc.array<i64 x 5>
}

func.func @test_3(%1: !cc.ptr<!cc.array<i64 x 5>> {llvm.sret = !cc.array<i64 x 5>}, %this: !cc.ptr<i8>) {
  return
}

// CHECK-LABEL: define [5 x i64] @__nvqpp__mlirgen__test_3() local_unnamed_addr {{.*}} {
// CHECK:         ret [5 x i64] [i64 5, i64 74, i64 299, i64 1659, i64 61234]
// CHECK:       }

// CHECK-LABEL: define void @test_3(ptr writeonly sret([5 x i64]) captures(none) initializes((0, 40))
// CHECK-SAME:                                                                     %[[VAL_0:.*]], ptr readnone captures(none)
// CHECK-SAME:                                                                     %[[VAL_1:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_3:.*]] = alloca [0 x ptr], align 8
// CHECK:         %[[VAL_4:.*]] = alloca [40 x i8], align 1
// CHECK:         %[[VAL_5:.*]] = alloca { ptr, ptr, ptr }, align 8
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_5]], align 8
// CHECK:         %[[VAL_6:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_5]], i64 8
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_6]], align 8
// CHECK:         %[[VAL_7:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_5]], i64 16
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_7]], align 8
// CHECK:         %[[VAL_8:.*]] = call { ptr, i64 } @hybridLaunchKernel(ptr nonnull @test_3.kernelName, ptr nonnull @test_3.thunk, ptr nonnull %[[VAL_4]], i64 40, i64 0, ptr nonnull %[[VAL_5]])
// CHECK:         call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %[[VAL_0]], ptr noundef nonnull align 1 dereferenceable(40) %[[VAL_4]], i64 40, i1 false)
// CHECK:         ret void
// CHECK:       }

// small struct (<= 128) -> { i64, f64 }
func.func @__nvqpp__mlirgen__test_4() -> (i64, f64) {
  %c1 = arith.constant 537892 : i64
  %c2 = arith.constant 94.2134 : f64
  return %c1, %c2 : i64, f64
}

func.func @test_4(%sret: !cc.ptr<!cc.struct<{i64, f64}>> {llvm.sret = !cc.struct<{i64, f64}>}, %this: !cc.ptr<i8>) {
  return
}

// CHECK-LABEL: define { i64, double } @__nvqpp__mlirgen__test_4() local_unnamed_addr {{.*}} {
// CHECK:         ret { i64, double } { i64 537892, double 0x40578DA858793DD9 }
// CHECK:       }

// CHECK-LABEL: define void @test_4(ptr writeonly sret({ i64, double }) captures(none) initializes((0, 16))
// CHECK-SAME:     %[[VAL_0:.*]], ptr readnone captures(none)
// CHECK-SAME:     %[[VAL_1:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_3:.*]] = alloca [0 x ptr], align 8
// CHECK:         %[[VAL_4:.*]] = alloca [16 x i8], align 1
// CHECK:         %[[VAL_5:.*]] = alloca { ptr, ptr, ptr }, align 8
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_5]], align 8
// CHECK:         %[[VAL_6:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_5]], i64 8
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_6]], align 8
// CHECK:         %[[VAL_7:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_5]], i64 16
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_7]], align 8
// CHECK:         %[[VAL_8:.*]] = call { ptr, i64 } @hybridLaunchKernel(ptr nonnull @test_4.kernelName, ptr nonnull @test_4.thunk, ptr nonnull %[[VAL_4]], i64 16, i64 0, ptr nonnull %[[VAL_5]])
// CHECK:         call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %[[VAL_0]], ptr noundef nonnull align 1 dereferenceable(16) %[[VAL_4]], i64 16, i1 false)
// CHECK:         ret void
// CHECK:       }

func.func @__nvqpp__mlirgen__test_5() -> (i64, f64) attributes {no_this} {
  %c1 = arith.constant 537892 : i64
  %c2 = arith.constant 94.2134 : f64
  return %c1, %c2 : i64, f64
}

func.func @test_5(%sret: !cc.ptr<!cc.struct<{i64, f64}>> {llvm.sret = !cc.struct<{i64, f64}>}) {
  return
}

// CHECK-LABEL: define { i64, double } @__nvqpp__mlirgen__test_5() local_unnamed_addr {{.*}} {
// CHECK:         ret { i64, double } { i64 537892, double 0x40578DA858793DD9 }
// CHECK:       }

// CHECK-LABEL: define void @test_5(ptr writeonly sret({ i64, double }) captures(none) initializes((0, 16))
// CHECK-SAME:                                                                                 %[[VAL_0:.*]]) local_unnamed_addr {
// CHECK:         %[[VAL_2:.*]] = alloca [0 x ptr], align 8
// CHECK:         %[[VAL_3:.*]] = alloca [16 x i8], align 1
// CHECK:         %[[VAL_4:.*]] = alloca { ptr, ptr, ptr }, align 8
// CHECK:         store ptr %[[VAL_2]], ptr %[[VAL_4]], align 8
// CHECK:         %[[VAL_5:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_4]], i64 8
// CHECK:         store ptr %[[VAL_2]], ptr %[[VAL_5]], align 8
// CHECK:         %[[VAL_6:.*]] = getelementptr inbounds nuw i8, ptr %[[VAL_4]], i64 16
// CHECK:         store ptr %[[VAL_2]], ptr %[[VAL_6]], align 8
// CHECK:         %[[VAL_7:.*]] = call { ptr, i64 } @hybridLaunchKernel(ptr nonnull @test_5.kernelName, ptr nonnull @test_5.thunk, ptr nonnull %[[VAL_3]], i64 16, i64 0, ptr nonnull %[[VAL_4]])
// CHECK:         call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %[[VAL_0]], ptr noundef nonnull align 1 dereferenceable(16) %[[VAL_3]], i64 16, i1 false)
// CHECK:         ret void
// CHECK:       }

}
//===----------------------------------------------------------------------===//

// CHECK-LABEL: define noundef i64 @test_0.returnOffset() local_unnamed_addr {{.*}} {
// CHECK:         ret i64 8
// CHECK:       }

// CHECK-LABEL: define { ptr, i64 } @test_0.thunk(ptr captures(none) initializes((8, 24))
// CHECK-SAME:       %[[VAL_0:.*]], i1 %[[VAL_1:.*]]) {
// CHECK:         %[[VAL_3:.*]] = load i32, ptr %[[VAL_0]], align 4
// CHECK:         %[[VAL_4:.*]] = tail call { ptr, i64 } @__nvqpp__mlirgen__test_0(i32 %[[VAL_3]])
// CHECK:         %[[VAL_5:.*]] = getelementptr i8, ptr %[[VAL_0]], i64 8
// CHECK:         %.elt = extractvalue { ptr, i64 } %[[VAL_4]], 0
// CHECK:         store ptr %.elt, ptr %[[VAL_5]], align 8
// CHECK:         %.repack1 = getelementptr i8, ptr %[[VAL_0]], i64 16
// CHECK:         %.elt2 = extractvalue { ptr, i64 } %[[VAL_4]], 1
// CHECK:         store i64 %.elt2, ptr %.repack1, align 8
// CHECK:         br i1 %[[VAL_1]], label %[[VAL_6:.*]], label %common.ret
// CHECK:       common.ret:                                       ; preds = %[[VAL_2:.*]], %[[VAL_6]]
// CHECK:         %common.ret.op = phi { ptr, i64 } [ %[[VAL_11:.*]], %[[VAL_6]] ], [ zeroinitializer, %[[VAL_2]] ]
// CHECK:         ret { ptr, i64 } %common.ret.op
// CHECK:       6:                                                ; preds = %[[VAL_2]]
// CHECK:         %[[VAL_7:.*]] = add i64 %.elt2, 24
// CHECK:         %[[VAL_8:.*]] = tail call ptr @malloc(i64 %[[VAL_7]])
// CHECK:         tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(24) %[[VAL_8]], ptr noundef nonnull align 1 dereferenceable(24) %[[VAL_0]], i64 24, i1 false)
// CHECK:         %[[VAL_9:.*]] = getelementptr i8, ptr %[[VAL_8]], i64 24
// CHECK:         tail call void @llvm.memcpy.p0.p0.i64(ptr align 1 %[[VAL_9]], ptr align 1 %.elt, i64 %.elt2, i1 false)
// CHECK:         %[[VAL_10:.*]] = insertvalue { ptr, i64 } undef, ptr %[[VAL_8]], 0
// CHECK:         %[[VAL_11]] = insertvalue { ptr, i64 } %[[VAL_10]], i64 %[[VAL_7]], 1
// CHECK:         %[[VAL_12:.*]] = getelementptr i8, ptr %[[VAL_8]], i64 8
// CHECK:         store ptr %[[VAL_9]], ptr %[[VAL_12]], align 8
// CHECK:         br label %common.ret
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_0.argsCreator(ptr readonly captures(none)
// CHECK-SAME:                                                         %[[VAL_0:.*]], ptr writeonly captures(none) initializes((0, 8))
// CHECK-SAME:                                                         %[[VAL_1:.*]]) {{.*}} {
// CHECK:         %[[VAL_3:.*]] = load ptr, ptr %[[VAL_0]], align 8
// CHECK:         %[[VAL_4:.*]] = load i32, ptr %[[VAL_3]], align 4
// CHECK:         %[[VAL_5:.*]] = tail call dereferenceable_or_null(24) ptr @malloc(i64 24)
// CHECK:         store i32 %[[VAL_4]], ptr %[[VAL_5]], align 4
// CHECK:         store ptr %[[VAL_5]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 24
// CHECK:       }

// CHECK-LABEL: define void @test_0.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_0.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_0.kernelName, ptr nonnull @test_0.argsCreator)
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_1.returnOffset() local_unnamed_addr {{.*}} {
// CHECK:         ret i64 0
// CHECK:       }

// CHECK-LABEL: define { ptr, i64 } @test_1.thunk(ptr writeonly captures(none) initializes((0, 2))
// CHECK-SAME:    %[[VAL_0:.*]], i1 %[[VAL_1:.*]]) {
// CHECK:         %[[VAL_3:.*]] = tail call ptr @__quantum__rt__qubit_allocate_array(i64 2)
// CHECK:         %[[VAL_4:.*]] = tail call ptr @__quantum__rt__array_get_element_ptr_1d(ptr %[[VAL_3]], i64 0)
// CHECK:         %[[VAL_5:.*]] = load ptr, ptr %[[VAL_4]], align 8
// CHECK:         %[[VAL_6:.*]] = tail call ptr @__quantum__rt__array_get_element_ptr_1d(ptr %[[VAL_3]], i64 1)
// CHECK:         %[[VAL_7:.*]] = load ptr, ptr %[[VAL_6]], align 8
// CHECK:         tail call void @__quantum__qis__h(ptr %[[VAL_5]])
// CHECK:         tail call void (i64, i64, i64, i64, ptr, ...) @generalizedInvokeWithRotationsControlsTargets(i64 0, i64 0, i64 1, i64 1, ptr nonnull @__quantum__qis__x__ctl, ptr %[[VAL_5]], ptr %[[VAL_7]])
// CHECK:         %[[VAL_8:.*]] = tail call ptr @__quantum__qis__mz(ptr %[[VAL_5]])
// CHECK:         %[[VAL_9:.*]] = tail call ptr @__quantum__qis__mz(ptr %[[VAL_7]])
// CHECK:         %[[VAL_10:.*]] = load i1, ptr %[[VAL_8]], align 1
// CHECK:         %[[VAL_11:.*]] = load i1, ptr %[[VAL_9]], align 1
// CHECK:         tail call void @__quantum__rt__qubit_release_array(ptr %[[VAL_3]])
// CHECK:         store i1 %[[VAL_10]], ptr %[[VAL_0]], align 1
// CHECK:         %.repack1 = getelementptr inbounds nuw i8, ptr %[[VAL_0]], i64 1
// CHECK:         store i1 %[[VAL_11]], ptr %.repack1, align 1
// CHECK:         ret { ptr, i64 } zeroinitializer
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_1.argsCreator(ptr readnone captures(none)
// CHECK-SAME:                                                         %[[VAL_0:.*]], ptr writeonly captures(none) initializes((0, 8))
// CHECK-SAME:                                                         %[[VAL_1:.*]]) {{.*}} {
// CHECK:         %[[VAL_3:.*]] = tail call dereferenceable_or_null(2) ptr @malloc(i64 2)
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 2
// CHECK:       }

// CHECK-LABEL: define void @test_1.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_1.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_1.kernelName, ptr nonnull @test_1.argsCreator)
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_2.returnOffset() local_unnamed_addr {{.*}} {
// CHECK:         ret i64 0
// CHECK:       }

// CHECK-LABEL: define { ptr, i64 } @test_2.thunk(ptr writeonly captures(none) initializes((0, 24))
// CHECK-SAME:                                                            %[[VAL_0:.*]], i1
// CHECK-SAME:                                                            %[[VAL_1:.*]]) {
// CHECK:         store { i16, float, double, i64 } { i16 8, float 0x40159999A0000000, double 3.783000e+01, i64 1479 }, ptr %[[VAL_0]], align 8
// CHECK:         ret { ptr, i64 } zeroinitializer
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_2.argsCreator(ptr readnone captures(none)
// CHECK-SAME:                                                         %[[VAL_0:.*]], ptr writeonly captures(none) initializes((0, 8))
// CHECK-SAME:                                                         %[[VAL_1:.*]]) {{.*}} {
// CHECK:         %[[VAL_3:.*]] = tail call dereferenceable_or_null(24) ptr @malloc(i64 24)
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 24
// CHECK:       }

// CHECK-LABEL: define void @test_2.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_2.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_2.kernelName, ptr nonnull @test_2.argsCreator)
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_3.returnOffset() local_unnamed_addr {{.*}} {
// CHECK:         ret i64 0
// CHECK:       }

// CHECK-LABEL: define { ptr, i64 } @test_3.thunk(ptr writeonly captures(none) initializes((0, 40))
// CHECK-SAME:                                                            %[[VAL_0:.*]], i1
// CHECK-SAME:                                                            %[[VAL_1:.*]]) {
// CHECK:         store i64 5, ptr %[[VAL_0]], align 4
// CHECK:         %.repack1 = getelementptr inbounds nuw i8, ptr %[[VAL_0]], i64 8
// CHECK:         store i64 74, ptr %.repack1, align 4
// CHECK:         %.repack2 = getelementptr inbounds nuw i8, ptr %[[VAL_0]], i64 16
// CHECK:         store i64 299, ptr %.repack2, align 4
// CHECK:         %.repack3 = getelementptr inbounds nuw i8, ptr %[[VAL_0]], i64 24
// CHECK:         store i64 1659, ptr %.repack3, align 4
// CHECK:         %.repack4 = getelementptr inbounds nuw i8, ptr %[[VAL_0]], i64 32
// CHECK:         store i64 61234, ptr %.repack4, align 4
// CHECK:         ret { ptr, i64 } zeroinitializer
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_3.argsCreator(ptr readnone captures(none)
// CHECK-SAME:                                                         %[[VAL_0:.*]], ptr writeonly captures(none) initializes((0, 8))
// CHECK-SAME:                                                         %[[VAL_1:.*]]) {{.*}} {
// CHECK:         %[[VAL_3:.*]] = tail call dereferenceable_or_null(40) ptr @malloc(i64 40)
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 40
// CHECK:       }

// CHECK-LABEL: define void @test_3.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_3.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_3.kernelName, ptr nonnull @test_3.argsCreator)
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_4.returnOffset() local_unnamed_addr {{.*}} {
// CHECK:         ret i64 0
// CHECK:       }

// CHECK-LABEL: define { ptr, i64 } @test_4.thunk(ptr writeonly captures(none) initializes((0, 16))
// CHECK-SAME:                                                            %[[VAL_0:.*]], i1
// CHECK-SAME:                                                            %[[VAL_1:.*]]) {
// CHECK:         store i64 537892, ptr %[[VAL_0]], align 4
// CHECK:         %[[VAL_3:.*]] = getelementptr i8, ptr %[[VAL_0]], i64 8
// CHECK:         store double 0x40578DA858793DD9, ptr %[[VAL_3]], align 8
// CHECK:         ret { ptr, i64 } zeroinitializer
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_4.argsCreator(ptr readnone captures(none)
// CHECK-SAME:                                                         %[[VAL_0:.*]], ptr writeonly captures(none) initializes((0, 8))
// CHECK-SAME:                                                         %[[VAL_1:.*]]) {{.*}} {
// CHECK:         %[[VAL_3:.*]] = tail call dereferenceable_or_null(16) ptr @malloc(i64 16)
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 16
// CHECK:       }

// CHECK-LABEL: define void @test_4.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_4.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_4.kernelName, ptr nonnull @test_4.argsCreator)
// CHECK:         ret void
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_5.returnOffset() local_unnamed_addr {{.*}} {
// CHECK:         ret i64 0
// CHECK:       }

// CHECK-LABEL: define { ptr, i64 } @test_5.thunk(ptr writeonly captures(none) initializes((0, 16))
// CHECK-SAME:                                                            %[[VAL_0:.*]], i1
// CHECK-SAME:                                                            %[[VAL_1:.*]]) {
// CHECK:         store i64 537892, ptr %[[VAL_0]], align 4
// CHECK:         %[[VAL_3:.*]] = getelementptr i8, ptr %[[VAL_0]], i64 8
// CHECK:         store double 0x40578DA858793DD9, ptr %[[VAL_3]], align 8
// CHECK:         ret { ptr, i64 } zeroinitializer
// CHECK:       }

// CHECK-LABEL: define noundef i64 @test_5.argsCreator(ptr readnone captures(none)
// CHECK-SAME:                                                         %[[VAL_0:.*]], ptr writeonly captures(none) initializes((0, 8))
// CHECK-SAME:                                                         %[[VAL_1:.*]]) {{.*}} {
// CHECK:         %[[VAL_3:.*]] = tail call dereferenceable_or_null(16) ptr @malloc(i64 16)
// CHECK:         store ptr %[[VAL_3]], ptr %[[VAL_1]], align 8
// CHECK:         ret i64 16
// CHECK:       }

// CHECK-LABEL: define void @test_5.kernelRegFunc() {
// CHECK:         tail call void @cudaqRegisterKernelName(ptr nonnull @test_5.kernelName)
// CHECK:         tail call void @cudaqRegisterArgsCreator(ptr nonnull @test_5.kernelName, ptr nonnull @test_5.argsCreator)
// CHECK:         ret void
// CHECK:       }
