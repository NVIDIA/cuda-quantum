// ========================================================================== //
// Copyright (c) 2025 NVIDIA Corporation & Affiliates.                        //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt --qir-insert-array-record %s | FileCheck %s

func.func @__nvqpp__mlirgen__function_bell._Z4bellv() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
  %0 = quake.alloca !quake.veq<2> {StartingOffset = 0 : i64}
  %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
  quake.h %1 : (!quake.ref) -> ()
  %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  %3 = cc.alloca !cc.array<i8 x 2>
  %4 = cc.cast %3 : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
  %5 = cc.compute_ptr %3[1] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
  %measOut = quake.mz %1 name "r00000" : (!quake.ref) -> !quake.measure {ResultIndex = 0 : i64}
  %6 = quake.discriminate %measOut : (!quake.measure) -> i1
  %7 = cc.cast unsigned %6 : (i1) -> i8
  cc.store %7, %4 : !cc.ptr<i8>
  %measOut_0 = quake.mz %2 name "r00001" : (!quake.ref) -> !quake.measure {ResultIndex = 1 : i64}
  %8 = quake.discriminate %measOut_0 : (!quake.measure) -> i1
  %9 = cc.cast unsigned %8 : (i1) -> i8
  cc.store %9, %5 : !cc.ptr<i8>
  quake.dealloc %0 : !quake.veq<2>
  return
}

func.func @__nvqpp__mlirgen__one_qubit() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
  %0 = quake.alloca !quake.veq<1> {StartingOffset = 0 : i64}
  %1 = quake.extract_ref %0[0] : (!quake.veq<1>) -> !quake.ref
  quake.h %1 : (!quake.ref) -> ()
  %measOut = quake.mz %1 name "r00000" : (!quake.ref) -> !quake.measure {ResultIndex = 0 : i64}
  quake.dealloc %0 : !quake.veq<1>
  return
}

func.func @__nvqpp__mlirgen__three_qubits() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
  %0 = quake.alloca !quake.veq<3> {StartingOffset = 0 : i64}
  %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
  %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
  %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
  quake.h %1 : (!quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
  %measOut = quake.mz %1 name "r00000" : (!quake.ref) -> !quake.measure {ResultIndex = 0 : i64}
  %measOut_0 = quake.mz %2 name "r00001" : (!quake.ref) -> !quake.measure {ResultIndex = 1 : i64}
  %measOut_1 = quake.mz %3 name "r00002" : (!quake.ref) -> !quake.measure {ResultIndex = 2 : i64}
  quake.dealloc %0 : !quake.veq<3>
  return
}

func.func @__nvqpp__mlirgen__one_vector() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
  %0 = quake.alloca !quake.veq<2>
  %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
  quake.h %1 : (!quake.ref) -> ()
  %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
  quake.h %2 : (!quake.ref) -> ()
  quake.h %2 : (!quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.h %2 : (!quake.ref) -> ()
  %3 = cc.alloca !cc.array<i8 x 2>
  %measOut = quake.mz %1 name "r00000" : (!quake.ref) -> !quake.measure
  %4 = quake.discriminate %measOut : (!quake.measure) -> i1
  %5 = cc.cast %3 : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
  %6 = cc.cast unsigned %4 : (i1) -> i8
  cc.store %6, %5 : !cc.ptr<i8>
  %measOut_0 = quake.mz %2 name "r00001" : (!quake.ref) -> !quake.measure
  %7 = quake.discriminate %measOut_0 : (!quake.measure) -> i1
  %8 = cc.compute_ptr %3[1] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
  %9 = cc.cast unsigned %7 : (i1) -> i8
  cc.store %9, %8 : !cc.ptr<i8>
  quake.dealloc %0 : !quake.veq<2>
  return
}

func.func @__nvqpp__mlirgen__multi_vector() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
  %0 = quake.alloca !quake.veq<4>
  %1 = quake.extract_ref %0[0] : (!quake.veq<4>) -> !quake.ref
  quake.h %1 : (!quake.ref) -> ()
  %2 = quake.extract_ref %0[1] : (!quake.veq<4>) -> !quake.ref
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  %3 = quake.extract_ref %0[3] : (!quake.veq<4>) -> !quake.ref
  quake.h %3 : (!quake.ref) -> ()
  %4 = quake.extract_ref %0[2] : (!quake.veq<4>) -> !quake.ref
  quake.h %4 : (!quake.ref) -> ()
  quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
  quake.h %4 : (!quake.ref) -> ()
  %5 = cc.alloca !cc.array<i8 x 2>
  %measOut = quake.mz %1 name "r00000" : (!quake.ref) -> !quake.measure
  %6 = quake.discriminate %measOut : (!quake.measure) -> i1
  %7 = cc.cast %5 : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
  %8 = cc.cast unsigned %6 : (i1) -> i8
  cc.store %8, %7 : !cc.ptr<i8>
  %measOut_0 = quake.mz %2 name "r00001" : (!quake.ref) -> !quake.measure
  %9 = quake.discriminate %measOut_0 : (!quake.measure) -> i1
  %10 = cc.compute_ptr %5[1] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
  %11 = cc.cast unsigned %9 : (i1) -> i8
  cc.store %11, %10 : !cc.ptr<i8>
  %12 = cc.alloca !cc.array<i8 x 2>
  %measOut_1 = quake.mz %4 name "r00002" : (!quake.ref) -> !quake.measure
  %13 = quake.discriminate %measOut_1 : (!quake.measure) -> i1
  %14 = cc.cast %12 : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
  %15 = cc.cast unsigned %13 : (i1) -> i8
  cc.store %15, %14 : !cc.ptr<i8>
  %measOut_2 = quake.mz %3 name "r00003" : (!quake.ref) -> !quake.measure
  %16 = quake.discriminate %measOut_2 : (!quake.measure) -> i1
  %17 = cc.compute_ptr %12[1] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
  %18 = cc.cast unsigned %16 : (i1) -> i8
  cc.store %18, %17 : !cc.ptr<i8>
  quake.dealloc %0 : !quake.veq<4>
  return
}

// CHECK-LABEL:   func.func @__nvqpp__mlirgen__function_bell._Z4bellv() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
// CHECK:           %[[VAL_0:.*]] = quake.alloca !quake.veq<2> {StartingOffset = 0 : i64}
// CHECK:           %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][0] : (!quake.veq<2>) -> !quake.ref
// CHECK:           quake.h %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:           %[[VAL_2:.*]] = quake.extract_ref %[[VAL_0]][1] : (!quake.veq<2>) -> !quake.ref
// CHECK:           quake.x {{\[}}%[[VAL_1]]] %[[VAL_2]] : (!quake.ref, !quake.ref) -> ()
// CHECK:           %[[VAL_3:.*]] = cc.alloca !cc.array<i8 x 2>
// CHECK:           %[[VAL_4:.*]] = cc.string_literal "array<i8 x 2>" : !cc.ptr<!cc.array<i8 x 14>>
// CHECK:           %[[VAL_5:.*]] = cc.cast %[[VAL_4]] : (!cc.ptr<!cc.array<i8 x 14>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_6:.*]] = arith.constant 2 : i64
// CHECK:           call @__quantum__rt__array_record_output(%[[VAL_6]], %[[VAL_5]]) : (i64, !cc.ptr<i8>) -> ()
// CHECK:           %[[VAL_7:.*]] = cc.cast %[[VAL_3]] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_8:.*]] = cc.compute_ptr %[[VAL_3]][1] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_9:.*]] = quake.mz %[[VAL_1]] name "r00000" : (!quake.ref) -> !quake.measure {ResultIndex = 0 : i64}
// CHECK:           %[[VAL_10:.*]] = quake.discriminate %[[VAL_9]] : (!quake.measure) -> i1
// CHECK:           %[[VAL_11:.*]] = cc.cast unsigned %[[VAL_10]] : (i1) -> i8
// CHECK:           cc.store %[[VAL_11]], %[[VAL_7]] : !cc.ptr<i8>
// CHECK:           %[[VAL_12:.*]] = quake.mz %[[VAL_2]] name "r00001" : (!quake.ref) -> !quake.measure {ResultIndex = 1 : i64}
// CHECK:           %[[VAL_13:.*]] = quake.discriminate %[[VAL_12]] : (!quake.measure) -> i1
// CHECK:           %[[VAL_14:.*]] = cc.cast unsigned %[[VAL_13]] : (i1) -> i8
// CHECK:           cc.store %[[VAL_14]], %[[VAL_8]] : !cc.ptr<i8>
// CHECK:           quake.dealloc %[[VAL_0]] : !quake.veq<2>
// CHECK:           return
// CHECK:         }

// CHECK-LABEL:   func.func @__nvqpp__mlirgen__one_qubit() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
// CHECK:           %[[VAL_0:.*]] = quake.alloca !quake.veq<1> {StartingOffset = 0 : i64}
// CHECK:           %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][0] : (!quake.veq<1>) -> !quake.ref
// CHECK:           quake.h %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:           %[[VAL_2:.*]] = cc.string_literal "array<i8 x 1>" : !cc.ptr<!cc.array<i8 x 14>>
// CHECK:           %[[VAL_3:.*]] = cc.cast %[[VAL_2]] : (!cc.ptr<!cc.array<i8 x 14>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_4:.*]] = arith.constant 1 : i64
// CHECK:           call @__quantum__rt__array_record_output(%[[VAL_4]], %[[VAL_3]]) : (i64, !cc.ptr<i8>) -> ()
// CHECK:           %[[VAL_5:.*]] = quake.mz %[[VAL_1]] name "r00000" : (!quake.ref) -> !quake.measure {ResultIndex = 0 : i64}
// CHECK:           quake.dealloc %[[VAL_0]] : !quake.veq<1>
// CHECK:           return
// CHECK:         }

// CHECK-LABEL:   func.func @__nvqpp__mlirgen__three_qubits() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
// CHECK:           %[[VAL_0:.*]] = quake.alloca !quake.veq<3> {StartingOffset = 0 : i64}
// CHECK:           %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][0] : (!quake.veq<3>) -> !quake.ref
// CHECK:           %[[VAL_2:.*]] = quake.extract_ref %[[VAL_0]][1] : (!quake.veq<3>) -> !quake.ref
// CHECK:           %[[VAL_3:.*]] = quake.extract_ref %[[VAL_0]][2] : (!quake.veq<3>) -> !quake.ref
// CHECK:           quake.h %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:           quake.x {{\[}}%[[VAL_1]]] %[[VAL_2]] : (!quake.ref, !quake.ref) -> ()
// CHECK:           quake.x {{\[}}%[[VAL_2]]] %[[VAL_3]] : (!quake.ref, !quake.ref) -> ()
// CHECK:           %[[VAL_4:.*]] = cc.string_literal "array<i8 x 3>" : !cc.ptr<!cc.array<i8 x 14>>
// CHECK:           %[[VAL_5:.*]] = cc.cast %[[VAL_4]] : (!cc.ptr<!cc.array<i8 x 14>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_6:.*]] = arith.constant 3 : i64
// CHECK:           call @__quantum__rt__array_record_output(%[[VAL_6]], %[[VAL_5]]) : (i64, !cc.ptr<i8>) -> ()
// CHECK:           %[[VAL_7:.*]] = quake.mz %[[VAL_1]] name "r00000" : (!quake.ref) -> !quake.measure {ResultIndex = 0 : i64}
// CHECK:           %[[VAL_8:.*]] = quake.mz %[[VAL_2]] name "r00001" : (!quake.ref) -> !quake.measure {ResultIndex = 1 : i64}
// CHECK:           %[[VAL_9:.*]] = quake.mz %[[VAL_3]] name "r00002" : (!quake.ref) -> !quake.measure {ResultIndex = 2 : i64}
// CHECK:           quake.dealloc %[[VAL_0]] : !quake.veq<3>
// CHECK:           return
// CHECK:         }

// CHECK-LABEL:   func.func @__nvqpp__mlirgen__one_vector() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
// CHECK:           %[[VAL_0:.*]] = quake.alloca !quake.veq<2>
// CHECK:           %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][0] : (!quake.veq<2>) -> !quake.ref
// CHECK:           quake.h %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:           %[[VAL_2:.*]] = quake.extract_ref %[[VAL_0]][1] : (!quake.veq<2>) -> !quake.ref
// CHECK:           quake.h %[[VAL_2]] : (!quake.ref) -> ()
// CHECK:           quake.h %[[VAL_2]] : (!quake.ref) -> ()
// CHECK:           quake.x {{\[}}%[[VAL_1]]] %[[VAL_2]] : (!quake.ref, !quake.ref) -> ()
// CHECK:           quake.h %[[VAL_2]] : (!quake.ref) -> ()
// CHECK:           %[[VAL_3:.*]] = cc.alloca !cc.array<i8 x 2>
// CHECK:           %[[VAL_4:.*]] = cc.string_literal "array<i8 x 2>" : !cc.ptr<!cc.array<i8 x 14>>
// CHECK:           %[[VAL_5:.*]] = cc.cast %[[VAL_4]] : (!cc.ptr<!cc.array<i8 x 14>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_6:.*]] = arith.constant 2 : i64
// CHECK:           call @__quantum__rt__array_record_output(%[[VAL_6]], %[[VAL_5]]) : (i64, !cc.ptr<i8>) -> ()
// CHECK:           %[[VAL_7:.*]] = quake.mz %[[VAL_1]] name "r00000" : (!quake.ref) -> !quake.measure
// CHECK:           %[[VAL_8:.*]] = quake.discriminate %[[VAL_7]] : (!quake.measure) -> i1
// CHECK:           %[[VAL_9:.*]] = cc.cast %[[VAL_3]] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_10:.*]] = cc.cast unsigned %[[VAL_8]] : (i1) -> i8
// CHECK:           cc.store %[[VAL_10]], %[[VAL_9]] : !cc.ptr<i8>
// CHECK:           %[[VAL_11:.*]] = quake.mz %[[VAL_2]] name "r00001" : (!quake.ref) -> !quake.measure
// CHECK:           %[[VAL_12:.*]] = quake.discriminate %[[VAL_11]] : (!quake.measure) -> i1
// CHECK:           %[[VAL_13:.*]] = cc.compute_ptr %[[VAL_3]][1] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_14:.*]] = cc.cast unsigned %[[VAL_12]] : (i1) -> i8
// CHECK:           cc.store %[[VAL_14]], %[[VAL_13]] : !cc.ptr<i8>
// CHECK:           quake.dealloc %[[VAL_0]] : !quake.veq<2>
// CHECK:           return
// CHECK:         }

// CHECK-LABEL:   func.func @__nvqpp__mlirgen__multi_vector() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
// CHECK:           %[[VAL_0:.*]] = quake.alloca !quake.veq<4>
// CHECK:           %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][0] : (!quake.veq<4>) -> !quake.ref
// CHECK:           quake.h %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:           %[[VAL_2:.*]] = quake.extract_ref %[[VAL_0]][1] : (!quake.veq<4>) -> !quake.ref
// CHECK:           quake.x {{\[}}%[[VAL_1]]] %[[VAL_2]] : (!quake.ref, !quake.ref) -> ()
// CHECK:           %[[VAL_3:.*]] = quake.extract_ref %[[VAL_0]][3] : (!quake.veq<4>) -> !quake.ref
// CHECK:           quake.h %[[VAL_3]] : (!quake.ref) -> ()
// CHECK:           %[[VAL_4:.*]] = quake.extract_ref %[[VAL_0]][2] : (!quake.veq<4>) -> !quake.ref
// CHECK:           quake.h %[[VAL_4]] : (!quake.ref) -> ()
// CHECK:           quake.x {{\[}}%[[VAL_3]]] %[[VAL_4]] : (!quake.ref, !quake.ref) -> ()
// CHECK:           quake.h %[[VAL_4]] : (!quake.ref) -> ()
// CHECK:           %[[VAL_5:.*]] = cc.alloca !cc.array<i8 x 2>
// CHECK:           %[[VAL_6:.*]] = cc.string_literal "array<i8 x 4>" : !cc.ptr<!cc.array<i8 x 14>>
// CHECK:           %[[VAL_7:.*]] = cc.cast %[[VAL_6]] : (!cc.ptr<!cc.array<i8 x 14>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_8:.*]] = arith.constant 4 : i64
// CHECK:           call @__quantum__rt__array_record_output(%[[VAL_8]], %[[VAL_7]]) : (i64, !cc.ptr<i8>) -> ()
// CHECK:           %[[VAL_9:.*]] = quake.mz %[[VAL_1]] name "r00000" : (!quake.ref) -> !quake.measure
// CHECK:           %[[VAL_10:.*]] = quake.discriminate %[[VAL_9]] : (!quake.measure) -> i1
// CHECK:           %[[VAL_11:.*]] = cc.cast %[[VAL_5]] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_12:.*]] = cc.cast unsigned %[[VAL_10]] : (i1) -> i8
// CHECK:           cc.store %[[VAL_12]], %[[VAL_11]] : !cc.ptr<i8>
// CHECK:           %[[VAL_13:.*]] = quake.mz %[[VAL_2]] name "r00001" : (!quake.ref) -> !quake.measure
// CHECK:           %[[VAL_14:.*]] = quake.discriminate %[[VAL_13]] : (!quake.measure) -> i1
// CHECK:           %[[VAL_15:.*]] = cc.compute_ptr %[[VAL_5]][1] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_16:.*]] = cc.cast unsigned %[[VAL_14]] : (i1) -> i8
// CHECK:           cc.store %[[VAL_16]], %[[VAL_15]] : !cc.ptr<i8>
// CHECK:           %[[VAL_17:.*]] = cc.alloca !cc.array<i8 x 2>
// CHECK:           %[[VAL_18:.*]] = quake.mz %[[VAL_4]] name "r00002" : (!quake.ref) -> !quake.measure
// CHECK:           %[[VAL_19:.*]] = quake.discriminate %[[VAL_18]] : (!quake.measure) -> i1
// CHECK:           %[[VAL_20:.*]] = cc.cast %[[VAL_17]] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_21:.*]] = cc.cast unsigned %[[VAL_19]] : (i1) -> i8
// CHECK:           cc.store %[[VAL_21]], %[[VAL_20]] : !cc.ptr<i8>
// CHECK:           %[[VAL_22:.*]] = quake.mz %[[VAL_3]] name "r00003" : (!quake.ref) -> !quake.measure
// CHECK:           %[[VAL_23:.*]] = quake.discriminate %[[VAL_22]] : (!quake.measure) -> i1
// CHECK:           %[[VAL_24:.*]] = cc.compute_ptr %[[VAL_17]][1] : (!cc.ptr<!cc.array<i8 x 2>>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_25:.*]] = cc.cast unsigned %[[VAL_23]] : (i1) -> i8
// CHECK:           cc.store %[[VAL_25]], %[[VAL_24]] : !cc.ptr<i8>
// CHECK:           quake.dealloc %[[VAL_0]] : !quake.veq<4>
// CHECK:           return
// CHECK:         }
// CHECK:         func.func private @__quantum__rt__bool_record_output(i1 {llvm.zeroext}, !cc.ptr<i8>)
// CHECK:         func.func private @__quantum__rt__double_record_output(f64, !cc.ptr<i8>)
// CHECK:         func.func private @__quantum__rt__int_record_output(i64, !cc.ptr<i8>)
// CHECK:         func.func private @__quantum__rt__tuple_record_output(i64, !cc.ptr<i8>)
// CHECK:         func.func private @__quantum__rt__array_record_output(i64, !cc.ptr<i8>)
