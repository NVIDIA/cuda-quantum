// ========================================================================== //
// Copyright (c) 2022 - 2026 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-translate --convert-to=openqasm2 %s | FileCheck %s

module {
  func.func @maj(%a: !quake.ref, %b: !quake.ref, %c: !quake.ref) {
    quake.x [%c] %a : (!quake.ref, !quake.ref) -> ()
    quake.x [%c] %b : (!quake.ref, !quake.ref) -> ()
    quake.x [%a, %b] %c : (!quake.ref, !quake.ref, !quake.ref) -> ()
    return
  }

  func.func @umaj(%a: !quake.ref, %b: !quake.ref, %c: !quake.ref) {
    quake.x [%a, %b] %c : (!quake.ref, !quake.ref, !quake.ref) -> ()
    quake.x [%c] %b : (!quake.ref, !quake.ref) -> ()
    quake.x [%c] %a : (!quake.ref, !quake.ref) -> ()
    return
  }

  func.func @ripple_carry_adder() attributes {"cudaq-entrypoint"} {
    %cin = quake.alloca !quake.ref
    %a = quake.alloca !quake.veq<4>
    %b = quake.alloca !quake.veq<4>
    %cout = quake.alloca !quake.ref

    // Extract wires:
    %cst0 = arith.constant 0 : index
    %cst1 = arith.constant 1 : index
    %cst2 = arith.constant 2 : index
    %cst3 = arith.constant 3 : index

    // Extract qubits
    %a0 = quake.extract_ref %a[%cst0] : (!quake.veq<4>, index) -> !quake.ref
    %a1 = quake.extract_ref %a[%cst1] : (!quake.veq<4>, index) -> !quake.ref
    %a2 = quake.extract_ref %a[%cst2] : (!quake.veq<4>, index) -> !quake.ref
    %a3 = quake.extract_ref %a[%cst3] : (!quake.veq<4>, index) -> !quake.ref

    %b0 = quake.extract_ref %b[%cst0] : (!quake.veq<4>, index) -> !quake.ref
    %b1 = quake.extract_ref %b[%cst1] : (!quake.veq<4>, index) -> !quake.ref
    %b2 = quake.extract_ref %b[%cst2] : (!quake.veq<4>, index) -> !quake.ref
    %b3 = quake.extract_ref %b[%cst3] : (!quake.veq<4>, index) -> !quake.ref

    // Input states
    // a = 0001
    quake.x %a0 : (!quake.ref) -> ()

    // b = 1111
    quake.x %b0 : (!quake.ref) -> ()
    quake.x %b1 : (!quake.ref) -> ()
    quake.x %b2 : (!quake.ref) -> ()
    quake.x %b3 : (!quake.ref) -> ()

    // add a to b, storing result in b majority cin[0],b[0],a[0];
    quake.apply @maj %cin, %b0, %a0 : (!quake.ref, !quake.ref, !quake.ref) -> ()

    quake.apply @maj %a0, %b1, %a1 : (!quake.ref, !quake.ref, !quake.ref) -> ()
    quake.apply @maj %a1, %b2, %a2 : (!quake.ref, !quake.ref, !quake.ref) -> ()
    quake.apply @maj %a2, %b3, %a3 : (!quake.ref, !quake.ref, !quake.ref) -> ()

    quake.x [%a3] %cout : (!quake.ref, !quake.ref) -> ()

    quake.apply @umaj %a2, %b3, %a3 : (!quake.ref, !quake.ref, !quake.ref) -> ()
    quake.apply @umaj %a1, %b2, %a2 : (!quake.ref, !quake.ref, !quake.ref) -> ()
    quake.apply @umaj %a0, %b1, %a1 : (!quake.ref, !quake.ref, !quake.ref) -> ()

    quake.apply @umaj %cout, %b0, %a0 : (!quake.ref, !quake.ref, !quake.ref) -> ()

    %ans = quake.mz %b : (!quake.veq<4>) -> !cc.stdvec<!quake.measure>
    %ans_cout = quake.mz %cout : (!quake.ref) -> !quake.measure
    return
  }
}


// CHECK: OPENQASM 2.0;

// CHECK: include "qelib1.inc";


// CHECK: gate maj q0, q1, q2 {
// CHECK:   cx  q2, q0;
// CHECK:   cx  q2, q1;
// CHECK:   ccx  q0, q1, q2;
// CHECK: }

// CHECK: gate umaj q0, q1, q2 {
// CHECK:   ccx  q0, q1, q2;
// CHECK:   cx  q2, q1;
// CHECK:   cx  q2, q0;
// CHECK: }

// CHECK: qreg var0[10];
// CHECK: x var0[1];
// CHECK: x var0[5];
// CHECK: x var0[6];
// CHECK: x var0[7];
// CHECK: x var0[8];
// CHECK: @maj var0[0], var0[5], var0[1];
// CHECK: @maj var0[1], var0[6], var0[2];
// CHECK: @maj var0[2], var0[7], var0[3];
// CHECK: @maj var0[3], var0[8], var0[4];
// CHECK: cx var0[4], var0[9];
// CHECK: @umaj var0[3], var0[8], var0[4];
// CHECK: @umaj var0[2], var0[7], var0[3];
// CHECK: @umaj var0[1], var0[6], var0[2];
// CHECK: @umaj var0[9], var0[5], var0[1];
// CHECK: creg var11[1];
// CHECK: measure var0[5] -> var11[0];
// CHECK: creg var12[1];
// CHECK: measure var0[6] -> var12[0];
// CHECK: creg var13[1];
// CHECK: measure var0[7] -> var13[0];
// CHECK: creg var14[1];
// CHECK: measure var0[8] -> var14[0];
// CHECK: creg var15[1];
// CHECK: measure var0[9] -> var15[0];
