// ========================================================================== //
// Copyright (c) 2025 NVIDIA Corporation & Affiliates.                        //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt --phase-polynomial-preprocess -split-input-file %s | FileCheck %s

module {
  func.func @kernel1() {
    %cst = arith.constant 1.000000e+00 : f64
    %0 = quake.alloca !quake.veq<2>
    %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.h %1 : (!quake.ref) -> ()
    quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: !quake.ref, %arg1: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: f64) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.rz (%arg2) %arg1 : (f64, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel1() {
// CHECK:   %cst = arith.constant 1.000000e+00 : f64
// CHECK:   %0 = quake.alloca !quake.veq<2>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
// CHECK:   call @subcircuit0(%1, %2, %cst) : (!quake.ref, !quake.ref, f64) -> ()
// CHECK:   quake.h %1 : (!quake.ref) -> ()
// CHECK:   call @subcircuit1(%1, %2) : (!quake.ref, !quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel2() {
    %cst = arith.constant 1.000000e+00 : f64
    %0 = quake.alloca !quake.veq<3>
    %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
    %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
    quake.h %1 : (!quake.ref) -> ()
    quake.h %2 : (!quake.ref) -> ()
    quake.h %3 : (!quake.ref) -> ()
    quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
    quake.rz (%cst) %3 : (f64, !quake.ref) -> ()
    quake.x [%2] %1 : (!quake.ref, !quake.ref) -> ()
    quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.h %3 : (!quake.ref) -> ()
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
    quake.h %1 : (!quake.ref) -> ()
    quake.h %2 : (!quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: !quake.ref, %arg3: f64) attributes {subcircuit} {
// CHECK:   quake.x [%arg1] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.rz (%arg3) %arg1 : (f64, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: !quake.ref, %arg3: f64, %arg4: f64, %arg5: f64) attributes {subcircuit} {
// CHECK:   quake.rz (%arg3) %arg1 : (f64, !quake.ref) -> ()
// CHECK:   quake.rz (%arg4) %arg2 : (f64, !quake.ref) -> ()
// CHECK:   quake.x [%arg1] %arg0 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.rz (%arg5) %arg0 : (f64, !quake.ref) -> ()
// CHECK:   quake.x [%arg1] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel2() {
// CHECK:   %cst = arith.constant 1.000000e+00 : f64
// CHECK:   %0 = quake.alloca !quake.veq<3>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
// CHECK:   %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
// CHECK:   quake.h %1 : (!quake.ref) -> ()
// CHECK:   quake.h %2 : (!quake.ref) -> ()
// CHECK:   quake.h %3 : (!quake.ref) -> ()
// CHECK:   call @subcircuit0(%1, %2, %3, %cst, %cst, %cst) : (!quake.ref, !quake.ref, !quake.ref, f64, f64, f64) -> ()
// CHECK:   quake.h %3 : (!quake.ref) -> ()
// CHECK:   call @subcircuit1(%1, %2, %3, %cst) : (!quake.ref, !quake.ref, !quake.ref, f64) -> ()
// CHECK:   quake.h %1 : (!quake.ref) -> ()
// CHECK:   quake.h %2 : (!quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel3() {
    %cst = arith.constant 1.000000e+00 : f64
    %true = arith.constant true
    %0 = quake.alloca !quake.veq<2>
    %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.h %1 : (!quake.ref) -> ()
    cc.if(%true) {
      quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
      quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    }
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: f64) attributes {subcircuit} {
// CHECK:   quake.rz (%arg2) %arg1 : (f64, !quake.ref) -> ()
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel3() {
// CHECK:   %cst = arith.constant 1.000000e+00 : f64
// CHECK:   %true = arith.constant true
// CHECK:   %0 = quake.alloca !quake.veq<2>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
// CHECK:   call @subcircuit0(%1, %2) : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.h %1 : (!quake.ref) -> ()
// CHECK:   cc.if(%true) {
// CHECK:     func.call @subcircuit1(%1, %2, %cst) : (!quake.ref, !quake.ref, f64) -> ()
// CHECK:   }
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel4() {
    %cst = arith.constant 1.000000e+00 : f64
    %0 = quake.alloca !quake.veq<3>
    %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
    %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
    quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
    quake.x [%2, %3] %1 : (!quake.ref, !quake.ref, !quake.ref) -> ()
    quake.x [%2, %3] %1 : (!quake.ref, !quake.ref, !quake.ref) -> ()
    quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel4() {
// CHECK:   %cst = arith.constant 1.000000e+00 : f64
// CHECK:   %0 = quake.alloca !quake.veq<3>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
// CHECK:   %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
// CHECK:   quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
// CHECK:   quake.x [%2, %3] %1 : (!quake.ref, !quake.ref, !quake.ref) -> ()
// CHECK:   quake.x [%2, %3] %1 : (!quake.ref, !quake.ref, !quake.ref) -> ()
// CHECK-DAG:   quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
// CHECK-DAG:   call @subcircuit0(%2, %3) : (!quake.ref, !quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel5() {
    %cst = arith.constant 1.000000e+00 : f64
    %0 = quake.alloca !quake.veq<2>
    %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.ry (%cst) %1 : (f64, !quake.ref) -> ()
    quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: !quake.ref, %arg1: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: f64) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.rz (%arg2) %arg1 : (f64, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel5() {
// CHECK:   %cst = arith.constant 1.000000e+00 : f64
// CHECK:   %0 = quake.alloca !quake.veq<2>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
// CHECK:   call @subcircuit0(%1, %2, %cst) : (!quake.ref, !quake.ref, f64) -> ()
// CHECK:   quake.ry (%cst) %1 : (f64, !quake.ref) -> ()
// CHECK:   call @subcircuit1(%1, %2) : (!quake.ref, !quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel6() {
    %0 = quake.alloca !quake.veq<3>
    %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
    %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.h %2 : (!quake.ref) -> ()
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    quake.x [%1] %3 : (!quake.ref, !quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg1] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.x [%arg0] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel6() {
// CHECK:   %0 = quake.alloca !quake.veq<3>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
// CHECK-DAG: %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
// CHECK-DAG: call @subcircuit0(%1, %2) : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.h %2 : (!quake.ref) -> ()
// CHECK:   call @subcircuit1(%1, %2, %3) : (!quake.ref, !quake.ref, !quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----

// Unfortunately, in the reference semantics, we cannot handle
// the case where a final termination point is before an initial
// termination point in the AST, because there is no valid placement
// of the new function and call without rewriting the AST from the
// netlist

module {
  func.func @kernel7() {
    %0 = quake.alloca !quake.veq<3>
    %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
    %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.h %1 : (!quake.ref) -> ()
    quake.h %3 : (!quake.ref) -> ()
    quake.x [%3] %2 : (!quake.ref, !quake.ref) -> ()
    quake.x [%3] %1 : (!quake.ref, !quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: !quake.ref, %arg1: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg1] %arg0 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel7() {
// CHECK:   %0 = quake.alloca !quake.veq<3>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
// CHECK:   %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
// CHECK:   quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.h %1 : (!quake.ref) -> ()
// CHECK:   quake.h %3 : (!quake.ref) -> ()
// CHECK:   quake.x [%3] %2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   call @subcircuit1(%1, %3) : (!quake.ref, !quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----

// Tests a similar case to above, but with operations in separate blocks

module {
  func.func @kernel8() {
    %cst = arith.constant 1.000000e+00 : f64
    %true = arith.constant true
    %0 = quake.alloca !quake.veq<3>
    %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
    %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    cc.if(%true) {
      quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
    }
    cc.if(%true) {
      quake.rz (%cst) %3 : (f64, !quake.ref) -> ()
    }
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func @kernel8() {
// CHECK:   %cst = arith.constant 1.000000e+00 : f64
// CHECK:   %true = arith.constant true
// CHECK:   %0 = quake.alloca !quake.veq<3>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
// CHECK:   %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
// CHECK:   quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.if(%true) {
// CHECK:     quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
// CHECK:   }
// CHECK:   cc.if(%true) {
// CHECK:     quake.rz (%cst) %3 : (f64, !quake.ref) -> ()
// CHECK:   }
// CHECK:   quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
// CHECK:   return
// CHECK: }
