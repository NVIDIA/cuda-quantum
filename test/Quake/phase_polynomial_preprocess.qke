module {
  func.func @kernel1() {
    %cst = arith.constant 1.000000e+00 : f64
    %0 = quake.alloca !quake.veq<2>
    %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.h %1 : (!quake.ref) -> ()
    quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: !quake.ref, %arg1: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func private @subcircuit0(%arg0: f64, %arg1: !quake.ref, %arg2: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg1] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.rz (%arg0) %arg2 : (f64, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel1() {
// CHECK:   %cst = arith.constant 1.000000e+00 : f64
// CHECK:   %0 = quake.alloca !quake.veq<2>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref {nlindex = 0 : i64}
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref {nlindex = 1 : i64}
// CHECK:   call @subcircuit0(%cst, %1, %2) : (f64, !quake.ref, !quake.ref) -> ()
// CHECK:   quake.h %1 : (!quake.ref) -> ()
// CHECK:   call @subcircuit1(%1, %2) : (!quake.ref, !quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel2() {
    %cst = arith.constant 1.000000e+00 : f64
    %0 = quake.alloca !quake.veq<3>
    %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
    %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
    quake.h %1 : (!quake.ref) -> ()
    quake.h %2 : (!quake.ref) -> ()
    quake.h %3 : (!quake.ref) -> ()
    quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
    quake.rz (%cst) %3 : (f64, !quake.ref) -> ()
    quake.x [%2] %1 : (!quake.ref, !quake.ref) -> ()
    quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.h %3 : (!quake.ref) -> ()
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
    quake.h %1 : (!quake.ref) -> ()
    quake.h %2 : (!quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: f64, %arg1: !quake.ref, %arg2: !quake.ref, %arg3: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg2] %arg3 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.x [%arg1] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.rz (%arg0) %arg2 : (f64, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func private @subcircuit0(%arg0: f64, %arg1: f64, %arg2: f64, %arg3: !quake.ref, %arg4: !quake.ref, %arg5: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.rz (%arg0) %arg4 : (f64, !quake.ref) -> ()
// CHECK:   quake.rz (%arg1) %arg5 : (f64, !quake.ref) -> ()
// CHECK:   quake.x [%arg4] %arg3 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.rz (%arg2) %arg3 : (f64, !quake.ref) -> ()
// CHECK:   quake.x [%arg4] %arg5 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.x [%arg3] %arg4 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel2() {
// CHECK:   %cst = arith.constant 1.000000e+00 : f64
// CHECK:   %0 = quake.alloca !quake.veq<3>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref {nlindex = 0 : i64}
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref {nlindex = 1 : i64}
// CHECK:   %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref {nlindex = 2 : i64}
// CHECK:   quake.h %1 : (!quake.ref) -> ()
// CHECK:   quake.h %2 : (!quake.ref) -> ()
// CHECK:   quake.h %3 : (!quake.ref) -> ()
// CHECK:   call @subcircuit0(%cst, %cst, %cst, %1, %2, %3) : (f64, f64, f64, !quake.ref, !quake.ref, !quake.ref) -> ()
// CHECK:   quake.h %3 : (!quake.ref) -> ()
// CHECK:   call @subcircuit1(%cst, %1, %2, %3) : (f64, !quake.ref, !quake.ref, !quake.ref) -> ()
// CHECK:   quake.h %1 : (!quake.ref) -> ()
// CHECK:   quake.h %2 : (!quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel3() {
    %cst = arith.constant 1.000000e+00 : f64
    %true = arith.constant true
    %0 = quake.alloca !quake.veq<2>
    %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.h %1 : (!quake.ref) -> ()
    cc.if(%true) {
      quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
      quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
      cc.continue
    }
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: f64, %arg1: !quake.ref, %arg2: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.rz (%arg0) %arg2 : (f64, !quake.ref) -> ()
// CHECK:   quake.x [%arg1] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel3() {
// CHECK:   %cst = arith.constant 1.000000e+00 : f64
// CHECK:   %true = arith.constant true
// CHECK:   %0 = quake.alloca !quake.veq<2>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref {nlindex = 0 : i64}
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref {nlindex = 1 : i64}
// CHECK:   call @subcircuit0(%1, %2) : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.h %1 : (!quake.ref) -> ()
// CHECK:   cc.if(%true) {
// CHECK:     func.call @subcircuit1(%cst, %1, %2) : (f64, !quake.ref, !quake.ref) -> ()
// CHECK:   }
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel4() {
    %cst = arith.constant 1.000000e+00 : f64
    %0 = quake.alloca !quake.veq<3>
    %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
    %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
    quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
    quake.x [%2, %3] %1 : (!quake.ref, !quake.ref, !quake.ref) -> ()
    quake.x [%2, %3] %1 : (!quake.ref, !quake.ref, !quake.ref) -> ()
    quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel4() {
// CHECK:   %cst = arith.constant 1.000000e+00 : f64
// CHECK:   %0 = quake.alloca !quake.veq<3>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref {nlindex = 0 : i64}
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref {nlindex = 1 : i64}
// CHECK:   %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref {nlindex = 2 : i64}
// CHECK:   quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
// CHECK:   quake.x [%2, %3] %1 : (!quake.ref, !quake.ref, !quake.ref) -> ()
// CHECK:   quake.x [%2, %3] %1 : (!quake.ref, !quake.ref, !quake.ref) -> ()
// CHECK:   quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
// CHECK:   call @subcircuit0(%2, %3) : (!quake.ref, !quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel5() {
    %cst = arith.constant 1.000000e+00 : f64
    %0 = quake.alloca !quake.veq<2>
    %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.ry (%cst) %1 : (f64, !quake.ref) -> ()
    quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: !quake.ref, %arg1: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func private @subcircuit0(%arg0: f64, %arg1: !quake.ref, %arg2: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg1] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.rz (%arg0) %arg2 : (f64, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel5() {
// CHECK:   %cst = arith.constant 1.000000e+00 : f64
// CHECK:   %0 = quake.alloca !quake.veq<2>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref {nlindex = 0 : i64}
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref {nlindex = 1 : i64}
// CHECK:   call @subcircuit0(%cst, %1, %2) : (f64, !quake.ref, !quake.ref) -> ()
// CHECK:   quake.ry (%cst) %1 : (f64, !quake.ref) -> ()
// CHECK:   call @subcircuit1(%1, %2) : (!quake.ref, !quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel6() {
    %0 = quake.alloca !quake.veq<3>
    %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
    %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.h %2 : (!quake.ref) -> ()
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    quake.x [%1] %3 : (!quake.ref, !quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg1] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.x [%arg0] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel6() {
// CHECK:   %0 = quake.alloca !quake.veq<3>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref {nlindex = 0 : i64}
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref {nlindex = 1 : i64}
// CHECK:   %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref {nlindex = 2 : i64}
// CHECK:   call @subcircuit0(%1, %2, %3) : (!quake.ref, !quake.ref, !quake.ref) -> ()
// CHECK:   quake.h %2 : (!quake.ref) -> ()
// CHECK:   call @subcircuit1(%1, %2, %3) : (!quake.ref, !quake.ref, !quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel7() {
    %0 = quake.alloca !quake.veq<3>
    %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
    %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.h %1 : (!quake.ref) -> ()
    quake.h %3 : (!quake.ref) -> ()
    quake.x [%3] %2 : (!quake.ref, !quake.ref) -> ()
    quake.x [%3] %1 : (!quake.ref, !quake.ref) -> ()
    return
  }
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: !quake.ref, %arg1: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg1] %arg0 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: !quake.ref) attributes {subcircuit} {
// CHECK:   quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   quake.x [%arg2] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:   cc.return
// CHECK: }
// CHECK-LABEL: func.func @kernel7() {
// CHECK:   %0 = quake.alloca !quake.veq<3>
// CHECK:   %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref {nlindex = 0 : i64}
// CHECK:   %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref {nlindex = 1 : i64}
// CHECK:   %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref {nlindex = 2 : i64}
// CHECK:   call @subcircuit0(%1, %2, %3) : (!quake.ref, !quake.ref, !quake.ref) -> ()
// CHECK:   quake.h %1 : (!quake.ref) -> ()
// CHECK:   quake.h %3 : (!quake.ref) -> ()
// CHECK:   call @subcircuit1(%1, %3) : (!quake.ref, !quake.ref) -> ()
// CHECK:   return
// CHECK: }

// -----
module {
  func.func @kernel8() {
    %0 = quake.alloca !quake.veq<4>
    %1 = quake.extract_ref %0[0] : (!quake.veq<4>) -> !quake.ref
    %2 = quake.extract_ref %0[1] : (!quake.veq<4>) -> !quake.ref
    %3 = quake.extract_ref %0[2] : (!quake.veq<4>) -> !quake.ref
    %4 = quake.extract_ref %0[3] : (!quake.veq<4>) -> !quake.ref
    quake.h %1 : (!quake.ref) -> ()
    quake.h %2 : (!quake.ref) -> ()
    quake.h %3 : (!quake.ref) -> ()
    quake.h %4 : (!quake.ref) -> ()
    quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    quake.h %1 : (!quake.ref) -> ()
    quake.h %2 : (!quake.ref) -> ()
    quake.h %3 : (!quake.ref) -> ()
    quake.h %4 : (!quake.ref) -> ()
    return
  }
}

//CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: !quake.ref, %arg3: !quake.ref) attributes {subcircuit} {
//CHECK:     quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
//CHECK:     quake.x [%arg1] %arg2 : (!quake.ref, !quake.ref) -> ()
//CHECK:     quake.x [%arg2] %arg3 : (!quake.ref, !quake.ref) -> ()
//CHECK:     cc.return
//CHECK: }
//CHECK-LABEL: func.func @kernel8() {
//CHECK:     %0 = quake.alloca !quake.veq<4>
//CHECK:     %1 = quake.extract_ref %0[0] : (!quake.veq<4>) -> !quake.ref {nlindex = 0 : i64}
//CHECK:     %2 = quake.extract_ref %0[1] : (!quake.veq<4>) -> !quake.ref {nlindex = 1 : i64}
//CHECK:     %3 = quake.extract_ref %0[2] : (!quake.veq<4>) -> !quake.ref {nlindex = 2 : i64}
//CHECK:     %4 = quake.extract_ref %0[3] : (!quake.veq<4>) -> !quake.ref {nlindex = 3 : i64}
//CHECK:     quake.h %1 : (!quake.ref) -> ()
//CHECK:     quake.h %2 : (!quake.ref) -> ()
//CHECK:     quake.h %3 : (!quake.ref) -> ()
//CHECK:     quake.h %4 : (!quake.ref) -> ()
//CHECK:     call @subcircuit0(%1, %2, %3, %4) : (!quake.ref, !quake.ref, !quake.ref, !quake.ref) -> ()
//CHECK:     quake.h %1 : (!quake.ref) -> ()
//CHECK:     quake.h %2 : (!quake.ref) -> ()
//CHECK:     quake.h %3 : (!quake.ref) -> ()
//CHECK:     quake.h %4 : (!quake.ref) -> ()
//CHECK:     return
//CHECK: }
