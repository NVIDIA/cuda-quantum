// ========================================================================== //
// Copyright (c) 2022 - 2023 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// Roundtrip test.

// RUN: cudaq-opt %s | cudaq-opt | FileCheck %s

func.func private @apply_kernel(%0 : i32, %1 : !quake.qvec<?>)

// Test roundtripping on the various quake ops.
func.func @quantum_ops() {
  // Allocations
  %0 = quake.alloca !quake.qref
  quake.dealloc %0 : !quake.qref
  %v0 = quake.alloca !quake.qvec<5>
  quake.dealloc %v0 : !quake.qvec<5>
  %1 = quake.alloca !quake.qvec<4>
  %2 = arith.constant 2 : i32
  %3 = quake.alloca[%2 : i32] !quake.qvec<?>
  %4 = quake.alloca !quake.qref

  // Vectors of references
  %zero = arith.constant 0 : i32
  %i = arith.constant 3    : i64
  %5 = quake.concat %3, %4 : (!quake.qvec<?>, !quake.qref) -> !quake.qvec<?>
  %6 = quake.concat %4, %1 : (!quake.qref, !quake.qvec<4>) -> !quake.qvec<5>
  %7 = quake.extract_ref %5[%zero] : (!quake.qvec<?>, i32) -> !quake.qref
  %8 = quake.extract_ref %6[%i]    : (!quake.qvec<5>, i64) -> !quake.qref
  %9 = quake.relax_size %6         : (!quake.qvec<5>) -> !quake.qvec<?>
  %z = arith.constant 0 : index
  %10 = quake.subvec %5, %z, %i : (!quake.qvec<?>, index, i64) -> !quake.qvec<?>
  %11 = quake.vec_size %5 : (!quake.qvec<?>) -> index

  // Reference/dereference
  quake.reset %4 : (!quake.qref) -> ()
  %12 = quake.null_wire
  %13 = quake.unwrap %4 : (!quake.qref) -> !quake.wire
  %18 = quake.reset %13 : (!quake.wire) -> !quake.wire
  quake.wrap %18 to %4 : !quake.wire, !quake.qref

  // Control type conversion
  %14 = quake.convert_ctrl %12 : (!quake.wire) -> !quake.control

  // Quantum operations, reference form
  quake.x %4 : (!quake.qref) -> ()
  quake.y %4 : (!quake.qref) -> ()
  quake.z %4 : (!quake.qref) -> ()
  quake.h %4 : (!quake.qref) -> ()
  quake.s %4 : (!quake.qref) -> ()
  quake.t %4 : (!quake.qref) -> ()
  quake.swap %4, %7 : (!quake.qref, !quake.qref) -> ()

  %f = arith.constant 12.0 : f32
  quake.r1 (%f) %7 : (f32, !quake.qref) -> ()
  quake.rx (%f) %7 : (f32, !quake.qref) -> ()
  %g = arith.constant 23.0 : f32
  quake.phased_rx (%f, %g) %7 : (f32, f32, !quake.qref) -> ()
  quake.ry (%f) %7 : (f32, !quake.qref) -> ()
  quake.rz (%f) %7 : (f32, !quake.qref) -> ()
  quake.u2 (%f, %g) %7 : (f32, f32, !quake.qref) -> ()
  %h = arith.constant 34.0 : f32
  quake.u3 (%f, %g, %h) %7 : (f32, f32, f32, !quake.qref) -> ()

  %15 = quake.mx %4 : (!quake.qref) -> i1
  %16 = quake.my %5 : (!quake.qvec<?>) -> !cc.stdvec<i1>
  %17 = quake.mz %6 : (!quake.qvec<5>) -> !cc.stdvec<i1>

  // Quantum operations, wire form
  %19 = cc.undef i32 {wires = true}
  %20 = quake.null_wire
  %21 = quake.null_wire
  %22 = quake.null_wire
  
  %23 = quake.x %22 : (!quake.wire) -> !quake.wire
  %24 = quake.y %23 : (!quake.wire) -> !quake.wire
  %25 = quake.z %24 : (!quake.wire) -> !quake.wire
  %26 = quake.h %25 : (!quake.wire) -> !quake.wire
  %27 = quake.s %26 : (!quake.wire) -> !quake.wire
  %28 = quake.t %27 : (!quake.wire) -> !quake.wire
  %29:2 = quake.swap %28, %21 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)

  %30 = quake.r1 (%f) %29#1 : (f32, !quake.wire) -> !quake.wire
  %31 = quake.rx (%f) %30 : (f32, !quake.wire) -> !quake.wire
  %32 = quake.phased_rx (%f, %g) %31 : (f32, f32, !quake.wire) -> !quake.wire
  %33 = quake.ry (%f) %32 : (f32, !quake.wire) -> !quake.wire
  %34 = quake.rz (%f) %33 : (f32, !quake.wire) -> !quake.wire
  %35 = quake.u2 (%f, %g) %34 : (f32, f32, !quake.wire) -> !quake.wire
  %36 = quake.u3 (%f, %g, %h) %35 : (f32, f32, f32, !quake.wire) -> !quake.wire

  %37 = quake.mx %29#0 : (!quake.wire) -> i1
  %38 = quake.my %20 : (!quake.wire) -> i1
  %39 = quake.mz %36 : (!quake.wire) -> i1

  // CUDA Quantum model support
  %40 = quake.alloca !quake.qref { apply_variants = true }
  %41 = quake.alloca !quake.qvec<2>
  %42 = arith.constant 0 : i32
  %43 = quake.alloca !quake.qref
  quake.apply @apply_kernel %42, %43 : (i32, !quake.qref) -> ()
  quake.apply @apply_kernel [%40, %41] %42, %43 : (!quake.qref, !quake.qvec<2>, i32, !quake.qref) -> ()
  quake.apply<adj> @apply_kernel [%40, %41] %42, %43 : (!quake.qref, !quake.qvec<2>, i32, !quake.qref) -> ()

  %44 = cc.undef !cc.lambda<() -> ()> { compute_action = true }
  %45 = cc.undef !cc.lambda<() -> ()>
  quake.compute_action %44, %45 : !cc.lambda<() -> ()>, !cc.lambda<() -> ()>
  quake.compute_action<dag> %44, %45 : !cc.lambda<() -> ()>, !cc.lambda<() -> ()>

  // Adjoint modifier
  %47 = cc.undef f64 { adjoint = true }
  quake.s<adj> %4 : (!quake.qref) -> ()
  quake.t<adj> %4 : (!quake.qref) -> ()

  quake.r1<adj> (%f) %7 : (f32, !quake.qref) -> ()
  quake.rx<adj> (%f) %7 : (f32, !quake.qref) -> ()
  quake.phased_rx<adj> (%f, %g) %7 : (f32, f32, !quake.qref) -> ()
  quake.ry<adj> (%f) %7 : (f32, !quake.qref) -> ()
  quake.rz<adj> (%f) %7 : (f32, !quake.qref) -> ()
  quake.u2<adj> (%f, %g) %7 : (f32, f32, !quake.qref) -> ()
  quake.u3<adj> (%f, %g, %h) %7 : (f32, f32, f32, !quake.qref) -> ()

  // Control modifier
  %46 = quake.alloca !quake.qvec<3> {control = true}
  quake.x [%46] %4 : (!quake.qvec<3>, !quake.qref) -> ()
  quake.y [%46] %4 : (!quake.qvec<3>, !quake.qref) -> ()
  quake.z [%7] %4 : (!quake.qref, !quake.qref) -> ()
  quake.h [%46] %4 : (!quake.qvec<3>, !quake.qref) -> ()
  quake.s [%46] %4 : (!quake.qvec<3>, !quake.qref) -> ()
  quake.t [%46] %4 : (!quake.qvec<3>, !quake.qref) -> ()
  quake.swap [%46] %4, %7 : (!quake.qvec<3>, !quake.qref, !quake.qref) -> ()

  quake.r1 (%f) [%46] %7 : (f32, !quake.qvec<3>, !quake.qref) -> ()
  quake.rx (%f) [%46] %7 : (f32, !quake.qvec<3>, !quake.qref) -> ()
  quake.phased_rx (%f, %g) [%46] %7 : (f32, f32, !quake.qvec<3>, !quake.qref) -> ()
  quake.ry (%f) [%46] %7 : (f32, !quake.qvec<3>, !quake.qref) -> ()
  quake.rz (%f) [%46] %7 : (f32, !quake.qvec<3>, !quake.qref) -> ()
  quake.u2 (%f, %g) [%46] %7 : (f32, f32, !quake.qvec<3>, !quake.qref) -> ()
  quake.u3 (%f, %g, %47) [%46] %7 : (f32, f32, f64, !quake.qvec<3>, !quake.qref) -> ()

  return
}

// CHECK-LABEL:   func.func @quantum_ops() {
// CHECK:           %[[VAL_0:.*]] = quake.alloca !quake.qref
// CHECK:           quake.dealloc %[[VAL_0]] : !quake.qref
// CHECK:           %[[VAL_1:.*]] = quake.alloca !quake.qvec<5>
// CHECK:           quake.dealloc %[[VAL_1]] : !quake.qvec<5>
// CHECK:           %[[VAL_2:.*]] = quake.alloca !quake.qvec<4>
// CHECK:           %[[VAL_3:.*]] = arith.constant 2 : i32
// CHECK:           %[[VAL_4:.*]] = quake.alloca{{\[}}%[[VAL_3]] : i32] !quake.qvec<?>
// CHECK:           %[[VAL_5:.*]] = quake.alloca !quake.qref
// CHECK:           %[[VAL_6:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_7:.*]] = arith.constant 3 : i64
// CHECK:           %[[VAL_8:.*]] = quake.concat %[[VAL_4]], %[[VAL_5]] : (!quake.qvec<?>, !quake.qref) -> !quake.qvec<?>
// CHECK:           %[[VAL_9:.*]] = quake.concat %[[VAL_5]], %[[VAL_2]] : (!quake.qref, !quake.qvec<4>) -> !quake.qvec<5>
// CHECK:           %[[VAL_10:.*]] = quake.extract_ref %[[VAL_8]]{{\[}}%[[VAL_6]]] : (!quake.qvec<?>, i32) -> !quake.qref
// CHECK:           %[[VAL_11:.*]] = quake.extract_ref %[[VAL_9]]{{\[}}%[[VAL_7]]] : (!quake.qvec<5>, i64) -> !quake.qref
// CHECK:           %[[VAL_12:.*]] = quake.relax_size %[[VAL_9]] : (!quake.qvec<5>) -> !quake.qvec<?>
// CHECK:           %[[VAL_13:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_14:.*]] = quake.subvec %[[VAL_8]], %[[VAL_13]], %[[VAL_7]] : (!quake.qvec<?>, index, i64) -> !quake.qvec<?>
// CHECK:           %[[VAL_15:.*]] = quake.vec_size %[[VAL_8]] : (!quake.qvec<?>) -> index
// CHECK:           quake.reset %[[VAL_5]] : (!quake.qref) -> ()
// CHECK:           %[[VAL_16:.*]] = quake.null_wire
// CHECK:           %[[VAL_17:.*]] = quake.unwrap %[[VAL_5]] : (!quake.qref) -> !quake.wire
// CHECK:           %[[VAL_18:.*]] = quake.reset %[[VAL_17]] : (!quake.wire) -> !quake.wire
// CHECK:           quake.wrap %[[VAL_18]] to %[[VAL_5]] : !quake.wire, !quake.qref
// CHECK:           %[[VAL_19:.*]] = quake.convert_ctrl %[[VAL_16]] : (!quake.wire) -> !quake.control
// CHECK:           quake.x %[[VAL_5]] : (!quake.qref) -> ()
// CHECK:           quake.y %[[VAL_5]] : (!quake.qref) -> ()
// CHECK:           quake.z %[[VAL_5]] : (!quake.qref) -> ()
// CHECK:           quake.h %[[VAL_5]] : (!quake.qref) -> ()
// CHECK:           quake.s %[[VAL_5]] : (!quake.qref) -> ()
// CHECK:           quake.t %[[VAL_5]] : (!quake.qref) -> ()
// CHECK:           quake.swap %[[VAL_5]], %[[VAL_10]] : (!quake.qref, !quake.qref) -> ()
// CHECK:           %[[VAL_20:.*]] = arith.constant 1.200000e+01 : f32
// CHECK:           quake.r1 (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.qref) -> ()
// CHECK:           quake.rx (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.qref) -> ()
// CHECK:           %[[VAL_21:.*]] = arith.constant 2.300000e+01 : f32
// CHECK:           quake.phased_rx (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.qref) -> ()
// CHECK:           quake.ry (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.qref) -> ()
// CHECK:           quake.rz (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.qref) -> ()
// CHECK:           quake.u2 (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.qref) -> ()
// CHECK:           %[[VAL_22:.*]] = arith.constant 3.400000e+01 : f32
// CHECK:           quake.u3 (%[[VAL_20]], %[[VAL_21]], %[[VAL_22]]) %[[VAL_10]] : (f32, f32, f32, !quake.qref) -> ()
// CHECK:           %[[VAL_23:.*]] = quake.mx %[[VAL_5]] : (!quake.qref) -> i1
// CHECK:           %[[VAL_24:.*]] = quake.my %[[VAL_8]] : (!quake.qvec<?>) -> !cc.stdvec<i1>
// CHECK:           %[[VAL_25:.*]] = quake.mz %[[VAL_9]] : (!quake.qvec<5>) -> !cc.stdvec<i1>
// CHECK:           %[[VAL_26:.*]] = cc.undef i32 {wires = true}
// CHECK:           %[[VAL_27:.*]] = quake.null_wire
// CHECK:           %[[VAL_28:.*]] = quake.null_wire
// CHECK:           %[[VAL_29:.*]] = quake.null_wire
// CHECK:           %[[VAL_30:.*]] = quake.x %[[VAL_29]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_31:.*]] = quake.y %[[VAL_30]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_32:.*]] = quake.z %[[VAL_31]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_33:.*]] = quake.h %[[VAL_32]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_34:.*]] = quake.s %[[VAL_33]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_35:.*]] = quake.t %[[VAL_34]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_36:.*]]:2 = quake.swap %[[VAL_35]], %[[VAL_28]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_37:.*]] = quake.r1 (%[[VAL_20]]) %[[VAL_36]]#1 : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_38:.*]] = quake.rx (%[[VAL_20]]) %[[VAL_37]] : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_39:.*]] = quake.phased_rx (%[[VAL_20]], %[[VAL_21]]) %[[VAL_38]] : (f32, f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_40:.*]] = quake.ry (%[[VAL_20]]) %[[VAL_39]] : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_41:.*]] = quake.rz (%[[VAL_20]]) %[[VAL_40]] : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_42:.*]] = quake.u2 (%[[VAL_20]], %[[VAL_21]]) %[[VAL_41]] : (f32, f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_43:.*]] = quake.u3 (%[[VAL_20]], %[[VAL_21]], %[[VAL_22]]) %[[VAL_42]] : (f32, f32, f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_44:.*]] = quake.mx %[[VAL_36]]#0 : (!quake.wire) -> i1
// CHECK:           %[[VAL_45:.*]] = quake.my %[[VAL_27]] : (!quake.wire) -> i1
// CHECK:           %[[VAL_46:.*]] = quake.mz %[[VAL_43]] : (!quake.wire) -> i1
// CHECK:           %[[VAL_47:.*]] = quake.alloca !quake.qref {apply_variants = true}
// CHECK:           %[[VAL_48:.*]] = quake.alloca !quake.qvec<2>
// CHECK:           %[[VAL_49:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_50:.*]] = quake.alloca !quake.qref
// CHECK:           quake.apply @apply_kernel %[[VAL_49]], %[[VAL_50]] : (i32, !quake.qref) -> ()
// CHECK:           quake.apply @apply_kernel{{\[}}%[[VAL_47]], %[[VAL_48]]] %[[VAL_49]], %[[VAL_50]] : (!quake.qref, !quake.qvec<2>, i32, !quake.qref) -> ()
// CHECK:           quake.apply<adj> @apply_kernel{{\[}}%[[VAL_47]], %[[VAL_48]]] %[[VAL_49]], %[[VAL_50]] : (!quake.qref, !quake.qvec<2>, i32, !quake.qref) -> ()
// CHECK:           %[[VAL_51:.*]] = cc.undef !cc.lambda<() -> ()> {compute_action = true}
// CHECK:           %[[VAL_52:.*]] = cc.undef !cc.lambda<() -> ()>
// CHECK:           quake.compute_action %[[VAL_51]], %[[VAL_52]] : !cc.lambda<() -> ()>, !cc.lambda<() -> ()>
// CHECK:           quake.compute_action<dag> %[[VAL_51]], %[[VAL_52]] : !cc.lambda<() -> ()>, !cc.lambda<() -> ()>
// CHECK:           %[[VAL_53:.*]] = cc.undef f64 {adjoint = true}
// CHECK:           quake.s<adj> %[[VAL_5]] : (!quake.qref) -> ()
// CHECK:           quake.t<adj> %[[VAL_5]] : (!quake.qref) -> ()
// CHECK:           quake.r1<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.qref) -> ()
// CHECK:           quake.rx<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.qref) -> ()
// CHECK:           quake.phased_rx<adj> (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.qref) -> ()
// CHECK:           quake.ry<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.qref) -> ()
// CHECK:           quake.rz<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.qref) -> ()
// CHECK:           quake.u2<adj> (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.qref) -> ()
// CHECK:           quake.u3<adj> (%[[VAL_20]], %[[VAL_21]], %[[VAL_22]]) %[[VAL_10]] : (f32, f32, f32, !quake.qref) -> ()
// CHECK:           %[[VAL_54:.*]] = quake.alloca !quake.qvec<3> {control = true}
// CHECK:           quake.x {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.qvec<3>, !quake.qref) -> ()
// CHECK:           quake.y {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.qvec<3>, !quake.qref) -> ()
// CHECK:           quake.z {{\[}}%[[VAL_10]]] %[[VAL_5]] : (!quake.qref, !quake.qref) -> ()
// CHECK:           quake.h {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.qvec<3>, !quake.qref) -> ()
// CHECK:           quake.s {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.qvec<3>, !quake.qref) -> ()
// CHECK:           quake.t {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.qvec<3>, !quake.qref) -> ()
// CHECK:           quake.swap {{\[}}%[[VAL_54]]] %[[VAL_5]], %[[VAL_10]] : (!quake.qvec<3>, !quake.qref, !quake.qref) -> ()
// CHECK:           quake.r1 (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.qvec<3>, !quake.qref) -> ()
// CHECK:           quake.rx (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.qvec<3>, !quake.qref) -> ()
// CHECK:           quake.phased_rx (%[[VAL_20]], %[[VAL_21]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, f32, !quake.qvec<3>, !quake.qref) -> ()
// CHECK:           quake.ry (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.qvec<3>, !quake.qref) -> ()
// CHECK:           quake.rz (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.qvec<3>, !quake.qref) -> ()
// CHECK:           quake.u2 (%[[VAL_20]], %[[VAL_21]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, f32, !quake.qvec<3>, !quake.qref) -> ()
// CHECK:           quake.u3 (%[[VAL_20]], %[[VAL_21]], %[[VAL_53]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, f32, f64, !quake.qvec<3>, !quake.qref) -> ()
// CHECK:           return
// CHECK:         }

// CHECK-LABEL:   func.func @quake_op1(
// CHECK-SAME:        %[[VAL_0:.*]]: !llvm.ptr<f64>, %[[VAL_1:.*]]: i64) -> i64 {
// CHECK:           %[[VAL_2:.*]] = cc.stdvec_init %[[VAL_0]], %[[VAL_1]] : (!llvm.ptr<f64>, i64) -> !cc.stdvec<f64>
// CHECK:           %[[VAL_3:.*]] = cc.stdvec_data %[[VAL_2]] : (!cc.stdvec<f64>) -> !llvm.ptr<f64>
// CHECK:           %[[VAL_4:.*]] = cc.stdvec_size %[[VAL_2]] : (!cc.stdvec<f64>) -> i64
// CHECK:           return %[[VAL_4]] : i64
// CHECK:         }


func.func @quake_op1(%a : !llvm.ptr<f64>, %b : i64) -> i64 {
  %svec = cc.stdvec_init %a, %b : (!llvm.ptr<f64>, i64) -> !cc.stdvec<f64>
  %dp = cc.stdvec_data %svec : (!cc.stdvec<f64>) -> !llvm.ptr<f64>
  %len = cc.stdvec_size %svec : (!cc.stdvec<f64>) -> i64
  return %len : i64
}

// CHECK-LABEL:   func.func @quake_op2() -> !llvm.ptr<i8> {
// CHECK:           %[[VAL_0:.*]] = constant @quake_op1 : (!llvm.ptr<f64>, i64) -> i64
// CHECK:           %[[VAL_1:.*]] = cc.func_ptr %[[VAL_0]] : ((!llvm.ptr<f64>, i64) -> i64) -> !llvm.ptr<i8>
// CHECK:           return %[[VAL_1]] : !llvm.ptr<i8>
// CHECK:         }

func.func @quake_op2() -> !llvm.ptr<i8> {
  %cp = constant @quake_op1 : (!llvm.ptr<f64>, i64) -> i64
  %ptr = cc.func_ptr %cp : ((!llvm.ptr<f64>, i64) -> i64) -> !llvm.ptr<i8>
  return %ptr : !llvm.ptr<i8>
}

// CHECK-LABEL:   func.func @quake_op3(
// CHECK-SAME:        %[[VAL_0:.*]]: !quake.qvec<?>,
// CHECK-SAME:        %[[VAL_1:.*]]: i32, %[[VAL_2:.*]]: i32) {
// CHECK:           %[[VAL_3:.*]] = quake.subvec %[[VAL_0]], %[[VAL_1]], %[[VAL_2]] : (!quake.qvec<?>, i32, i32) -> !quake.qvec<?>
// CHECK:           return
// CHECK:         }

func.func @quake_op3(%vec : !quake.qvec<?>, %a : i32, %b : i32) {
  %sub = quake.subvec %vec, %a, %b : (!quake.qvec<?>, i32, i32) -> !quake.qvec<?>
  return
}

// CHECK-LABEL:   func.func @cc_op4() {
// CHECK:           cc.scope {
// CHECK:             %[[VAL_0:.*]] = cc.alloca i32 : () -> !cc.ptr<i32>
// CHECK:           }
// CHECK:           return
// CHECK:         }

func.func @cc_op4() {
  cc.scope {
    %x = cc.alloca i32 : () -> !cc.ptr<i32>
  }
  return
}

// See loop.qke for cc.loop, cc.if, cc.condition, cc.continue, cc.break, ...

func.func private @do_nothing() -> ()

// CHECK-LABEL:   func.func @cc_op5() -> !cc.lambda<() -> i32> {
// CHECK:           %[[VAL_0:.*]] = cc.create_lambda {
// CHECK:             func.call @do_nothing() : () -> ()
// CHECK:             %[[VAL_1:.*]] = arith.constant 1 : i32
// CHECK:             cc.return %[[VAL_1]] : i32
// CHECK:           } : !cc.lambda<() -> i32>
// CHECK:           %[[VAL_2:.*]] = cc.alloca !llvm.struct<(i32, i32)> : () -> !cc.ptr<i8>
// CHECK:           %[[VAL_3:.*]] = cc.instantiate_callable @do_nothing(%[[VAL_2]]) : (!cc.ptr<i8>) -> !cc.lambda<() -> ()>
// CHECK:           %[[VAL_4:.*]] = cc.callable_func %[[VAL_3]] : (!cc.lambda<() -> ()>) -> (() -> ())
// CHECK:           %[[VAL_5:.*]] = cc.callable_closure %[[VAL_3]] : (!cc.lambda<() -> ()>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_6:.*]] = cc.call_callable %[[VAL_0]] : (!cc.lambda<() -> i32>) -> i32
// CHECK:           cc.call_callable %[[VAL_3]] : (!cc.lambda<() -> ()>) -> ()
// CHECK:           return %[[VAL_0]] : !cc.lambda<() -> i32>
// CHECK:         }

func.func @cc_op5() -> !cc.lambda<() -> i32> {
  %1 = cc.create_lambda {
    func.call @do_nothing() : () -> ()
    %1 = arith.constant 1 : i32
    cc.return %1 : i32
  } : !cc.lambda<() -> i32>
  %closure = cc.alloca !llvm.struct<(i32, i32)> : () -> !cc.ptr<i8>
  %2 = cc.instantiate_callable @do_nothing(%closure) : (!cc.ptr<i8>) -> !cc.lambda<()->()>
  %3 = cc.callable_func %2 : (!cc.lambda<() -> ()>) -> (() -> ())
  %4 = cc.callable_closure %2 : (!cc.lambda<() -> ()>) -> !cc.ptr<i8>
  %5 = cc.call_callable %1 : (!cc.lambda<() -> (i32)>) -> i32
  cc.call_callable %2 : (!cc.lambda<() -> ()>) -> ()
  return %1 : !cc.lambda<() -> i32>
}

// CHECK-LABEL:   func.func @cc_op6_return_test() -> i32 {
// CHECK:           %[[VAL_0:.*]] = cc.alloca i32 : () -> !cc.ptr<i32>
// CHECK:           %[[VAL_1:.*]] = cc.undef i32
// CHECK:           cc.scope {
// CHECK:             %[[VAL_2:.*]] = cc.alloca i1 : () -> !cc.ptr<i1>
// CHECK:             %[[VAL_3:.*]] = cc.undef i1
// CHECK:             cc.if(%[[VAL_3]]) {
// CHECK:               cc.scope {
// CHECK:                 %[[VAL_4:.*]] = cc.alloca i32 : () -> !cc.ptr<i32>
// CHECK:                 %[[VAL_5:.*]] = cc.alloca i1 : () -> !cc.ptr<i1>
// CHECK:                 cc.loop while {
// CHECK:                   %[[VAL_6:.*]] = cc.undef i1
// CHECK:                   cc.condition %[[VAL_6]]
// CHECK:                 } do {
// CHECK:                   cc.scope {
// CHECK:                     %[[VAL_7:.*]] = cc.alloca i1 : () -> !cc.ptr<i1>
// CHECK:                     %[[VAL_8:.*]] = cc.undef i1
// CHECK:                     cc.if(%[[VAL_8]]) {
// CHECK:                       %[[VAL_9:.*]] = cc.undef i32
// CHECK:                       cc.unwind_return %[[VAL_9]] : i32 {insn = 1 : i64}
// CHECK:                     }
// CHECK:                   }
// CHECK:                   %[[VAL_10:.*]] = cc.undef i32
// CHECK:                   cc.unwind_return %[[VAL_10]] : i32 {insn = 2 : i64}
// CHECK:                   cc.continue
// CHECK:                 } step {
// CHECK:                   %[[VAL_11:.*]] = cc.undef i32
// CHECK:                 }
// CHECK:               }
// CHECK:             }
// CHECK:           }
// CHECK:           return %[[VAL_1]] : i32
// CHECK:         }

func.func @cc_op6_return_test() -> i32 {
  %1 = cc.alloca i32 : () -> !cc.ptr<i32>
  %result = cc.undef i32
  cc.scope {
    %2 = cc.alloca i1 : () -> !cc.ptr<i1>
    %b1 = cc.undef i1
    cc.if (%b1) {
      cc.scope {
        %3 = cc.alloca i32 : () -> !cc.ptr<i32>
        %4 = cc.alloca i1 : () -> !cc.ptr<i1>
        cc.loop while {
	  %b2 = cc.undef i1
	  cc.condition %b2
	} do {
          cc.scope {
            %5 = cc.alloca i1 : () -> !cc.ptr<i1>
	    %b3 = cc.undef i1
            cc.if (%b3) {
	      %val = cc.undef i32
              cc.unwind_return %val : i32 {insn = 1}
	      cc.continue
            }
          }
	  %val2 = cc.undef i32
	  cc.unwind_return %val2 : i32 {insn = 2}
	  cc.continue
        } step {
	  %incr = cc.undef i32
	}
      }
    }
  }
  return %result : i32
}

// CHECK-LABEL:   func.func @cc_op7_break_test() -> f64 {
// CHECK:           cc.scope {
// CHECK:             cc.if(%{{.*}}) {
// CHECK:               cc.scope {
// CHECK:                 %[[VAL_7:.*]] = cc.loop while ((%[[VAL_8:.*]] = %{{.*}}) -> (i16)) {
// CHECK:                   cc.condition %{{.*}}(%[[VAL_8]] : i16)
// CHECK:                 } do {
// CHECK:                 ^bb0(%[[VAL_10:.*]]: i16):
// CHECK:                   cc.scope {
// CHECK:                     cc.if(%{{.*}}) {
// CHECK:                       %[[VAL_13:.*]] = cc.undef f64
// CHECK:                       cc.unwind_break %[[VAL_10]] : i16
// CHECK:                     }
// CHECK:                   }
// CHECK:                   cc.continue %[[VAL_10]] : i16
// CHECK:                 } step {
// CHECK:                 ^bb0(%[[VAL_15:.*]]: i16):
// CHECK:                   cc.continue %[[VAL_15]] : i16
// CHECK:                 }
// CHECK:               }
// CHECK:             }
// CHECK:           }
// CHECK:           return %[[VAL_1]] : f64
// CHECK:         }

func.func @cc_op7_break_test() -> f64 {
  %1 = cc.alloca i32 : () -> !cc.ptr<i32>
  %result = cc.undef f64
  cc.scope {
    %2 = cc.alloca i1 : () -> !cc.ptr<i1>
    %b1 = cc.undef i1
    cc.if (%b1) {
      cc.scope {
        %3 = cc.alloca i32 : () -> !cc.ptr<i32>
        %4 = cc.alloca i1 : () -> !cc.ptr<i1>
	%w = cc.undef i16
        cc.loop while ((%arg0 = %w) -> i16) {
	  %b2 = cc.undef i1
	  cc.condition %b2 (%arg0 : i16)
	} do {
         ^bb1(%arg1 : i16):
          cc.scope {
            %5 = cc.alloca i1 : () -> !cc.ptr<i1>
	    %b3 = cc.undef i1
            cc.if (%b3) {
	      %val = cc.undef f64
              cc.unwind_break %arg1 : i16
	      cc.continue
            }
	    cc.continue
          }
	  %val2 = cc.undef i32
	  cc.continue %arg1 : i16
        } step {
	 ^bb2(%arg2 : i16):
	  %incr = cc.undef i32
	  cc.continue %arg2 : i16
	}
      }
    }
  }
  return %result : f64
}

// CHECK-LABEL:   func.func @cc_op8_continue_test() -> f64 {
// CHECK:           cc.scope {
// CHECK:             cc.if(%{{.*}}) {
// CHECK:               cc.scope {
// CHECK:                 %[[VAL_7:.*]] = cc.loop while ((%[[VAL_8:.*]] = %{{.*}}) -> (i16)) {
// CHECK:                   cc.condition %{{.*}}(%[[VAL_8]] : i16)
// CHECK:                 } do {
// CHECK:                 ^bb0(%[[VAL_10:.*]]: i16):
// CHECK:                   cc.scope {
// CHECK:                     cc.if(%{{.*}}) {
// CHECK:                       %[[VAL_13:.*]] = cc.undef f64
// CHECK:                       cc.unwind_continue %[[VAL_10]] : i16
// CHECK:                     }
// CHECK:                   }
// CHECK:                   cc.continue %[[VAL_10]] : i16
// CHECK:                 } step {
// CHECK:                 ^bb0(%[[VAL_15:.*]]: i16):
// CHECK:                   cc.continue %[[VAL_15]] : i16
// CHECK:                 }
// CHECK:               }
// CHECK:             }
// CHECK:           }
// CHECK:           return %[[VAL_1]] : f64
// CHECK:         }

func.func @cc_op8_continue_test() -> f64 {
  %1 = cc.alloca i32 : () -> !cc.ptr<i32>
  %result = cc.undef f64
  cc.scope {
    %2 = cc.alloca i1 : () -> !cc.ptr<i1>
    %b1 = cc.undef i1
    cc.if (%b1) {
      cc.scope {
        %3 = cc.alloca i32 : () -> !cc.ptr<i32>
        %4 = cc.alloca i1 : () -> !cc.ptr<i1>
	%w = cc.undef i16
        cc.loop while ((%arg0 = %w) -> i16) {
	  %b2 = cc.undef i1
	  cc.condition %b2 (%arg0 : i16)
	} do {
         ^bb1(%arg1 : i16):
          cc.scope {
            %5 = cc.alloca i1 : () -> !cc.ptr<i1>
	    %b3 = cc.undef i1
            cc.if (%b3) {
	      %val = cc.undef f64
              cc.unwind_continue %arg1 : i16
	      cc.continue
            }
	    cc.continue
          }
	  %val2 = cc.undef i32
	  cc.continue %arg1 : i16
        } step {
	 ^bb2(%arg2 : i16):
	  %incr = cc.undef i32
	  cc.continue %arg2 : i16
	}
      }
    }
  }
  return %result : f64
}

// CHECK-LABEL:   func.func @cc.scope_result() {
// CHECK:           %[[VAL_0:.*]] = cc.scope -> (i32) {
// CHECK:             %[[VAL_1:.*]] = cc.alloca i32 : () -> !cc.ptr<i32>
// CHECK:             %[[VAL_2:.*]] = cc.undef i32
// CHECK:             cc.continue %[[VAL_2]] : i32
// CHECK:           }
// CHECK:           return
// CHECK:         }

func.func @cc.scope_result() {
  %0 = cc.scope -> i32 {
    %x = cc.alloca i32 : () -> !cc.ptr<i32>
    %0 = cc.undef i32
    cc.continue %0 : i32
  }
  return
}

// CHECK-LABEL:   func.func @cc.scope_blocks() {
// CHECK:           cc.scope {
// CHECK:             %[[VAL_0:.*]] = cc.alloca i32 : () -> !cc.ptr<i32>
// CHECK:             %[[VAL_1:.*]] = cc.undef i1
// CHECK:             cf.cond_br %[[VAL_1]], ^bb1, ^bb2
// CHECK:           ^bb1:
// CHECK:             %[[VAL_2:.*]] = cc.undef i32
// CHECK:             cf.br ^bb3
// CHECK:           ^bb2:
// CHECK:             %[[VAL_3:.*]] = cc.undef f64
// CHECK:             cf.br ^bb3
// CHECK:           ^bb3:
// CHECK:             %[[VAL_4:.*]] = cc.undef i64
// CHECK:             cc.unwind_return
// CHECK:           }
// CHECK:           return
// CHECK:         }

// scope with an embedded primitive CFG
func.func @cc.scope_blocks() {
  cc.scope {
  ^bb2:
    %x = cc.alloca i32 : () -> !cc.ptr<i32>
    %0 = cc.undef i1
    cf.cond_br %0, ^bb0, ^bb1
  ^bb0:
    %b = cc.undef i32
    cf.br ^bb3
  ^bb1:
    %c = cc.undef f64
    cf.br ^bb3
  ^bb3:
    %e = cc.undef i64
    cc.unwind_return
  }
  return
}

// CHECK-LABEL:   func.func @load_store(
// CHECK-SAME:      %[[ARG0:.*]]: !cc.ptr<i32>) {
// CHECK:           %[[VAL_0:.*]] = cc.load %[[ARG0]] : !cc.ptr<i32>
// CHECK:           cc.store %{{.*}}, %[[ARG0]] : !cc.ptr<i32>

func.func @load_store(%arg0: !cc.ptr<i32>) {
  %1 = cc.load %arg0 : !cc.ptr<i32>
  %2 = arith.addi %1, %1 : i32
  cc.store %2, %arg0 : !cc.ptr<i32>
  return
}

// CHECK-LABEL:   func.func @wire_type() -> !quake.wire {
// CHECK:           %[[VAL_0:.*]] = cc.undef !quake.wire
// CHECK:           return %[[VAL_0]] : !quake.wire

func.func @wire_type() -> !quake.wire {
  %0 = cc.undef !quake.wire
  return %0 : !quake.wire
}

// CHECK-LABEL:   func.func @unwrap_wrap(
// CHECK-SAME:      %[[VAL_0:.*]]: !quake.qref) {
// CHECK:           %[[VAL_1:.*]] = quake.unwrap %[[VAL_0]] : (!quake.qref) -> !quake.wire
// CHECK:           %[[VAL_2:.*]] = quake.null_wire
// CHECK:           %[[VAL_3:.*]] = quake.x [%[[VAL_2]]] %[[VAL_1]] : (!quake.wire, !quake.wire) -> !quake.wire
// CHECK:           quake.wrap %[[VAL_3]] to %[[VAL_0]] : !quake.wire, !quake.qref

func.func @unwrap_wrap(%0 : !quake.qref) {
  %1 = quake.unwrap %0 : (!quake.qref) -> !quake.wire
  %3 = quake.null_wire
  %2 = quake.x [%3] %1 : (!quake.wire, !quake.wire) -> !quake.wire
  quake.wrap %2 to %0 : !quake.wire, !quake.qref
  return
}

// CHECK-LABEL:   func.func @cc_struct() {
// CHECK:           %[[VAL_0:.*]] = cc.undef !cc.struct<"foo" {i32, i8}>
// CHECK:           %[[VAL_1:.*]] = cc.undef !cc.struct<"foo">
// CHECK:           %[[VAL_2:.*]] = cc.undef !cc.struct<"bar" {}>
// CHECK:           %[[VAL_3:.*]] = cc.undef !cc.struct<{!cc.array<f64 x 10>}>
// CHECK:           %[[VAL_9:.*]] = cc.undef !cc.struct<"foo6" {f32, i8} packed>
// CHECK:           return
// CHECK:         }

func.func @cc_struct() {
  %0 = cc.undef !cc.struct<"foo"{i32, i8}>
  %1 = cc.undef !cc.struct<"foo">
  %2 = cc.undef !cc.struct<"bar" {}>
  %3 = cc.undef !cc.struct<{!cc.array<f64 x 10>}>
  %9 = cc.undef !cc.struct<"foo6"{f32, i8} packed>
  return
}
