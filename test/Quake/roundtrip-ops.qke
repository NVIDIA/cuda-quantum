// ========================================================================== //
// Copyright (c) 2022 - 2023 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// Roundtrip test.

// RUN: cudaq-opt %s | cudaq-opt | FileCheck %s

func.func private @apply_kernel(%0 : i32, %1 : !quake.veq<?>)

// Test roundtripping on the various quake ops.
func.func @quantum_ops() {
  // Allocations
  %0 = quake.alloca !quake.ref
  quake.dealloc %0 : !quake.ref
  %v0 = quake.alloca !quake.veq<5>
  quake.dealloc %v0 : !quake.veq<5>
  %1 = quake.alloca !quake.veq<4>
  %2 = arith.constant 2 : i32
  %3 = quake.alloca !quake.veq<?>[%2 : i32]
  %4 = quake.alloca !quake.ref

  // Vectors of references
  %zero = arith.constant 0 : i32
  %i = arith.constant 3    : i64
  %5 = quake.concat %3, %4 : (!quake.veq<?>, !quake.ref) -> !quake.veq<?>
  %6 = quake.concat %4, %1 : (!quake.ref, !quake.veq<4>) -> !quake.veq<5>
  %7 = quake.extract_ref %5[%zero] : (!quake.veq<?>, i32) -> !quake.ref
  %8 = quake.extract_ref %6[%i]    : (!quake.veq<5>, i64) -> !quake.ref
  %9 = quake.relax_size %6         : (!quake.veq<5>) -> !quake.veq<?>
  %z = arith.constant 0 : index
  %10 = quake.subveq %5, %z, %i : (!quake.veq<?>, index, i64) -> !quake.veq<?>
  %11 = quake.veq_size %5 : (!quake.veq<?>) -> index

  // Reference/dereference
  quake.reset %4 : (!quake.ref) -> ()
  %12 = quake.null_wire
  %13 = quake.unwrap %4 : (!quake.ref) -> !quake.wire
  %18 = quake.reset %13 : (!quake.wire) -> !quake.wire
  quake.wrap %18 to %4 : !quake.wire, !quake.ref

  // Control type conversion
  %14 = quake.to_ctrl %12 : (!quake.wire) -> !quake.control
  %a14 = quake.from_ctrl %14 : (!quake.control) -> !quake.wire
  quake.sink %a14 : !quake.wire

  // Quantum operations, reference form
  quake.x %4 : (!quake.ref) -> ()
  quake.y %4 : (!quake.ref) -> ()
  quake.z %4 : (!quake.ref) -> ()
  quake.h %4 : (!quake.ref) -> ()
  quake.s %4 : (!quake.ref) -> ()
  quake.t %4 : (!quake.ref) -> ()
  quake.swap %4, %7 : (!quake.ref, !quake.ref) -> ()

  %f = arith.constant 12.0 : f32
  quake.r1 (%f) %7 : (f32, !quake.ref) -> ()
  quake.rx (%f) %7 : (f32, !quake.ref) -> ()
  %g = arith.constant 23.0 : f32
  quake.phased_rx (%f, %g) %7 : (f32, f32, !quake.ref) -> ()
  quake.ry (%f) %7 : (f32, !quake.ref) -> ()
  quake.rz (%f) %7 : (f32, !quake.ref) -> ()
  quake.u2 (%f, %g) %7 : (f32, f32, !quake.ref) -> ()
  %h = arith.constant 34.0 : f32
  quake.u3 (%f, %g, %h) %7 : (f32, f32, f32, !quake.ref) -> ()

  %15 = quake.mx %4 : (!quake.ref) -> !quake.measure
  %16 = quake.my %5 : (!quake.veq<?>) -> !cc.stdvec<!quake.measure>
  %17 = quake.mz %6 : (!quake.veq<5>) -> !cc.stdvec<!quake.measure>
  %z15 = quake.discriminate %15 : (!quake.measure) -> i1
  %z16 = quake.discriminate %16 : (!cc.stdvec<!quake.measure>) -> !cc.stdvec<i1>

  // Quantum operations, wire form
  %19 = cc.undef i32 {wires = true}
  %20 = quake.null_wire
  %21 = quake.null_wire
  %22 = quake.null_wire
  
  %23 = quake.x %22 : (!quake.wire) -> !quake.wire
  %24 = quake.y %23 : (!quake.wire) -> !quake.wire
  %25 = quake.z %24 : (!quake.wire) -> !quake.wire
  %26 = quake.h %25 : (!quake.wire) -> !quake.wire
  %27 = quake.s %26 : (!quake.wire) -> !quake.wire
  %28 = quake.t %27 : (!quake.wire) -> !quake.wire
  %29:2 = quake.swap %28, %21 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)

  %30 = quake.r1 (%f) %29#1 : (f32, !quake.wire) -> !quake.wire
  %31 = quake.rx (%f) %30 : (f32, !quake.wire) -> !quake.wire
  %32 = quake.phased_rx (%f, %g) %31 : (f32, f32, !quake.wire) -> !quake.wire
  %33 = quake.ry (%f) %32 : (f32, !quake.wire) -> !quake.wire
  %34 = quake.rz (%f) %33 : (f32, !quake.wire) -> !quake.wire
  %35 = quake.u2 (%f, %g) %34 : (f32, f32, !quake.wire) -> !quake.wire
  %36 = quake.u3 (%f, %g, %h) %35 : (f32, f32, f32, !quake.wire) -> !quake.wire

  %37:2 = quake.mx %29#0 : (!quake.wire) -> (!quake.measure, !quake.wire)
  quake.sink %37#1 : !quake.wire
  %38:2 = quake.my %20 : (!quake.wire) -> (!quake.measure, !quake.wire)
  quake.sink %38#1 : !quake.wire
  %39:2 = quake.mz %36 : (!quake.wire) -> (!quake.measure, !quake.wire)
  quake.sink %39#1 : !quake.wire

  // CUDA Quantum model support
  %40 = quake.alloca !quake.ref { apply_variants = true }
  %41 = quake.alloca !quake.veq<2>
  %42 = arith.constant 0 : i32
  %43 = quake.alloca !quake.ref
  quake.apply @apply_kernel %42, %43 : (i32, !quake.ref) -> ()
  quake.apply @apply_kernel [%40, %41] %42, %43 : (!quake.ref, !quake.veq<2>, i32, !quake.ref) -> ()
  quake.apply<adj> @apply_kernel [%40, %41] %42, %43 : (!quake.ref, !quake.veq<2>, i32, !quake.ref) -> ()

  %44 = cc.undef !cc.callable<() -> ()> { compute_action = true }
  %45 = cc.undef !cc.callable<() -> ()>
  quake.compute_action %44, %45 : !cc.callable<() -> ()>, !cc.callable<() -> ()>
  quake.compute_action<dag> %44, %45 : !cc.callable<() -> ()>, !cc.callable<() -> ()>

  // Adjoint modifier
  %47 = cc.undef f64 { adjoint = true }
  quake.s<adj> %4 : (!quake.ref) -> ()
  quake.t<adj> %4 : (!quake.ref) -> ()

  quake.r1<adj> (%f) %7 : (f32, !quake.ref) -> ()
  quake.rx<adj> (%f) %7 : (f32, !quake.ref) -> ()
  quake.phased_rx<adj> (%f, %g) %7 : (f32, f32, !quake.ref) -> ()
  quake.ry<adj> (%f) %7 : (f32, !quake.ref) -> ()
  quake.rz<adj> (%f) %7 : (f32, !quake.ref) -> ()
  quake.u2<adj> (%f, %g) %7 : (f32, f32, !quake.ref) -> ()
  quake.u3<adj> (%f, %g, %h) %7 : (f32, f32, f32, !quake.ref) -> ()

  // Control modifier
  %46 = quake.alloca !quake.veq<3> {control = true}
  quake.x [%46] %4 : (!quake.veq<3>, !quake.ref) -> ()
  quake.y [%46] %4 : (!quake.veq<3>, !quake.ref) -> ()
  quake.z [%7] %4 : (!quake.ref, !quake.ref) -> ()
  quake.h [%46] %4 : (!quake.veq<3>, !quake.ref) -> ()
  quake.s [%46] %4 : (!quake.veq<3>, !quake.ref) -> ()
  quake.t [%46] %4 : (!quake.veq<3>, !quake.ref) -> ()
  quake.swap [%46] %4, %7 : (!quake.veq<3>, !quake.ref, !quake.ref) -> ()

  quake.r1 (%f) [%46] %7 : (f32, !quake.veq<3>, !quake.ref) -> ()
  quake.rx (%f) [%46] %7 : (f32, !quake.veq<3>, !quake.ref) -> ()
  quake.phased_rx (%f, %g) [%46] %7 : (f32, f32, !quake.veq<3>, !quake.ref) -> ()
  quake.ry (%f) [%46] %7 : (f32, !quake.veq<3>, !quake.ref) -> ()
  quake.rz (%f) [%46] %7 : (f32, !quake.veq<3>, !quake.ref) -> ()
  quake.u2 (%f, %g) [%46] %7 : (f32, f32, !quake.veq<3>, !quake.ref) -> ()
  quake.u3 (%f, %g, %47) [%46] %7 : (f32, f32, f64, !quake.veq<3>, !quake.ref) -> ()

  // Exp Pauli and StringLiteral
  %f2 = arith.constant 12.0 : f64
  %48 = cc.string_literal "XXY" : !cc.ptr<!cc.array<i8 x 4>>
  quake.exp_pauli (%f2) %46, %48 : (f64, !quake.veq<3>, !cc.ptr<!cc.array<i8 x 4>>) -> ()
  
  return
}

// CHECK-LABEL:   func.func @quantum_ops() {
// CHECK:           %[[VAL_0:.*]] = quake.alloca !quake.ref
// CHECK:           quake.dealloc %[[VAL_0]] : !quake.ref
// CHECK:           %[[VAL_1:.*]] = quake.alloca !quake.veq<5>
// CHECK:           quake.dealloc %[[VAL_1]] : !quake.veq<5>
// CHECK:           %[[VAL_2:.*]] = quake.alloca !quake.veq<4>
// CHECK:           %[[VAL_3:.*]] = arith.constant 2 : i32
// CHECK:           %[[VAL_4:.*]] = quake.alloca !quake.veq<?>[%[[VAL_3]] : i32]
// CHECK:           %[[VAL_5:.*]] = quake.alloca !quake.ref
// CHECK:           %[[VAL_6:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_7:.*]] = arith.constant 3 : i64
// CHECK:           %[[VAL_8:.*]] = quake.concat %[[VAL_4]], %[[VAL_5]] : (!quake.veq<?>, !quake.ref) -> !quake.veq<?>
// CHECK:           %[[VAL_9:.*]] = quake.concat %[[VAL_5]], %[[VAL_2]] : (!quake.ref, !quake.veq<4>) -> !quake.veq<5>
// CHECK:           %[[VAL_10:.*]] = quake.extract_ref %[[VAL_8]]{{\[}}%[[VAL_6]]] : (!quake.veq<?>, i32) -> !quake.ref
// CHECK:           %[[VAL_11:.*]] = quake.extract_ref %[[VAL_9]]{{\[}}%[[VAL_7]]] : (!quake.veq<5>, i64) -> !quake.ref
// CHECK:           %[[VAL_12:.*]] = quake.relax_size %[[VAL_9]] : (!quake.veq<5>) -> !quake.veq<?>
// CHECK:           %[[VAL_13:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_14:.*]] = quake.subveq %[[VAL_8]], %[[VAL_13]], %[[VAL_7]] : (!quake.veq<?>, index, i64) -> !quake.veq<?>
// CHECK:           %[[VAL_15:.*]] = quake.veq_size %[[VAL_8]] : (!quake.veq<?>) -> index
// CHECK:           quake.reset %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           %[[VAL_16:.*]] = quake.null_wire
// CHECK:           %[[VAL_17:.*]] = quake.unwrap %[[VAL_5]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_18:.*]] = quake.reset %[[VAL_17]] : (!quake.wire) -> !quake.wire
// CHECK:           quake.wrap %[[VAL_18]] to %[[VAL_5]] : !quake.wire, !quake.ref
// CHECK:           %[[VAL_19:.*]] = quake.to_ctrl %[[VAL_16]] : (!quake.wire) -> !quake.control
// CHECK:           %[[WAL_19:.*]] = quake.from_ctrl %[[VAL_19]] : (!quake.control) -> !quake.wire
// CHECK:           quake.sink %[[WAL_19]] : !quake.wire
// CHECK:           quake.x %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.y %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.z %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.h %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.s %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.t %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.swap %[[VAL_5]], %[[VAL_10]] : (!quake.ref, !quake.ref) -> ()
// CHECK:           %[[VAL_20:.*]] = arith.constant 1.200000e+01 : f32
// CHECK:           quake.r1 (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.rx (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           %[[VAL_21:.*]] = arith.constant 2.300000e+01 : f32
// CHECK:           quake.phased_rx (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.ref) -> ()
// CHECK:           quake.ry (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.rz (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.u2 (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.ref) -> ()
// CHECK:           %[[VAL_22:.*]] = arith.constant 3.400000e+01 : f32
// CHECK:           quake.u3 (%[[VAL_20]], %[[VAL_21]], %[[VAL_22]]) %[[VAL_10]] : (f32, f32, f32, !quake.ref) -> ()
// CHECK:           %[[VAL_23:.*]] = quake.mx %[[VAL_5]] : (!quake.ref) -> !quake.measure
// CHECK:           %[[VAL_24:.*]] = quake.my %[[VAL_8]] : (!quake.veq<?>) -> !cc.stdvec<!quake.measure>
// CHECK:           %[[VAL_25:.*]] = quake.mz %[[VAL_9]] : (!quake.veq<5>) -> !cc.stdvec<!quake.measure>
// CHECK:           %[[VAL_123:.*]] = quake.discriminate %[[VAL_23]] : (!quake.measure) -> i1
// CHECK:           %[[VAL_124:.*]] = quake.discriminate %[[VAL_24]] : (!cc.stdvec<!quake.measure>) -> !cc.stdvec<i1>
// CHECK:           %[[VAL_26:.*]] = cc.undef i32 {wires = true}
// CHECK:           %[[VAL_27:.*]] = quake.null_wire
// CHECK:           %[[VAL_28:.*]] = quake.null_wire
// CHECK:           %[[VAL_29:.*]] = quake.null_wire
// CHECK:           %[[VAL_30:.*]] = quake.x %[[VAL_29]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_31:.*]] = quake.y %[[VAL_30]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_32:.*]] = quake.z %[[VAL_31]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_33:.*]] = quake.h %[[VAL_32]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_34:.*]] = quake.s %[[VAL_33]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_35:.*]] = quake.t %[[VAL_34]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_36:.*]]:2 = quake.swap %[[VAL_35]], %[[VAL_28]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_37:.*]] = quake.r1 (%[[VAL_20]]) %[[VAL_36]]#1 : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_38:.*]] = quake.rx (%[[VAL_20]]) %[[VAL_37]] : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_39:.*]] = quake.phased_rx (%[[VAL_20]], %[[VAL_21]]) %[[VAL_38]] : (f32, f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_40:.*]] = quake.ry (%[[VAL_20]]) %[[VAL_39]] : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_41:.*]] = quake.rz (%[[VAL_20]]) %[[VAL_40]] : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_42:.*]] = quake.u2 (%[[VAL_20]], %[[VAL_21]]) %[[VAL_41]] : (f32, f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_43:.*]] = quake.u3 (%[[VAL_20]], %[[VAL_21]], %[[VAL_22]]) %[[VAL_42]] : (f32, f32, f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_44:.*]], %[[WAL_44:.*]] = quake.mx %[[VAL_36]]#0 : (!quake.wire) -> (!quake.measure, !quake.wire)
// CHECK:           %[[VAL_45:.*]], %[[WAL_45:.*]] = quake.my %[[VAL_27]] : (!quake.wire) -> (!quake.measure, !quake.wire)
// CHECK:           %[[VAL_46:.*]], %[[WAL_46:.*]] = quake.mz %[[VAL_43]] : (!quake.wire) -> (!quake.measure, !quake.wire)
// CHECK:           %[[VAL_47:.*]] = quake.alloca !quake.ref {apply_variants = true}
// CHECK:           %[[VAL_48:.*]] = quake.alloca !quake.veq<2>
// CHECK:           %[[VAL_49:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_50:.*]] = quake.alloca !quake.ref
// CHECK:           quake.apply @apply_kernel %[[VAL_49]], %[[VAL_50]] : (i32, !quake.ref) -> ()
// CHECK:           quake.apply @apply_kernel [%[[VAL_47]], %[[VAL_48]]] %[[VAL_49]], %[[VAL_50]] : (!quake.ref, !quake.veq<2>, i32, !quake.ref) -> ()
// CHECK:           quake.apply<adj> @apply_kernel [%[[VAL_47]], %[[VAL_48]]] %[[VAL_49]], %[[VAL_50]] : (!quake.ref, !quake.veq<2>, i32, !quake.ref) -> ()
// CHECK:           %[[VAL_51:.*]] = cc.undef !cc.callable<() -> ()> {compute_action = true}
// CHECK:           %[[VAL_52:.*]] = cc.undef !cc.callable<() -> ()>
// CHECK:           quake.compute_action %[[VAL_51]], %[[VAL_52]] : !cc.callable<() -> ()>, !cc.callable<() -> ()>
// CHECK:           quake.compute_action<dag> %[[VAL_51]], %[[VAL_52]] : !cc.callable<() -> ()>, !cc.callable<() -> ()>
// CHECK:           %[[VAL_53:.*]] = cc.undef f64 {adjoint = true}
// CHECK:           quake.s<adj> %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.t<adj> %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.r1<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.rx<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.phased_rx<adj> (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.ref) -> ()
// CHECK:           quake.ry<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.rz<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.u2<adj> (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.ref) -> ()
// CHECK:           quake.u3<adj> (%[[VAL_20]], %[[VAL_21]], %[[VAL_22]]) %[[VAL_10]] : (f32, f32, f32, !quake.ref) -> ()
// CHECK:           %[[VAL_54:.*]] = quake.alloca !quake.veq<3> {control = true}
// CHECK:           quake.x {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.y {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.z {{\[}}%[[VAL_10]]] %[[VAL_5]] : (!quake.ref, !quake.ref) -> ()
// CHECK:           quake.h {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.s {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.t {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.swap {{\[}}%[[VAL_54]]] %[[VAL_5]], %[[VAL_10]] : (!quake.veq<3>, !quake.ref, !quake.ref) -> ()
// CHECK:           quake.r1 (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.rx (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.phased_rx (%[[VAL_20]], %[[VAL_21]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.ry (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.rz (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.u2 (%[[VAL_20]], %[[VAL_21]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.u3 (%[[VAL_20]], %[[VAL_21]], %[[VAL_53]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, f32, f64, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           %[[VAL_59:.*]] = arith.constant 1.200000e+01 : f64
// CHECK:           %[[VAL_60:.*]] = cc.string_literal "XXY" : !cc.ptr<!cc.array<i8 x 4>>
// CHECK:           quake.exp_pauli(%[[VAL_59]]) %[[VAL_54]], %[[VAL_60]] : (f64, !quake.veq<3>, !cc.ptr<!cc.array<i8 x 4>>) -> ()
// CHECK:           return
// CHECK:         }

// CHECK-LABEL:   func.func @quake_op1(
// CHECK-SAME:        %[[VAL_0:.*]]: !cc.ptr<f64>, %[[VAL_1:.*]]: i64) -> i64 {
// CHECK:           %[[VAL_2:.*]] = cc.stdvec_init %[[VAL_0]], %[[VAL_1]] : (!cc.ptr<f64>, i64) -> !cc.stdvec<f64>
// CHECK:           %[[VAL_3:.*]] = cc.stdvec_data %[[VAL_2]] : (!cc.stdvec<f64>) -> !cc.ptr<f64>
// CHECK:           %[[VAL_4:.*]] = cc.stdvec_size %[[VAL_2]] : (!cc.stdvec<f64>) -> i64
// CHECK:           return %[[VAL_4]] : i64
// CHECK:         }

func.func @quake_op1(%a : !cc.ptr<f64>, %b : i64) -> i64 {
  %svec = cc.stdvec_init %a, %b : (!cc.ptr<f64>, i64) -> !cc.stdvec<f64>
  %dp = cc.stdvec_data %svec : (!cc.stdvec<f64>) -> !cc.ptr<f64>
  %len = cc.stdvec_size %svec : (!cc.stdvec<f64>) -> i64
  return %len : i64
}

// CHECK-LABEL:   func.func @quake_op2() -> !cc.ptr<i8> {
// CHECK:           %[[VAL_0:.*]] = constant @quake_op1 : (!cc.ptr<f64>, i64) -> i64
// CHECK:           %[[VAL_1:.*]] = cc.func_ptr %[[VAL_0]] : ((!cc.ptr<f64>, i64) -> i64) -> !cc.ptr<i8>
// CHECK:           return %[[VAL_1]] : !cc.ptr<i8>
// CHECK:         }

func.func @quake_op2() -> !cc.ptr<i8> {
  %cp = constant @quake_op1 : (!cc.ptr<f64>, i64) -> i64
  %ptr = cc.func_ptr %cp : ((!cc.ptr<f64>, i64) -> i64) -> !cc.ptr<i8>
  return %ptr : !cc.ptr<i8>
}

// CHECK-LABEL:   func.func @quake_op3(
// CHECK-SAME:        %[[VAL_0:.*]]: !quake.veq<?>,
// CHECK-SAME:        %[[VAL_1:.*]]: i32, %[[VAL_2:.*]]: i32) {
// CHECK:           %[[VAL_3:.*]] = quake.subveq %[[VAL_0]], %[[VAL_1]], %[[VAL_2]] : (!quake.veq<?>, i32, i32) -> !quake.veq<?>
// CHECK:           return
// CHECK:         }

func.func @quake_op3(%vec : !quake.veq<?>, %a : i32, %b : i32) {
  %sub = quake.subveq %vec, %a, %b : (!quake.veq<?>, i32, i32) -> !quake.veq<?>
  return
}

// CHECK-LABEL:   func.func @cc_op4() {
// CHECK:           cc.scope {
// CHECK:             %[[VAL_0:.*]] = cc.alloca i32
// CHECK:           }
// CHECK:           return
// CHECK:         }

func.func @cc_op4() {
  cc.scope {
    %x = cc.alloca i32
  }
  return
}

// See loop.qke for cc.loop, cc.if, cc.condition, cc.continue, cc.break, ...

func.func private @do_nothing() -> ()

// CHECK-LABEL:   func.func @cc_op5() -> !cc.callable<() -> i32> {
// CHECK:           %[[VAL_0:.*]] = cc.create_lambda {
// CHECK:             func.call @do_nothing() : () -> ()
// CHECK:             %[[VAL_1:.*]] = arith.constant 1 : i32
// CHECK:             cc.return %[[VAL_1]] : i32
// CHECK:           } : !cc.callable<() -> i32>
// CHECK:           %[[VAL_21:.*]] = cc.alloca !cc.struct<{i32, i32}>
// CHECK:           %[[VAL_2:.*]] = cc.cast %[[VAL_21]] :
// CHECK:           %[[VAL_3:.*]] = cc.instantiate_callable @do_nothing(%[[VAL_2]]) : (!cc.ptr<i8>) -> !cc.callable<() -> ()>
// CHECK:           %[[VAL_4:.*]] = cc.callable_func %[[VAL_3]] : (!cc.callable<() -> ()>) -> (() -> ())
// CHECK:           %[[VAL_5:.*]] = cc.callable_closure %[[VAL_3]] : (!cc.callable<() -> ()>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_6:.*]] = cc.call_callable %[[VAL_0]] : (!cc.callable<() -> i32>) -> i32
// CHECK:           cc.call_callable %[[VAL_3]] : (!cc.callable<() -> ()>) -> ()
// CHECK:           return %[[VAL_0]] : !cc.callable<() -> i32>
// CHECK:         }

func.func @cc_op5() -> !cc.callable<() -> i32> {
  %1 = cc.create_lambda {
    func.call @do_nothing() : () -> ()
    %1 = arith.constant 1 : i32
    cc.return %1 : i32
  } : !cc.callable<() -> i32>
  %closure = cc.alloca !cc.struct<{i32, i32}>
  %cast = cc.cast %closure : (!cc.ptr<!cc.struct<{i32, i32}>>) -> !cc.ptr<i8>
  %2 = cc.instantiate_callable @do_nothing(%cast) : (!cc.ptr<i8>) -> !cc.callable<()->()>
  %3 = cc.callable_func %2 : (!cc.callable<() -> ()>) -> (() -> ())
  %4 = cc.callable_closure %2 : (!cc.callable<() -> ()>) -> !cc.ptr<i8>
  %5 = cc.call_callable %1 : (!cc.callable<() -> (i32)>) -> i32
  cc.call_callable %2 : (!cc.callable<() -> ()>) -> ()
  return %1 : !cc.callable<() -> i32>
}

// CHECK-LABEL:   func.func @cc_op6_return_test() -> i32 {
// CHECK:           %[[VAL_0:.*]] = cc.alloca i32
// CHECK:           %[[VAL_1:.*]] = cc.undef i32
// CHECK:           cc.scope {
// CHECK:             %[[VAL_2:.*]] = cc.alloca i1
// CHECK:             %[[VAL_3:.*]] = cc.undef i1
// CHECK:             cc.if(%[[VAL_3]]) {
// CHECK:               cc.scope {
// CHECK:                 %[[VAL_4:.*]] = cc.alloca i32
// CHECK:                 %[[VAL_5:.*]] = cc.alloca i1
// CHECK:                 cc.loop while {
// CHECK:                   %[[VAL_6:.*]] = cc.undef i1
// CHECK:                   cc.condition %[[VAL_6]]
// CHECK:                 } do {
// CHECK:                   cc.scope {
// CHECK:                     %[[VAL_7:.*]] = cc.alloca i1
// CHECK:                     %[[VAL_8:.*]] = cc.undef i1
// CHECK:                     cc.if(%[[VAL_8]]) {
// CHECK:                       %[[VAL_9:.*]] = cc.undef i32
// CHECK:                       cc.unwind_return %[[VAL_9]] : i32 {insn = 1 : i64}
// CHECK:                     }
// CHECK:                   }
// CHECK:                   %[[VAL_10:.*]] = cc.undef i32
// CHECK:                   cc.unwind_return %[[VAL_10]] : i32 {insn = 2 : i64}
// CHECK:                   cc.continue
// CHECK:                 } step {
// CHECK:                   %[[VAL_11:.*]] = cc.undef i32
// CHECK:                 }
// CHECK:               }
// CHECK:             }
// CHECK:           }
// CHECK:           return %[[VAL_1]] : i32
// CHECK:         }

func.func @cc_op6_return_test() -> i32 {
  %1 = cc.alloca i32
  %result = cc.undef i32
  cc.scope {
    %2 = cc.alloca i1
    %b1 = cc.undef i1
    cc.if (%b1) {
      cc.scope {
        %3 = cc.alloca i32
        %4 = cc.alloca i1
        cc.loop while {
	  %b2 = cc.undef i1
	  cc.condition %b2
	} do {
          cc.scope {
            %5 = cc.alloca i1
	    %b3 = cc.undef i1
            cc.if (%b3) {
	      %val = cc.undef i32
              cc.unwind_return %val : i32 {insn = 1}
	      cc.continue
            }
          }
	  %val2 = cc.undef i32
	  cc.unwind_return %val2 : i32 {insn = 2}
	  cc.continue
        } step {
	  %incr = cc.undef i32
	}
      }
    }
  }
  return %result : i32
}

// CHECK-LABEL:   func.func @cc_op7_break_test() -> f64 {
// CHECK:           cc.scope {
// CHECK:             cc.if(%{{.*}}) {
// CHECK:               cc.scope {
// CHECK:                 %[[VAL_7:.*]] = cc.loop while ((%[[VAL_8:.*]] = %{{.*}}) -> (i16)) {
// CHECK:                   cc.condition %{{.*}}(%[[VAL_8]] : i16)
// CHECK:                 } do {
// CHECK:                 ^bb0(%[[VAL_10:.*]]: i16):
// CHECK:                   cc.scope {
// CHECK:                     cc.if(%{{.*}}) {
// CHECK:                       %[[VAL_13:.*]] = cc.undef f64
// CHECK:                       cc.unwind_break %[[VAL_10]] : i16
// CHECK:                     }
// CHECK:                   }
// CHECK:                   cc.continue %[[VAL_10]] : i16
// CHECK:                 } step {
// CHECK:                 ^bb0(%[[VAL_15:.*]]: i16):
// CHECK:                   cc.continue %[[VAL_15]] : i16
// CHECK:                 }
// CHECK:               }
// CHECK:             }
// CHECK:           }
// CHECK:           return %[[VAL_1]] : f64
// CHECK:         }

func.func @cc_op7_break_test() -> f64 {
  %1 = cc.alloca i32
  %result = cc.undef f64
  cc.scope {
    %2 = cc.alloca i1
    %b1 = cc.undef i1
    cc.if (%b1) {
      cc.scope {
        %3 = cc.alloca i32
        %4 = cc.alloca i1
	%w = cc.undef i16
        cc.loop while ((%arg0 = %w) -> i16) {
	  %b2 = cc.undef i1
	  cc.condition %b2 (%arg0 : i16)
	} do {
         ^bb1(%arg1 : i16):
          cc.scope {
            %5 = cc.alloca i1
	    %b3 = cc.undef i1
            cc.if (%b3) {
	      %val = cc.undef f64
              cc.unwind_break %arg1 : i16
	      cc.continue
            }
	    cc.continue
          }
	  %val2 = cc.undef i32
	  cc.continue %arg1 : i16
        } step {
	 ^bb2(%arg2 : i16):
	  %incr = cc.undef i32
	  cc.continue %arg2 : i16
	}
      }
    }
  }
  return %result : f64
}

// CHECK-LABEL:   func.func @cc_op8_continue_test() -> f64 {
// CHECK:           cc.scope {
// CHECK:             cc.if(%{{.*}}) {
// CHECK:               cc.scope {
// CHECK:                 %[[VAL_7:.*]] = cc.loop while ((%[[VAL_8:.*]] = %{{.*}}) -> (i16)) {
// CHECK:                   cc.condition %{{.*}}(%[[VAL_8]] : i16)
// CHECK:                 } do {
// CHECK:                 ^bb0(%[[VAL_10:.*]]: i16):
// CHECK:                   cc.scope {
// CHECK:                     cc.if(%{{.*}}) {
// CHECK:                       %[[VAL_13:.*]] = cc.undef f64
// CHECK:                       cc.unwind_continue %[[VAL_10]] : i16
// CHECK:                     }
// CHECK:                   }
// CHECK:                   cc.continue %[[VAL_10]] : i16
// CHECK:                 } step {
// CHECK:                 ^bb0(%[[VAL_15:.*]]: i16):
// CHECK:                   cc.continue %[[VAL_15]] : i16
// CHECK:                 }
// CHECK:               }
// CHECK:             }
// CHECK:           }
// CHECK:           return %[[VAL_1]] : f64
// CHECK:         }

func.func @cc_op8_continue_test() -> f64 {
  %1 = cc.alloca i32
  %result = cc.undef f64
  cc.scope {
    %2 = cc.alloca i1
    %b1 = cc.undef i1
    cc.if (%b1) {
      cc.scope {
        %3 = cc.alloca i32
        %4 = cc.alloca i1
	%w = cc.undef i16
        cc.loop while ((%arg0 = %w) -> i16) {
	  %b2 = cc.undef i1
	  cc.condition %b2 (%arg0 : i16)
	} do {
         ^bb1(%arg1 : i16):
          cc.scope {
            %5 = cc.alloca i1
	    %b3 = cc.undef i1
            cc.if (%b3) {
	      %val = cc.undef f64
              cc.unwind_continue %arg1 : i16
	      cc.continue
            }
	    cc.continue
          }
	  %val2 = cc.undef i32
	  cc.continue %arg1 : i16
        } step {
	 ^bb2(%arg2 : i16):
	  %incr = cc.undef i32
	  cc.continue %arg2 : i16
	}
      }
    }
  }
  return %result : f64
}

// CHECK-LABEL:   func.func @cc.scope_result() {
// CHECK:           %[[VAL_0:.*]] = cc.scope -> (i32) {
// CHECK:             %[[VAL_1:.*]] = cc.alloca i32
// CHECK:             %[[VAL_2:.*]] = cc.undef i32
// CHECK:             cc.continue %[[VAL_2]] : i32
// CHECK:           }
// CHECK:           return
// CHECK:         }

func.func @cc.scope_result() {
  %0 = cc.scope -> i32 {
    %x = cc.alloca i32
    %0 = cc.undef i32
    cc.continue %0 : i32
  }
  return
}

// CHECK-LABEL:   func.func @cc.scope_blocks() {
// CHECK:           cc.scope {
// CHECK:             %[[VAL_0:.*]] = cc.alloca i32
// CHECK:             %[[VAL_1:.*]] = cc.undef i1
// CHECK:             cf.cond_br %[[VAL_1]], ^bb1, ^bb2
// CHECK:           ^bb1:
// CHECK:             %[[VAL_2:.*]] = cc.undef i32
// CHECK:             cf.br ^bb3
// CHECK:           ^bb2:
// CHECK:             %[[VAL_3:.*]] = cc.undef f64
// CHECK:             cf.br ^bb3
// CHECK:           ^bb3:
// CHECK:             %[[VAL_4:.*]] = cc.undef i64
// CHECK:             cc.unwind_return
// CHECK:           }
// CHECK:           return
// CHECK:         }

// scope with an embedded primitive CFG
func.func @cc.scope_blocks() {
  cc.scope {
  ^bb2:
    %x = cc.alloca i32
    %0 = cc.undef i1
    cf.cond_br %0, ^bb0, ^bb1
  ^bb0:
    %b = cc.undef i32
    cf.br ^bb3
  ^bb1:
    %c = cc.undef f64
    cf.br ^bb3
  ^bb3:
    %e = cc.undef i64
    cc.unwind_return
  }
  return
}

// CHECK-LABEL:   func.func @load_store(
// CHECK-SAME:      %[[ARG0:.*]]: !cc.ptr<i32>) {
// CHECK:           %[[VAL_0:.*]] = cc.load %[[ARG0]] : !cc.ptr<i32>
// CHECK:           cc.store %{{.*}}, %[[ARG0]] : !cc.ptr<i32>

func.func @load_store(%arg0: !cc.ptr<i32>) {
  %1 = cc.load %arg0 : !cc.ptr<i32>
  %2 = arith.addi %1, %1 : i32
  cc.store %2, %arg0 : !cc.ptr<i32>
  return
}

// CHECK-LABEL:   func.func @wire_type() -> !quake.wire {
// CHECK:           %[[VAL_0:.*]] = cc.undef !quake.wire
// CHECK:           return %[[VAL_0]] : !quake.wire

func.func @wire_type() -> !quake.wire {
  %0 = cc.undef !quake.wire
  return %0 : !quake.wire
}

// CHECK-LABEL:   func.func @unwrap_wrap(
// CHECK-SAME:      %[[VAL_0:.*]]: !quake.ref) {
// CHECK:           %[[VAL_1:.*]] = quake.unwrap %[[VAL_0]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_2:.*]] = quake.null_wire
// CHECK:           %[[VAL_3:.*]]:2 = quake.x [%[[VAL_2]]] %[[VAL_1]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           quake.wrap %[[VAL_3]]#1 to %[[VAL_0]] : !quake.wire, !quake.ref
// CHECK:           return
// CHECK:         }

func.func @unwrap_wrap(%0 : !quake.ref) {
  %1 = quake.unwrap %0 : (!quake.ref) -> !quake.wire
  %3 = quake.null_wire
  %2:2 = quake.x [%3] %1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
  quake.wrap %2#1 to %0 : !quake.wire, !quake.ref
  quake.sink %2#0 : !quake.wire
  return
}

// CHECK-LABEL:   func.func @cc_struct() {
// CHECK:           %[[VAL_0:.*]] = cc.undef !cc.struct<"foo" {i32, i8}>
// CHECK:           %[[VAL_1:.*]] = cc.undef !cc.struct<"foo">
// CHECK:           %[[VAL_2:.*]] = cc.undef !cc.struct<"bar" {}>
// CHECK:           %[[VAL_3:.*]] = cc.undef !cc.struct<{!cc.array<f64 x 10>}>
// CHECK:           %[[VAL_9:.*]] = cc.undef !cc.struct<"foo6" {f32, i8} packed>
// CHECK:           return
// CHECK:         }

func.func @cc_struct() {
  %0 = cc.undef !cc.struct<"foo"{i32, i8}>
  %1 = cc.undef !cc.struct<"foo">
  %2 = cc.undef !cc.struct<"bar" {}>
  %3 = cc.undef !cc.struct<{!cc.array<f64 x 10>}>
  %9 = cc.undef !cc.struct<"foo6"{f32, i8} packed>
  return
}

// CHECK-LABEL:   func.func @cc_indexing(
// CHECK-SAME:                           %[[VAL_0:.*]]: !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) {
// CHECK:           %[[VAL_1:.*]] = cc.address_of @cc_struct : !cc.ptr<() -> ()>
// CHECK:           %[[VAL_2:.*]] = cc.extract_value %[[VAL_0]][0] : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) -> i32
// CHECK:           %[[VAL_3:.*]] = cc.extract_value %[[VAL_0]][1, 15, 2] : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) -> f32
// CHECK:           %[[VAL_4:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_5:.*]] = arith.addi %[[VAL_2]], %[[VAL_4]] : i32
// CHECK:           %[[VAL_6:.*]] = cc.insert_value %[[VAL_5]], %[[VAL_0]][0] : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>, i32) -> !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>
// CHECK:           %[[VAL_7:.*]] = cc.alloca !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>
// CHECK:           cc.store %[[VAL_6]], %[[VAL_7]] : !cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>
// CHECK:           %[[VAL_8:.*]] = cc.compute_ptr %[[VAL_7]][1, 4, 3] : (!cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>) -> !cc.ptr<i64>
// CHECK:           %[[VAL_9:.*]] = cc.compute_ptr %[[VAL_7]][1, %[[VAL_4]], 1] : (!cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>, i32) -> !cc.ptr<i16>
// CHECK:           %[[VAL_10:.*]] = cc.const_array [1.000000e+00, 2.000000e+00] : !cc.array<f32 x 2>
// CHECK:           %[[VAL_11:.*]] = cc.get_const_element %[[VAL_10]], %[[VAL_4]] : (!cc.array<f32 x 2>, i32) -> f32
// CHECK:           return
// CHECK:         }

func.func @cc_indexing(%arg0 : !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) {
  %0 = cc.address_of @cc_struct : !cc.ptr<() -> ()>
  %1 = cc.extract_value %arg0[0] : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) -> i32
  %2 = cc.extract_value %arg0[1, 15, 2] : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) -> f32
  %one = arith.constant 1 : i32
  %incr = arith.addi %1, %one : i32
  %3 = cc.insert_value %incr, %arg0[0] : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>, i32) -> !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>
  %ss = cc.alloca !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>
  cc.store %3, %ss : !cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>
  %p = cc.compute_ptr %ss[1, 4, 3] : (!cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>) -> !cc.ptr<i64>
  %q = cc.compute_ptr %ss[1, %one, 1] : (!cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>, i32) -> !cc.ptr<i16>
  %arr = cc.const_array [1.0, 2.0] : !cc.array<f32 x 2>
  %ele = cc.get_const_element %arr, %one : (!cc.array<f32 x 2>, i32) -> f32
  return
}
