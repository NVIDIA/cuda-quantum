// ========================================================================== //
// Copyright (c) 2022 - 2024 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt -canonicalize %s | FileCheck %s

module {
  func.func @if_true_no_result() {
    %c0_i64 = arith.constant 1 : i64
    %c1_i64 = arith.constant 1 : i64
    %true = arith.constant true
    %0 = quake.alloca !quake.veq<2>
    cc.if(%true) {
      %6 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
      quake.x %6 : (!quake.ref) -> ()
    }
    return
  }

// CHECK-LABEL:  func.func @if_true_no_result() {
// CHECK:          %[[VAL_0:.*]] = quake.alloca !quake.veq<2>
// CHECK:          %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][0] : (!quake.veq<2>) -> !quake.ref
// CHECK:          quake.x %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:          return
// CHECK:        }

  func.func @if_false_no_result() {
    %c0_i64 = arith.constant 1 : i64
    %c1_i64 = arith.constant 1 : i64
    %false = arith.constant false
    %0 = quake.alloca !quake.veq<2>
    cc.if(%false) {
      %6 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
      quake.x %6 : (!quake.ref) -> ()
    }
    return
  }

// CHECK-LABEL:  func.func @if_false_no_result() {
// CHECK:          %[[VAL_0:.*]] = quake.alloca !quake.veq<2>
// CHECK:          return
// CHECK:        }

  func.func @if_true_else_no_result() {
    %c0_i64 = arith.constant 1 : i64
    %c1_i64 = arith.constant 1 : i64
    %true = arith.constant true
    %0 = quake.alloca !quake.veq<2>
    cc.if(%true) {
      %6 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
      quake.x %6 : (!quake.ref) -> ()
    } else {
      %6 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
      quake.x %6 : (!quake.ref) -> ()
    }
    return
  }

// CHECK-LABEL:  func.func @if_true_else_no_result() {
// CHECK:          %[[VAL_0:.*]] = quake.alloca !quake.veq<2>
// CHECK:          %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][0] : (!quake.veq<2>) -> !quake.ref
// CHECK:          quake.x %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:          return
// CHECK:        }

  func.func @if_false_else_no_result() {
    %c0_i64 = arith.constant 1 : i64
    %c1_i64 = arith.constant 1 : i64
    %false = arith.constant false
    %0 = quake.alloca !quake.veq<2>
    cc.if(%false) {
      %6 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
      quake.x %6 : (!quake.ref) -> ()
    } else {
      %6 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
      quake.x %6 : (!quake.ref) -> ()
    }
    return
  }

// CHECK-LABEL:  func.func @if_false_else_no_result() {
// CHECK:          %[[VAL_0:.*]] = quake.alloca !quake.veq<2>
// CHECK:          %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][1] : (!quake.veq<2>) -> !quake.ref
// CHECK:          quake.x %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:          return
// CHECK:        }

  func.func @if_true_else_no_result_continue() {
    %c0_i64 = arith.constant 1 : i64
    %c1_i64 = arith.constant 1 : i64
    %true = arith.constant true
    %0 = quake.alloca !quake.veq<2>
    cc.if(%true) {
      %6 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
      quake.x %6 : (!quake.ref) -> ()
      cc.continue
    } else {
      %6 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
      quake.x %6 : (!quake.ref) -> ()
      cc.continue
    }
    return
  }

// CHECK-LABEL:  func.func @if_true_else_no_result_continue() {
// CHECK:          %[[VAL_0:.*]] = quake.alloca !quake.veq<2>
// CHECK:          %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][0] : (!quake.veq<2>) -> !quake.ref
// CHECK:          quake.x %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:          return
// CHECK:        }

  func.func @if_false_else_no_result_continue() {
    %c0_i64 = arith.constant 1 : i64
    %c1_i64 = arith.constant 1 : i64
    %false = arith.constant false
    %0 = quake.alloca !quake.veq<2>
    cc.if(%false) {
      %6 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
      quake.x %6 : (!quake.ref) -> ()
      cc.continue
    } else {
      %6 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
      quake.x %6 : (!quake.ref) -> ()
      cc.continue
    }
    return
  }

// CHECK-LABEL:  func.func @if_false_else_no_result_continue() {
// CHECK:          %[[VAL_0:.*]] = quake.alloca !quake.veq<2>
// CHECK:          %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][1] : (!quake.veq<2>) -> !quake.ref
// CHECK:          quake.x %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:          return
// CHECK:        }

  func.func @load_value() attributes {"cudaq-entrypoint", "cudaq-kernel", no_this} {
    cf.br ^bb1
  ^bb1:  // pred: ^bb0
    %c0_i32 = arith.constant 0 : i32
    cf.br ^bb2
  ^bb2:  // pred: ^bb1
    %c3_i64 = arith.constant 3 : i64
    %c4_i64 = arith.constant 4 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i32_0 = arith.constant 0 : i32
    %0 = quake.alloca !quake.veq<4>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %2 = arith.cmpi ult, %arg0, %c4_i64 : i64
      cc.condition %2(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %2 = arith.shli %c1_i64, %arg0 : i64
      %3 = cc.cast %2 : (i64) -> i32
      %4 = arith.andi %c0_i32, %3 : i32
      %5 = arith.cmpi ne, %4, %c0_i32_0 : i32
      cc.if(%5) {
        %6 = arith.subi %c3_i64, %arg0 : i64
        %7 = quake.extract_ref %0[%6] : (!quake.veq<4>, i64) -> !quake.ref
        quake.x %7 : (!quake.ref) -> ()
      }
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %2 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %2 : i64
    }
    %measOut = quake.mz %0 : (!quake.veq<4>) -> !cc.stdvec<!quake.measure>
    return
  }

// CHECK-LABEL:  func.func @load_value() attributes {"cudaq-entrypoint", "cudaq-kernel", no_this} {
// CHECK:          %[[VAL_0:.*]] = quake.alloca !quake.veq<4>
// CHECK:          %measOut = quake.mz %[[VAL_0]] : (!quake.veq<4>) -> !cc.stdvec<!quake.measure>
// CHECK:          return
// CHECK:        }

  func.func @if_single_result() {
    %c0_i64 = arith.constant 1 : i64
    %c1_i64 = arith.constant 1 : i64
    %true = arith.constant true
    %false = arith.constant false
    %0 = quake.alloca !quake.veq<2>
    %2 = cc.if(%true) -> i64 {
      cc.continue %c0_i64 : i64
    } else {
      cc.continue %c1_i64 : i64
    }
    %6 = quake.extract_ref %0[%2] : (!quake.veq<2>, i64) -> !quake.ref
    quake.x %6 : (!quake.ref) -> ()
    return
  }

// CHECK-LABEL:  func.func @if_single_result() {
// CHECK:          %[[VAL_0:.*]] = quake.alloca !quake.veq<2>
// CHECK:          %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][1] : (!quake.veq<2>) -> !quake.ref
// CHECK:          quake.x %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:          return
// CHECK:        }

  func.func @if_multiple_results() {
    %c0_i64 = arith.constant 0 : i64
    %c1_i64 = arith.constant 1 : i64
    %true = arith.constant true
    %false = arith.constant false
    %0 = quake.alloca !quake.veq<2>
    %2:2 = cc.if(%true) -> (i64, i64) {
      cc.continue %c0_i64, %c1_i64 : i64, i64
    } else {
      cc.continue %c1_i64, %c0_i64 : i64, i64
    }
    %6 = quake.extract_ref %0[%2#0] : (!quake.veq<2>, i64) -> !quake.ref
    %7 = quake.extract_ref %0[%2#1] : (!quake.veq<2>, i64) -> !quake.ref
    quake.x %6 : (!quake.ref) -> ()
    quake.x %7 : (!quake.ref) -> ()
    return
  }

// CHECK-LABEL:  func.func @if_multiple_results() {
// CHECK:          %[[VAL_0:.*]] = quake.alloca !quake.veq<2>
// CHECK:          %[[VAL_1:.*]] = quake.extract_ref %[[VAL_0]][0] : (!quake.veq<2>) -> !quake.ref
// CHECK:          %[[VAL_2:.*]] = quake.extract_ref %[[VAL_0]][1] : (!quake.veq<2>) -> !quake.ref
// CHECK:          quake.x %[[VAL_1]] : (!quake.ref) -> ()
// CHECK:          quake.x %[[VAL_2]] : (!quake.ref) -> ()
// CHECK:          return
// CHECK:        }
}
