// ========================================================================== //
// Copyright (c) 2022 - 2025 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt %s --resource-count-preprocess=dump-preprocessed=true --canonicalize -split-input-file | FileCheck %s

// CHECK: Preprocessing h for 1 counts
// CHECK-LABEL:   func.func @kernel1() {
// CHECK:       %0 = quake.alloca !quake.ref
// CHECK:       return
// CHECK:   }

// Preprocess inside invariant if, but not inside
func.func @kernel1() {
  %0 = arith.constant true
  %1 = quake.alloca !quake.ref
  cc.if(%0) {
    quake.h %1 : (!quake.ref) -> ()
  }
  return
}

// -----

// CHECK: Preprocessing h for 1 counts
// CHECK-LABEL:   func.func @kernel2() {
// CHECK:       %0 = quake.alloca !quake.ref
// CHECK:       %1 = quake.alloca !quake.ref
// CHECK:       %measOut = quake.mz %0 name "m1" : (!quake.ref) -> !quake.measure
// CHECK:       %2 = quake.discriminate %measOut : (!quake.measure) -> i1
// CHECK:       cc.if(%2) {
// CHECK:           quake.x %1 : (!quake.ref) -> ()
// CHECK:       }
// CHECK:       %measOut_0 = quake.mz %1 : (!quake.ref) -> !quake.measure
// CHECK:       return
// CHECK:   }

// Preprocess outside variant if, but not inside
func.func @kernel2() {
  %0 = quake.alloca !quake.ref
  %1 = quake.alloca !quake.ref
  quake.h %0 : (!quake.ref) -> ()
  %measOut = quake.mz %0 name "m1" : (!quake.ref) -> !quake.measure
  %2 = quake.discriminate %measOut : (!quake.measure) -> i1
  cc.if(%2) {
    quake.x %1 : (!quake.ref) -> ()
  }
  %measOut_0 = quake.mz %1 : (!quake.ref) -> !quake.measure
  return
}

// -----

// CHECK: Preprocessing h for 9 counts
// CHECK-LABEL:   func.func @kernel3() {
// CHECK:     %0 = quake.alloca !quake.veq<10>
// CHECK:     %measOut = quake.mz %0 : (!quake.veq<10>) -> !cc.stdvec<!quake.measure>
// CHECK:     return
// CHECK:   }

// Preprocess inside invariant loop (should remove loop after canonicalize)
func.func @kernel3() {
  %c0_i64 = arith.constant 0 : i64
  %c9_i64 = arith.constant 9 : i64
  %c1_i64 = arith.constant 1 : i64
  %c10_i64 = arith.constant 10 : i64
  %0 = quake.alloca !quake.veq<10>
  %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
    %2 = arith.cmpi ult, %arg0, %c9_i64 : i64
    cc.condition %2(%arg0 : i64)
  } do {
  ^bb0(%arg0: i64):
    %2 = quake.extract_ref %0[%arg0] : (!quake.veq<10>, i64) -> !quake.ref
    quake.h %2 : (!quake.ref) -> ()
    cc.continue %arg0 : i64
  } step {
  ^bb0(%arg0: i64):
    %2 = arith.addi %arg0, %c1_i64 : i64
    cc.continue %2 : i64
  }
  %measOut = quake.mz %0 : (!quake.veq<10>) -> !cc.stdvec<!quake.measure>
  return
}

// -----

// CHECK: Preprocessing h for 1 count
// CHECK-LABEL: func.func @kernel4() {
// CHECK:   %cst = arith.constant 1.000000e-01 : f64
// CHECK:   %0 = quake.alloca !quake.ref
// CHECK:   cc.loop while {
// CHECK:     %measOut = quake.mz %0 : (!quake.ref) -> !quake.measure
// CHECK:     %1 = quake.discriminate %measOut : (!quake.measure) -> i1
// CHECK:     cc.condition %1
// CHECK:   } do {
// CHECK:     quake.rz (%cst) %0 : (f64, !quake.ref) -> ()
// CHECK:     quake.h %0 : (!quake.ref) -> ()
// CHECK:     cc.continue
// CHECK:   }
// CHECK:   return
// CHECK: }

// Don't preprocess inside variant loop
func.func @kernel4() {
  %cst = arith.constant 1.000000e-01 : f64
  %0 = quake.alloca !quake.ref
  quake.h %0 : (!quake.ref) -> ()
  cc.loop while {
    %measOut = quake.mz %0 : (!quake.ref) -> !quake.measure
    %1 = quake.discriminate %measOut : (!quake.measure) -> i1
    cc.condition %1
  } do {
    quake.rz (%cst) %0 : (f64, !quake.ref) -> ()
    quake.h %0 : (!quake.ref) -> ()
    cc.continue
  }
  return
}

// -----

// CHECK: Preprocessing x for 1 count
// CHECK: Preprocessing cx for 1 count
// CHECK: Preprocessing ccx for 1 count
// CHECK: Preprocessing cccx for 1 count

// CHECK-LABEL: func.func @kernel5() {
// CHECK:   %0 = quake.alloca !quake.ref
// CHECK:   %1 = quake.alloca !quake.ref
// CHECK:   %2 = quake.alloca !quake.ref
// CHECK:   %3 = quake.alloca !quake.ref
// CHECK:   return
// CHECK: }

// Ensure gate names are correct for controlled gates
func.func @kernel5() {
  %0 = quake.alloca !quake.ref
  %1 = quake.alloca !quake.ref
  %2 = quake.alloca !quake.ref
  %3 = quake.alloca !quake.ref
  quake.x %3 : (!quake.ref) -> ()
  quake.x [%0] %3 : (!quake.ref, !quake.ref) -> ()
  quake.x [%0, %1] %3 : (!quake.ref, !quake.ref, !quake.ref) -> ()
  quake.x [%0, %1, %2] %3 : (!quake.ref, !quake.ref, !quake.ref, !quake.ref) -> ()
  return
}
