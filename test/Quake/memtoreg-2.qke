// ========================================================================== //
// Copyright (c) 2022 - 2023 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt --memtoreg %s | FileCheck %s

func.func @classical_if01(%c1: i1) {
  %q0 = quake.alloca !quake.ref
  %q1 = quake.alloca !quake.ref
  cc.if (%c1) {
    quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  } else {
    quake.y [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  }
  quake.z [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.dealloc %q0 : !quake.ref
  quake.dealloc %q1 : !quake.ref
  return
}

// CHECK-LABEL:   func.func @classical_if01(
// CHECK-SAME:                              %[[VAL_0:.*]]: i1) {
// CHECK:           %[[VAL_1:.*]] = quake.null_wire
// CHECK:           %[[VAL_2:.*]] = quake.null_wire
// CHECK:           %[[VAL_3:.*]]:2 = cc.if(%[[VAL_0]]) -> (!quake.wire, !quake.wire) {
// CHECK:             %[[VAL_4:.*]]:2 = quake.x [%[[VAL_1]]] %[[VAL_2]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             cc.continue %[[VAL_4]]#0, %[[VAL_4]]#1 : !quake.wire, !quake.wire
// CHECK:           } else {
// CHECK:             %[[VAL_5:.*]]:2 = quake.y [%[[VAL_1]]] %[[VAL_2]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             cc.continue %[[VAL_5]]#0, %[[VAL_5]]#1 : !quake.wire, !quake.wire
// CHECK:           }
// CHECK:           %[[VAL_6:.*]]:2 = quake.z [%[[VAL_3]]#0] %[[VAL_3]]#1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           return
// CHECK:         }

func.func @classical_if02(%c1: i1) {
  %q0 = quake.alloca !quake.ref
  %q1 = quake.alloca !quake.ref
  cc.if (%c1) {
    quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  } else {
    quake.y [%q1] %q0 : (!quake.ref, !quake.ref) -> ()
  }
  quake.z [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.dealloc %q0 : !quake.ref
  quake.dealloc %q1 : !quake.ref
  return
}

// CHECK-LABEL:   func.func @classical_if02(
// CHECK-SAME:                              %[[VAL_0:.*]]: i1) {
// CHECK:           %[[VAL_1:.*]] = quake.null_wire
// CHECK:           %[[VAL_2:.*]] = quake.null_wire
// CHECK:           %[[VAL_3:.*]]:2 = cc.if(%[[VAL_0]]) -> (!quake.wire, !quake.wire) {
// CHECK:             %[[VAL_4:.*]]:2 = quake.x [%[[VAL_1]]] %[[VAL_2]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             cc.continue %[[VAL_4]]#0, %[[VAL_4]]#1 : !quake.wire, !quake.wire
// CHECK:           } else {
// CHECK:             %[[VAL_5:.*]]:2 = quake.y [%[[VAL_2]]] %[[VAL_1]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             cc.continue %[[VAL_5]]#1, %[[VAL_5]]#0 : !quake.wire, !quake.wire
// CHECK:           }
// CHECK:           %[[VAL_6:.*]]:2 = quake.z [%[[VAL_3]]#0] %[[VAL_3]]#1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           return
// CHECK:         }

func.func @classical_if03(%c1: i1) {
  %q0 = quake.alloca !quake.ref
  %q1 = quake.alloca !quake.ref
  cc.if (%c1) {
    quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  }
  quake.y [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.dealloc %q0 : !quake.ref
  quake.dealloc %q1 : !quake.ref
  return
}

// CHECK-LABEL:   func.func @classical_if03(
// CHECK-SAME:                              %[[VAL_0:.*]]: i1) {
// CHECK:           %[[VAL_1:.*]] = quake.null_wire
// CHECK:           %[[VAL_2:.*]] = quake.null_wire
// CHECK:           %[[VAL_3:.*]]:2 = cc.if(%[[VAL_0]]) -> (!quake.wire, !quake.wire) {
// CHECK:             %[[VAL_4:.*]]:2 = quake.x [%[[VAL_1]]] %[[VAL_2]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             cc.continue %[[VAL_4]]#0, %[[VAL_4]]#1 : !quake.wire, !quake.wire
// CHECK:           } else {
// CHECK:             cc.continue %[[VAL_1]], %[[VAL_2]] : !quake.wire, !quake.wire
// CHECK:           }
// CHECK:           %[[VAL_5:.*]]:2 = quake.y [%[[VAL_3]]#0] %[[VAL_3]]#1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           return
// CHECK:         }

func.func @classical_if04(%c1: i1, %c2: i1) {
  %q0 = quake.alloca !quake.ref
  %q1 = quake.alloca !quake.ref
  %q2 = quake.alloca !quake.ref
  cc.if (%c1) {
    quake.h [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
    cc.if (%c2) {
      quake.x [%q0] %q2 : (!quake.ref, !quake.ref) -> ()
    }
  }
  quake.y [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.z [%q0] %q2 : (!quake.ref, !quake.ref) -> ()
  quake.dealloc %q0 : !quake.ref
  quake.dealloc %q1 : !quake.ref
  quake.dealloc %q2 : !quake.ref
  return
}

// CHECK-LABEL:   func.func @classical_if04(
// CHECK-SAME:        %[[VAL_0:.*]]: i1, %[[VAL_1:.*]]: i1) {
// CHECK:           %[[VAL_2:.*]] = quake.null_wire
// CHECK:           %[[VAL_3:.*]] = quake.null_wire
// CHECK:           %[[VAL_4:.*]] = quake.null_wire
// CHECK:           %[[VAL_5:.*]]:3 = cc.if(%[[VAL_0]]) -> (!quake.wire, !quake.wire, !quake.wire) {
// CHECK:             %[[VAL_6:.*]]:2 = quake.h [%[[VAL_2]]] %[[VAL_3]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             %[[VAL_7:.*]]:2 = cc.if(%[[VAL_1]]) -> (!quake.wire, !quake.wire) {
// CHECK:               %[[VAL_8:.*]]:2 = quake.x [%[[VAL_6]]#0] %[[VAL_4]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:               cc.continue %[[VAL_8]]#0, %[[VAL_8]]#1 : !quake.wire, !quake.wire
// CHECK:             } else {
// CHECK:               cc.continue %[[VAL_6]]#0, %[[VAL_4]] : !quake.wire, !quake.wire
// CHECK:             }
// CHECK:             cc.continue %[[VAL_7]]#0, %[[VAL_6]]#1, %[[VAL_7]]#1 : !quake.wire, !quake.wire, !quake.wire
// CHECK:           } else {
// CHECK:             cc.continue %[[VAL_2]], %[[VAL_3]], %[[VAL_4]] : !quake.wire, !quake.wire, !quake.wire
// CHECK:           }
// CHECK:           %[[VAL_10:.*]]:2 = quake.y [%[[VAL_5]]#0] %[[VAL_5]]#1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_12:.*]]:2 = quake.z [%[[VAL_10]]#0] %[[VAL_5]]#2 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           quake.sink %[[VAL_12]]#0
// CHECK:           quake.sink %[[VAL_10]]#1
// CHECK:           quake.sink %[[VAL_12]]#1
// CHECK:           return
// CHECK:         }

func.func @classical_if05(%q0: !quake.ref, %c1: i1) {
  cc.if (%c1) {
    cc.scope {
      %q1 = quake.alloca !quake.ref
      quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
      quake.dealloc %q1 : !quake.ref
    }
    cc.continue
  }
  quake.y %q0 : (!quake.ref) -> ()
  return
}

// CHECK-LABEL:   func.func @classical_if05(
// CHECK-SAME:        %[[VAL_0:.*]]: !quake.ref, %[[VAL_1:.*]]: i1) {
// CHECK:           %[[VAL_2:.*]] = quake.unwrap %[[VAL_0]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_6:.*]] = cc.if(%[[VAL_1]]) -> !quake.wire {
// CHECK:             %[[VAL_7:.*]] = cc.scope -> (!quake.wire) {
// CHECK:               %[[VAL_3:.*]] = quake.null_wire
// CHECK:               %[[VAL_4:.*]]:2 = quake.x [%[[VAL_2]]] %[[VAL_3]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:               quake.sink
// CHECK:               cc.continue %[[VAL_4]]#0
// CHECK:             }
// CHECK:           } else {
// CHECK:           }
// CHECK:           %[[VAL_5:.*]] = quake.y %[[VAL_6]] : (!quake.wire) -> !quake.wire
// CHECK:           quake.wrap %[[VAL_5]] to %[[VAL_0]] : !quake.wire, !quake.ref
// CHECK:           return
// CHECK:         }

func.func @classical_if06(%veq : !quake.veq<2>, %c1: i1) {
  %c_0 = arith.constant 0 : i32
  %q0 = quake.extract_ref %veq[%c_0] : (!quake.veq<2>, i32) -> !quake.ref
  quake.x %q0 : (!quake.ref) -> ()
  cc.if (%c1) {
    %c_1 = arith.constant 1 : i32
    %q1 = quake.extract_ref %veq[%c_1] : (!quake.veq<2>, i32) -> !quake.ref
    quake.y %q1 : (!quake.ref) -> ()
  }
  %reg = quake.mz %veq : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
  return
}

// CHECK-LABEL:   func.func @classical_if06(
// CHECK-SAME:        %[[VAL_0:.*]]: !quake.veq<2>, %[[VAL_1:.*]]: i1) {
// CHECK:           %[[VAL_2:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_3:.*]] = quake.extract_ref %[[VAL_0]][%[[VAL_2]]] : (!quake.veq<2>, i32) -> !quake.ref
// CHECK:           %[[VAL_4:.*]] = quake.unwrap %[[VAL_3]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_5:.*]] = quake.x %[[VAL_4]] : (!quake.wire) -> !quake.wire
// CHECK:           cc.if(%[[VAL_1]]) {
// CHECK:             %[[VAL_6:.*]] = arith.constant 1 : i32
// CHECK:             %[[VAL_7:.*]] = quake.extract_ref %[[VAL_0]][%[[VAL_6]]] : (!quake.veq<2>, i32) -> !quake.ref
// CHECK:             %[[VAL_8:.*]] = quake.unwrap %[[VAL_7]] : (!quake.ref) -> !quake.wire
// CHECK:             %[[VAL_9:.*]] = quake.y %[[VAL_8]] : (!quake.wire) -> !quake.wire
// CHECK:           } else {
// CHECK:           }
// CHECK:           quake.mz %[[VAL_0]] : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
// CHECK:           return
// CHECK:         }

func.func @classical_if07(%veq : !quake.veq<2>, %c1: i1, %c2: i1) {
  %c_0 = arith.constant 0 : i32
  %c_1 = arith.constant 1 : i32
  %q0 = quake.extract_ref %veq[%c_0] : (!quake.veq<2>, i32) -> !quake.ref
  quake.x %q0 : (!quake.ref) -> ()
  cc.if (%c1) {
    %q1 = quake.extract_ref %veq[%c_1] : (!quake.veq<2>, i32) -> !quake.ref
    cc.if (%c2) {
      quake.reset %veq : (!quake.veq<2>) -> ()
    }
  }
  %reg = quake.mz %veq : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
  return
}

// CHECK-LABEL:   func.func @classical_if07(
// CHECK-SAME:        %[[VAL_0:.*]]: !quake.veq<2>, %[[VAL_1:.*]]: i1, %[[VAL_2:.*]]: i1) {
// CHECK:           %[[VAL_3:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_4:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_5:.*]] = quake.extract_ref %[[VAL_0]][%[[VAL_3]]] : (!quake.veq<2>, i32) -> !quake.ref
// CHECK:           %[[VAL_6:.*]] = quake.unwrap %[[VAL_5]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_7:.*]] = quake.x %[[VAL_6]] : (!quake.wire) -> !quake.wire
// CHECK:           cc.if(%[[VAL_1]]) {
// CHECK:             %[[VAL_8:.*]] = quake.extract_ref %[[VAL_0]][%[[VAL_4]]] : (!quake.veq<2>, i32) -> !quake.ref
// CHECK:             %[[VAL_9:.*]] = quake.unwrap %[[VAL_8]] : (!quake.ref) -> !quake.wire
// CHECK:             cc.if(%[[VAL_2]]) {
// CHECK:               quake.reset %[[VAL_0]] : (!quake.veq<2>) -> ()
// CHECK:             } else {
// CHECK:             }
// CHECK:           } else {
// CHECK:           }
// CHECK:           quake.mz %[[VAL_0]] : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
// CHECK:           return
// CHECK:         }

func.func @one_scope() {
  %q0 = quake.alloca !quake.ref
  %q1 = quake.alloca !quake.ref
  cc.scope {
    quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  }
  quake.z [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.dealloc %q0 : !quake.ref
  quake.dealloc %q1 : !quake.ref
  return
}

// CHECK-LABEL:   func.func @one_scope() {
// CHECK:           %[[VAL_0:.*]] = quake.null_wire
// CHECK:           %[[VAL_1:.*]] = quake.null_wire
// CHECK:           %[[VAL_2:.*]]:2 = cc.scope -> (!quake.wire, !quake.wire) {
// CHECK:             %[[VAL_3:.*]]:2 = quake.x [%[[VAL_0]]] %[[VAL_1]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             cc.continue %[[VAL_3]]#0, %[[VAL_3]]#1 : !quake.wire, !quake.wire
// CHECK:           }
// CHECK:           %[[VAL_4:.*]]:2 = quake.z [%[[VAL_2]]#0] %[[VAL_2]]#1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           return
// CHECK:         }

func.func @scope_local_wire() {
  %q0 = quake.alloca !quake.ref
  cc.scope {
    %q1 = quake.alloca !quake.ref
    quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
    quake.y [%q1] %q0 : (!quake.ref, !quake.ref) -> ()
    quake.dealloc %q1 : !quake.ref
  }
  quake.z %q0 : (!quake.ref) -> ()
  quake.dealloc %q0 : !quake.ref
  return
}

// CHECK-LABEL:   func.func @scope_local_wire() {
// CHECK:           %[[VAL_0:.*]] = quake.null_wire
// CHECK:           %[[VAL_1:.*]] = cc.scope -> (!quake.wire) {
// CHECK:             %[[VAL_2:.*]] = quake.null_wire
// CHECK:             %[[VAL_3:.*]]:2 = quake.x [%[[VAL_0]]] %[[VAL_2]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             %[[VAL_4:.*]]:2 = quake.y [%[[VAL_3]]#1] %[[VAL_3]]#0 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             cc.continue %[[VAL_4]]#1 : !quake.wire
// CHECK:           }
// CHECK:           %[[VAL_5:.*]] = quake.z %[[VAL_6:.*]] : (!quake.wire) -> !quake.wire
// CHECK:           return
// CHECK:         }

func.func @nested_scopes() {
  %q0 = quake.alloca  !quake.ref
  %q1 = quake.alloca  !quake.ref
  %q2 = quake.alloca  !quake.ref
  cc.scope {
    quake.h [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
    cc.scope {
      quake.x [%q0] %q2 : (!quake.ref, !quake.ref) -> ()
    }
  }
  quake.y [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.dealloc %q2 : !quake.ref
  quake.dealloc %q1 : !quake.ref
  quake.dealloc %q0 : !quake.ref
  return
}

// CHECK-LABEL:   func.func @nested_scopes() {
// CHECK:           %[[VAL_0:.*]] = quake.null_wire
// CHECK:           %[[VAL_1:.*]] = quake.null_wire
// CHECK:           %[[VAL_2:.*]] = quake.null_wire
// CHECK:           %[[VAL_3:.*]]:3 = cc.scope -> (!quake.wire, !quake.wire, !quake.wire) {
// CHECK:             %[[VAL_4:.*]]:2 = quake.h [%[[VAL_0]]] %[[VAL_1]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             %[[VAL_5:.*]]:2 = cc.scope -> (!quake.wire, !quake.wire) {
// CHECK:               %[[VAL_6:.*]]:2 = quake.x [%[[VAL_4]]#0] %[[VAL_2]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:               cc.continue %[[VAL_6]]#0, %[[VAL_6]]#1 : !quake.wire, !quake.wire
// CHECK:             }
// CHECK:             cc.continue %[[VAL_5]]#0, %[[VAL_4]]#1, %[[VAL_5]]#1 : !quake.wire, !quake.wire, !quake.wire
// CHECK:           }
// CHECK:           %[[VAL_8:.*]]:2 = quake.y [%[[VAL_3]]#0] %[[VAL_3]]#1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           return
// CHECK:         }

func.func @scope_local_extract_and_vec_measurement(%veq : !quake.veq<2>) {
  %c_0 = arith.constant 0 : i32
  %c_1 = arith.constant 1 : i32
  %q0 = quake.extract_ref %veq[%c_0] : (!quake.veq<2>, i32) -> !quake.ref
  cc.scope {
    %q1 = quake.extract_ref %veq[%c_1] : (!quake.veq<2>,i32) -> !quake.ref
    quake.y %q1 : (!quake.ref) -> ()
  }
  %reg = quake.mz %veq : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
  return
}

// CHECK-LABEL:   func.func @scope_local_extract_and_vec_measurement(
// CHECK-SAME:                                  %[[VAL_0:.*]]: !quake.veq<2>) {
// CHECK:           %[[VAL_1:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_2:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_3:.*]] = quake.extract_ref %[[VAL_0]][%[[VAL_1]]] : (!quake.veq<2>, i32) -> !quake.ref
// CHECK:           %[[VAL_4:.*]] = quake.unwrap %[[VAL_3]] : (!quake.ref) -> !quake.wire
// CHECK:           cc.scope {
// CHECK:             %[[VAL_5:.*]] = quake.extract_ref %[[VAL_0]][%[[VAL_2]]] : (!quake.veq<2>, i32) -> !quake.ref
// CHECK:             %[[VAL_6:.*]] = quake.unwrap %[[VAL_5]] : (!quake.ref) -> !quake.wire
// CHECK:             %[[VAL_7:.*]] = quake.y %[[VAL_6]] : (!quake.wire) -> !quake.wire
// CHECK:           }
// CHECK:           quake.mz %[[VAL_0]] : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
// CHECK:           return
// CHECK:         }

func.func @vec_op_in_nested_scope(%veq : !quake.veq<2>) {
  %c_0 = arith.constant 0 : i32
  %q0 = quake.extract_ref %veq[%c_0] : (!quake.veq<2>,i32) -> !quake.ref
  cc.scope {
    cc.scope {
      quake.reset %veq : (!quake.veq<2>)-> ()
    }
  }
  %reg = quake.mz %veq : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
  return
}

// CHECK-LABEL:   func.func @vec_op_in_nested_scope(
// CHECK-SAME:                                      %[[VAL_0:.*]]: !quake.veq<2>) {
// CHECK:           %[[VAL_1:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_2:.*]] = quake.extract_ref %[[VAL_0]][%[[VAL_1]]] : (!quake.veq<2>, i32) -> !quake.ref
// CHECK:           %[[VAL_3:.*]] = quake.unwrap %[[VAL_2]] : (!quake.ref) -> !quake.wire
// CHECK:           cc.scope {
// CHECK:             cc.scope {
// CHECK:               quake.reset %[[VAL_0]] : (!quake.veq<2>) -> ()
// CHECK:             }
// CHECK:           }
// CHECK:           quake.mz %[[VAL_0]] : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
// CHECK:           return
// CHECK:         }

func.func @vec_op_in_nested_scope_and_local_extraction(%veq : !quake.veq<2>) {
  %c_0 = arith.constant 0 : i32
  %c_1 = arith.constant 1 : i32
  %q0 = quake.extract_ref %veq[%c_0] : (!quake.veq<2>,i32) -> !quake.ref
  cc.scope {
    cc.scope {
      %q1 = quake.extract_ref %veq[%c_1] : (!quake.veq<2>,i32) -> !quake.ref
      quake.reset %veq : (!quake.veq<2>) -> ()
    }
  }
  %reg = quake.mz %veq : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
  return
}

// CHECK-LABEL:   func.func @vec_op_in_nested_scope_and_local_extraction(
// CHECK-SAME:                                                           %[[VAL_0:.*]]: !quake.veq<2>) {
// CHECK:           %[[VAL_1:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_2:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_3:.*]] = quake.extract_ref %[[VAL_0]][%[[VAL_1]]] : (!quake.veq<2>, i32) -> !quake.ref
// CHECK:           %[[VAL_4:.*]] = quake.unwrap %[[VAL_3]] : (!quake.ref) -> !quake.wire
// CHECK:           cc.scope {
// CHECK:             cc.scope {
// CHECK:               %[[VAL_5:.*]] = quake.extract_ref %[[VAL_0]][%[[VAL_2]]] : (!quake.veq<2>, i32) -> !quake.ref
// CHECK:               %[[VAL_6:.*]] = quake.unwrap %[[VAL_5]] : (!quake.ref) -> !quake.wire
// CHECK:               quake.reset %[[VAL_0]] : (!quake.veq<2>) -> ()
// CHECK:             }
// CHECK:           }
// CHECK:           quake.mz %[[VAL_0]] : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
// CHECK:           return
// CHECK:         }

func.func @raw_cfg01() {
  %q0 = quake.alloca !quake.ref
  %q1 = quake.alloca !quake.ref
  quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  cf.br ^bb1
^bb1:
  quake.y [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  cf.br ^bb2
^bb2:
  quake.z [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.dealloc %q1 : !quake.ref
  quake.dealloc %q0 : !quake.ref
  return
}

// CHECK-LABEL:   func.func @raw_cfg01() {
// CHECK:           %[[VAL_0:.*]] = quake.null_wire
// CHECK:           %[[VAL_1:.*]] = quake.null_wire
// CHECK:           %[[VAL_2:.*]]:2 = quake.x [%[[VAL_0]]] %[[VAL_1]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           cf.br ^bb1(%[[VAL_2]]#0, %[[VAL_2]]#1 : !quake.wire, !quake.wire)
// CHECK:         ^bb1(%[[VAL_3:.*]]: !quake.wire, %[[VAL_4:.*]]: !quake.wire):
// CHECK:           %[[VAL_5:.*]]:2 = quake.y [%[[VAL_3]]] %[[VAL_4]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           cf.br ^bb2(%[[VAL_5]]#0, %[[VAL_5]]#1 : !quake.wire, !quake.wire)
// CHECK:         ^bb2(%[[VAL_6:.*]]: !quake.wire, %[[VAL_7:.*]]: !quake.wire):
// CHECK:           %[[VAL_8:.*]]:2 = quake.z [%[[VAL_6]]] %[[VAL_7]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           return
// CHECK:         }

func.func @raw_cfg02(%q0: !quake.ref, %q1: !quake.ref, %c1: i1) {
  cf.cond_br %c1, ^bb1, ^bb2
^bb1:
  quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  cf.br ^bb3
^bb2:
  quake.y [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  cf.br ^bb3
^bb3:
  quake.z [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  return
}

// CHECK-LABEL:   func.func @raw_cfg02(
// CHECK-SAME:        %[[VAL_0:.*]]: !quake.ref, %[[VAL_1:.*]]: !quake.ref, %[[VAL_2:.*]]: i1) {
// CHECK:           %[[VAL_3:.*]] = quake.unwrap %[[VAL_1]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_4:.*]] = quake.unwrap %[[VAL_0]] : (!quake.ref) -> !quake.wire
// CHECK:           cf.cond_br %[[VAL_2]], ^bb1(%[[VAL_4]], %[[VAL_3]] : !quake.wire, !quake.wire), ^bb2(%[[VAL_4]], %[[VAL_3]] : !quake.wire, !quake.wire)
// CHECK:         ^bb1(%[[VAL_5:.*]]: !quake.wire, %[[VAL_6:.*]]: !quake.wire):
// CHECK:           %[[VAL_7:.*]]:2 = quake.x [%[[VAL_5]]] %[[VAL_6]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           cf.br ^bb3(%[[VAL_7]]#0, %[[VAL_7]]#1 : !quake.wire, !quake.wire)
// CHECK:         ^bb2(%[[VAL_8:.*]]: !quake.wire, %[[VAL_9:.*]]: !quake.wire):
// CHECK:           %[[VAL_10:.*]]:2 = quake.y [%[[VAL_8]]] %[[VAL_9]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           cf.br ^bb3(%[[VAL_10]]#0, %[[VAL_10]]#1 : !quake.wire, !quake.wire)
// CHECK:         ^bb3(%[[VAL_11:.*]]: !quake.wire, %[[VAL_12:.*]]: !quake.wire):
// CHECK:           %[[VAL_13:.*]]:2 = quake.z [%[[VAL_11]]] %[[VAL_12]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           quake.wrap %[[VAL_13]]#1 to %[[VAL_1]] : !quake.wire, !quake.ref
// CHECK:           return
// CHECK:         }

func.func @raw_cfg03(%q0: !quake.ref, %q1: !quake.ref, %c1: i1) {
  quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  cf.br ^bb1
^bb1:
  quake.y [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  cf.cond_br %c1, ^bb1, ^bb2
^bb2:
  quake.z [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  return
}

// CHECK-LABEL:   func.func @raw_cfg03(
// CHECK-SAME:        %[[VAL_0:.*]]: !quake.ref, %[[VAL_1:.*]]: !quake.ref, %[[VAL_2:.*]]: i1) {
// CHECK:           %[[VAL_3:.*]] = quake.unwrap %[[VAL_1]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_4:.*]] = quake.unwrap %[[VAL_0]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_5:.*]]:2 = quake.x [%[[VAL_4]]] %[[VAL_3]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           cf.br ^bb1(%[[VAL_5]]#0, %[[VAL_5]]#1 : !quake.wire, !quake.wire)
// CHECK:         ^bb1(%[[VAL_6:.*]]: !quake.wire, %[[VAL_7:.*]]: !quake.wire):
// CHECK:           %[[VAL_8:.*]]:2 = quake.y [%[[VAL_6]]] %[[VAL_7]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           cf.cond_br %[[VAL_2]], ^bb1(%[[VAL_8]]#0, %[[VAL_8]]#1 : !quake.wire, !quake.wire), ^bb2(%[[VAL_8]]#0, %[[VAL_8]]#1 : !quake.wire, !quake.wire)
// CHECK:         ^bb2(%[[VAL_9:.*]]: !quake.wire, %[[VAL_10:.*]]: !quake.wire):
// CHECK:           %[[VAL_11:.*]]:2 = quake.z [%[[VAL_9]]] %[[VAL_10]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           quake.wrap %[[VAL_11]]#1 to %[[VAL_1]] : !quake.wire, !quake.ref
// CHECK:           return
// CHECK:         }

func.func @raw_cfg04(%q0: !quake.ref, %q1: !quake.ref, %c1: i1) {
  cf.cond_br %c1, ^bb1, ^bb2
^bb1:
  quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  return
^bb2:
  quake.y [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  return
}

// CHECK-LABEL:   func.func @raw_cfg04(
// CHECK-SAME:        %[[VAL_0:.*]]: !quake.ref, %[[VAL_1:.*]]: !quake.ref, %[[VAL_2:.*]]: i1) {
// CHECK:           %[[VAL_3:.*]] = quake.unwrap %[[VAL_1]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_4:.*]] = quake.unwrap %[[VAL_0]] : (!quake.ref) -> !quake.wire
// CHECK:           cf.cond_br %[[VAL_2]], ^bb1(%[[VAL_4]], %[[VAL_3]] : !quake.wire, !quake.wire), ^bb2(%[[VAL_4]], %[[VAL_3]] : !quake.wire, !quake.wire)
// CHECK:         ^bb1(%[[VAL_5:.*]]: !quake.wire, %[[VAL_6:.*]]: !quake.wire):
// CHECK:           %[[VAL_7:.*]]:2 = quake.x [%[[VAL_5]]] %[[VAL_6]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           quake.wrap %[[VAL_7]]#1 to %[[VAL_1]] : !quake.wire, !quake.ref
// CHECK:           return
// CHECK:         ^bb2(%[[VAL_8:.*]]: !quake.wire, %[[VAL_9:.*]]: !quake.wire):
// CHECK:           %[[VAL_10:.*]]:2 = quake.y [%[[VAL_8]]] %[[VAL_9]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           quake.wrap %[[VAL_10]]#1 to %[[VAL_1]] : !quake.wire, !quake.ref
// CHECK:           return
// CHECK:         }

func.func @raw_cfg05(%c1: i1) {
  %c0_i64 = arith.constant 0 : i64
  %veq = quake.alloca !quake.veq<2>
  cf.cond_br %c1, ^bb1, ^bb2
^bb1:
  %q0 = quake.extract_ref %veq[%c0_i64] : (!quake.veq<2>, i64) -> !quake.ref
  cf.br ^bb3
^bb2:
  cf.br ^bb3
^bb3:
  %reg = quake.mz %veq: (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
  quake.dealloc %veq : !quake.veq<2>
  return
}

// CHECK-LABEL:   func.func @raw_cfg05(
// CHECK-SAME:                         %[[VAL_0:.*]]: i1) {
// CHECK:           %[[VAL_1:.*]] = arith.constant 0 : i64
// CHECK:           %[[VAL_2:.*]] = quake.alloca !quake.veq<2>
// CHECK:           cf.cond_br %[[VAL_0]], ^bb1, ^bb2
// CHECK:         ^bb1:
// CHECK:           %[[VAL_3:.*]] = quake.extract_ref %[[VAL_2]][%[[VAL_1]]] : (!quake.veq<2>, i64) -> !quake.ref
// CHECK:           %[[VAL_4:.*]] = quake.unwrap %[[VAL_3]] : (!quake.ref) -> !quake.wire
// CHECK:           cf.br ^bb3
// CHECK:         ^bb2:
// CHECK:           cf.br ^bb3
// CHECK:         ^bb3:
// CHECK:           quake.mz %[[VAL_2]] : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
// CHECK:           return
// CHECK:         }

func.func @raw_cfg06(%c1: i1) {
  %c0_i64 = arith.constant 0 : i64
  %c1_i64 = arith.constant 1 : i64
  %veq = quake.alloca !quake.veq<2>
  %q0 = quake.extract_ref %veq[%c0_i64] : (!quake.veq<2>, i64) -> !quake.ref
  cf.cond_br %c1, ^bb1, ^bb4
^bb1:
  %q1 = quake.extract_ref %veq[%c1_i64] : (!quake.veq<2>, i64) -> !quake.ref
  cf.cond_br %c1, ^bb2, ^bb3
^bb2:
  cf.br ^bb5
^bb3:
  cf.br ^bb5
^bb4:
  %q2 = quake.extract_ref %veq[%c1_i64] : (!quake.veq<2>, i64) -> !quake.ref
  cf.br ^bb5
^bb5:
  %reg = quake.mz %veq: (!quake.veq<2>)-> !cc.stdvec<!quake.measure>
  quake.dealloc %veq : !quake.veq<2>
  return
}

// CHECK-LABEL:   func.func @raw_cfg06(
// CHECK-SAME:                         %[[VAL_0:.*]]: i1) {
// CHECK:           %[[VAL_1:.*]] = arith.constant 0 : i64
// CHECK:           %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK:           %[[VAL_3:.*]] = quake.alloca !quake.veq<2>
// CHECK:           %[[VAL_4:.*]] = quake.extract_ref %[[VAL_3]][%[[VAL_1]]] : (!quake.veq<2>, i64) -> !quake.ref
// CHECK:           %[[VAL_5:.*]] = quake.unwrap %[[VAL_4]] : (!quake.ref) -> !quake.wire
// CHECK:           cf.cond_br %[[VAL_0]], ^bb1, ^bb4
// CHECK:         ^bb1:
// CHECK:           %[[VAL_6:.*]] = quake.extract_ref %[[VAL_3]][%[[VAL_2]]] : (!quake.veq<2>, i64) -> !quake.ref
// CHECK:           %[[VAL_7:.*]] = quake.unwrap %[[VAL_6]] : (!quake.ref) -> !quake.wire
// CHECK:           cf.cond_br %[[VAL_0]], ^bb2, ^bb3
// CHECK:         ^bb2:
// CHECK:           cf.br ^bb5
// CHECK:         ^bb3:
// CHECK:           cf.br ^bb5
// CHECK:         ^bb4:
// CHECK:           %[[VAL_8:.*]] = quake.extract_ref %[[VAL_3]][%[[VAL_2]]] : (!quake.veq<2>, i64) -> !quake.ref
// CHECK:           %[[VAL_9:.*]] = quake.unwrap %[[VAL_8]] : (!quake.ref) -> !quake.wire
// CHECK:           cf.br ^bb5
// CHECK:         ^bb5:
// CHECK:           quake.mz %[[VAL_3]] : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
// CHECK:           return
// CHECK:         }

func.func @raw_cfg07(%c1: i1) {
  %c0_i64 = arith.constant 0 : i64
  %c1_i64 = arith.constant 1 : i64
  %veq = quake.alloca !quake.veq<2>
  %q0 = quake.extract_ref %veq[%c0_i64] : (!quake.veq<2>, i64) -> !quake.ref
  cf.cond_br %c1, ^bb1, ^bb2
^bb1:
  %q1 = quake.extract_ref %veq[%c0_i64] : (!quake.veq<2>, i64) -> !quake.ref
  cf.br ^bb3
^bb2:
  quake.reset %veq: (!quake.veq<2>)->()
  cf.br ^bb3
^bb3:
  %reg = quake.mz %veq: (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
  quake.dealloc %veq : !quake.veq<2>
  return
}

// CHECK-LABEL:   func.func @raw_cfg07(
// CHECK-SAME:                         %[[VAL_0:.*]]: i1) {
// CHECK:           %[[VAL_1:.*]] = arith.constant 0 : i64
// CHECK:           %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK:           %[[VAL_3:.*]] = quake.alloca !quake.veq<2>
// CHECK:           %[[VAL_4:.*]] = quake.extract_ref %[[VAL_3]][%[[VAL_1]]] : (!quake.veq<2>, i64) -> !quake.ref
// CHECK:           %[[VAL_5:.*]] = quake.unwrap %[[VAL_4]] : (!quake.ref) -> !quake.wire
// CHECK:           cf.cond_br %[[VAL_0]], ^bb1, ^bb2
// CHECK:         ^bb1:
// CHECK:           %[[VAL_6:.*]] = quake.extract_ref %[[VAL_3]][%[[VAL_1]]] : (!quake.veq<2>, i64) -> !quake.ref
// CHECK:           %[[VAL_7:.*]] = quake.unwrap %[[VAL_6]] : (!quake.ref) -> !quake.wire
// CHECK:           cf.br ^bb3
// CHECK:         ^bb2:
// CHECK:           quake.reset %[[VAL_3]] : (!quake.veq<2>) -> ()
// CHECK:           cf.br ^bb3
// CHECK:         ^bb3:
// CHECK:           quake.mz %[[VAL_3]] : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
// CHECK:           return
// CHECK:         }

func.func @alloc_dealloc_veq_with_extracted_refs() {
  %veq = quake.alloca  !quake.veq<2>
  %q0 = quake.extract_ref %veq[0] : (!quake.veq<2>) -> !quake.ref
  %q1 = quake.extract_ref %veq[1] : (!quake.veq<2>) -> !quake.ref
  quake.dealloc %veq : !quake.veq<2>
  return
}

// CHECK-LABEL:   func.func @alloc_dealloc_veq_with_extracted_refs() {
// CHECK:           %[[VAL_1:.*]] = quake.alloca !quake.veq<2>
// CHECK:           %[[VAL_2:.*]] = quake.extract_ref %[[VAL_1]][0] : (!quake.veq<2>) -> !quake.ref
// CHECK:           %[[VAL_5:.*]] = quake.unwrap %[[VAL_2]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_3:.*]] = quake.extract_ref %[[VAL_1]][1] : (!quake.veq<2>) -> !quake.ref
// CHECK:           %[[VAL_4:.*]] = quake.unwrap %[[VAL_3]] : (!quake.ref) -> !quake.wire
// CHECK:           quake.dealloc %[[VAL_1]] : !quake.veq<2>
// CHECK:           return
// CHECK:         }

func.func @apply_one_target_operators(%q0: !quake.ref, %q1: !quake.ref) {
  quake.h [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.s [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.t [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.x [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.y [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  quake.z [%q0] %q1 : (!quake.ref, !quake.ref) -> ()
  return
}

// CHECK-LABEL:   func.func @apply_one_target_operators(
// CHECK-SAME:        %[[VAL_0:.*]]: !quake.ref, %[[VAL_1:.*]]: !quake.ref) {
// CHECK:           %[[VAL_2:.*]] = quake.unwrap %[[VAL_1]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_3:.*]] = quake.unwrap %[[VAL_0]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_4:.*]]:2 = quake.h [%[[VAL_3]]] %[[VAL_2]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_5:.*]]:2 = quake.s [%[[VAL_4]]#0] %[[VAL_4]]#1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_6:.*]]:2 = quake.t [%[[VAL_5]]#0] %[[VAL_5]]#1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_7:.*]]:2 = quake.x [%[[VAL_6]]#0] %[[VAL_6]]#1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_8:.*]]:2 = quake.y [%[[VAL_7]]#0] %[[VAL_7]]#1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_9:.*]]:2 = quake.z [%[[VAL_8]]#0] %[[VAL_8]]#1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           quake.wrap %[[VAL_9]]#1 to %[[VAL_1]] : !quake.wire, !quake.ref
// CHECK:           return
// CHECK:         }

func.func @apply_parametrized_one_target_operators() {
  %angle = arith.constant 3.14 : f64
  %q0 = quake.alloca !quake.ref
  %q1 = quake.alloca !quake.ref
  quake.r1 (%angle) [%q1] %q0 : (f64, !quake.ref, !quake.ref) -> ()
  quake.rx (%angle) [%q1] %q0 : (f64, !quake.ref, !quake.ref) -> ()
  quake.ry (%angle) [%q1] %q0 : (f64, !quake.ref, !quake.ref) -> ()
  quake.rz (%angle) [%q1] %q0 : (f64, !quake.ref, !quake.ref) -> ()
  quake.dealloc %q0 : !quake.ref
  quake.dealloc %q1 : !quake.ref
  return
}

// CHECK-LABEL:   func.func @apply_parametrized_one_target_operators() {
// CHECK:           %[[VAL_0:.*]] = arith.constant 3.140000e+00 : f64
// CHECK:           %[[VAL_1:.*]] = quake.null_wire
// CHECK:           %[[VAL_2:.*]] = quake.null_wire
// CHECK:           %[[VAL_3:.*]]:2 = quake.r1 (%[[VAL_0]]) [%[[VAL_2]]] %[[VAL_1]] : (f64, !quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_4:.*]]:2 = quake.rx (%[[VAL_0]]) [%[[VAL_3]]#0] %[[VAL_3]]#1 : (f64, !quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_5:.*]]:2 = quake.ry (%[[VAL_0]]) [%[[VAL_4]]#0] %[[VAL_4]]#1 : (f64, !quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_6:.*]]:2 = quake.rz (%[[VAL_0]]) [%[[VAL_5]]#0] %[[VAL_5]]#1 : (f64, !quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           return
// CHECK:         }

func.func @qextract_and_apply_controlled_two_targets_operator() {
  %c_0 = arith.constant 0 : i32
  %c_1 = arith.constant 1 : i32
  %c_2 = arith.constant 2 : i32
  %0 = quake.alloca !quake.veq<3>
  %q0 = quake.extract_ref %0 [%c_0] : (!quake.veq<3>,i32) -> !quake.ref
  %q1 = quake.extract_ref %0 [%c_1] : (!quake.veq<3>,i32) -> !quake.ref
  %q2 = quake.extract_ref %0 [%c_2] : (!quake.veq<3>,i32) -> !quake.ref
  quake.swap [%q2] %q0, %q1 : (!quake.ref,!quake.ref,!quake.ref) -> ()
  quake.dealloc %0 : !quake.veq<3>
  return
}

// CHECK-LABEL:   func.func @qextract_and_apply_controlled_two_targets_operator() {
// CHECK:           %[[VAL_0:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_1:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_2:.*]] = arith.constant 2 : i32
// CHECK:           %[[VAL_3:.*]] = quake.alloca !quake.veq<3>
// CHECK:           %[[VAL_4:.*]] = quake.extract_ref %[[VAL_3]][%[[VAL_0]]] : (!quake.veq<3>, i32) -> !quake.ref
// CHECK:           %[[VAL_5:.*]] = quake.unwrap %[[VAL_4]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_6:.*]] = quake.extract_ref %[[VAL_3]][%[[VAL_1]]] : (!quake.veq<3>, i32) -> !quake.ref
// CHECK:           %[[VAL_7:.*]] = quake.unwrap %[[VAL_6]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_8:.*]] = quake.extract_ref %[[VAL_3]][%[[VAL_2]]] : (!quake.veq<3>, i32) -> !quake.ref
// CHECK:           %[[VAL_9:.*]] = quake.unwrap %[[VAL_8]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_10:.*]]:3 = quake.swap [%[[VAL_9]]] %[[VAL_5]], %[[VAL_7]] : (!quake.wire, !quake.wire, !quake.wire) -> (!quake.wire, !quake.wire, !quake.wire)
// CHECK:           return
// CHECK:         }

func.func @mz_and_reset_veq_with_extracted_refs() {
  %c_0 = arith.constant 0 : i32
  %c_1 = arith.constant 1 : i32
  %0 = quake.alloca !quake.veq<2>
  %q0 = quake.extract_ref %0[%c_0] : (!quake.veq<2>, i32) -> !quake.ref
  %q1 = quake.extract_ref %0[%c_1] : (!quake.veq<2>, i32) -> !quake.ref
  %reg = quake.mz %0 : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
  quake.reset %0 : (!quake.veq<2>) -> ()
  quake.dealloc %0 : !quake.veq<2>
  return
}

// CHECK-LABEL:   func.func @mz_and_reset_veq_with_extracted_refs() {
// CHECK:           %[[VAL_0:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_1:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_2:.*]] = quake.alloca !quake.veq<2>
// CHECK:           %[[VAL_3:.*]] = quake.extract_ref %[[VAL_2]][%[[VAL_0]]] : (!quake.veq<2>, i32) -> !quake.ref
// CHECK:           %[[VAL_4:.*]] = quake.unwrap %[[VAL_3]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_5:.*]] = quake.extract_ref %[[VAL_2]][%[[VAL_1]]] : (!quake.veq<2>, i32) -> !quake.ref
// CHECK:           %[[VAL_6:.*]] = quake.unwrap %[[VAL_5]] : (!quake.ref) -> !quake.wire
// CHECK:           quake.mz %[[VAL_2]] : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
// CHECK:           quake.reset %[[VAL_2]] : (!quake.veq<2>) -> ()
// CHECK:           return
// CHECK:         }

func.func @simple_loop() {
  %c0_i64 = arith.constant 0 : i64
  %c1_i64 = arith.constant 1 : i64
  %c42_i64 = arith.constant 42 : i64
  %q0 = quake.alloca !quake.ref
  // memtoreg does not promote memref types.
  %alloca = memref.alloca() : memref<i64>
  memref.store %c0_i64, %alloca[] : memref<i64>
  cc.loop while {
    %1 = memref.load %alloca[] : memref<i64>
    %2 = arith.cmpi ult, %1, %c42_i64 : i64
    cc.condition %2
  } do {
    quake.x %q0 : (!quake.ref) -> ()
    cc.continue
  } step {
    %1 = memref.load %alloca[] : memref<i64>
    %2 = arith.addi %1, %c1_i64 : i64
    memref.store %2, %alloca[] : memref<i64>
  }
  quake.z %q0 : (!quake.ref) -> ()
  quake.dealloc %q0 : !quake.ref
  return
}

// CHECK-LABEL:   func.func @simple_loop() {
// CHECK:           %[[VAL_0:.*]] = arith.constant 0 : i64
// CHECK:           %[[VAL_1:.*]] = arith.constant 1 : i64
// CHECK:           %[[VAL_2:.*]] = arith.constant 42 : i64
// CHECK:           %[[VAL_3:.*]] = quake.null_wire
// CHECK:           %[[VAL_4:.*]] = memref.alloca() : memref<i64>
// CHECK:           memref.store %[[VAL_0]], %[[VAL_4]][] : memref<i64>
// CHECK:           %[[VAL_5:.*]] = cc.loop while ((%[[VAL_6:.*]] = %[[VAL_3]]) -> (!quake.wire)) {
// CHECK:             %[[VAL_7:.*]] = memref.load %[[VAL_4]][] : memref<i64>
// CHECK:             %[[VAL_8:.*]] = arith.cmpi ult, %[[VAL_7]], %[[VAL_2]] : i64
// CHECK:             cc.condition %[[VAL_8]](%[[VAL_6]] : !quake.wire)
// CHECK:           } do {
// CHECK:           ^bb0(%[[VAL_9:.*]]: !quake.wire):
// CHECK:             %[[VAL_10:.*]] = quake.x %[[VAL_9]] : (!quake.wire) -> !quake.wire
// CHECK:             cc.continue %[[VAL_10]] : !quake.wire
// CHECK:           } step {
// CHECK:           ^bb0(%[[VAL_11:.*]]: !quake.wire):
// CHECK:             %[[VAL_12:.*]] = memref.load %[[VAL_4]][] : memref<i64>
// CHECK:             %[[VAL_13:.*]] = arith.addi %[[VAL_12]], %[[VAL_1]] : i64
// CHECK:             memref.store %[[VAL_13]], %[[VAL_4]][] : memref<i64>
// CHECK:             cc.continue %[[VAL_11]] : !quake.wire
// CHECK:           }
// CHECK:           %[[VAL_14:.*]] = quake.z %[[VAL_15:.*]] : (!quake.wire) -> !quake.wire
// CHECK:           return
// CHECK:         }

func.func @floop_with_vector_and_qextract() {
  %c0_i64 = arith.constant 0 : i64
  %c1_i64 = arith.constant 1 : i64
  %c2_i64 = arith.constant 2 : i64
  %veq = quake.alloca  !quake.veq<2>
  %q0 = quake.extract_ref %veq[%c0_i64] : (!quake.veq<2> ,i64) -> !quake.ref
  %alloca = memref.alloca() : memref<i64>
  memref.store %c0_i64, %alloca[] : memref<i64>
  cc.loop while {
    %3 = memref.load %alloca[] : memref<i64>
    %4 = arith.cmpi ult, %3, %c2_i64 : i64
    cc.condition %4
  } do {
    %3 = memref.load %alloca[] : memref<i64>
    %4 = quake.extract_ref %veq[%3] : (!quake.veq<2> ,i64) -> !quake.ref
    cc.continue
  } step {
    %3 = memref.load %alloca[] : memref<i64>
    %4 = arith.addi %3, %c1_i64 : i64
    memref.store %4, %alloca[] : memref<i64>
  }
  %2 = quake.mz %veq : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
  quake.dealloc %veq : !quake.veq<2>
  return
}


// CHECK-LABEL:   func.func @floop_with_vector_and_qextract() {
// CHECK:           %[[VAL_0:.*]] = arith.constant 0 : i64
// CHECK:           %[[VAL_1:.*]] = arith.constant 1 : i64
// CHECK:           %[[VAL_2:.*]] = arith.constant 2 : i64
// CHECK:           %[[VAL_3:.*]] = quake.alloca !quake.veq<2>
// CHECK:           %[[VAL_4:.*]] = quake.extract_ref %[[VAL_3]][%[[VAL_0]]] : (!quake.veq<2>, i64) -> !quake.ref
// CHECK:           %[[VAL_5:.*]] = quake.unwrap %[[VAL_4]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_6:.*]] = memref.alloca() : memref<i64>
// CHECK:           memref.store %[[VAL_0]], %[[VAL_6]][] : memref<i64>
// CHECK:           cc.loop while {
// CHECK:             %[[VAL_7:.*]] = memref.load %[[VAL_6]][] : memref<i64>
// CHECK:             %[[VAL_8:.*]] = arith.cmpi ult, %[[VAL_7]], %[[VAL_2]] : i64
// CHECK:             cc.condition %[[VAL_8]]
// CHECK:           } do {
// CHECK:             %[[VAL_9:.*]] = memref.load %[[VAL_6]][] : memref<i64>
// CHECK:             %[[VAL_10:.*]] = quake.extract_ref %[[VAL_3]][%[[VAL_9]]] : (!quake.veq<2>, i64) -> !quake.ref
// CHECK:             %[[VAL_11:.*]] = quake.unwrap %[[VAL_10]] : (!quake.ref) -> !quake.wire
// CHECK:             cc.continue
// CHECK:           } step {
// CHECK:             %[[VAL_12:.*]] = memref.load %[[VAL_6]][] : memref<i64>
// CHECK:             %[[VAL_13:.*]] = arith.addi %[[VAL_12]], %[[VAL_1]] : i64
// CHECK:             memref.store %[[VAL_13]], %[[VAL_6]][] : memref<i64>
// CHECK:           }
// CHECK:           quake.mz %[[VAL_3]] : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
// CHECK:           return
// CHECK:         }

