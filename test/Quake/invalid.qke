// ========================================================================== //
// Copyright (c) 2022 - 2024 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt %s -split-input-file -verify-diagnostics

func.func @test_struq() {
  %0 = quake.alloca !quake.veq<4>
  %1 = arith.constant 1 : i32
  %2 = arith.constant 2.0 : f32
  // expected-error@+2 {{invalid struq member type}}
  // expected-error@+1 {{must be non-struct quantum reference type}}
  %6 = quake.make_struq %0, %1, %2 : (!quake.veq<4>, i32, f32) -> !quake.struq<!quake.veq<?>, i32, f32>
  return
}

// -----

func.func @test_struq() {
  %0 = quake.alloca !quake.veq<4>
  %1 = quake.alloca !quake.veq<7>
  // expected-error@+1 {{member type not compatible with operand type}}
  %6 = quake.make_struq %0, %1 : (!quake.veq<4>, !quake.veq<7>) -> !quake.struq<!quake.veq<3>, !quake.veq<8>>
  return
}

// -----

func.func @test_struq() {
  %0 = quake.alloca !quake.veq<4>
  %1 = quake.alloca !quake.veq<7>
  // expected-error@+1 {{result type has different member count than operands}}
  %6 = quake.make_struq %0, %1 : (!quake.veq<4>, !quake.veq<7>) -> !quake.struq<!quake.veq<?>>
  return
}

// -----

func.func @test_struq() {
  %0 = quake.alloca !quake.veq<4>
  %1 = quake.alloca !quake.veq<7>
  // expected-error@+1 {{result type has different member count than operands}}
  %6 = quake.make_struq %0, %1 : (!quake.veq<4>, !quake.veq<7>) -> !quake.struq<!quake.veq<?>, !quake.veq<?>, !quake.veq<?>>
  return
}

// -----

func.func @test_struq(%arg : !quake.struq<!quake.veq<1>, !quake.veq<2>, !quake.veq<3>>) {
  // expected-error@+1 {{invalid index}}
  %6 = quake.get_member %arg[3] : (!quake.struq<!quake.veq<1>, !quake.veq<2>, !quake.veq<3>>) -> !quake.veq<1>
  return
}

// -----

func.func @test_struq() {
  // expected-error@+1 {{struq type must have specified size}}
  %0 = quake.alloca !quake.struq<!quake.veq<1>, !quake.veq<?>>
  return
}

// -----

func.func @test_struq() {
  // expected-error@+1 {{invalid struq member type}}
  %0 = quake.alloca !quake.struq<!quake.struq<!quake.veq<3>, !quake.ref>, !quake.veq<7>>
  return
}

// -----

func.func @test_subveq(%0: !quake.veq<2>) {
  // expected-error@+1 {{does not fully intersect}}
  %1 = quake.subveq %0, 10, 10 : (!quake.veq<2>) -> !quake.veq<1>
  return
}

// -----

func.func @test_subveq(%0: !quake.veq<?>) {
  // expected-error@+1 {{invalid subrange specified}}
  %1 = quake.subveq %0, 10, 4 : (!quake.veq<?>) -> !quake.veq<?>
  return
}

// -----

func.func @test_subveq(%0: !quake.veq<?>) {
  // expected-error@+1 {{incorrect size for result}}
  %1 = quake.subveq %0, 8, 35 : (!quake.veq<?>) -> !quake.veq<1>
  return
}
