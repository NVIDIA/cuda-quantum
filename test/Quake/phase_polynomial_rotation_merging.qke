// ========================================================================== //
// Copyright (c) 2025 NVIDIA Corporation & Affiliates.                        //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt --phase-polynomial-rotation-merging %s | FileCheck %s

func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: f64) attributes {num_cnots = 3 : ui32, subcircuit} {
    quake.rz (%arg2) %arg1 : (f64, !quake.ref) -> ()
    quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
    quake.rz (%arg2) %arg1 : (f64, !quake.ref) -> ()
    quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
    quake.rz (%arg2) %arg0 : (f64, !quake.ref) -> ()
    quake.rz (%arg2) %arg1 : (f64, !quake.ref) -> ()
    quake.x [%arg1] %arg0 : (!quake.ref, !quake.ref) -> ()
    cc.return
}

// CHECK-LABEL: func.func private @subcircuit0(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: f64) attributes {num_cnots = 3 : ui32, subcircuit} {
// CHECK:     %0 = arith.addf %arg2, %arg2 : f64
// CHECK:     quake.rz (%0) %arg1 : (f64, !quake.ref) -> ()
// CHECK:     quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:     quake.rz (%arg2) %arg1 : (f64, !quake.ref) -> ()
// CHECK:     quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:     quake.rz (%arg2) %arg0 : (f64, !quake.ref) -> ()
// CHECK:     quake.x [%arg1] %arg0 : (!quake.ref, !quake.ref) -> ()
// CHECK:     cc.return
// CHECK: }

func.func private @subcircuit1(%arg0: !quake.ref, %arg1: f64, %arg2: f64, %arg3: f64) attributes {num_cnots = 0 : ui32, subcircuit} {
    quake.rz (%arg1) %arg0 : (f64, !quake.ref) -> ()
    quake.x %arg0 : (!quake.ref) -> ()
    quake.rz (%arg2) %arg0 : (f64, !quake.ref) -> ()
    quake.x %arg0 : (!quake.ref) -> ()
    quake.rz (%arg3) %arg0 : (f64, !quake.ref) -> ()
    cc.return
}

// CHECK-LABEL: func.func private @subcircuit1(%arg0: !quake.ref, %arg1: f64, %arg2: f64, %arg3: f64) attributes {num_cnots = 0 : ui32, subcircuit} {
// CHECK:     %0 = arith.addf %arg1, %arg3 : f64
// CHECK:     quake.rz (%0) %arg0 : (f64, !quake.ref) -> ()
// CHECK:     quake.x %arg0 : (!quake.ref) -> ()
// CHECK:     quake.rz (%arg2) %arg0 : (f64, !quake.ref) -> ()
// CHECK:     quake.x %arg0 : (!quake.ref) -> ()
// CHECK:     cc.return
// CHECK: }

// Invalid subcircuit functions shouldn't be touched

func.func private @subcircuit2(%arg0: !quake.ref, %arg1: f64, %arg2: f64, %arg3: f64) attributes {num_cnots = 0 : ui32} {
    quake.rz (%arg1) %arg0 : (f64, !quake.ref) -> ()
    quake.x %arg0 : (!quake.ref) -> ()
    quake.rz (%arg2) %arg0 : (f64, !quake.ref) -> ()
    quake.x %arg0 : (!quake.ref) -> ()
    quake.rz (%arg3) %arg0 : (f64, !quake.ref) -> ()
    cc.return
}

// CHECK-LABEL: func.func private @subcircuit2(%arg0: !quake.ref, %arg1: f64, %arg2: f64, %arg3: f64) attributes {num_cnots = 0 : ui32} {
// CHECK:     quake.rz (%arg1) %arg0 : (f64, !quake.ref) -> ()
// CHECK:     quake.x %arg0 : (!quake.ref) -> ()
// CHECK:     quake.rz (%arg2) %arg0 : (f64, !quake.ref) -> ()
// CHECK:     quake.x %arg0 : (!quake.ref) -> ()
// CHECK:     quake.rz (%arg3) %arg0 : (f64, !quake.ref) -> ()
// CHECK:     cc.return
// CHECK: }

func.func private @subcircuit3(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: !quake.ref, %arg3: f64, %arg4: f64) attributes {num_cnots = 2 : ui32, subcircuit} {
    quake.rz (%arg3) %arg2 : (f64, !quake.ref) -> ()
    quake.x [%arg0] %arg2 : (!quake.ref, !quake.ref) -> ()
    quake.swap %arg0, %arg1 : (!quake.ref, !quake.ref) -> ()
    quake.x [%arg1] %arg2 : (!quake.ref, !quake.ref) -> ()
    quake.rz (%arg4) %arg2 : (f64, !quake.ref) -> ()
    cc.return
}

// CHECK-LABEL: func.func private @subcircuit3(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: !quake.ref, %arg3: f64, %arg4: f64) attributes {num_cnots = 2 : ui32, subcircuit} {
// CHECK:     %0 = arith.addf %arg3, %arg4 : f64
// CHECK:     quake.rz (%0) %arg2 : (f64, !quake.ref) -> ()
// CHECK:     quake.x [%arg0] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:     quake.swap %arg0, %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:     quake.x [%arg1] %arg2 : (!quake.ref, !quake.ref) -> ()
// CHECK:     cc.return
// CHECK: }

func.func private @subcircuit4(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: f64, %arg3: f64, %arg4: f64, %arg5: f64) attributes {num_cnots = 3 : ui32, subcircuit} {
    quake.x %arg0 : (!quake.ref) -> ()
    quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
    quake.rz (%arg2) %arg1 : (f64, !quake.ref) -> ()
    quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
    quake.x %arg0 : (!quake.ref) -> ()
    quake.rz (%arg3) %arg1 : (f64, !quake.ref) -> ()
    quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
    quake.rz (%arg4) %arg1 : (f64, !quake.ref) -> ()
    quake.x %arg1 : (!quake.ref) -> ()
    quake.rz (%arg5) %arg1 : (f64, !quake.ref) -> ()
    cc.return
}

// CHECK-LABEL: func.func private @subcircuit4(%arg0: !quake.ref, %arg1: !quake.ref, %arg2: f64, %arg3: f64, %arg4: f64, %arg5: f64) attributes {num_cnots = 3 : ui32, subcircuit} {
// CHECK:     quake.x %arg0 : (!quake.ref) -> ()
// CHECK:     quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:     %0 = arith.addf %arg2, %arg5 : f64
// CHECK:     quake.rz (%0) %arg1 : (f64, !quake.ref) -> ()
// CHECK:     quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:     quake.x %arg0 : (!quake.ref) -> ()
// CHECK:     quake.rz (%arg3) %arg1 : (f64, !quake.ref) -> ()
// CHECK:     quake.x [%arg0] %arg1 : (!quake.ref, !quake.ref) -> ()
// CHECK:     quake.rz (%arg4) %arg1 : (f64, !quake.ref) -> ()
// CHECK:     quake.x %arg1 : (!quake.ref) -> ()
// CHECK:     cc.return
// CHECK:   }
