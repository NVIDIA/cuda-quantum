// ========================================================================== //
// Copyright (c) 2025 NVIDIA Corporation & Affiliates.                        //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt --phase-polynomial-rotation-merging -split-input-file %s | FileCheck %s

func.func private @subcircuit0(%arg0: !quake.wire, %arg1: !quake.wire, %arg2: f64) -> (!quake.wire, !quake.wire) attributes {num_cnots = 3 : ui32, subcircuit} {
    %0 = quake.rz (%arg2) %arg1 : (f64, !quake.wire) -> !quake.wire
    %1:2 = quake.x [%arg0] %0 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
    %2 = quake.rz (%arg2) %1#1 : (f64, !quake.wire) -> !quake.wire
    %3:2 = quake.x [%1#0] %2 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
    %4 = quake.rz (%arg2) %3#0 : (f64, !quake.wire) -> !quake.wire
    %5 = quake.rz (%arg2) %3#1 : (f64, !quake.wire) -> !quake.wire
    %6:2 = quake.x [%5] %4 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
    cc.return %6#1, %6#0 : !quake.wire, !quake.wire
}

// CHECK: func.func private @subcircuit0(%arg0: !quake.wire, %arg1: !quake.wire, %arg2: f64) -> (!quake.wire, !quake.wire) attributes {num_cnots = 3 : ui32, subcircuit} {
// CHECK:     %[[VAL_0:.*]] = arith.addf %arg2, %arg2 : f64
// CHECK:     %[[VAL_1:.*]] = quake.rz (%[[VAL_0]]) %arg1 : (f64, !quake.wire) -> !quake.wire
// CHECK:     %[[VAL_2:.*]]:2 = quake.x [%arg0] %[[VAL_1]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:     %[[VAL_3:.*]] = quake.rz (%arg2) %[[VAL_2]]#1 : (f64, !quake.wire) -> !quake.wire
// CHECK:     %[[VAL_4:.*]]:2 = quake.x [%[[VAL_2]]#0] %[[VAL_3]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:     %[[VAL_5:.*]] = quake.rz (%arg2) %[[VAL_4]]#0 : (f64, !quake.wire) -> !quake.wire
// CHECK:     %[[VAL_6:.*]]:2 = quake.x [%[[VAL_4]]#1] %[[VAL_5]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:     cc.return %[[VAL_6]]#1, %[[VAL_6]]#0 : !quake.wire, !quake.wire
// CHECK: }

// -----

func.func private @subcircuit1(%arg0: !quake.wire, %arg1: f64, %arg2: f64, %arg3: f64) -> !quake.wire attributes {num_cnots = 0 : ui32, subcircuit} {
    %0 = quake.rz (%arg1) %arg0 : (f64, !quake.wire) -> !quake.wire
    %1 = quake.x %0 : (!quake.wire) -> !quake.wire
    %2 = quake.rz (%arg2) %1 : (f64, !quake.wire) -> !quake.wire
    %3 = quake.x %2 : (!quake.wire) -> !quake.wire
    %4 = quake.rz (%arg3) %3 : (f64, !quake.wire) -> !quake.wire
    cc.return %4 : !quake.wire
}

// CHECK: func.func private @subcircuit1(%arg0: !quake.wire, %arg1: f64, %arg2: f64, %arg3: f64) -> !quake.wire attributes {num_cnots = 0 : ui32, subcircuit} {
// CHECK:     %[[VAL_0:.*]] = arith.addf %arg1, %arg3 : f64
// CHECK:     %[[VAL_1:.*]] = quake.rz (%[[VAL_0]]) %arg0 : (f64, !quake.wire) -> !quake.wire
// CHECK:     %[[VAL_2:.*]] = quake.x %[[VAL_1]] : (!quake.wire) -> !quake.wire
// CHECK:     %[[VAL_3:.*]] = quake.rz (%arg2) %[[VAL_2]] : (f64, !quake.wire) -> !quake.wire
// CHECK:     %[[VAL_4:.*]] = quake.x %[[VAL_3]] : (!quake.wire) -> !quake.wire
// CHECK:     cc.return %[[VAL_4]] : !quake.wire
// CHECK: }

// -----

// Invalid subcircuit functions shouldn't be touched

func.func private @subcircuit2(%arg0: !quake.wire, %arg1: f64, %arg2: f64, %arg3: f64) -> !quake.wire attributes {num_cnots = 0 : ui32, subcircuit} {
    %0 = quake.rz (%arg1) %arg0 : (f64, !quake.wire) -> !quake.wire
    %1 = quake.x %0 : (!quake.wire) -> !quake.wire
    %2 = quake.ry (%arg2) %1 : (f64, !quake.wire) -> !quake.wire
    %3 = quake.x %2 : (!quake.wire) -> !quake.wire
    %4 = quake.rz (%arg3) %3 : (f64, !quake.wire) -> !quake.wire
    cc.return %4 : !quake.wire
}

// CHECK-LABEL: func.func private @subcircuit2(%arg0: !quake.wire, %arg1: f64, %arg2: f64, %arg3: f64) -> !quake.wire attributes {num_cnots = 0 : ui32, subcircuit} {
// CHECK:     %0 = quake.rz (%arg1) %arg0 : (f64, !quake.wire) -> !quake.wire
// CHECK:     %1 = quake.x %0 : (!quake.wire) -> !quake.wire
// CHECK:     %2 = quake.ry (%arg2) %1 : (f64, !quake.wire) -> !quake.wire
// CHECK:     %3 = quake.x %2 : (!quake.wire) -> !quake.wire
// CHECK:     %4 = quake.rz (%arg3) %3 : (f64, !quake.wire) -> !quake.wire
// CHECK:     cc.return %4 : !quake.wire
// CHECK: }

// -----

func.func private @subcircuit3(%arg0: !quake.wire, %arg1: f64, %arg2: f64, %arg3: f64) -> !quake.wire attributes {num_cnots = 0 : ui32} {
    %0 = quake.rz (%arg1) %arg0 : (f64, !quake.wire) -> !quake.wire
    %1 = quake.x %0 : (!quake.wire) -> !quake.wire
    %2 = quake.rz (%arg2) %1 : (f64, !quake.wire) -> !quake.wire
    %3 = quake.x %2 : (!quake.wire) -> !quake.wire
    %4 = quake.rz (%arg3) %3 : (f64, !quake.wire) -> !quake.wire
    cc.return %4 : !quake.wire
}

// CHECK-LABEL: func.func private @subcircuit3(%arg0: !quake.wire, %arg1: f64, %arg2: f64, %arg3: f64) -> !quake.wire attributes {num_cnots = 0 : ui32} {
// CHECK:     %0 = quake.rz (%arg1) %arg0 : (f64, !quake.wire) -> !quake.wire
// CHECK:     %1 = quake.x %0 : (!quake.wire) -> !quake.wire
// CHECK:     %2 = quake.rz (%arg2) %1 : (f64, !quake.wire) -> !quake.wire
// CHECK:     %3 = quake.x %2 : (!quake.wire) -> !quake.wire
// CHECK:     %4 = quake.rz (%arg3) %3 : (f64, !quake.wire) -> !quake.wire
// CHECK:     cc.return %4 : !quake.wire
// CHECK: }
