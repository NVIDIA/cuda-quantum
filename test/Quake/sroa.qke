// ========================================================================== //
// Copyright (c) 2022 - 2025 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt -cc-sroa %s | FileCheck %s

func.func @sroa_regression_1() {
  %false = arith.constant false
  %cst = arith.constant 3.140000e+00 : f64
  %c13_i64 = arith.constant 13 : i64
  %cst_0 = arith.constant 9.123000e+00 : f64
  %c654_i64 = arith.constant 654 : i64
  %true = arith.constant true
  %0 = cc.undef !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  %1 = cc.insert_value %0[0], %true : (!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>, i1) -> !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  %2 = cc.insert_value %1[1], %c654_i64 : (!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>, i64) -> !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  %3 = cc.insert_value %2[2], %cst_0 : (!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>, f64) -> !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  %4 = cc.alloca !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  cc.store %3, %4 : !cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>
  %5 = cc.cast %4 : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<i1>
  cc.store %false, %5 : !cc.ptr<i1>
  %6 = cc.compute_ptr %4[1] : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<i64>
  cc.store %c13_i64, %6 : !cc.ptr<i64>
  %7 = cc.compute_ptr %4[2] : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<f64>
  cc.store %cst, %7 : !cc.ptr<f64>
  %8 = cc.load %4 : !cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>
  cc.log_output %8 : !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  return
}

// CHECK-LABEL:   func.func @sroa_regression_1() {
// CHECK:           %[[VAL_0:.*]] = arith.constant false
// CHECK:           %[[VAL_1:.*]] = arith.constant 3.140000e+00 : f64
// CHECK:           %[[VAL_2:.*]] = arith.constant 13 : i64
// CHECK:           %[[VAL_3:.*]] = arith.constant 9.123000e+00 : f64
// CHECK:           %[[VAL_4:.*]] = arith.constant 654 : i64
// CHECK:           %[[VAL_5:.*]] = arith.constant true
// CHECK:           %[[VAL_6:.*]] = cc.alloca !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
// CHECK:           %[[VAL_7:.*]] = cc.compute_ptr %[[VAL_6]][2] : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<f64>
// CHECK:           cc.store %[[VAL_3]], %[[VAL_7]] : !cc.ptr<f64>
// CHECK:           %[[VAL_8:.*]] = cc.compute_ptr %[[VAL_6]][1] : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<i64>
// CHECK:           cc.store %[[VAL_4]], %[[VAL_8]] : !cc.ptr<i64>
// CHECK:           %[[VAL_9:.*]] = cc.compute_ptr %[[VAL_6]][0] : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<i1>
// CHECK:           cc.store %[[VAL_5]], %[[VAL_9]] : !cc.ptr<i1>
// CHECK:           %[[VAL_10:.*]] = cc.cast %[[VAL_6]] : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<i1>
// CHECK:           cc.store %[[VAL_0]], %[[VAL_10]] : !cc.ptr<i1>
// CHECK:           %[[VAL_11:.*]] = cc.compute_ptr %[[VAL_6]][1] : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<i64>
// CHECK:           cc.store %[[VAL_2]], %[[VAL_11]] : !cc.ptr<i64>
// CHECK:           %[[VAL_12:.*]] = cc.compute_ptr %[[VAL_6]][2] : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<f64>
// CHECK:           cc.store %[[VAL_1]], %[[VAL_12]] : !cc.ptr<f64>
// CHECK:           %[[VAL_13:.*]] = cc.load %[[VAL_6]] : !cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>
// CHECK:           cc.log_output %[[VAL_13]] : !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
// CHECK:           return
// CHECK:         }

