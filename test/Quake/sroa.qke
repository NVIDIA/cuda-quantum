// ========================================================================== //
// Copyright (c) 2022 - 2025 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt -cc-sroa %s | FileCheck %s

func.func @sroa_regression_1() {
  %false = arith.constant false
  %cst = arith.constant 3.140000e+00 : f64
  %c13_i64 = arith.constant 13 : i64
  %cst_0 = arith.constant 9.123000e+00 : f64
  %c654_i64 = arith.constant 654 : i64
  %true = arith.constant true
  %0 = cc.undef !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  %1 = cc.insert_value %0[0], %true : (!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>, i1) -> !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  %2 = cc.insert_value %1[1], %c654_i64 : (!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>, i64) -> !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  %3 = cc.insert_value %2[2], %cst_0 : (!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>, f64) -> !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  %4 = cc.alloca !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  cc.store %3, %4 : !cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>
  %5 = cc.cast %4 : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<i1>
  cc.store %false, %5 : !cc.ptr<i1>
  %6 = cc.compute_ptr %4[1] : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<i64>
  cc.store %c13_i64, %6 : !cc.ptr<i64>
  %7 = cc.compute_ptr %4[2] : (!cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>) -> !cc.ptr<f64>
  cc.store %cst, %7 : !cc.ptr<f64>
  %8 = cc.load %4 : !cc.ptr<!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>>
  cc.log_output %8 : !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
  return
}

// CHECK-LABEL:   func.func @sroa_regression_1() {
// CHECK:           %[[VAL_0:.*]] = arith.constant false
// CHECK:           %[[VAL_1:.*]] = arith.constant 3.140000e+00 : f64
// CHECK:           %[[VAL_2:.*]] = arith.constant 13 : i64
// CHECK:           %[[VAL_6:.*]] = cc.alloca i1
// CHECK:           %[[VAL_7:.*]] = cc.alloca i64
// CHECK:           %[[VAL_8:.*]] = cc.alloca f64
// CHECK:           cc.store %[[VAL_0]], %[[VAL_6]] : !cc.ptr<i1>
// CHECK:           cc.store %[[VAL_2]], %[[VAL_7]] : !cc.ptr<i64>
// CHECK:           cc.store %[[VAL_1]], %[[VAL_8]] : !cc.ptr<f64>
// CHECK:           %[[VAL_9:.*]] = cc.undef !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
// CHECK:           %[[VAL_10:.*]] = cc.load %[[VAL_6]] : !cc.ptr<i1>
// CHECK:           %[[VAL_11:.*]] = cc.insert_value %[[VAL_9]][0], %[[VAL_10]] : (!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>, i1) -> !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
// CHECK:           %[[VAL_12:.*]] = cc.load %[[VAL_7]] : !cc.ptr<i64>
// CHECK:           %[[VAL_13:.*]] = cc.insert_value %[[VAL_11]][1], %[[VAL_12]] : (!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>, i64) -> !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
// CHECK:           %[[VAL_14:.*]] = cc.load %[[VAL_8]] : !cc.ptr<f64>
// CHECK:           %[[VAL_15:.*]] = cc.insert_value %[[VAL_13]][2], %[[VAL_14]] : (!cc.struct<"MyTuple" {i1, i64, f64} [192,8]>, f64) -> !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
// CHECK:           cc.log_output %[[VAL_15]] : !cc.struct<"MyTuple" {i1, i64, f64} [192,8]>
// CHECK:           return
// CHECK:         }

func.func @sroa_regression_2(%a0 : i64, %a1 : i64) -> !cc.struct<{i64, i64}> {
  %0 = cc.alloca !cc.struct<{i64, i64}>
  %1 = cc.compute_ptr %0[0] : (!cc.ptr<!cc.struct<{i64, i64}>>) -> !cc.ptr<i64>
  cc.store %a0, %1 : !cc.ptr<i64>
  %2 = cc.compute_ptr %0[1] : (!cc.ptr<!cc.struct<{i64, i64}>>) -> !cc.ptr<i64>
  cc.store %a1, %2 : !cc.ptr<i64>
  %10 = cc.load %0 : !cc.ptr<!cc.struct<{i64, i64}>>
  return %10 : !cc.struct<{i64, i64}>
}

// CHECK-LABEL:   func.func @sroa_regression_2(
// CHECK-SAME:      %[[VAL_0:.*]]: i64, %[[VAL_1:.*]]: i64) -> !cc.struct<{i64, i64}> {
// CHECK:           %[[VAL_2:.*]] = cc.alloca i64
// CHECK:           %[[VAL_3:.*]] = cc.alloca i64
// CHECK:           cc.store %[[VAL_0]], %[[VAL_2]] : !cc.ptr<i64>
// CHECK:           cc.store %[[VAL_1]], %[[VAL_3]] : !cc.ptr<i64>
// CHECK:           %[[VAL_4:.*]] = cc.undef !cc.struct<{i64, i64}>
// CHECK:           %[[VAL_5:.*]] = cc.load %[[VAL_2]] : !cc.ptr<i64>
// CHECK:           %[[VAL_6:.*]] = cc.insert_value %[[VAL_4]][0], %[[VAL_5]] : (!cc.struct<{i64, i64}>, i64) -> !cc.struct<{i64, i64}>
// CHECK:           %[[VAL_7:.*]] = cc.load %[[VAL_3]] : !cc.ptr<i64>
// CHECK:           %[[VAL_8:.*]] = cc.insert_value %[[VAL_6]][1], %[[VAL_7]] : (!cc.struct<{i64, i64}>, i64) -> !cc.struct<{i64, i64}>
// CHECK:           return %[[VAL_8]] : !cc.struct<{i64, i64}>
// CHECK:         }
