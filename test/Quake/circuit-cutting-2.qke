// ========================================================================== //
// Copyright (c) 2022 - 2023 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// Only run this test if the metis plugin is available 

// REQUIRES: partitioner-plugins
// RUN: outcome=0
// RUN: for plugin in %cudaq_partitioner_plugins; do \
// RUN:   echo "Using partitioner plugin " $plugin; \
// RUN:   cudaq-opt %s --cut-quake \
// RUN:     --load-cudaq-plugin %cudaq_lib_dir/partitioners/lib$plugin%cudaq_plugin_ext \
// RUN:   | FileCheck %s; \
// RUN:   if [ $? -eq 0 ]; then echo "Succeeded."; \
// RUN:   else echo "Failed." && outcome=$(($outcome + 1)); \
// RUN:   fi; \
// RUN: done
// RUN: exit $outcome

module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__ansatz = "_ZN6ansatzclEv"}} {
  func.func @__nvqpp__mlirgen__ansatz() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
    %cst = arith.constant 5.900000e-01 : f64
    %0 = quake.null_wire
    %1 = quake.null_wire
    %2 = quake.x %0 : (!quake.wire) -> !quake.wire
    %3 = quake.ry (%cst) %1 : (f64, !quake.wire) -> !quake.wire
    %4 = quake.x [%3] %2 : (!quake.wire, !quake.wire) -> !quake.wire
    return
  }
}
// CHECK-LABEL:   func.func @__nvqpp__mlirgen__ansatz.partition_0() {
// CHECK:           %[[VAL_0:.*]] = quake.null_wire
// CHECK:           %[[VAL_1:.*]] = quake.x %[[VAL_0]] : (!quake.wire) -> !quake.wire
// CHECK:           quake.cut_measure %[[VAL_1]]
// CHECK:           return
// CHECK:         }


// CHECK-LABEL:   func.func @__nvqpp__mlirgen__ansatz.partition_1() {
// CHECK:           %[[VAL_0:.*]] = quake.null_wire
// CHECK:           %[[VAL_1:.*]] = quake.cut_state_prep %[[VAL_0]] : !quake.wire
// CHECK:           %[[VAL_2:.*]] = quake.null_wire
// CHECK:           %[[VAL_3:.*]] = arith.constant 5.900000e-01 : f64
// CHECK:           %[[VAL_4:.*]] = quake.ry (%[[VAL_3]]) %[[VAL_2]] : (f64, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_5:.*]] = quake.x {{\[}}%[[VAL_4]]] %[[VAL_1]] : (!quake.wire, !quake.wire) -> !quake.wire
// CHECK:           return
// CHECK:         }
