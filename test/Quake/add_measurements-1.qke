// ========================================================================== //
// Copyright (c) 2025 NVIDIA Corporation & Affiliates.                        //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt --add-measurements %s | FileCheck %s

module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__caller = "__nvqpp__mlirgen__caller_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__subkernel() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
    %0 = quake.alloca !quake.ref
    quake.x %0 : (!quake.ref) -> ()
    %measOut = quake.mz %0 : (!quake.ref) -> !quake.measure
    return
  }
  func.func @__nvqpp__mlirgen__caller() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
    %c2_i64 = arith.constant 2 : i64
    %c3_i64 = arith.constant 3 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<3>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %4 = arith.cmpi slt, %arg0, %c3_i64 : i64
      cc.condition %4(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %4 = quake.extract_ref %0[%arg0] : (!quake.veq<3>, i64) -> !quake.ref
      quake.h %4 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %4 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %4 : i64
    } {invariant}
    call @__nvqpp__mlirgen__subkernel() : () -> ()
    %2 = quake.alloca !quake.veq<2>
    %3 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %4 = arith.cmpi slt, %arg0, %c2_i64 : i64
      cc.condition %4(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %4 = quake.extract_ref %2[%arg0] : (!quake.veq<2>, i64) -> !quake.ref
      quake.h %4 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %4 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %4 : i64
    } {invariant}
    return
  }
}

// CHECK-LABEL:   func.func @__nvqpp__mlirgen__subkernel() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
// CHECK:           %[[VAL_0:.*]] = quake.alloca !quake.ref
// CHECK:           quake.x %[[VAL_0]] : (!quake.ref) -> ()
// CHECK:           %[[VAL_1:.*]] = quake.mz %[[VAL_0]] : (!quake.ref) -> !quake.measure
// CHECK:           return
// CHECK:         }

// CHECK-LABEL:   func.func @__nvqpp__mlirgen__caller() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
// CHECK-DAG:           %[[VAL_0:.*]] = arith.constant 2 : i64
// CHECK-DAG:           %[[VAL_1:.*]] = arith.constant 3 : i64
// CHECK-DAG:           %[[VAL_2:.*]] = arith.constant 1 : i64
// CHECK-DAG:           %[[VAL_3:.*]] = arith.constant 0 : i64
// CHECK:           %[[VAL_4:.*]] = quake.alloca !quake.veq<3>
// CHECK:           %[[VAL_5:.*]] = cc.loop while ((%[[VAL_6:.*]] = %[[VAL_3]]) -> (i64)) {
// CHECK:             %[[VAL_7:.*]] = arith.cmpi slt, %[[VAL_6]], %[[VAL_1]] : i64
// CHECK:             cc.condition %[[VAL_7]](%[[VAL_6]] : i64)
// CHECK:           } do {
// CHECK:           ^bb0(%[[VAL_8:.*]]: i64):
// CHECK:             %[[VAL_9:.*]] = quake.extract_ref %[[VAL_4]]{{\[}}%[[VAL_8]]] : (!quake.veq<3>, i64) -> !quake.ref
// CHECK:             quake.h %[[VAL_9]] : (!quake.ref) -> ()
// CHECK:             cc.continue %[[VAL_8]] : i64
// CHECK:           } step {
// CHECK:           ^bb0(%[[VAL_10:.*]]: i64):
// CHECK:             %[[VAL_11:.*]] = arith.addi %[[VAL_10]], %[[VAL_2]] : i64
// CHECK:             cc.continue %[[VAL_11]] : i64
// CHECK:           } {invariant}
// CHECK:           call @__nvqpp__mlirgen__subkernel() : () -> ()
// CHECK:           %[[VAL_12:.*]] = quake.alloca !quake.veq<2>
// CHECK:           %[[VAL_13:.*]] = cc.loop while ((%[[VAL_14:.*]] = %[[VAL_3]]) -> (i64)) {
// CHECK:             %[[VAL_15:.*]] = arith.cmpi slt, %[[VAL_14]], %[[VAL_0]] : i64
// CHECK:             cc.condition %[[VAL_15]](%[[VAL_14]] : i64)
// CHECK:           } do {
// CHECK:           ^bb0(%[[VAL_16:.*]]: i64):
// CHECK:             %[[VAL_17:.*]] = quake.extract_ref %[[VAL_12]]{{\[}}%[[VAL_16]]] : (!quake.veq<2>, i64) -> !quake.ref
// CHECK:             quake.h %[[VAL_17]] : (!quake.ref) -> ()
// CHECK:             cc.continue %[[VAL_16]] : i64
// CHECK:           } step {
// CHECK:           ^bb0(%[[VAL_18:.*]]: i64):
// CHECK:             %[[VAL_19:.*]] = arith.addi %[[VAL_18]], %[[VAL_2]] : i64
// CHECK:             cc.continue %[[VAL_19]] : i64
// CHECK:           } {invariant}
// CHECK:           cf.br ^bb1
// CHECK:         ^bb1:
// CHECK:           %[[VAL_20:.*]] = quake.mz %[[VAL_4]] : (!quake.veq<3>) -> !cc.stdvec<!quake.measure>
// CHECK:           %[[VAL_21:.*]] = quake.mz %[[VAL_12]] : (!quake.veq<2>) -> !cc.stdvec<!quake.measure>
// CHECK:           return
// CHECK:         }
