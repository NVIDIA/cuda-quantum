// ========================================================================== //
// Copyright (c) 2022 - 2026 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt -canonicalize %s | FileCheck %s

func.func @canonicalize_scope(%arg0: !quake.ref) attributes {"cudaq-kernel"} {
  %0 = cc.create_lambda {
    cc.scope {
      quake.h %arg0 : (!quake.ref) -> ()
    }
    cc.return
  } : !cc.callable<() -> ()>
  %1 = cc.create_lambda {
    cc.scope {
      quake.z %arg0 : (!quake.ref) -> ()
    }
    cc.return
  } : !cc.callable<() -> ()>
  quake.compute_action %0, %1 : !cc.callable<() -> ()>, !cc.callable<() -> ()>
  return
}

// CHECK-LABEL:   func.func @canonicalize_scope(
// CHECK:           %[[VAL_0:.*]] = cc.create_lambda {
// CHECK-NOT:       cc.scope
// CHECK:             quake.h %{{.*}} :
// CHECK:           } : !cc.callable<() -> ()>
// CHECK:           %[[VAL_1:.*]] = cc.create_lambda {
// CHECK-NOT:       cc.scope
// CHECK:             quake.z %{{.*}} :
// CHECK:           } : !cc.callable<() -> ()>
// CHECK:           quake.compute_action %[[VAL_0]], %[[VAL_1]]

// Test here is that this does not crash.
func.func @cast_to_stdvec() {
    %c0_i64 = arith.constant 0 : i64
    %c2_i64 = arith.constant 2 : i64
    %ptr = cc.cast %c0_i64 : (i64) -> !cc.ptr<i64>
    %vector = cc.stdvec_init %ptr, %c0_i64 : (!cc.ptr<i64>, i64) -> !cc.stdvec<i64>
    %size = cc.stdvec_size %vector : (!cc.stdvec<i64>) -> i64
    return
}

// CHECK-LABEL:   func.func @cast_to_stdvec() {
// CHECK:           return
// CHECK:         }
