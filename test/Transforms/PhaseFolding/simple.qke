// ========================================================================== //
// Copyright (c) 2025 NVIDIA Corporation & Affiliates.                        //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// Use CircuitCheck to verify that the optimization produces
// an equivalent circuit. The IR check in test/Quake/phase_folding.qke
// separately verifies that the optimization is actually applied.

// RUN: cudaq-opt --phase-folding --canonicalize %s | CircuitCheck %s

func.func private @kernel0() {
  %cst = arith.constant 1.000000e+00 : f64
  %0 = quake.alloca !quake.veq<2>
  %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
  %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
  quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
  quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
  quake.x [%2] %1 : (!quake.ref, !quake.ref) -> ()
  cc.return
}

func.func @kernel1() {
  %cst = arith.constant 1.000000e+00 : f64
  %0 = quake.alloca !quake.veq<3>
  %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
  %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
  %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
  quake.h %1 : (!quake.ref) -> ()
  quake.h %2 : (!quake.ref) -> ()
  quake.h %3 : (!quake.ref) -> ()
  quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
  quake.rz (%cst) %3 : (f64, !quake.ref) -> ()
  quake.x [%2] %1 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
  quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.h %3 : (!quake.ref) -> ()
  quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
  quake.h %1 : (!quake.ref) -> ()
  quake.h %2 : (!quake.ref) -> ()
  return
}

func.func private @kernel2() {
  %cst = arith.constant 1.000000e+00 : f64
  %cst_1 = arith.constant 1.000000e+00 : f64
  %0 = quake.alloca !quake.veq<3>
  %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
  %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
  %3 = quake.extract_ref %0[2] : (!quake.veq<3>) -> !quake.ref
  quake.rz (%cst) %3 : (f64, !quake.ref) -> ()
  quake.x [%1] %3 : (!quake.ref, !quake.ref) -> ()
  quake.swap %1, %2 : (!quake.ref, !quake.ref) -> ()
  quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst_1) %3 : (f64, !quake.ref) -> ()
  cc.return
}

func.func private @kernel3() {
  %cst = arith.constant 1.000000e+00 : f64
  %cst_1 = arith.constant 2.000000e+00 : f64
  %cst_2 = arith.constant 3.000000e+00 : f64
  %cst_3 = arith.constant 4.000000e+00 : f64
  %0 = quake.alloca !quake.veq<3>
  %1 = quake.extract_ref %0[0] : (!quake.veq<3>) -> !quake.ref
  %2 = quake.extract_ref %0[1] : (!quake.veq<3>) -> !quake.ref
  quake.x %1 : (!quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.x %1 : (!quake.ref) -> ()
  quake.rz (%cst_1) %2 : (f64, !quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst_2) %2 : (f64, !quake.ref) -> ()
  quake.x %2 : (!quake.ref) -> ()
  quake.rz (%cst_3) %2 : (f64, !quake.ref) -> ()
  cc.return
}

func.func private @kernel4() {
  %cst = arith.constant 1.000000e+00 : f64
  %0 = quake.alloca !quake.veq<2>
  %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref
  %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
  quake.swap %1, %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst) %1 : (f64, !quake.ref) -> ()
  quake.swap %1, %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
  cc.return
}

// This test case is a regression from a specific bug where pruning
// continued twice along the same qubit when encountering a CNot along
// the control qubit, instead of continuing once along both the control
// and targets.

func.func private @kernel5() {
  %cst = arith.constant 0.98174770424681035 : f64
  %cst_0 = arith.constant -0.98174770424681035 : f64
  %cst_1 = arith.constant -0.39269908169872414 : f64
  %cst_2 = arith.constant -0.78539816339744828 : f64
  %cst_3 = arith.constant -1.5707963267948966 : f64
  %0 = quake.alloca !quake.veq<2>
  %1 = quake.extract_ref %0[0] : (!quake.veq<2>) -> !quake.ref {nlindex = 0 : i64}
  quake.h %1 : (!quake.ref) -> ()
  %2 = quake.extract_ref %0[1] : (!quake.veq<2>) -> !quake.ref {nlindex = 1 : i64}
  quake.x %2 : (!quake.ref) -> ()
  quake.rz (%cst_0) %1 : (f64, !quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst_0) %2 : (f64, !quake.ref) -> ()
  quake.h %1 : (!quake.ref) -> ()
  %measOut = quake.mz %1 name "cr0" : (!quake.ref) -> !quake.measure
  %3 = quake.discriminate %measOut : (!quake.measure) -> i1
  quake.reset %1 : (!quake.ref) -> ()
  quake.h %1 : (!quake.ref) -> ()
  quake.rz (%cst_0) %1 : (f64, !quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst) %2 : (f64, !quake.ref) -> ()
  quake.x [%1] %2 : (!quake.ref, !quake.ref) -> ()
  quake.rz (%cst_0) %2 : (f64, !quake.ref) -> ()
  return
}
