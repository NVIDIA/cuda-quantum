// ========================================================================== //
// Copyright (c) 2022 - 2026 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// Roundtrip test.

// RUN: cudaq-opt %s | cudaq-opt | FileCheck %s

func.func private @apply_kernel(%0 : i32, %1 : !quake.veq<?>)

// Test roundtripping on the various quake ops.
func.func @quantum_ops() {
  // Allocations
  %0 = quake.alloca !quake.ref
  quake.dealloc %0 : !quake.ref
  %v0 = quake.alloca !quake.veq<5>
  quake.dealloc %v0 : !quake.veq<5>
  %1 = quake.alloca !quake.veq<4>
  %2 = arith.constant 2 : i32
  %3 = quake.alloca !quake.veq<?>[%2 : i32]
  %4 = quake.alloca !quake.ref

  // Vectors of references
  %zero = arith.constant 0 : i32
  %i = arith.constant 3    : i64
  %5 = quake.concat %3, %4 : (!quake.veq<?>, !quake.ref) -> !quake.veq<?>
  %6 = quake.concat %4, %1 : (!quake.ref, !quake.veq<4>) -> !quake.veq<5>
  %7 = quake.extract_ref %5[%zero] : (!quake.veq<?>, i32) -> !quake.ref
  %8 = quake.extract_ref %6[%i]    : (!quake.veq<5>, i64) -> !quake.ref
  %9 = quake.relax_size %6         : (!quake.veq<5>) -> !quake.veq<?>
  %z = arith.constant 0 : index
  %10 = quake.subveq %5, %z, %i : (!quake.veq<?>, index, i64) -> !quake.veq<?>
  %11 = quake.veq_size %5 : (!quake.veq<?>) -> index

  // Reference/dereference
  quake.reset %4 : (!quake.ref) -> ()
  %12 = quake.null_wire
  %13 = quake.unwrap %4 : (!quake.ref) -> !quake.wire
  %18 = quake.reset %13 : (!quake.wire) -> !quake.wire
  quake.wrap %18 to %4 : !quake.wire, !quake.ref

  // Control type conversion
  %14 = quake.to_ctrl %12 : (!quake.wire) -> !quake.control
  %a14 = quake.from_ctrl %14 : (!quake.control) -> !quake.wire
  quake.sink %a14 : !quake.wire

  // Quantum operations, reference form
  quake.x %4 : (!quake.ref) -> ()
  quake.y %4 : (!quake.ref) -> ()
  quake.z %4 : (!quake.ref) -> ()
  quake.h %4 : (!quake.ref) -> ()
  quake.s %4 : (!quake.ref) -> ()
  quake.t %4 : (!quake.ref) -> ()
  quake.swap %4, %7 : (!quake.ref, !quake.ref) -> ()

  %f = arith.constant 12.0 : f32
  quake.r1 (%f) %7 : (f32, !quake.ref) -> ()
  quake.rx (%f) %7 : (f32, !quake.ref) -> ()
  %g = arith.constant 23.0 : f32
  quake.phased_rx (%f, %g) %7 : (f32, f32, !quake.ref) -> ()
  quake.ry (%f) %7 : (f32, !quake.ref) -> ()
  quake.rz (%f) %7 : (f32, !quake.ref) -> ()
  quake.u2 (%f, %g) %7 : (f32, f32, !quake.ref) -> ()
  %h = arith.constant 34.0 : f32
  quake.u3 (%f, %g, %h) %7 : (f32, f32, f32, !quake.ref) -> ()

  %15 = quake.mx %4 : (!quake.ref) -> !quake.measure
  %16 = quake.my %5 : (!quake.veq<?>) -> !cc.stdvec<!quake.measure>
  %17 = quake.mz %6 : (!quake.veq<5>) -> !cc.stdvec<!quake.measure>
  %z15 = quake.discriminate %15 : (!quake.measure) -> i1
  %z16 = quake.discriminate %16 : (!cc.stdvec<!quake.measure>) -> !cc.stdvec<i1>

  // Quantum operations, wire form
  %19 = cc.undef i32 {wires = true}
  %20 = quake.null_wire
  %21 = quake.null_wire
  %22 = quake.null_wire
  
  %23 = quake.x %22 : (!quake.wire) -> !quake.wire
  %24 = quake.y %23 : (!quake.wire) -> !quake.wire
  %25 = quake.z %24 : (!quake.wire) -> !quake.wire
  %26 = quake.h %25 : (!quake.wire) -> !quake.wire
  %27 = quake.s %26 : (!quake.wire) -> !quake.wire
  %28 = quake.t %27 : (!quake.wire) -> !quake.wire
  %29:2 = quake.swap %28, %21 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)

  %30 = quake.r1 (%f) %29#1 : (f32, !quake.wire) -> !quake.wire
  %31 = quake.rx (%f) %30 : (f32, !quake.wire) -> !quake.wire
  %32 = quake.phased_rx (%f, %g) %31 : (f32, f32, !quake.wire) -> !quake.wire
  %33 = quake.ry (%f) %32 : (f32, !quake.wire) -> !quake.wire
  %34 = quake.rz (%f) %33 : (f32, !quake.wire) -> !quake.wire
  %35 = quake.u2 (%f, %g) %34 : (f32, f32, !quake.wire) -> !quake.wire
  %36 = quake.u3 (%f, %g, %h) %35 : (f32, f32, f32, !quake.wire) -> !quake.wire

  %37:2 = quake.mx %29#0 : (!quake.wire) -> (!quake.measure, !quake.wire)
  quake.sink %37#1 : !quake.wire
  %38:2 = quake.my %20 : (!quake.wire) -> (!quake.measure, !quake.wire)
  quake.sink %38#1 : !quake.wire
  %39:2 = quake.mz %36 : (!quake.wire) -> (!quake.measure, !quake.wire)
  quake.sink %39#1 : !quake.wire

  // CUDA-Q model support
  %40 = quake.alloca !quake.ref { apply_variants = true }
  %41 = quake.alloca !quake.veq<2>
  %42 = arith.constant 0 : i32
  %43 = quake.alloca !quake.ref
  quake.apply @apply_kernel %42, %43 : (i32, !quake.ref) -> ()
  quake.apply @apply_kernel [%40, %41] %42, %43 : (!quake.ref, !quake.veq<2>, i32, !quake.ref) -> ()
  quake.apply<adj> @apply_kernel [%40, %41] %42, %43 : (!quake.ref, !quake.veq<2>, i32, !quake.ref) -> ()

  %44 = cc.undef !cc.callable<() -> ()> { compute_action = true }
  %45 = cc.undef !cc.callable<() -> ()>
  quake.compute_action %44, %45 : !cc.callable<() -> ()>, !cc.callable<() -> ()>
  quake.compute_action<dag> %44, %45 : !cc.callable<() -> ()>, !cc.callable<() -> ()>

  // Adjoint modifier
  %47 = cc.undef f64 { adjoint = true }
  quake.s<adj> %4 : (!quake.ref) -> ()
  quake.t<adj> %4 : (!quake.ref) -> ()

  quake.r1<adj> (%f) %7 : (f32, !quake.ref) -> ()
  quake.rx<adj> (%f) %7 : (f32, !quake.ref) -> ()
  quake.phased_rx<adj> (%f, %g) %7 : (f32, f32, !quake.ref) -> ()
  quake.ry<adj> (%f) %7 : (f32, !quake.ref) -> ()
  quake.rz<adj> (%f) %7 : (f32, !quake.ref) -> ()
  quake.u2<adj> (%f, %g) %7 : (f32, f32, !quake.ref) -> ()
  quake.u3<adj> (%f, %g, %h) %7 : (f32, f32, f32, !quake.ref) -> ()

  // Control modifier
  %46 = quake.alloca !quake.veq<3> {control = true}
  quake.x [%46] %4 : (!quake.veq<3>, !quake.ref) -> ()
  quake.y [%46] %4 : (!quake.veq<3>, !quake.ref) -> ()
  quake.z [%7] %4 : (!quake.ref, !quake.ref) -> ()
  quake.h [%46] %4 : (!quake.veq<3>, !quake.ref) -> ()
  quake.s [%46] %4 : (!quake.veq<3>, !quake.ref) -> ()
  quake.t [%46] %4 : (!quake.veq<3>, !quake.ref) -> ()
  quake.swap [%46] %4, %7 : (!quake.veq<3>, !quake.ref, !quake.ref) -> ()

  quake.r1 (%f) [%46] %7 : (f32, !quake.veq<3>, !quake.ref) -> ()
  quake.rx (%f) [%46] %7 : (f32, !quake.veq<3>, !quake.ref) -> ()
  quake.phased_rx (%f, %g) [%46] %7 : (f32, f32, !quake.veq<3>, !quake.ref) -> ()
  quake.ry (%f) [%46] %7 : (f32, !quake.veq<3>, !quake.ref) -> ()
  quake.rz (%f) [%46] %7 : (f32, !quake.veq<3>, !quake.ref) -> ()
  quake.u2 (%f, %g) [%46] %7 : (f32, f32, !quake.veq<3>, !quake.ref) -> ()
  quake.u3 (%f, %g, %47) [%46] %7 : (f32, f32, f64, !quake.veq<3>, !quake.ref) -> ()

  // Exp Pauli and StringLiteral
  %f2 = arith.constant 12.0 : f64
  %48 = cc.string_literal "XXY" : !cc.ptr<!cc.array<i8 x 4>>
  quake.exp_pauli (%f2) %46 to %48 : (f64, !quake.veq<3>, !cc.ptr<!cc.array<i8 x 4>>) -> ()
  quake.exp_pauli (%f2) %46 to "XYZ" : (f64, !quake.veq<3>) -> ()
  
  // State
  %i8 = arith.constant 8 : i64
  %49 = cc.address_of @quantum_ops.rodata_synth_0 : !cc.ptr<!cc.array<complex<f32> x 8>>
  %50 = quake.create_state %49, %i8 : (!cc.ptr<!cc.array<complex<f32> x 8>>, i64) -> !cc.ptr<!quake.state>
  %51 = quake.get_number_of_qubits %50 : (!cc.ptr<!quake.state>) -> i64
  %52 = quake.alloca !quake.veq<?>[%51 : i64]
  %53 = quake.init_state %52, %50 : (!quake.veq<?>, !cc.ptr<!quake.state>) -> !quake.veq<?>

  %54 = quake.create_state %49, %i8 : (!cc.ptr<!cc.array<complex<f32> x 8>>, i64) -> !cc.ptr<!quake.state>
  quake.delete_state %54: !cc.ptr<!quake.state>
  return
}

cc.global constant private @quantum_ops.rodata_synth_0 (dense<[(0.707106769,0.000000e+00), (0.707106769,0.000000e+00), (0.000000e+00,0.000000e+00), (0.000000e+00,0.000000e+00), (0.000000e+00,0.000000e+00), (0.000000e+00,0.000000e+00), (0.000000e+00
,0.000000e+00), (0.000000e+00,0.000000e+00)]> : tensor<8xcomplex<f32>>) : !cc.array<complex<f32> x 8>


// CHECK-LABEL:   func.func @quantum_ops() {
// CHECK:           %[[VAL_0:.*]] = quake.alloca !quake.ref
// CHECK:           quake.dealloc %[[VAL_0]] : !quake.ref
// CHECK:           %[[VAL_1:.*]] = quake.alloca !quake.veq<5>
// CHECK:           quake.dealloc %[[VAL_1]] : !quake.veq<5>
// CHECK:           %[[VAL_2:.*]] = quake.alloca !quake.veq<4>
// CHECK:           %[[VAL_3:.*]] = arith.constant 2 : i32
// CHECK:           %[[VAL_4:.*]] = quake.alloca !quake.veq<?>[%[[VAL_3]] : i32]
// CHECK:           %[[VAL_5:.*]] = quake.alloca !quake.ref
// CHECK:           %[[VAL_6:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_7:.*]] = arith.constant 3 : i64
// CHECK:           %[[VAL_8:.*]] = quake.concat %[[VAL_4]], %[[VAL_5]] : (!quake.veq<?>, !quake.ref) -> !quake.veq<?>
// CHECK:           %[[VAL_9:.*]] = quake.concat %[[VAL_5]], %[[VAL_2]] : (!quake.ref, !quake.veq<4>) -> !quake.veq<5>
// CHECK:           %[[VAL_10:.*]] = quake.extract_ref %[[VAL_8]]{{\[}}%[[VAL_6]]] : (!quake.veq<?>, i32) -> !quake.ref
// CHECK:           %[[VAL_11:.*]] = quake.extract_ref %[[VAL_9]]{{\[}}%[[VAL_7]]] : (!quake.veq<5>, i64) -> !quake.ref
// CHECK:           %[[VAL_12:.*]] = quake.relax_size %[[VAL_9]] : (!quake.veq<5>) -> !quake.veq<?>
// CHECK:           %[[VAL_13:.*]] = arith.constant 0 : index
// CHECK:           %[[VAL_14:.*]] = quake.subveq %[[VAL_8]], %[[VAL_13]], %[[VAL_7]] : (!quake.veq<?>, index, i64) -> !quake.veq<?>
// CHECK:           %[[VAL_15:.*]] = quake.veq_size %[[VAL_8]] : (!quake.veq<?>) -> index
// CHECK:           quake.reset %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           %[[VAL_16:.*]] = quake.null_wire
// CHECK:           %[[VAL_17:.*]] = quake.unwrap %[[VAL_5]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_18:.*]] = quake.reset %[[VAL_17]] : (!quake.wire) -> !quake.wire
// CHECK:           quake.wrap %[[VAL_18]] to %[[VAL_5]] : !quake.wire, !quake.ref
// CHECK:           %[[VAL_19:.*]] = quake.to_ctrl %[[VAL_16]] : (!quake.wire) -> !quake.control
// CHECK:           %[[WAL_19:.*]] = quake.from_ctrl %[[VAL_19]] : (!quake.control) -> !quake.wire
// CHECK:           quake.sink %[[WAL_19]] : !quake.wire
// CHECK:           quake.x %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.y %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.z %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.h %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.s %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.t %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.swap %[[VAL_5]], %[[VAL_10]] : (!quake.ref, !quake.ref) -> ()
// CHECK:           %[[VAL_20:.*]] = arith.constant 1.200000e+01 : f32
// CHECK:           quake.r1 (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.rx (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           %[[VAL_21:.*]] = arith.constant 2.300000e+01 : f32
// CHECK:           quake.phased_rx (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.ref) -> ()
// CHECK:           quake.ry (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.rz (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.u2 (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.ref) -> ()
// CHECK:           %[[VAL_22:.*]] = arith.constant 3.400000e+01 : f32
// CHECK:           quake.u3 (%[[VAL_20]], %[[VAL_21]], %[[VAL_22]]) %[[VAL_10]] : (f32, f32, f32, !quake.ref) -> ()
// CHECK:           %[[VAL_23:.*]] = quake.mx %[[VAL_5]] : (!quake.ref) -> !quake.measure
// CHECK:           %[[VAL_24:.*]] = quake.my %[[VAL_8]] : (!quake.veq<?>) -> !cc.stdvec<!quake.measure>
// CHECK:           %[[VAL_25:.*]] = quake.mz %[[VAL_9]] : (!quake.veq<5>) -> !cc.stdvec<!quake.measure>
// CHECK:           %[[VAL_123:.*]] = quake.discriminate %[[VAL_23]] : (!quake.measure) -> i1
// CHECK:           %[[VAL_124:.*]] = quake.discriminate %[[VAL_24]] : (!cc.stdvec<!quake.measure>) -> !cc.stdvec<i1>
// CHECK:           %[[VAL_26:.*]] = cc.undef i32 {wires = true}
// CHECK:           %[[VAL_27:.*]] = quake.null_wire
// CHECK:           %[[VAL_28:.*]] = quake.null_wire
// CHECK:           %[[VAL_29:.*]] = quake.null_wire
// CHECK:           %[[VAL_30:.*]] = quake.x %[[VAL_29]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_31:.*]] = quake.y %[[VAL_30]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_32:.*]] = quake.z %[[VAL_31]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_33:.*]] = quake.h %[[VAL_32]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_34:.*]] = quake.s %[[VAL_33]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_35:.*]] = quake.t %[[VAL_34]] : (!quake.wire) -> !quake.wire
// CHECK:           %[[VAL_36:.*]]:2 = quake.swap %[[VAL_35]], %[[VAL_28]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           %[[VAL_37:.*]] = quake.r1 (%[[VAL_20]]) %[[VAL_36]]#1 : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_38:.*]] = quake.rx (%[[VAL_20]]) %[[VAL_37]] : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_39:.*]] = quake.phased_rx (%[[VAL_20]], %[[VAL_21]]) %[[VAL_38]] : (f32, f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_40:.*]] = quake.ry (%[[VAL_20]]) %[[VAL_39]] : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_41:.*]] = quake.rz (%[[VAL_20]]) %[[VAL_40]] : (f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_42:.*]] = quake.u2 (%[[VAL_20]], %[[VAL_21]]) %[[VAL_41]] : (f32, f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_43:.*]] = quake.u3 (%[[VAL_20]], %[[VAL_21]], %[[VAL_22]]) %[[VAL_42]] : (f32, f32, f32, !quake.wire) -> !quake.wire
// CHECK:           %[[VAL_44:.*]], %[[WAL_44:.*]] = quake.mx %[[VAL_36]]#0 : (!quake.wire) -> (!quake.measure, !quake.wire)
// CHECK:           %[[VAL_45:.*]], %[[WAL_45:.*]] = quake.my %[[VAL_27]] : (!quake.wire) -> (!quake.measure, !quake.wire)
// CHECK:           %[[VAL_46:.*]], %[[WAL_46:.*]] = quake.mz %[[VAL_43]] : (!quake.wire) -> (!quake.measure, !quake.wire)
// CHECK:           %[[VAL_47:.*]] = quake.alloca !quake.ref {apply_variants = true}
// CHECK:           %[[VAL_48:.*]] = quake.alloca !quake.veq<2>
// CHECK:           %[[VAL_49:.*]] = arith.constant 0 : i32
// CHECK:           %[[VAL_50:.*]] = quake.alloca !quake.ref
// CHECK:           quake.apply @apply_kernel %[[VAL_49]], %[[VAL_50]] : (i32, !quake.ref) -> ()
// CHECK:           quake.apply @apply_kernel [%[[VAL_47]], %[[VAL_48]]] %[[VAL_49]], %[[VAL_50]] : (!quake.ref, !quake.veq<2>, i32, !quake.ref) -> ()
// CHECK:           quake.apply<adj> @apply_kernel [%[[VAL_47]], %[[VAL_48]]] %[[VAL_49]], %[[VAL_50]] : (!quake.ref, !quake.veq<2>, i32, !quake.ref) -> ()
// CHECK:           %[[VAL_51:.*]] = cc.undef !cc.callable<() -> ()> {compute_action = true}
// CHECK:           %[[VAL_52:.*]] = cc.undef !cc.callable<() -> ()>
// CHECK:           quake.compute_action %[[VAL_51]], %[[VAL_52]] : !cc.callable<() -> ()>, !cc.callable<() -> ()>
// CHECK:           quake.compute_action<dag> %[[VAL_51]], %[[VAL_52]] : !cc.callable<() -> ()>, !cc.callable<() -> ()>
// CHECK:           %[[VAL_53:.*]] = cc.undef f64 {adjoint = true}
// CHECK:           quake.s<adj> %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.t<adj> %[[VAL_5]] : (!quake.ref) -> ()
// CHECK:           quake.r1<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.rx<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.phased_rx<adj> (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.ref) -> ()
// CHECK:           quake.ry<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.rz<adj> (%[[VAL_20]]) %[[VAL_10]] : (f32, !quake.ref) -> ()
// CHECK:           quake.u2<adj> (%[[VAL_20]], %[[VAL_21]]) %[[VAL_10]] : (f32, f32, !quake.ref) -> ()
// CHECK:           quake.u3<adj> (%[[VAL_20]], %[[VAL_21]], %[[VAL_22]]) %[[VAL_10]] : (f32, f32, f32, !quake.ref) -> ()
// CHECK:           %[[VAL_54:.*]] = quake.alloca !quake.veq<3> {control = true}
// CHECK:           quake.x {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.y {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.z {{\[}}%[[VAL_10]]] %[[VAL_5]] : (!quake.ref, !quake.ref) -> ()
// CHECK:           quake.h {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.s {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.t {{\[}}%[[VAL_54]]] %[[VAL_5]] : (!quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.swap {{\[}}%[[VAL_54]]] %[[VAL_5]], %[[VAL_10]] : (!quake.veq<3>, !quake.ref, !quake.ref) -> ()
// CHECK:           quake.r1 (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.rx (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.phased_rx (%[[VAL_20]], %[[VAL_21]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.ry (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.rz (%[[VAL_20]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.u2 (%[[VAL_20]], %[[VAL_21]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, f32, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           quake.u3 (%[[VAL_20]], %[[VAL_21]], %[[VAL_53]]) {{\[}}%[[VAL_54]]] %[[VAL_10]] : (f32, f32, f64, !quake.veq<3>, !quake.ref) -> ()
// CHECK:           %[[VAL_59:.*]] = arith.constant 1.200000e+01 : f64
// CHECK:           %[[VAL_60:.*]] = cc.string_literal "XXY" : !cc.ptr<!cc.array<i8 x 4>>
// CHECK:           quake.exp_pauli (%[[VAL_59]]) %[[VAL_54]] to %[[VAL_60]] : (f64, !quake.veq<3>, !cc.ptr<!cc.array<i8 x 4>>) -> ()
// CHECK:           quake.exp_pauli (%[[VAL_59]]) %[[VAL_54]] to "XYZ" : (f64, !quake.veq<3>) -> ()
// CHECK:           %[[VAL_61:.*]] = arith.constant 8 : i64
// CHECK:           %[[VAL_62:.*]] = cc.address_of @quantum_ops.rodata_synth_0 : !cc.ptr<!cc.array<complex<f32> x 8>>
// CHECK:           %[[VAL_63:.*]] = quake.create_state %[[VAL_62]], %[[VAL_61]] : (!cc.ptr<!cc.array<complex<f32> x 8>>, i64) -> !cc.ptr<!quake.state>
// CHECK:           %[[VAL_64:.*]] = quake.get_number_of_qubits %[[VAL_63]] : (!cc.ptr<!quake.state>) -> i64
// CHECK:           %[[VAL_65:.*]] = quake.alloca !quake.veq<?>[%[[VAL_64]] : i64]
// CHECK:           %[[VAL_66:.*]] = quake.init_state %[[VAL_65]], %[[VAL_63]] : (!quake.veq<?>, !cc.ptr<!quake.state>) -> !quake.veq<?>
// CHECK:           %[[VAL_67:.*]] = quake.create_state %[[VAL_62]], %[[VAL_61]] : (!cc.ptr<!cc.array<complex<f32> x 8>>, i64) -> !cc.ptr<!quake.state>
// CHECK:           quake.delete_state %[[VAL_67]] : !cc.ptr<!quake.state>
// CHECK:           return
// CHECK:         }

// CHECK-LABEL:   func.func @quake_op1(
// CHECK-SAME:        %[[VAL_0:.*]]: !cc.ptr<f64>, %[[VAL_1:.*]]: i64) -> i64 {
// CHECK:           %[[VAL_2:.*]] = cc.stdvec_init %[[VAL_0]], %[[VAL_1]] : (!cc.ptr<f64>, i64) -> !cc.stdvec<f64>
// CHECK:           %[[VAL_3:.*]] = cc.stdvec_data %[[VAL_2]] : (!cc.stdvec<f64>) -> !cc.ptr<f64>
// CHECK:           %[[VAL_4:.*]] = cc.stdvec_size %[[VAL_2]] : (!cc.stdvec<f64>) -> i64
// CHECK:           return %[[VAL_4]] : i64
// CHECK:         }

func.func @quake_op1(%a : !cc.ptr<f64>, %b : i64) -> i64 {
  %svec = cc.stdvec_init %a, %b : (!cc.ptr<f64>, i64) -> !cc.stdvec<f64>
  %dp = cc.stdvec_data %svec : (!cc.stdvec<f64>) -> !cc.ptr<f64>
  %len = cc.stdvec_size %svec : (!cc.stdvec<f64>) -> i64
  return %len : i64
}

// CHECK-LABEL:   func.func @quake_op2() -> !cc.ptr<i8> {
// CHECK:           %[[VAL_0:.*]] = constant @quake_op1 : (!cc.ptr<f64>, i64) -> i64
// CHECK:           %[[VAL_1:.*]] = cc.func_ptr %[[VAL_0]] : ((!cc.ptr<f64>, i64) -> i64) -> !cc.ptr<i8>
// CHECK:           return %[[VAL_1]] : !cc.ptr<i8>
// CHECK:         }

func.func @quake_op2() -> !cc.ptr<i8> {
  %cp = constant @quake_op1 : (!cc.ptr<f64>, i64) -> i64
  %ptr = cc.func_ptr %cp : ((!cc.ptr<f64>, i64) -> i64) -> !cc.ptr<i8>
  return %ptr : !cc.ptr<i8>
}

// CHECK-LABEL:   func.func @quake_op3(
// CHECK-SAME:        %[[VAL_0:.*]]: !quake.veq<?>,
// CHECK-SAME:        %[[VAL_1:.*]]: i32, %[[VAL_2:.*]]: i32) {
// CHECK:           %[[VAL_3:.*]] = quake.subveq %[[VAL_0]], %[[VAL_1]], %[[VAL_2]] : (!quake.veq<?>, i32, i32) -> !quake.veq<?>
// CHECK:           return
// CHECK:         }

func.func @quake_op3(%vec : !quake.veq<?>, %a : i32, %b : i32) {
  %sub = quake.subveq %vec, %a, %b : (!quake.veq<?>, i32, i32) -> !quake.veq<?>
  return
}

// CHECK-LABEL:   func.func @cc_op4() {
// CHECK:           cc.scope {
// CHECK:             %[[VAL_0:.*]] = cc.alloca i32
// CHECK:           }
// CHECK:           return
// CHECK:         }

func.func @cc_op4() {
  cc.scope {
    %x = cc.alloca i32
  }
  return
}

// See loop.qke for cc.loop, cc.if, cc.condition, cc.continue, cc.break, ...

func.func private @do_nothing() -> ()

// CHECK-LABEL:   func.func @cc_op5() -> !cc.callable<() -> i32> {
// CHECK:           %[[VAL_0:.*]] = cc.create_lambda {
// CHECK:             func.call @do_nothing() : () -> ()
// CHECK:             %[[VAL_1:.*]] = arith.constant 1 : i32
// CHECK:             cc.return %[[VAL_1]] : i32
// CHECK:           } : !cc.callable<() -> i32>
// CHECK:           %[[VAL_21:.*]] = cc.alloca !cc.struct<{i32, i32}>
// CHECK:           %[[VAL_2:.*]] = cc.cast %[[VAL_21]] :
// CHECK:           %[[VAL_3:.*]] = cc.instantiate_callable @do_nothing(%[[VAL_2]]) : (!cc.ptr<i8>) -> !cc.callable<() -> ()>
// CHECK:           %[[VAL_4:.*]] = cc.callable_func %[[VAL_3]] : (!cc.callable<() -> ()>) -> (() -> ())
// CHECK:           %[[VAL_5:.*]] = cc.callable_closure %[[VAL_3]] : (!cc.callable<() -> ()>) -> !cc.ptr<i8>
// CHECK:           %[[VAL_6:.*]] = cc.call_callable %[[VAL_0]] : (!cc.callable<() -> i32>) -> i32
// CHECK:           cc.call_callable %[[VAL_3]] : (!cc.callable<() -> ()>) -> ()
// CHECK:           return %[[VAL_0]] : !cc.callable<() -> i32>
// CHECK:         }

func.func @cc_op5() -> !cc.callable<() -> i32> {
  %1 = cc.create_lambda {
    func.call @do_nothing() : () -> ()
    %1 = arith.constant 1 : i32
    cc.return %1 : i32
  } : !cc.callable<() -> i32>
  %closure = cc.alloca !cc.struct<{i32, i32}>
  %cast = cc.cast %closure : (!cc.ptr<!cc.struct<{i32, i32}>>) -> !cc.ptr<i8>
  %2 = cc.instantiate_callable @do_nothing(%cast) : (!cc.ptr<i8>) -> !cc.callable<()->()>
  %3 = cc.callable_func %2 : (!cc.callable<() -> ()>) -> (() -> ())
  %4 = cc.callable_closure %2 : (!cc.callable<() -> ()>) -> !cc.ptr<i8>
  %5 = cc.call_callable %1 : (!cc.callable<() -> (i32)>) -> i32
  cc.call_callable %2 : (!cc.callable<() -> ()>) -> ()
  return %1 : !cc.callable<() -> i32>
}

// CHECK-LABEL:   func.func @cc_op6_return_test() -> i32 {
// CHECK:           %[[VAL_0:.*]] = cc.alloca i32
// CHECK:           %[[VAL_1:.*]] = cc.undef i32
// CHECK:           cc.scope {
// CHECK:             %[[VAL_2:.*]] = cc.alloca i1
// CHECK:             %[[VAL_3:.*]] = cc.undef i1
// CHECK:             cc.if(%[[VAL_3]]) {
// CHECK:               cc.scope {
// CHECK:                 %[[VAL_4:.*]] = cc.alloca i32
// CHECK:                 %[[VAL_5:.*]] = cc.alloca i1
// CHECK:                 cc.loop while {
// CHECK:                   %[[VAL_6:.*]] = cc.undef i1
// CHECK:                   cc.condition %[[VAL_6]]
// CHECK:                 } do {
// CHECK:                   cc.scope {
// CHECK:                     %[[VAL_7:.*]] = cc.alloca i1
// CHECK:                     %[[VAL_8:.*]] = cc.undef i1
// CHECK:                     cc.if(%[[VAL_8]]) {
// CHECK:                       %[[VAL_9:.*]] = cc.undef i32
// CHECK:                       cc.unwind_return %[[VAL_9]] : i32 {insn = 1 : i64}
// CHECK:                     }
// CHECK:                   }
// CHECK:                   %[[VAL_10:.*]] = cc.undef i32
// CHECK:                   cc.unwind_return %[[VAL_10]] : i32 {insn = 2 : i64}
// CHECK:                   cc.continue
// CHECK:                 } step {
// CHECK:                   %[[VAL_11:.*]] = cc.undef i32
// CHECK:                 }
// CHECK:               }
// CHECK:             }
// CHECK:           }
// CHECK:           return %[[VAL_1]] : i32
// CHECK:         }

func.func @cc_op6_return_test() -> i32 {
  %1 = cc.alloca i32
  %result = cc.undef i32
  cc.scope {
    %2 = cc.alloca i1
    %b1 = cc.undef i1
    cc.if (%b1) {
      cc.scope {
        %3 = cc.alloca i32
        %4 = cc.alloca i1
        cc.loop while {
	  %b2 = cc.undef i1
	  cc.condition %b2
	} do {
          cc.scope {
            %5 = cc.alloca i1
	    %b3 = cc.undef i1
            cc.if (%b3) {
	      %val = cc.undef i32
              cc.unwind_return %val : i32 {insn = 1}
	      cc.continue
            }
          }
	  %val2 = cc.undef i32
	  cc.unwind_return %val2 : i32 {insn = 2}
	  cc.continue
        } step {
	  %incr = cc.undef i32
	}
      }
    }
  }
  return %result : i32
}

// CHECK-LABEL:   func.func @cc_op7_break_test() -> f64 {
// CHECK:           cc.scope {
// CHECK:             cc.if(%{{.*}}) {
// CHECK:               cc.scope {
// CHECK:                 %[[VAL_7:.*]] = cc.loop while ((%[[VAL_8:.*]] = %{{.*}}) -> (i16)) {
// CHECK:                   cc.condition %{{.*}}(%[[VAL_8]] : i16)
// CHECK:                 } do {
// CHECK:                 ^bb0(%[[VAL_10:.*]]: i16):
// CHECK:                   cc.scope {
// CHECK:                     cc.if(%{{.*}}) {
// CHECK:                       %[[VAL_13:.*]] = cc.undef f64
// CHECK:                       cc.unwind_break %[[VAL_10]] : i16
// CHECK:                     }
// CHECK:                   }
// CHECK:                   cc.continue %[[VAL_10]] : i16
// CHECK:                 } step {
// CHECK:                 ^bb0(%[[VAL_15:.*]]: i16):
// CHECK:                   cc.continue %[[VAL_15]] : i16
// CHECK:                 }
// CHECK:               }
// CHECK:             }
// CHECK:           }
// CHECK:           return %[[VAL_1]] : f64
// CHECK:         }

func.func @cc_op7_break_test() -> f64 {
  %1 = cc.alloca i32
  %result = cc.undef f64
  cc.scope {
    %2 = cc.alloca i1
    %b1 = cc.undef i1
    cc.if (%b1) {
      cc.scope {
        %3 = cc.alloca i32
        %4 = cc.alloca i1
	%w = cc.undef i16
        cc.loop while ((%arg0 = %w) -> i16) {
	  %b2 = cc.undef i1
	  cc.condition %b2 (%arg0 : i16)
	} do {
         ^bb1(%arg1 : i16):
          cc.scope {
            %5 = cc.alloca i1
	    %b3 = cc.undef i1
            cc.if (%b3) {
	      %val = cc.undef f64
              cc.unwind_break %arg1 : i16
	      cc.continue
            }
	    cc.continue
          }
	  %val2 = cc.undef i32
	  cc.continue %arg1 : i16
        } step {
	 ^bb2(%arg2 : i16):
	  %incr = cc.undef i32
	  cc.continue %arg2 : i16
	}
      }
    }
  }
  return %result : f64
}

// CHECK-LABEL:   func.func @cc_op8_continue_test() -> f64 {
// CHECK:           cc.scope {
// CHECK:             cc.if(%{{.*}}) {
// CHECK:               cc.scope {
// CHECK:                 %[[VAL_7:.*]] = cc.loop while ((%[[VAL_8:.*]] = %{{.*}}) -> (i16)) {
// CHECK:                   cc.condition %{{.*}}(%[[VAL_8]] : i16)
// CHECK:                 } do {
// CHECK:                 ^bb0(%[[VAL_10:.*]]: i16):
// CHECK:                   cc.scope {
// CHECK:                     cc.if(%{{.*}}) {
// CHECK:                       %[[VAL_13:.*]] = cc.undef f64
// CHECK:                       cc.unwind_continue %[[VAL_10]] : i16
// CHECK:                     }
// CHECK:                   }
// CHECK:                   cc.continue %[[VAL_10]] : i16
// CHECK:                 } step {
// CHECK:                 ^bb0(%[[VAL_15:.*]]: i16):
// CHECK:                   cc.continue %[[VAL_15]] : i16
// CHECK:                 }
// CHECK:               }
// CHECK:             }
// CHECK:           }
// CHECK:           return %[[VAL_1]] : f64
// CHECK:         }

func.func @cc_op8_continue_test() -> f64 {
  %1 = cc.alloca i32
  %result = cc.undef f64
  cc.scope {
    %2 = cc.alloca i1
    %b1 = cc.undef i1
    cc.if (%b1) {
      cc.scope {
        %3 = cc.alloca i32
        %4 = cc.alloca i1
	%w = cc.undef i16
        cc.loop while ((%arg0 = %w) -> i16) {
	  %b2 = cc.undef i1
	  cc.condition %b2 (%arg0 : i16)
	} do {
         ^bb1(%arg1 : i16):
          cc.scope {
            %5 = cc.alloca i1
	    %b3 = cc.undef i1
            cc.if (%b3) {
	      %val = cc.undef f64
              cc.unwind_continue %arg1 : i16
	      cc.continue
            }
	    cc.continue
          }
	  %val2 = cc.undef i32
	  cc.continue %arg1 : i16
        } step {
	 ^bb2(%arg2 : i16):
	  %incr = cc.undef i32
	  cc.continue %arg2 : i16
	}
      }
    }
  }
  return %result : f64
}

// CHECK-LABEL:   func.func @cc.scope_result() {
// CHECK:           %[[VAL_0:.*]] = cc.scope -> (i32) {
// CHECK:             %[[VAL_1:.*]] = cc.alloca i32
// CHECK:             %[[VAL_2:.*]] = cc.undef i32
// CHECK:             cc.continue %[[VAL_2]] : i32
// CHECK:           }
// CHECK:           return
// CHECK:         }

func.func @cc.scope_result() {
  %0 = cc.scope -> i32 {
    %x = cc.alloca i32
    %0 = cc.undef i32
    cc.continue %0 : i32
  }
  return
}

// CHECK-LABEL:   func.func @cc.scope_blocks() {
// CHECK:           cc.scope {
// CHECK:             %[[VAL_0:.*]] = cc.alloca i32
// CHECK:             %[[VAL_1:.*]] = cc.undef i1
// CHECK:             cf.cond_br %[[VAL_1]], ^bb1, ^bb2
// CHECK:           ^bb1:
// CHECK:             %[[VAL_2:.*]] = cc.undef i32
// CHECK:             cf.br ^bb3
// CHECK:           ^bb2:
// CHECK:             %[[VAL_3:.*]] = cc.undef f64
// CHECK:             cf.br ^bb3
// CHECK:           ^bb3:
// CHECK:             %[[VAL_4:.*]] = cc.undef i64
// CHECK:             cc.unwind_return
// CHECK:           }
// CHECK:           return
// CHECK:         }

// scope with an embedded primitive CFG
func.func @cc.scope_blocks() {
  cc.scope {
  ^bb2:
    %x = cc.alloca i32
    %0 = cc.undef i1
    cf.cond_br %0, ^bb0, ^bb1
  ^bb0:
    %b = cc.undef i32
    cf.br ^bb3
  ^bb1:
    %c = cc.undef f64
    cf.br ^bb3
  ^bb3:
    %e = cc.undef i64
    cc.unwind_return
  }
  return
}

// CHECK-LABEL:   func.func @load_store(
// CHECK-SAME:      %[[ARG0:.*]]: !cc.ptr<i32>) {
// CHECK:           %[[VAL_0:.*]] = cc.load %[[ARG0]] : !cc.ptr<i32>
// CHECK:           cc.store %{{.*}}, %[[ARG0]] : !cc.ptr<i32>

func.func @load_store(%arg0: !cc.ptr<i32>) {
  %1 = cc.load %arg0 : !cc.ptr<i32>
  %2 = arith.addi %1, %1 : i32
  cc.store %2, %arg0 : !cc.ptr<i32>
  return
}

// CHECK-LABEL:   func.func @wire_type() -> !quake.wire {
// CHECK:           %[[VAL_0:.*]] = cc.undef !quake.wire
// CHECK:           return %[[VAL_0]] : !quake.wire

func.func @wire_type() -> !quake.wire {
  %0 = cc.undef !quake.wire
  return %0 : !quake.wire
}

// CHECK-LABEL:   func.func @unwrap_wrap(
// CHECK-SAME:      %[[VAL_0:.*]]: !quake.ref) {
// CHECK:           %[[VAL_1:.*]] = quake.unwrap %[[VAL_0]] : (!quake.ref) -> !quake.wire
// CHECK:           %[[VAL_2:.*]] = quake.null_wire
// CHECK:           %[[VAL_3:.*]]:2 = quake.x [%[[VAL_2]]] %[[VAL_1]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:           quake.wrap %[[VAL_3]]#1 to %[[VAL_0]] : !quake.wire, !quake.ref
// CHECK:           return
// CHECK:         }

func.func @unwrap_wrap(%0 : !quake.ref) {
  %1 = quake.unwrap %0 : (!quake.ref) -> !quake.wire
  %3 = quake.null_wire
  %2:2 = quake.x [%3] %1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
  quake.wrap %2#1 to %0 : !quake.wire, !quake.ref
  quake.sink %2#0 : !quake.wire
  return
}

// CHECK-LABEL:   func.func @cc_struct() {
// CHECK:           %[[VAL_0:.*]] = cc.undef !cc.struct<"foo" {i32, i8}>
// CHECK:           %[[VAL_1:.*]] = cc.undef !cc.struct<"foo">
// CHECK:           %[[VAL_2:.*]] = cc.undef !cc.struct<"bar" {}>
// CHECK:           %[[VAL_3:.*]] = cc.undef !cc.struct<{!cc.array<f64 x 10>}>
// CHECK:           %[[VAL_9:.*]] = cc.undef !cc.struct<"foo6" {f32, i8} packed>
// CHECK:           return
// CHECK:         }

func.func @cc_struct() {
  %0 = cc.undef !cc.struct<"foo"{i32, i8}>
  %1 = cc.undef !cc.struct<"foo">
  %2 = cc.undef !cc.struct<"bar" {}>
  %3 = cc.undef !cc.struct<{!cc.array<f64 x 10>}>
  %9 = cc.undef !cc.struct<"foo6"{f32, i8} packed>
  return
}

// CHECK-LABEL:   func.func @cc_indexing(
// CHECK-SAME:                           %[[VAL_0:.*]]: !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) {
// CHECK:           %[[VAL_1:.*]] = cc.address_of @cc_struct : !cc.ptr<() -> ()>
// CHECK:           %[[VAL_2:.*]] = cc.extract_value %[[VAL_0]][0] : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) -> i32
// CHECK:           %[[VAL_3:.*]] = cc.extract_value %[[VAL_0]][1, 15, 2] : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) -> f32
// CHECK:           %[[VAL_4:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_5:.*]] = arith.addi %[[VAL_2]], %[[VAL_4]] : i32
// CHECK:           %[[VAL_6:.*]] = cc.insert_value %[[VAL_0]][0], %[[VAL_5]] : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>, i32) -> !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>
// CHECK:           %[[VAL_7:.*]] = cc.alloca !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>
// CHECK:           cc.store %[[VAL_6]], %[[VAL_7]] : !cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>
// CHECK:           %[[VAL_8:.*]] = cc.compute_ptr %[[VAL_7]][1, 4, 3] : (!cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>) -> !cc.ptr<i64>
// CHECK:           %[[VAL_9:.*]] = cc.compute_ptr %[[VAL_7]][1, %[[VAL_4]], 1] : (!cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>, i32) -> !cc.ptr<i16>
// CHECK:           %[[VAL_10:.*]] = cc.const_array [1.000000e+00, 2.000000e+00] : !cc.array<f32 x 2>
// CHECK:           %[[VAL_11:.*]] = cc.extract_value %[[VAL_10]][%[[VAL_4]]] : (!cc.array<f32 x 2>, i32) -> f32
// CHECK:   %[[VAL_12:.*]] = cc.sizeof !cc.struct<{i32, f64}> : i32
// CHECK:   %[[VAL_13:.*]] = cc.sizeof !cc.struct<{f64, f32}> : i64
// CHECK:           return
// CHECK:         }

func.func @cc_indexing(%arg0 : !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) {
  %0 = cc.address_of @cc_struct : !cc.ptr<() -> ()>
  %1 = cc.extract_value %arg0[0] : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) -> i32
  %2 = cc.extract_value %arg0[1, 15, 2] : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>) -> f32
  %one = arith.constant 1 : i32
  %incr = arith.addi %1, %one : i32
  %3 = cc.insert_value %arg0[0], %incr : (!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>, i32) -> !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>
  %ss = cc.alloca !cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>
  cc.store %3, %ss : !cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>
  %p = cc.compute_ptr %ss[1, 4, 3] : (!cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>) -> !cc.ptr<i64>
  %q = cc.compute_ptr %ss[1, %one, 1] : (!cc.ptr<!cc.struct<{i32, !cc.array<!cc.struct<{i8, i16, f32, i64}> x 100>}>>, i32) -> !cc.ptr<i16>
  %arr = cc.const_array [1.0, 2.0] : !cc.array<f32 x 2>
  %ele = cc.extract_value %arr[%one] : (!cc.array<f32 x 2>, i32) -> f32
  %size1 = cc.sizeof !cc.struct<{i32, f64}> : i32
  %size2 = cc.sizeof !cc.struct<{f64, f32}> : i64
  return
}

func.func @ssi_if(%arg0: i1) {
  %0 = quake.null_wire
  %1 = quake.null_wire
  %2:2 = cc.if (%arg0) ((%arg1 = %0, %arg2 = %1)) -> (!quake.wire, !quake.wire) {
    %3:2 = quake.x [%arg1] %arg2 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
    cc.continue %3#0, %3#1 : !quake.wire, !quake.wire
  } else {
    %4:2 = quake.x [%arg1] %arg2 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
    cc.continue %4#0, %4#1 : !quake.wire, !quake.wire
  }
  quake.sink %2#1 : !quake.wire
  quake.sink %2#0 : !quake.wire
  return
}

// CHECK-LABEL:   func.func @ssi_if(
// CHECK-SAME:      %[[VAL_0:.*]]: i1) {
// CHECK:           %[[VAL_1:.*]] = quake.null_wire
// CHECK:           %[[VAL_2:.*]] = quake.null_wire
// CHECK:           %[[VAL_3:.*]]:2 = cc.if(%[[VAL_0]]) ((%[[VAL_4:.*]] = %[[VAL_1]], %[[VAL_5:.*]] = %[[VAL_2]])) -> (!quake.wire, !quake.wire) {
// CHECK:             %[[VAL_6:.*]]:2 = quake.x [%[[VAL_4]]] %[[VAL_5]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             cc.continue %[[VAL_6]]#0, %[[VAL_6]]#1 : !quake.wire, !quake.wire
// CHECK:           } else {
// CHECK:             %[[VAL_7:.*]]:2 = quake.x [%[[VAL_8:.*]]] %[[VAL_9:.*]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:             cc.continue %[[VAL_7]]#0, %[[VAL_7]]#1 : !quake.wire, !quake.wire
// CHECK:           }
// CHECK:           quake.sink %[[VAL_10:.*]]#1 : !quake.wire
// CHECK:           quake.sink %[[VAL_10]]#0 : !quake.wire
// CHECK:           return
// CHECK:         }

quake.wire_set @phys [8]

quake.wire_set @phys_ed [4] adjacency
  sparse<[[0, 1], [1, 2], [2, 3]], true> : tensor<4x4xi1>

func.func @phys_hoops() {
  %0 = quake.borrow_wire @phys[0] : !quake.wire
  %1 = quake.borrow_wire @phys_ed[3] : !quake.wire
  %2:2 = quake.x [%0] %1 : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
  quake.return_wire %2#0 : !quake.wire
  quake.return_wire %2#1 : !quake.wire
  return
}

// CHECK-LABEL:  quake.wire_set @phys[8]
// CHECK-LABEL:  quake.wire_set @phys_ed[4] adjacency sparse<
// CHECK-SAME:    {{\[}}[0, 1], [1, 2], [2, 3]], true> : tensor<4x4xi1>
// CHECK-LABEL:  func.func @phys_hoops() {
// CHECK:    %[[VAL_0:.*]] = quake.borrow_wire @phys[0] : !quake.wire
// CHECK:    %[[VAL_1:.*]] = quake.borrow_wire @phys_ed[3] : !quake.wire
// CHECK:    %[[VAL_2:.*]]:2 = quake.x [%[[VAL_0]]] %[[VAL_1]] : (!quake.wire, !quake.wire) -> (!quake.wire, !quake.wire)
// CHECK:    quake.return_wire %[[VAL_2]]#0 : !quake.wire
// CHECK:    quake.return_wire %[[VAL_2]]#1 : !quake.wire
// CHECK:    return
// CHECK:  }

func.func @offsets() {
  %0 = cc.offsetof !cc.struct<{i32, f64}> [1] : i64
  %1 = cc.offsetof !cc.struct<{i32, f64}> [1] : i64
  %2 = cc.offsetof !cc.struct<{i32, f64, complex<f64>}> [2,1] : i64
  %3 = cc.offsetof !cc.array<!cc.struct<{i32, f64}> x 100> [86, 1] : i64
  %4 = cc.offsetof !cc.array<!cc.struct<{i32, f64}> x 100> [0, 0] : i64
  return
}

// CHECK-LABEL:   func.func @offsets() {
// CHECK:           %[[VAL_0:.*]] = cc.offsetof !cc.struct<{i32, f64}> [1] : i64
// CHECK:           %[[VAL_1:.*]] = cc.offsetof !cc.struct<{i32, f64}> [1] : i64
// CHECK:           %[[VAL_2:.*]] = cc.offsetof !cc.struct<{i32, f64, complex<f64>}> [2, 1] : i64
// CHECK:           %[[VAL_3:.*]] = cc.offsetof !cc.array<!cc.struct<{i32, f64}> x 100> [86, 1] : i64
// CHECK:           %[[VAL_4:.*]] = cc.offsetof !cc.array<!cc.struct<{i32, f64}> x 100> [0, 0] : i64
// CHECK:           return

func.func @indirect_callable1(%arg : !cc.indirect_callable<() -> ()>) {
  cc.call_indirect_callable %arg : (!cc.indirect_callable<() -> ()>) -> ()
  return
}

// CHECK-LABEL:   func.func @indirect_callable1(
// CHECK-SAME:      %[[VAL_0:.*]]: !cc.indirect_callable<() -> ()>) {
// CHECK:           cc.call_indirect_callable %[[VAL_0]] : (!cc.indirect_callable<() -> ()>) -> ()
// CHECK:           return
// CHECK:         }

func.func @varargs_test() {
  %1 = arith.constant 12 : i32
  %2 = cc.undef !cc.ptr<none>
  cc.call_vararg @my_variadic(%1, %2) : (i32, !cc.ptr<none>) -> ()
  return
}

llvm.func @my_variadic(i32, ...)

// CHECK-LABEL:   func.func @varargs_test() {
// CHECK:           %[[VAL_0:.*]] = arith.constant 12 : i32
// CHECK:           %[[VAL_1:.*]] = cc.undef !cc.ptr<none>
// CHECK:           cc.call_vararg @my_variadic(%[[VAL_0]], %[[VAL_1]]) : (i32, !cc.ptr<none>) -> ()
// CHECK:           return
// CHECK:         }
// CHECK:         llvm.func @my_variadic(i32, ...)

func.func @indirect_callable2(%arg : !cc.indirect_callable<(i32) -> i64>) -> i64 {
  %cst = arith.constant 4 : i32
  %0 = cc.call_indirect_callable %arg, %cst : (!cc.indirect_callable<(i32) -> i64>, i32) -> i64
  return %0 : i64
}

// CHECK-LABEL:   func.func @indirect_callable2(
// CHECK-SAME:      %[[VAL_0:.*]]: !cc.indirect_callable<(i32) -> i64>) -> i64 {
// CHECK:           %[[VAL_1:.*]] = arith.constant 4 : i32
// CHECK:           %[[VAL_2:.*]] = cc.call_indirect_callable %[[VAL_0]], %[[VAL_1]] : (!cc.indirect_callable<(i32) -> i64>, i32) -> i64
// CHECK:           return %[[VAL_2]] : i64
// CHECK:         }

func.func @quantum_product_type() {
  %0 = quake.alloca !quake.veq<3>
  %1 = quake.alloca !quake.veq<4>
  %2 = quake.make_struq %0, %1 : (!quake.veq<3>, !quake.veq<4>) -> !quake.struq<!quake.veq<?>, !quake.veq<?>>
  %3 = quake.get_member %2[0] : (!quake.struq<!quake.veq<?>, !quake.veq<?>>) -> !quake.veq<?>
  %4 = quake.get_member %2[1] : (!quake.struq<!quake.veq<?>, !quake.veq<?>>) -> !quake.veq<?>
  %10 = quake.alloca !quake.veq<5>
  %11 = quake.alloca !quake.veq<6>
  %12 = quake.make_struq %10, %11 : (!quake.veq<5>, !quake.veq<6>) -> !quake.struq<"gumby": !quake.veq<?>, !quake.veq<?>>
  %13 = quake.get_member %12[0] : (!quake.struq<"gumby": !quake.veq<?>, !quake.veq<?>>) -> !quake.veq<?>
  %14 = quake.get_member %12[1] : (!quake.struq<"gumby": !quake.veq<?>, !quake.veq<?>>) -> !quake.veq<?>
  %20 = quake.alloca !quake.veq<7>
  %21 = quake.alloca !quake.veq<8>
  %22 = quake.make_struq %20, %21 : (!quake.veq<7>, !quake.veq<8>) -> !quake.struq<!quake.veq<7>, !quake.veq<8>>
  %23 = quake.get_member %22[0] : (!quake.struq<!quake.veq<7>, !quake.veq<8>>) -> !quake.veq<7>
  %24 = quake.get_member %22[1] : (!quake.struq<!quake.veq<7>, !quake.veq<8>>) -> !quake.veq<8>
  %25 = quake.alloca !quake.struq<!quake.veq<8>, !quake.veq<5>>
  return
}

// CHECK-LABEL:   func.func @quantum_product_type() {
// CHECK:           %[[VAL_0:.*]] = quake.alloca !quake.veq<3>
// CHECK:           %[[VAL_1:.*]] = quake.alloca !quake.veq<4>
// CHECK:           %[[VAL_2:.*]] = quake.make_struq %[[VAL_0]], %[[VAL_1]] : (!quake.veq<3>, !quake.veq<4>) -> !quake.struq<!quake.veq<?>, !quake.veq<?>>
// CHECK:           %[[VAL_3:.*]] = quake.get_member %[[VAL_2]][0] : (!quake.struq<!quake.veq<?>, !quake.veq<?>>) -> !quake.veq<?>
// CHECK:           %[[VAL_4:.*]] = quake.get_member %[[VAL_2]][1] : (!quake.struq<!quake.veq<?>, !quake.veq<?>>) -> !quake.veq<?>
// CHECK:           %[[VAL_5:.*]] = quake.alloca !quake.veq<5>
// CHECK:           %[[VAL_6:.*]] = quake.alloca !quake.veq<6>
// CHECK:           %[[VAL_7:.*]] = quake.make_struq %[[VAL_5]], %[[VAL_6]] : (!quake.veq<5>, !quake.veq<6>) -> !quake.struq<"gumby": !quake.veq<?>, !quake.veq<?>>
// CHECK:           %[[VAL_8:.*]] = quake.get_member %[[VAL_7]][0] : (!quake.struq<"gumby": !quake.veq<?>, !quake.veq<?>>) -> !quake.veq<?>
// CHECK:           %[[VAL_9:.*]] = quake.get_member %[[VAL_7]][1] : (!quake.struq<"gumby": !quake.veq<?>, !quake.veq<?>>) -> !quake.veq<?>
// CHECK:           %[[VAL_10:.*]] = quake.alloca !quake.veq<7>
// CHECK:           %[[VAL_11:.*]] = quake.alloca !quake.veq<8>
// CHECK:           %[[VAL_12:.*]] = quake.make_struq %[[VAL_10]], %[[VAL_11]] : (!quake.veq<7>, !quake.veq<8>) -> !quake.struq<!quake.veq<7>, !quake.veq<8>>
// CHECK:           %[[VAL_13:.*]] = quake.get_member %[[VAL_12]][0] : (!quake.struq<!quake.veq<7>, !quake.veq<8>>) -> !quake.veq<7>
// CHECK:           %[[VAL_14:.*]] = quake.get_member %[[VAL_12]][1] : (!quake.struq<!quake.veq<7>, !quake.veq<8>>) -> !quake.veq<8>
// CHECK:           %[[VAL_15:.*]] = quake.alloca !quake.struq<!quake.veq<8>, !quake.veq<5>>
// CHECK:           return
// CHECK:         }

func.func private @santa_kraus(!cc.ptr<f64>, !quake.ref)
func.func private @otto_kraus(!quake.ref, !quake.veq<3>)
func.func private @oskar_kraus(!cc.ptr<f64>, !cc.ptr<f32>, !quake.veq<3>)

func.func @quantum_apply_noise(%0 : !cc.ptr<f64>, %3 : !cc.ptr<f32>) {
  %1 = quake.alloca !quake.ref
  quake.apply_noise @santa_kraus(%0) %1 : (!cc.ptr<f64>, !quake.ref) -> ()
  %2 = quake.alloca !quake.veq<3>
  quake.apply_noise @otto_kraus() %1, %2 : (!quake.ref, !quake.veq<3>) -> ()
  quake.apply_noise @oskar_kraus(%0, %3) %2 : (!cc.ptr<f64>, !cc.ptr<f32>, !quake.veq<3>) -> ()
  %key = arith.constant -872 : i64
  quake.apply_noise %key (%0, %3) %2 : (i64, !cc.ptr<f64>, !cc.ptr<f32>, !quake.veq<3>) -> ()
  return
}

// CHECK-LABEL:   func.func @quantum_apply_noise(
// CHECK-SAME:      %[[VAL_0:.*]]: !cc.ptr<f64>, %[[VAL_1:.*]]: !cc.ptr<f32>) {
// CHECK:           %[[VAL_2:.*]] = quake.alloca !quake.ref
// CHECK:           quake.apply_noise @santa_kraus(%[[VAL_0]]) %[[VAL_2]] : (!cc.ptr<f64>, !quake.ref) -> ()
// CHECK:           %[[VAL_3:.*]] = quake.alloca !quake.veq<3>
// CHECK:           quake.apply_noise @otto_kraus() %[[VAL_2]], %[[VAL_3]] : (!quake.ref, !quake.veq<3>) -> ()
// CHECK:           quake.apply_noise @oskar_kraus(%[[VAL_0]], %[[VAL_1]]) %[[VAL_3]] : (!cc.ptr<f64>, !cc.ptr<f32>, !quake.veq<3>) -> ()
// CHECK:           %[[VAL_4:.*]] = arith.constant -872 : i64
// CHECK:           quake.apply_noise %[[VAL_4]](%[[VAL_0]], %[[VAL_1]]) %[[VAL_3]] : (i64, !cc.ptr<f64>, !cc.ptr<f32>, !quake.veq<3>) -> ()
// CHECK:           return
// CHECK:         }

func.func @cable() {
  %0 = quake.null_cable !quake.cable<4>
  %1:4 = quake.terminate_cable %0 : (!quake.cable<4>) -> (!quake.wire, !quake.wire, !quake.wire, !quake.wire)
  %2 = quake.bundle_cable %1#0, %1#3, %1#1, %1#2 : (!quake.wire, !quake.wire, !quake.wire, !quake.wire) -> !quake.cable<4>
  quake.sink_cable %2 : !quake.cable<4>
  return
}

// CHECK-LABEL:   func.func @cable() {
// CHECK:           %[[VAL_0:.*]] = quake.null_cable <4>
// CHECK:           %[[VAL_1:.*]]:4 = quake.terminate_cable %[[VAL_0]] : (!quake.cable<4>) -> (!quake.wire, !quake.wire, !quake.wire, !quake.wire)
// CHECK:           %[[VAL_2:.*]] = quake.bundle_cable %[[VAL_1]]#0, %[[VAL_1]]#3, %[[VAL_1]]#1, %[[VAL_1]]#2 : (!quake.wire, !quake.wire, !quake.wire, !quake.wire) -> !quake.cable<4>
// CHECK:           quake.sink_cable %[[VAL_2]] : <4>
// CHECK:           return
// CHECK:         }

func.func private @integrated_device_callback(i64) -> i64

func.func @integrated_device() {
  %0 = arith.constant 4 : i64
  %1 = cc.device_call @integrated_device_callback (%0) : (i64) -> i64
  %blocks = arith.constant 64 : i64
  %threads = arith.constant 32 : i64
  %2 = cc.device_call @integrated_device_callback <%blocks * %threads> (%0) : (i64, i64, i64) -> i64
  %device = arith.constant 4 : i64
  %3 = cc.device_call @integrated_device_callback <%blocks * %threads> on %device (%0) : (i64, i64, i64, i64) -> i64
  %4 = cc.undef !cc.ptr<!cc.struct<"device_ptr" {i64, i64, i64}>>
  %5 = cc.resolve_device_ptr %4 : (!cc.ptr<!cc.struct<"device_ptr" {i64, i64, i64}>>) -> !cc.ptr<i32>
  %6 = cc.resolve_device_ptr %4 : (!cc.ptr<!cc.struct<"device_ptr" {i64, i64, i64}>>) -> !cc.ptr<f64>
  %blocks_y = arith.constant 1 : i64
  %blocks_z = arith.constant 2 : i64
  %threads_y = arith.constant 3 : i64
  %threads_z = arith.constant 4 : i64
  %7 = cc.device_call @integrated_device_callback <%blocks, %blocks_y, %blocks_z * %threads, %threads_y, %threads_z> on %device (%0) : (i64, i64, i64, i64, i64, i64, i64, i64) -> i64
  return
}

// CHECK-LABEL:   func.func @integrated_device() {
// CHECK:           %[[VAL_0:.*]] = arith.constant 4 : i64
// CHECK:           %[[VAL_1:.*]] = cc.device_call @integrated_device_callback(%[[VAL_0]]) : (i64) -> i64
// CHECK:           %[[VAL_2:.*]] = arith.constant 64 : i64
// CHECK:           %[[VAL_3:.*]] = arith.constant 32 : i64
// CHECK:           %[[VAL_4:.*]] = cc.device_call @integrated_device_callback<%[[VAL_2]] * %[[VAL_3]]>(%[[VAL_0]]) : (i64, i64, i64) -> i64
// CHECK:           %[[VAL_5:.*]] = arith.constant 4 : i64
// CHECK:           %[[VAL_6:.*]] = cc.device_call @integrated_device_callback<%[[VAL_2]] * %[[VAL_3]]> on %[[VAL_5]](%[[VAL_0]]) : (i64, i64, i64, i64) -> i64
// CHECK:           %[[VAL_7:.*]] = cc.undef !cc.ptr<!cc.struct<"device_ptr" {i64, i64, i64}>>
// CHECK:           %[[VAL_8:.*]] = cc.resolve_device_ptr %[[VAL_7]] : (!cc.ptr<!cc.struct<"device_ptr" {i64, i64, i64}>>) -> !cc.ptr<i32>
// CHECK:           %[[VAL_9:.*]] = cc.resolve_device_ptr %[[VAL_7]] : (!cc.ptr<!cc.struct<"device_ptr" {i64, i64, i64}>>) -> !cc.ptr<f64>
// CHECK:           %[[VAL_10:.*]] = arith.constant 1 : i64
// CHECK:           %[[VAL_11:.*]] = arith.constant 2 : i64
// CHECK:           %[[VAL_12:.*]] = arith.constant 3 : i64
// CHECK:           %[[VAL_13:.*]] = arith.constant 4 : i64
// CHECK:           %[[VAL_14:.*]] = cc.device_call @integrated_device_callback<%[[VAL_2]], %[[VAL_10]], %[[VAL_11]] * %[[VAL_3]], %[[VAL_12]], %[[VAL_13]]> on %[[VAL_5]](%[[VAL_0]]) : (i64, i64, i64, i64, i64, i64, i64, i64) -> i64
// CHECK:           return
// CHECK:         }
