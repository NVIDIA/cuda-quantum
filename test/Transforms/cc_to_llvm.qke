// ========================================================================== //
// Copyright (c) 2022 - 2026 NVIDIA Corporation & Affiliates.                 //
// All rights reserved.                                                       //
//                                                                            //
// This source code and the accompanying materials are made available under   //
// the terms of the Apache License 2.0 which accompanies this distribution.   //
// ========================================================================== //

// RUN: cudaq-opt -cc-to-llvm %s | FileCheck %s

func.func @__nvqpp__mlirgen__test3..0x7bf902b23e50() attributes {"cudaq-entrypoint", "cudaq-kernel", "qir-api"} {
  %c0_i64 = arith.constant 0 : i64
  %true = arith.constant true
  %c1_i64 = arith.constant 1 : i64
  %0 = call @__quantum__rt__qubit_allocate_array(%c1_i64) : (i64) -> !cc.ptr<!llvm.struct<"Array", opaque>>
  %1 = cc.alloca i1
  %2 = call @__quantum__rt__array_get_element_ptr_1d(%0, %c0_i64) : (!cc.ptr<!llvm.struct<"Array", opaque>>, i64) -> !cc.ptr<!cc.ptr<!llvm.struct<"Qubit", opaque>>>
  %3 = cc.load %2 : !cc.ptr<!cc.ptr<!llvm.struct<"Qubit", opaque>>>
  %4 = cc.instantiate_callable @__nvqpp__callable.thunk.lambda.0(%true, %1, %3) : (i1, !cc.ptr<i1>, !cc.ptr<!llvm.struct<"Qubit", opaque>>) -> !cc.callable<() -> ()>
  %5:3 = cc.callable_closure %4 : (!cc.callable<() -> ()>) -> (i1, !cc.ptr<i1>, !cc.ptr<!llvm.struct<"Qubit", opaque>>)
  cc.store %5#0, %5#1 : !cc.ptr<i1>
  %6 = cc.load %5#1 : !cc.ptr<i1>
  cf.cond_br %6, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  call @__quantum__qis__x(%5#2) : (!cc.ptr<!llvm.struct<"Qubit", opaque>>) -> ()
  cf.br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  call @__quantum__rt__qubit_release_array(%0) : (!cc.ptr<!llvm.struct<"Array", opaque>>) -> ()
  return
}

func.func private @__nvqpp__callable.thunk.lambda.0(%arg0: !cc.callable<() -> ()>) attributes {"cudaq-kernel", "qir-api"} {
  %0:3 = cc.callable_closure %arg0 : (!cc.callable<() -> ()>) -> (i1, !cc.ptr<i1>, !cc.ptr<!llvm.struct<"Qubit", opaque>>)
  cc.store %0#0, %0#1 : !cc.ptr<i1>
  %1 = cc.load %0#1 : !cc.ptr<i1>
  cf.cond_br %1, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  call @__quantum__qis__x(%0#2) : (!cc.ptr<!llvm.struct<"Qubit", opaque>>) -> ()
  cf.br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  return
}

func.func private @__quantum__rt__qubit_allocate_array(i64) -> !cc.ptr<!llvm.struct<"Array", opaque>>
func.func private @__quantum__rt__qubit_release_array(!cc.ptr<!llvm.struct<"Array", opaque>>)
func.func private @__quantum__rt__array_get_element_ptr_1d(!cc.ptr<!llvm.struct<"Array", opaque>>, i64) -> !cc.ptr<!cc.ptr<!llvm.struct<"Qubit", opaque>>>
func.func private @__quantum__qis__x(!cc.ptr<!llvm.struct<"Qubit", opaque>>)


// CHECK-LABEL:   llvm.func @__nvqpp__callable.thunk.lambda.0(
// CHECK-SAME:      %[[VAL_0:.*]]: !llvm.struct<(ptr<i8>, ptr<i8>)>) attributes {"cudaq-kernel", "qir-api", sym_visibility = "private"} {
// CHECK:           %[[VAL_1:.*]] = llvm.extractvalue %[[VAL_0]][1] : !llvm.struct<(ptr<i8>, ptr<i8>)>
// CHECK:           %[[VAL_2:.*]] = llvm.bitcast %[[VAL_1]] : !llvm.ptr<i8> to !llvm.ptr<struct<(i1, ptr<i1>, ptr<struct<"Qubit", opaque>>)>>
// CHECK:           %[[VAL_3:.*]] = llvm.load %[[VAL_2]] : !llvm.ptr<struct<(i1, ptr<i1>, ptr<struct<"Qubit", opaque>>)>>
// CHECK:           %[[VAL_4:.*]] = llvm.extractvalue %[[VAL_3]][0] : !llvm.struct<(i1, ptr<i1>, ptr<struct<"Qubit", opaque>>)>
// CHECK:           %[[VAL_5:.*]] = llvm.extractvalue %[[VAL_3]][1] : !llvm.struct<(i1, ptr<i1>, ptr<struct<"Qubit", opaque>>)>
// CHECK:           %[[VAL_6:.*]] = llvm.extractvalue %[[VAL_3]][2] : !llvm.struct<(i1, ptr<i1>, ptr<struct<"Qubit", opaque>>)>
// CHECK:           llvm.store %[[VAL_4]], %[[VAL_5]] : !llvm.ptr<i1>
// CHECK:           %[[VAL_7:.*]] = llvm.load %[[VAL_5]] : !llvm.ptr<i1>
