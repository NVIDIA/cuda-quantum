<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>12. Quantum Algorithmic Primitives &mdash; NVIDIA CUDA Quantum  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/cudaq_override.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/_static/cudaq_override.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="13. Example Programs" href="examples.html" />
    <link rel="prev" title="11. Quantum Platform" href="platform.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" > 

          
          
          <a href="../../index.html" class="icon icon-home">
            NVIDIA CUDA Quantum
          </a>
              <div class="version">
                amd64-pr-621
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

  <style>
    /* Sidebar header (and topbar for mobile) */
    .wy-side-nav-search, .wy-nav-top {
      background: #76b900;
    }

    .wy-side-nav-search a:link, .wy-nav-top a:link {
      color: #fff;
    }
    .wy-side-nav-search a:visited, .wy-nav-top a:visited {
      color: #fff;
    }
    .wy-side-nav-search a:hover, .wy-nav-top a:hover {
      color: #fff;
    }

    .wy-menu-vertical a:link, .wy-menu-vertical a:visited {
      color: #d9d9d9
    }

    .wy-menu-vertical a:active {
      background-color: #76b900
    }

    .wy-side-nav-search>div.version {
      color: rgba(0, 0, 0, 0.3)
    }

    /* override table width restrictions */
    .wy-table-responsive table td, .wy-table-responsive table th {
        white-space: normal;
    }

    .wy-table-responsive {
        margin-bottom: 24px;
        max-width: 100%;
        overflow: visible;
    }
  </style>
  
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../install.html">   Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../install.html#docker-image">Docker Image</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#install-the-docker-image">Install the Docker Image</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#use-cuda-quantum-in-a-terminal">Use CUDA Quantum in a Terminal</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#use-cuda-quantum-in-vs-code">Use CUDA Quantum in VS Code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../install.html#python-wheels">Python wheels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../install.html#build-cuda-quantum-from-source">Build CUDA Quantum from Source</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../install.html#next-steps">Next Steps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../using/cudaq.html">   Learn the Basics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../using/cudaq/prereqs.html">CUDA Quantum Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/cudaq/compiling.html">Compiling CUDA Quantum Programs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/cudaq/kernel.html">What is a CUDA Quantum Kernel?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/cudaq/allocating_quantum_memory.html">Allocating Quantum Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/cudaq/runtime_v_compile.html">Runtime Versus Compile-time Kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/cudaq/generic_functions.html">Generic Library Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/cudaq/builder.html">Creating Kernels at Runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/cudaq/variational.html">Variational Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/cudaq/platform.html">Asynchronous Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/cudaq/verbose_out.html">Debugging and Verbose Logging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../using/advanced.html">   Advanced Topics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../using/advanced/nvqir_simulator.html">Create a new NVQIR Simulator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/advanced/nvqir_simulator.html#circuitsimulator"><code class="code docutils literal notranslate"><span class="pre">CircuitSimulator</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/advanced/nvqir_simulator.html#let-s-see-this-in-action">Let‚Äôs see this in action</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../using/advanced/cmake_app.html">Downstream CMake Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/advanced/cudaq_ir.html">Working with CUDA Quantum IR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../using/advanced/mlir_pass.html">Create an MLIR Pass for CUDA Quantum</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../using/examples.html">   Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../using/cpp.html">   CUDA Quantum in C++</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/cpp.html#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/cpp.html#computing-expectation-values">Computing Expectation Values</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/cpp.html#multi-control-synthesis">Multi-control Synthesis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/cpp.html#simulations-with-cuquantum">Simulations with cuQuantum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/cpp.html#using-quantum-hardware-providers">Using Quantum Hardware Providers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../using/python.html">   CUDA Quantum in Python</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/python.html#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/python.html#bernstein-vazirani">Bernstein-Vazirani</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/python.html#variational-quantum-eigensolver">Variational Quantum Eigensolver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/python.html#quantum-approximate-optimization-algorithm">Quantum Approximate Optimization Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/python.html#using-quantum-hardware-providers">Using Quantum Hardware Providers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../using/simulators.html">   Simulator Backends</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../using/simulators.html#state-vector-simulators">State Vector Simulators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/simulators.html#cuquantum-single-gpu">cuQuantum single-GPU</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/simulators.html#cuquantum-multi-node-multi-gpu">cuQuantum multi-node multi-GPU</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/simulators.html#openmp-cpu-only">OpenMP CPU-only</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../using/simulators.html#tensor-network-simulators">Tensor Network Simulators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/simulators.html#id1">cuQuantum multi-node multi-GPU</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../using/hardware.html">   Hardware Backends</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../using/hardware.html#quantinuum">Quantinuum</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/hardware.html#setting-credentials">Setting Credentials</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/hardware.html#submission-from-c">Submission from C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/hardware.html#submission-from-python">Submission from Python</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../using/hardware.html#ionq">IonQ</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../using/hardware.html#id1">Setting Credentials</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/hardware.html#id2">Submission from C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../using/hardware.html#id3">Submission from Python</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">   Specifications</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../cudaq.html">   Language Specification</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="machine_model.html">1. Machine Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="namespace.html">2. Namespace</a></li>
<li class="toctree-l3"><a class="reference internal" href="types.html">3. Quantum Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="types.html#cudaq-qudit-levels">3.1. <code class="code docutils literal notranslate"><span class="pre">cudaq::qudit&lt;Levels&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="types.html#cudaq-qubit">3.2. <code class="code docutils literal notranslate"><span class="pre">cudaq::qubit</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="types.html#quantum-containers">3.3. Quantum Containers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="operators.html">4. Quantum Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="operators.html#cudaq-spin-op">4.1. <code class="code docutils literal notranslate"><span class="pre">cudaq::spin_op</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="operations.html">5. Quantum Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="operations.html#operations-on-cudaq-qubit">5.1. Operations on <code class="code docutils literal notranslate"><span class="pre">cudaq::qubit</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="kernels.html">6. Quantum Kernels</a><ul>
<li class="toctree-l4"><a class="reference internal" href="kernels.html#kernel-composability">6.1. Kernel Composability</a></li>
<li class="toctree-l4"><a class="reference internal" href="kernels.html#allowed-kernel-classical-function-invocations">6.2. Allowed Kernel Classical Function Invocations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="synthesis.html">7. Sub-circuit Synthesis</a></li>
<li class="toctree-l3"><a class="reference internal" href="control_flow.html">8. Control Flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamic_kernels.html">9. Just-in-Time Kernel Creation</a></li>
<li class="toctree-l3"><a class="reference internal" href="patterns.html">10. Quantum Patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="patterns.html#compute-action-uncompute">10.1. Compute-Action-Uncompute</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="platform.html">11. Platform</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">12. Algorithmic Primitives</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cudaq-sample">12.1. <code class="code docutils literal notranslate"><span class="pre">cudaq::sample</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cudaq-observe">12.2. <code class="code docutils literal notranslate"><span class="pre">cudaq::observe</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cudaq-optimizer">12.3. <code class="code docutils literal notranslate"><span class="pre">cudaq::optimizer</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cudaq-gradient">12.4. <code class="code docutils literal notranslate"><span class="pre">cudaq::gradient</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="examples.html">13. Example Programs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="examples.html#hello-world-simple-bell-state">13.1. Hello World - Simple Bell State</a></li>
<li class="toctree-l4"><a class="reference internal" href="examples.html#ghz-state-preparation-and-sampling">13.2. GHZ State Preparation and Sampling</a></li>
<li class="toctree-l4"><a class="reference internal" href="examples.html#quantum-phase-estimation">13.3. Quantum Phase Estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="examples.html#deuteron-binding-energy-parameter-sweep">13.4. Deuteron Binding Energy Parameter Sweep</a></li>
<li class="toctree-l4"><a class="reference internal" href="examples.html#grover-s-algorithm">13.5. Grover‚Äôs Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="examples.html#iterative-phase-estimation">13.6. Iterative Phase Estimation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../quake-dialect.html">   Quake Specification</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../quake-dialect.html#general-introduction">General Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../quake-dialect.html#motivation">Motivation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../quake-dialect.html#quake-types">Quake Types</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api/api.html">   API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/languages/cpp_api.html">C++ API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/cpp_api.html#operators">Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/cpp_api.html#quantum">Quantum</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/cpp_api.html#common">Common</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/cpp_api.html#noise-modeling">Noise Modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/cpp_api.html#kernel-builder">Kernel Builder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/cpp_api.html#algorithms">Algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/cpp_api.html#platform">Platform</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/cpp_api.html#namespaces">Namespaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/languages/python_api.html">Python API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.initialize_cudaq"><code class="docutils literal notranslate"><span class="pre">initialize_cudaq()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.num_available_gpus"><code class="docutils literal notranslate"><span class="pre">num_available_gpus()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.set_random_seed"><code class="docutils literal notranslate"><span class="pre">set_random_seed()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.mpi.initialize"><code class="docutils literal notranslate"><span class="pre">initialize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.mpi.rank"><code class="docutils literal notranslate"><span class="pre">rank()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.mpi.num_ranks"><code class="docutils literal notranslate"><span class="pre">num_ranks()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.mpi.all_gather"><code class="docutils literal notranslate"><span class="pre">all_gather()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.mpi.is_initialized"><code class="docutils literal notranslate"><span class="pre">is_initialized()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.mpi.finalize"><code class="docutils literal notranslate"><span class="pre">finalize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#program-construction">Program Construction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.from_state"><code class="docutils literal notranslate"><span class="pre">from_state()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.make_kernel"><code class="docutils literal notranslate"><span class="pre">make_kernel()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.Kernel"><code class="docutils literal notranslate"><span class="pre">Kernel</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#kernel-execution">Kernel Execution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.sample"><code class="docutils literal notranslate"><span class="pre">sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.sample_async"><code class="docutils literal notranslate"><span class="pre">sample_async()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.observe"><code class="docutils literal notranslate"><span class="pre">observe()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.observe_async"><code class="docutils literal notranslate"><span class="pre">observe_async()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.vqe"><code class="docutils literal notranslate"><span class="pre">vqe()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#backend-configuration">Backend Configuration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.has_target"><code class="docutils literal notranslate"><span class="pre">has_target()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.get_target"><code class="docutils literal notranslate"><span class="pre">get_target()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.get_targets"><code class="docutils literal notranslate"><span class="pre">get_targets()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.set_target"><code class="docutils literal notranslate"><span class="pre">set_target()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.reset_target"><code class="docutils literal notranslate"><span class="pre">reset_target()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.set_noise"><code class="docutils literal notranslate"><span class="pre">set_noise()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.unset_noise"><code class="docutils literal notranslate"><span class="pre">unset_noise()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../api/languages/python_api.html#data-types">Data Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.QuakeValue"><code class="docutils literal notranslate"><span class="pre">QuakeValue</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.qubit"><code class="docutils literal notranslate"><span class="pre">qubit</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.qreg"><code class="docutils literal notranslate"><span class="pre">qreg</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.ComplexMatrix"><code class="docutils literal notranslate"><span class="pre">ComplexMatrix</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.SpinOperator"><code class="docutils literal notranslate"><span class="pre">SpinOperator</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.spin.i"><code class="docutils literal notranslate"><span class="pre">spin.i()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.spin.x"><code class="docutils literal notranslate"><span class="pre">spin.x()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.spin.y"><code class="docutils literal notranslate"><span class="pre">spin.y()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.spin.z"><code class="docutils literal notranslate"><span class="pre">spin.z()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.SampleResult"><code class="docutils literal notranslate"><span class="pre">SampleResult</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.AsyncSampleResult"><code class="docutils literal notranslate"><span class="pre">AsyncSampleResult</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.ObserveResult"><code class="docutils literal notranslate"><span class="pre">ObserveResult</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.AsyncObserveResult"><code class="docutils literal notranslate"><span class="pre">AsyncObserveResult</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#cudaq.OptimizationResult"><code class="docutils literal notranslate"><span class="pre">OptimizationResult</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#optimizers">Optimizers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#gradients">Gradients</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../api/languages/python_api.html#noisy-simulation">Noisy Simulation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">   Other Versions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NVIDIA CUDA Quantum</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Specifications</a></li>
          <li class="breadcrumb-item"><a href="../cudaq.html">Language Specification</a></li>
      <li class="breadcrumb-item active"><span class="section-number">12. </span>Quantum Algorithmic Primitives</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/specification/cudaq/algorithmic_primitives.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quantum-algorithmic-primitives">
<h1><span class="section-number">12. </span>Quantum Algorithmic Primitives<a class="headerlink" href="#quantum-algorithmic-primitives" title="Permalink to this heading">¬∂</a></h1>
<p>The CUDA Quantum model provides the implementation of common quantum algorithmic
primitives within the <code class="code docutils literal notranslate"><span class="pre">cudaq::</span></code> namespace. Here we enumerate available
function calls:</p>
<section id="cudaq-sample">
<h2><span class="section-number">12.1. </span><code class="code docutils literal notranslate"><span class="pre">cudaq::sample</span></code><a class="headerlink" href="#cudaq-sample" title="Permalink to this heading">¬∂</a></h2>
<p>A common task for near-term quantum execution is to sample the state
of a given quantum circuit for a specified number of shots (circuit
executions). The result of this task is typically a mapping of observed
measurement bit strings to the number of times each was observed. This
is typically termed the counts dictionary in the community.</p>
<p>The CUDA Quantum model enables this functionality via template functions within the
<code class="code docutils literal notranslate"><span class="pre">cudaq</span></code> namespace with the following structure:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">QuantumKernel</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">requires</span><span class="w"> </span><span class="n">HasVoidReturnType</span><span class="o">&lt;</span><span class="n">QuantumKernel</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span>
<span class="n">sample_result</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">QuantumKernel</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">QuantumKernel</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">requires</span><span class="w"> </span><span class="n">HasVoidReturnType</span><span class="o">&lt;</span><span class="n">QuantumKernel</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span>
<span class="n">sample_result</span><span class="w"> </span><span class="n">sample</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">shots</span><span class="p">,</span><span class="w"> </span><span class="n">QuantumKernel</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
</pre></div>
</div>
<p>This function takes as input a quantum kernel instance followed by the
concrete arguments at which the kernel should be invoked. CUDA Quantum kernels
passed to this function must be entry-point kernels and return <code class="code docutils literal notranslate"><span class="pre">void</span></code>.</p>
<p>An overload exists for specifying the number of shots to sample.</p>
<p>The function returns an instance of the <code class="code docutils literal notranslate"><span class="pre">cudaq::sample_result</span></code> type which encapsulates
the counts dictionary produced by the sampling task. Programmers can
extract the result information in the following manner:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">bell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]()</span><span class="w"> </span><span class="n">__qpu__</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">counts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaq</span><span class="o">::</span><span class="n">sample</span><span class="p">(</span><span class="n">bell</span><span class="p">)</span>

<span class="c1">// Print to standard out</span>
<span class="n">counts</span><span class="p">.</span><span class="n">dump</span><span class="p">();</span>

<span class="c1">// Fine-grained access to the bits and counts</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">counts</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Observed: %s, %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>CUDA Quantum specifies the following structure for <code class="code docutils literal notranslate"><span class="pre">cudaq::sample_result</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">cudaq</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">CountsDictionary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">GlobalRegisterName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;__global__&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">sample_result</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">      </span><span class="n">sample_result</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">      </span><span class="n">sample_result</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">sample_result</span><span class="w"> </span><span class="o">&amp;</span><span class="p">);</span>
<span class="w">      </span><span class="o">~</span><span class="n">sample_result</span><span class="p">();</span>

<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">register_names</span><span class="p">();</span>

<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">bitString</span><span class="p">,</span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">registerName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GlobalRegisterName</span><span class="p">);</span>

<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>
<span class="w">      </span><span class="n">sequential_data</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">registerName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GlobalRegisterName</span><span class="p">);</span>

<span class="w">      </span><span class="n">CountsDictionary</span>
<span class="w">      </span><span class="nf">to_map</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">registerName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GlobalRegisterName</span><span class="p">);</span>

<span class="w">      </span><span class="n">sample_result</span>
<span class="w">      </span><span class="nf">get_marginal</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">marginalIndices</span><span class="p">,</span>
<span class="w">             </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">registerName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GlobalRegisterName</span><span class="p">);</span>

<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="nf">exp_val_z</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">registerName</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GlobalRegisterName</span><span class="p">);</span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="nf">probability</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">bitString</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">registerName</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GlobalRegisterName</span><span class="p">);</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">registerName</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GlobalRegisterName</span><span class="p">);</span>

<span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="nf">dump</span><span class="p">();</span>
<span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="nf">clear</span><span class="p">();</span>

<span class="w">      </span><span class="n">CountsDictionary</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="nf">begin</span><span class="p">();</span>
<span class="w">      </span><span class="n">CountsDictionary</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="nf">end</span><span class="p">();</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">sample_result</span></code> type enables one to encode measurement results from a
quantum circuit sampling task. It keeps track of a list of sample results, each
one corresponding to a measurement action during the sampling process and represented
by a unique register name. It also tracks a unique global register, the implicit sampling
of the state at the end of circuit execution. The API gives fine-grain access
to the measurement results for each register. To illustrate this, observe</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]()</span><span class="w"> </span><span class="n">__qpu__</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cudaq</span><span class="o">::</span><span class="n">qubit</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="w">  </span><span class="n">h</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">reg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mz</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="w">  </span><span class="n">reset</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="w">  </span><span class="n">x</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">cudaq</span><span class="o">::</span><span class="n">sample</span><span class="p">(</span><span class="n">kernel</span><span class="p">).</span><span class="n">dump</span><span class="p">();</span>
</pre></div>
</div>
<p>should produce</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">{</span>
<span class="w">  </span>__global__<span class="w"> </span>:<span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="m">1</span>:1000<span class="w"> </span><span class="o">}</span>
<span class="w">  </span>reg1<span class="w"> </span>:<span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="m">0</span>:501<span class="w"> </span><span class="m">1</span>:499<span class="w"> </span><span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Here we see that we have measured a qubit in a uniform superposition to a
register named <code class="code docutils literal notranslate"><span class="pre">reg1</span></code>, and followed it with a reset and the application
of an NOT operation. The <code class="code docutils literal notranslate"><span class="pre">sample_result</span></code> returned for this sampling
tasks contains the default <code class="code docutils literal notranslate"><span class="pre">__global__</span></code> register as well as the user
specified <code class="code docutils literal notranslate"><span class="pre">reg1</span></code> register.</p>
<p>The API exposed by the <code class="code docutils literal notranslate"><span class="pre">sample_result</span></code> data type allows one to extract
the information contained at a variety of levels and for each available
register name. One can get the number of times a bit string was observed via
<code class="code docutils literal notranslate"><span class="pre">sample_result::count</span></code>, extract a <code class="code docutils literal notranslate"><span class="pre">std::unordered_map</span></code> representation via
<code class="code docutils literal notranslate"><span class="pre">sample_result::to_map</span></code>, get a new <code class="code docutils literal notranslate"><span class="pre">sample_result</span></code> instance over a subset of
measured qubits via <code class="code docutils literal notranslate"><span class="pre">sample_result::get_marginal</span></code>, and extract the
measurement data as it was produced sequentially (a vector of bit string observations
for each shot in the sampling process). One can also compute probabilities and expectation
values.</p>
<p>There are specific requirements on input quantum kernels for the use of the
sample function which must be enforced by compiler implementations.
The kernel must be an entry-point kernel that returns <code class="code docutils literal notranslate"><span class="pre">void</span></code>.</p>
<p>CUDA Quantum also provides an asynchronous version of this function
(<code class="code docutils literal notranslate"><span class="pre">cudaq::sample_async</span></code>) which returns a
<code class="code docutils literal notranslate"><span class="pre">sample_async_result</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">QuantumKernel</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">async_sample_result</span><span class="w"> </span><span class="n">sample_async</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">qpu_id</span><span class="p">,</span><span class="w"> </span><span class="n">QuantumKernel</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
</pre></div>
</div>
<p>Programmers can asynchronously launch sampling tasks on any <code class="code docutils literal notranslate"><span class="pre">qpu_id</span></code>.</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">async_sample_result</span></code> wraps a <code class="code docutils literal notranslate"><span class="pre">std::future&lt;sample_result&gt;</span></code> and exposes the same
<code class="code docutils literal notranslate"><span class="pre">get()</span></code> functionality to extract the results after asynchronous execution.</p>
<p>For remote QPU systems with long queue times, the <code class="code docutils literal notranslate"><span class="pre">async_sample_result</span></code> type encodes job ID
information and can be persisted to file and loaded from file at a later time. After loading from file,
and when remote queue jobs are completed, one can invoke <code class="code docutils literal notranslate"><span class="pre">get()</span></code> and the results will
be retrieved and returned.</p>
</section>
<section id="cudaq-observe">
<h2><span class="section-number">12.2. </span><code class="code docutils literal notranslate"><span class="pre">cudaq::observe</span></code><a class="headerlink" href="#cudaq-observe" title="Permalink to this heading">¬∂</a></h2>
<p>A common task in variational algorithms is the computation of the expected
value of a given observable with respect to a parameterized quantum circuit
(<span class="math notranslate nohighlight">\(\langle H \rangle(ùöπ) = \langle \psi(ùöπ)|H|\psi(ùöπ) \rangle\)</span>).</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">cudaq::observe</span></code> function is provided to enable one to quickly compute
this expectation value via execution of the parameterized quantum circuit
with repeated measurements in the bases of the provided spin_op terms. The
function has the following signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">QuantumKernel</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">observe_result</span><span class="w"> </span><span class="n">observe</span><span class="p">(</span><span class="n">QuantumKernel</span><span class="o">&amp;&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaq</span><span class="o">::</span><span class="n">spin_op</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">QuantumKernel</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">observe_result</span><span class="w"> </span><span class="n">observe</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">shots</span><span class="p">,</span><span class="w"> </span><span class="n">QuantumKernel</span><span class="o">&amp;&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">cudaq</span><span class="o">::</span><span class="n">spin_op</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
</pre></div>
</div>
<p>This function takes as input an instantiated quantum kernel, the
<code class="code docutils literal notranslate"><span class="pre">cudaq::spin_op</span></code> whose expectation is requested, and the concrete
arguments used as input to the parameterized quantum kernel. This function
returns an instance of the <code class="code docutils literal notranslate"><span class="pre">observe_result</span></code> type which can be implicitly
converted to a <code class="code docutils literal notranslate"><span class="pre">double</span></code> expectation value, but also retains all data directly
generated and used as part of that expectation value computation. The
<code class="code docutils literal notranslate"><span class="pre">observe_result</span></code> takes on the following form:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">observe_result</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">observe_result</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">spin_op</span><span class="w"> </span><span class="o">&amp;</span><span class="n">H</span><span class="p">);</span>
<span class="w">    </span><span class="n">observe_result</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">spin_op</span><span class="w"> </span><span class="o">&amp;</span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n">MeasureCounts</span><span class="w"> </span><span class="n">counts</span><span class="p">);</span>

<span class="w">    </span><span class="n">sample_results</span><span class="w"> </span><span class="nf">raw_data</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">operator</span><span class="w"> </span><span class="kt">double</span><span class="p">();</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="nf">exp_val_z</span><span class="p">();</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">SpinOpType</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">exp_val_z</span><span class="p">(</span><span class="n">SpinOpType</span><span class="w"> </span><span class="n">term</span><span class="p">);</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">SpinOpType</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">sample_result</span><span class="w"> </span><span class="n">counts</span><span class="p">(</span><span class="n">SpinOpType</span><span class="w"> </span><span class="n">term</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="nf">id_coefficient</span><span class="p">()</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">dump</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The public API for <code class="code docutils literal notranslate"><span class="pre">observe_result</span></code> enables one to extract the
<code class="code docutils literal notranslate"><span class="pre">sample_result</span></code> data for each term in the provided <code class="code docutils literal notranslate"><span class="pre">spin_op</span></code>.
This return type can be used in the following way.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// I only care about the expected value, discard</span>
<span class="c1">// the fine-grain data produced</span>
<span class="kt">double</span><span class="w"> </span><span class="n">expVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaq</span><span class="o">::</span><span class="n">observe</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">spinOp</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">...);</span>

<span class="c1">// I require the result with all generated data</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaq</span><span class="o">::</span><span class="n">observe</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">spinOp</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">...);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">expVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">exp_val_z</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">X0X1Exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">exp_val_z</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="k">auto</span><span class="w"> </span><span class="n">X0X1Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">counts</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">result</span><span class="p">.</span><span class="n">dump</span><span class="p">();</span>
</pre></div>
</div>
<p>Here is an example of the utility of the <code class="code docutils literal notranslate"><span class="pre">cudaq::observe</span></code> function:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">ansatz</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">double</span><span class="w"> </span><span class="n">theta</span><span class="p">)</span><span class="w"> </span><span class="n">__qpu__</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cudaq</span><span class="o">::</span><span class="n">qreg</span><span class="w"> </span><span class="nf">q</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">x</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">ry</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">x</span><span class="o">&lt;</span><span class="n">cudaq</span><span class="o">::</span><span class="n">ctrl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">cudaq</span><span class="o">::</span><span class="nn">spin</span><span class="p">;</span><span class="w"> </span><span class="c1">// make it easier to use pauli X,Y,Z below</span>

<span class="w">  </span><span class="n">spin_op</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.907</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.1433</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.1433</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">              </span><span class="mf">.21829</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">6.125</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaq</span><span class="o">::</span><span class="n">observe</span><span class="p">(</span><span class="n">ansatz</span><span class="p">{},</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="mf">.59</span><span class="p">);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Energy is %lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">energy</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are specific requirements on input quantum kernels for the use of the
observe function which must be enforced by compiler implementations. The
kernel must be an entry-point kernel that does not contain any conditional
or measurement statements.</p>
<p>By default on simulation backends, <code class="code docutils literal notranslate"><span class="pre">cudaq::observe</span></code> computes the true
analytic expectation value (i.e. without stochastic noise due to shots-based sampling).
If a specific shot count is provided then the returned expectation value will contain some
level of statistical noise. An overload of the <code class="code docutils literal notranslate"><span class="pre">observe</span></code> function is provided to
specify the number of shots.</p>
<p>CUDA Quantum also provides an asynchronous version of this function
(<code class="code docutils literal notranslate"><span class="pre">cudaq::observe_async</span></code>) which returns a <code class="code docutils literal notranslate"><span class="pre">async_observe_result</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">QuantumKernel</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="n">async_observe_result</span><span class="w"> </span><span class="n">observe_async</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">qpu_id</span><span class="p">,</span><span class="w"> </span><span class="n">QuantumKernel</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">cudaq</span><span class="o">::</span><span class="n">spin_op</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">argss</span><span class="p">);</span>
</pre></div>
</div>
<p>Programmers can asynchronously launch sampling tasks on any <code class="code docutils literal notranslate"><span class="pre">qpu_id</span></code>.</p>
<p>For remote QPU systems with long queue times, the <code class="code docutils literal notranslate"><span class="pre">async_observe_result</span></code> type encodes job ID
information for each execution and can be persisted to file and loaded from file at a later time. After loading from file,
and when remote queue jobs are completed, one can invoke <code class="code docutils literal notranslate"><span class="pre">get()</span></code> and the results will
be retrieved and returned.</p>
</section>
<section id="cudaq-optimizer">
<h2><span class="section-number">12.3. </span><code class="code docutils literal notranslate"><span class="pre">cudaq::optimizer</span></code><a class="headerlink" href="#cudaq-optimizer" title="Permalink to this heading">¬∂</a></h2>
<p>The primary use case for <code class="code docutils literal notranslate"><span class="pre">cudaq::observe</span></code> is to leverage it as
the core of a broader objective function optimization workflow.
<code class="code docutils literal notranslate"><span class="pre">cudaq::observe</span></code> produces the expected value of a specified
<code class="code docutils literal notranslate"><span class="pre">spin_op</span></code> with respect to a given parameterized ansatz at a concrete
set of parameters, and often programmers will require an extremal value of that expected value
at a specific set of concrete parameters. This will directly require
abstractions for gradient-based and gradient-free optimization strategies.</p>
<p>The CUDA Quantum model provides a <code class="code docutils literal notranslate"><span class="pre">cudaq::optimizer</span></code> data type that exposes
an <code class="code docutils literal notranslate"><span class="pre">optimize()</span></code> method that takes as input an
<code class="code docutils literal notranslate"><span class="pre">optimizable_function</span></code> to optimize and the number of independent
function dimensions. Implementations are free to implement this abstraction
in any way that is pertinent, but it is expected that most approaches will
enable optimization strategy extensibility. For example, programmers should
be able to instantiate a specific <code class="code docutils literal notranslate"><span class="pre">cudaq::optimizer</span></code> sub-type, thereby
dictating the underlying optimization algorithm in a type-safe manner.
Moreover, the optimizer should expose a public API of pertinent optimizer-specific
options that the programmer can customize.</p>
<p>CUDA Quantum models the <code class="code docutils literal notranslate"><span class="pre">cudaq::optimizer</span></code> as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">cudaq</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Encode the optimal value and optimal parameters</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">optimization_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Initialized with user specified callable of a specific signature</span>
<span class="w">  </span><span class="c1">// Clients can query if the function computes gradients or not</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">optimizable_function</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">      </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Callable</span><span class="o">&gt;</span>
<span class="w">      </span><span class="n">optimizable_function</span><span class="p">(</span><span class="n">Callable</span><span class="o">&amp;&amp;</span><span class="p">);</span>
<span class="w">      </span><span class="kt">bool</span><span class="w"> </span><span class="nf">providesGradients</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">_providesGradients</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dx</span><span class="p">);</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">optimizer</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">      </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">requiresGradients</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="k">virtual</span><span class="w"> </span><span class="n">optimization_result</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dimensions</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">optimizable_function</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">opt_function</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, <code class="code docutils literal notranslate"><span class="pre">optimization_result</span></code> should encode the optimal value and optimal
parameters achieved during the optimization workflow
(i.e. a <code class="code docutils literal notranslate"><span class="pre">tuple&lt;double,</span> <span class="pre">std::vector&lt;double&gt;&gt;</span></code>). The optimize method takes
as input the number of parameters (or dimensions of the objective function),
and a function-like object (i.e. <code class="code docutils literal notranslate"><span class="pre">std::function</span></code> or a lambda, something
<code class="code docutils literal notranslate"><span class="pre">optimizable_function</span></code> can be constructed from) that takes a
<code class="code docutils literal notranslate"><span class="pre">const</span> <span class="pre">std::vector&lt;double&gt;&amp;</span></code> and <code class="code docutils literal notranslate"><span class="pre">std::vector&lt;double&gt;&amp;</span></code> for the
function input parameters and gradient vector, respectively. The objective
function must return a double representing the scalar cost for the
objective function (e.g. the expected value from <code class="code docutils literal notranslate"><span class="pre">cudaq::observe()</span></code>).</p>
<p>Here is an example of how the <code class="code docutils literal notranslate"><span class="pre">cudaq::optimizer</span></code> is intended to be used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">ansatz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">theta</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">phi</span><span class="p">)</span><span class="w"> </span><span class="n">__qpu__</span><span class="w"> </span><span class="p">{...};</span>
<span class="n">cudaq</span><span class="o">::</span><span class="n">spin_op</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">;</span>

<span class="n">cudaq</span><span class="o">::</span><span class="n">optimizers</span><span class="o">::</span><span class="n">cobyla</span><span class="w"> </span><span class="n">optimizer</span><span class="p">;</span>
<span class="n">optimizer</span><span class="p">.</span><span class="n">max_eval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">opt_energy</span><span class="p">,</span><span class="w"> </span><span class="n">opt_params</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optimizer</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span>
<span class="w">      </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">grad_vec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">cudaq</span><span class="o">::</span><span class="n">observe</span><span class="p">(</span><span class="n">ansatz</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">      </span><span class="p">});</span>
</pre></div>
</div>
</section>
<section id="cudaq-gradient">
<h2><span class="section-number">12.4. </span><code class="code docutils literal notranslate"><span class="pre">cudaq::gradient</span></code><a class="headerlink" href="#cudaq-gradient" title="Permalink to this heading">¬∂</a></h2>
<p>Typical optimization use cases will require the computation of gradients for the specified
objective function. The gradient is a vector over all ansatz circuit
parameters <span class="math notranslate nohighlight">\(‚àÇH(ùöπ) / ‚àÇùöπ_i\)</span>. There are a number of potential strategies for
computing this gradient vector, but most require additional evaluations
of the ansatz circuit on the quantum processor.</p>
<p>To enable true extensibility in gradient strategies, CUDA Quantum programmers can
instantiate custom sub-types of the <code class="code docutils literal notranslate"><span class="pre">cudaq::gradient</span></code> type. The <code class="code docutils literal notranslate"><span class="pre">cudaq::gradient</span></code>
type defines a <code class="code docutils literal notranslate"><span class="pre">compute(...)</span></code> method that takes a mutable reference to the
current gradient vector and is free to update that vector in a strategy-specific way.
The method also takes the current evaluation parameter vector, the <code class="code docutils literal notranslate"><span class="pre">cudaq::spin_op</span></code> used
in the current variational task, and the computed expected value at the given parameters.
The gradient strategy type takes the following form:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">cudaq</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">gradient</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">      </span><span class="n">gradient</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">kernel</span><span class="p">);</span>

<span class="w">      </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">QuantumKernel</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ArgsMapper</span><span class="o">&gt;</span>
<span class="w">      </span><span class="n">gradient</span><span class="p">(</span><span class="n">QuantumKernel</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">kernel</span><span class="p">,</span><span class="w"> </span><span class="n">ArgsMapper</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">argsMapper</span><span class="p">);</span>

<span class="w">      </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dx</span><span class="p">,</span>
<span class="w">                         </span><span class="n">spin_op</span><span class="o">&amp;</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">exp_h</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">      </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span>
<span class="w">      </span><span class="n">compute</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span>
<span class="w">              </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="c1">// gradient is intended for subclassing</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">central_difference</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">gradient</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">      </span><span class="kt">void</span><span class="w"> </span><span class="n">compute</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">spin_op</span><span class="o">&amp;</span><span class="w"> </span><span class="n">h</span><span class="p">,</span>
<span class="w">               </span><span class="kt">double</span><span class="w"> </span><span class="n">exp_h</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="code docutils literal notranslate"><span class="pre">compute</span></code> function can make use of the quantum kernel parameterized ansatz, the
<code class="code docutils literal notranslate"><span class="pre">spin_op</span></code> for which the expected value is being computed, the
pre-computed expected value at the current iteration‚Äôs parameter, and the
concrete arguments for the given quantum kernel at this iteration.</p>
<p>A non-trivial aspect of the computation of gradients (in an extensible manner)
is that we model the gradient as a derivative over concrete parameters for the
circuit ansatz represented as a <code class="code docutils literal notranslate"><span class="pre">std::vector&lt;double&gt;</span></code> when the actual
quantum kernel may be defined with general variadic <code class="code docutils literal notranslate"><span class="pre">Args...</span></code> types.
To address this issue, programmers can provide a default translation
mechanism for mapping common quantum kernel ansatz functional expressions to a <code class="code docutils literal notranslate"><span class="pre">vector&lt;double&gt;</span></code> representation - the
<code class="code docutils literal notranslate"><span class="pre">ArgsMapper</span></code> callable template type. This type must implement the
<code class="code docutils literal notranslate"><span class="pre">std::tuple&lt;Args...&gt;(std::vector&lt;double&gt;&amp;)</span></code> callable concept.</p>
<p>The overall CUDA Quantum workflow for leveraging the <code class="code docutils literal notranslate"><span class="pre">cudaq::optimizer</span></code>
will work as follows (here we demonstrate with an ansatz without the
default <code class="code docutils literal notranslate"><span class="pre">std::vector&lt;double&gt;</span></code> signature):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">deuteron_n3_ansatz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x1</span><span class="p">)</span><span class="w"> </span><span class="n">__qpu__</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">cudaq</span><span class="o">::</span><span class="n">qreg</span><span class="w"> </span><span class="nf">q</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">  </span><span class="n">x</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">  </span><span class="n">ry</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">ry</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">  </span><span class="n">x</span><span class="o">&lt;</span><span class="n">cudaq</span><span class="o">::</span><span class="n">ctrl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">  </span><span class="n">x</span><span class="o">&lt;</span><span class="n">vctrl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">x</span><span class="o">&lt;</span><span class="n">cudaq</span><span class="o">::</span><span class="n">ctrl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">  </span><span class="n">x</span><span class="o">&lt;</span><span class="n">cudaq</span><span class="o">::</span><span class="n">ctrl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">};</span>

<span class="n">cudaq</span><span class="o">::</span><span class="n">spin_op</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.907</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.1433</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.1433</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="mf">.21829</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">6.125</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">cudaq</span><span class="o">::</span><span class="n">spin_op</span><span class="w"> </span><span class="n">h3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">9.625</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">9.625</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">3.913119</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">-</span>
<span class="w">            </span><span class="mf">3.913119</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="c1">// The above ansatz takes 2 doubles, not a single std::vector&lt;double&gt;, which</span>
<span class="c1">// the gradient type is expecting. So we must provide an ArgsMapper callable type</span>
<span class="k">auto</span><span class="w"> </span><span class="n">argsMapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]);};</span>

<span class="c1">// Create the gradient strategy</span>
<span class="n">cudaq</span><span class="o">::</span><span class="n">gradients</span><span class="o">::</span><span class="n">central_difference</span><span class="w"> </span><span class="nf">gradient</span><span class="p">(</span><span class="n">deuteron_n3_ansatz</span><span class="p">,</span><span class="w"> </span><span class="n">argsMapper</span><span class="p">);</span>

<span class="c1">// Create the L-BFGS optimizer, requires gradients</span>
<span class="n">cudaq</span><span class="o">::</span><span class="n">optimizers</span><span class="o">::</span><span class="n">lbfgs</span><span class="w"> </span><span class="n">optimizer</span><span class="p">;</span>

<span class="c1">// Run the optimization routine.</span>
<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">min_val</span><span class="p">,</span><span class="w"> </span><span class="n">opt_params</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">optimizer</span><span class="p">.</span><span class="n">optimize</span><span class="p">(</span>
<span class="w">    </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">grad_vec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Compute the cost, here its an energy</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">cost</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cudaq</span><span class="o">::</span><span class="n">observe</span><span class="p">(</span><span class="n">deuteron_n3_ansatz</span><span class="p">,</span><span class="w"> </span><span class="n">h3</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Compute the gradient, results written to the grad_vec reference</span>
<span class="w">      </span><span class="n">gradient</span><span class="p">.</span><span class="n">compute</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">grad_vec</span><span class="p">,</span><span class="w"> </span><span class="n">h3</span><span class="p">,</span><span class="w"> </span><span class="n">cost</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Return the cost to the optimizer</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">cost</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>

<span class="c1">// Print the results</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Optimizer found %lf at [%lf,%lf]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">min_val</span><span class="p">,</span><span class="w"> </span><span class="n">opt_params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">opt_params</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="platform.html" class="btn btn-neutral float-left" title="11. Quantum Platform" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="examples.html" class="btn btn-neutral float-right" title="13. Example Programs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, NVIDIA Corporation &amp; Affiliates.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script>  

  <style>
  a:link, a:visited {
    color: #76b900;
  }

  a:hover {
    color: #8c0;
  }

  .rst-content dl:not(.docutils) dt {
    background: rgba(118, 185, 0, 0.1);
    color: rgba(59,93,0,1);
    border-top: solid 3px rgba(59,93,0,1);
  }
  </style>
  

</body>
</html>