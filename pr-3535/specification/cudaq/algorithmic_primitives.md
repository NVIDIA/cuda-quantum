::: wy-grid-for-nav
::: wy-side-scroll
::: {.wy-side-nav-search style="background: #76b900"}
[NVIDIA CUDA-Q](../../index.html){.icon .icon-home}

::: version
pr-3535
:::

::: {role="search"}
:::
:::

::: {.wy-menu .wy-menu-vertical spy="affix" role="navigation" aria-label="Navigation menu"}
[Contents]{.caption-text}

-   [Quick Start](../../using/quick_start.html){.reference .internal}
    -   [Install
        CUDA-Q](../../using/quick_start.html#install-cuda-q){.reference
        .internal}
    -   [Validate your
        Installation](../../using/quick_start.html#validate-your-installation){.reference
        .internal}
    -   [CUDA-Q
        Academic](../../using/quick_start.html#cuda-q-academic){.reference
        .internal}
-   [Basics](../../using/basics/basics.html){.reference .internal}
    -   [What is a CUDA-Q
        Kernel?](../../using/basics/kernel_intro.html){.reference
        .internal}
    -   [Building your first CUDA-Q
        Program](../../using/basics/build_kernel.html){.reference
        .internal}
    -   [Running your first CUDA-Q
        Program](../../using/basics/run_kernel.html){.reference
        .internal}
        -   [Sample](../../using/basics/run_kernel.html#sample){.reference
            .internal}
        -   [Run](../../using/basics/run_kernel.html#run){.reference
            .internal}
        -   [Observe](../../using/basics/run_kernel.html#observe){.reference
            .internal}
        -   [Running on a
            GPU](../../using/basics/run_kernel.html#running-on-a-gpu){.reference
            .internal}
    -   [Troubleshooting](../../using/basics/troubleshooting.html){.reference
        .internal}
        -   [Debugging and Verbose Simulation
            Output](../../using/basics/troubleshooting.html#debugging-and-verbose-simulation-output){.reference
            .internal}
-   [Examples](../../using/examples/examples.html){.reference .internal}
    -   [Introduction](../../using/examples/introduction.html){.reference
        .internal}
    -   [Building
        Kernels](../../using/examples/building_kernels.html){.reference
        .internal}
        -   [Defining
            Kernels](../../using/examples/building_kernels.html#defining-kernels){.reference
            .internal}
        -   [Initializing
            states](../../using/examples/building_kernels.html#initializing-states){.reference
            .internal}
        -   [Applying
            Gates](../../using/examples/building_kernels.html#applying-gates){.reference
            .internal}
        -   [Controlled
            Operations](../../using/examples/building_kernels.html#controlled-operations){.reference
            .internal}
        -   [Multi-Controlled
            Operations](../../using/examples/building_kernels.html#multi-controlled-operations){.reference
            .internal}
        -   [Adjoint
            Operations](../../using/examples/building_kernels.html#adjoint-operations){.reference
            .internal}
        -   [Custom
            Operations](../../using/examples/building_kernels.html#custom-operations){.reference
            .internal}
        -   [Building Kernels with
            Kernels](../../using/examples/building_kernels.html#building-kernels-with-kernels){.reference
            .internal}
        -   [Parameterized
            Kernels](../../using/examples/building_kernels.html#parameterized-kernels){.reference
            .internal}
    -   [Quantum
        Operations](../../using/examples/quantum_operations.html){.reference
        .internal}
        -   [Quantum
            States](../../using/examples/quantum_operations.html#quantum-states){.reference
            .internal}
        -   [Quantum
            Gates](../../using/examples/quantum_operations.html#quantum-gates){.reference
            .internal}
        -   [Measurements](../../using/examples/quantum_operations.html#measurements){.reference
            .internal}
    -   [Measuring
        Kernels](../../using/examples/measuring_kernels.html){.reference
        .internal}
        -   [Mid-circuit Measurement and Conditional
            Logic](../../using/examples/measuring_kernels.html#mid-circuit-measurement-and-conditional-logic){.reference
            .internal}
    -   [Visualizing
        Kernels](../../examples/python/visualization.html){.reference
        .internal}
        -   [Qubit
            Visualization](../../examples/python/visualization.html#Qubit-Visualization){.reference
            .internal}
        -   [Kernel
            Visualization](../../examples/python/visualization.html#Kernel-Visualization){.reference
            .internal}
    -   [Executing
        Kernels](../../using/examples/executing_kernels.html){.reference
        .internal}
        -   [Sample](../../using/examples/executing_kernels.html#sample){.reference
            .internal}
            -   [Sample
                Asynchronous](../../using/examples/executing_kernels.html#sample-asynchronous){.reference
                .internal}
        -   [Run](../../using/examples/executing_kernels.html#run){.reference
            .internal}
            -   [Return Custom Data
                Types](../../using/examples/executing_kernels.html#return-custom-data-types){.reference
                .internal}
            -   [Run
                Asynchronous](../../using/examples/executing_kernels.html#run-asynchronous){.reference
                .internal}
        -   [Observe](../../using/examples/executing_kernels.html#observe){.reference
            .internal}
            -   [Observe
                Asynchronous](../../using/examples/executing_kernels.html#observe-asynchronous){.reference
                .internal}
        -   [Get
            State](../../using/examples/executing_kernels.html#get-state){.reference
            .internal}
            -   [Get State
                Asynchronous](../../using/examples/executing_kernels.html#get-state-asynchronous){.reference
                .internal}
    -   [Computing Expectation
        Values](../../using/examples/expectation_values.html){.reference
        .internal}
        -   [Parallelizing across Multiple
            Processors](../../using/examples/expectation_values.html#parallelizing-across-multiple-processors){.reference
            .internal}
    -   [Multi-GPU
        Workflows](../../using/examples/multi_gpu_workflows.html){.reference
        .internal}
        -   [From CPU to
            GPU](../../using/examples/multi_gpu_workflows.html#from-cpu-to-gpu){.reference
            .internal}
        -   [Pooling the memory of multiple GPUs ([`mgpu`{.code
            .docutils .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#pooling-the-memory-of-multiple-gpus-mgpu){.reference
            .internal}
        -   [Parallel execution over multiple QPUs ([`mqpu`{.code
            .docutils .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#parallel-execution-over-multiple-qpus-mqpu){.reference
            .internal}
            -   [Batching Hamiltonian
                Terms](../../using/examples/multi_gpu_workflows.html#batching-hamiltonian-terms){.reference
                .internal}
            -   [Circuit
                Batching](../../using/examples/multi_gpu_workflows.html#circuit-batching){.reference
                .internal}
        -   [Multi-QPU + Other Backends ([`remote-mqpu`{.code .docutils
            .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#multi-qpu-other-backends-remote-mqpu){.reference
            .internal}
    -   [Optimizers &
        Gradients](../../examples/python/optimizers_gradients.html){.reference
        .internal}
        -   [Built in CUDA-Q Optimizers and
            Gradients](../../examples/python/optimizers_gradients.html#Built-in-CUDA-Q-Optimizers-and-Gradients){.reference
            .internal}
        -   [Third-Party
            Optimizers](../../examples/python/optimizers_gradients.html#Third-Party-Optimizers){.reference
            .internal}
        -   [Parallel Parameter Shift
            Gradients](../../examples/python/optimizers_gradients.html#Parallel-Parameter-Shift-Gradients){.reference
            .internal}
    -   [Noisy
        Simulations](../../examples/python/noisy_simulations.html){.reference
        .internal}
    -   [Constructing
        Operators](../../using/examples/operators.html){.reference
        .internal}
        -   [Constructing Spin
            Operators](../../using/examples/operators.html#constructing-spin-operators){.reference
            .internal}
        -   [Pauli Words and Exponentiating Pauli
            Words](../../using/examples/operators.html#pauli-words-and-exponentiating-pauli-words){.reference
            .internal}
    -   [Performance
        Optimizations](../../examples/python/performance_optimizations.html){.reference
        .internal}
        -   [Gate
            Fusion](../../examples/python/performance_optimizations.html#Gate-Fusion){.reference
            .internal}
    -   [Using Quantum Hardware
        Providers](../../using/examples/hardware_providers.html){.reference
        .internal}
        -   [Amazon
            Braket](../../using/examples/hardware_providers.html#amazon-braket){.reference
            .internal}
        -   [Anyon
            Technologies](../../using/examples/hardware_providers.html#anyon-technologies){.reference
            .internal}
        -   [Infleqtion](../../using/examples/hardware_providers.html#infleqtion){.reference
            .internal}
        -   [IonQ](../../using/examples/hardware_providers.html#ionq){.reference
            .internal}
        -   [IQM](../../using/examples/hardware_providers.html#iqm){.reference
            .internal}
        -   [OQC](../../using/examples/hardware_providers.html#oqc){.reference
            .internal}
        -   [ORCA
            Computing](../../using/examples/hardware_providers.html#orca-computing){.reference
            .internal}
        -   [Pasqal](../../using/examples/hardware_providers.html#pasqal){.reference
            .internal}
        -   [Quantinuum](../../using/examples/hardware_providers.html#quantinuum){.reference
            .internal}
        -   [Quantum Circuits,
            Inc.](../../using/examples/hardware_providers.html#quantum-circuits-inc){.reference
            .internal}
        -   [Quantum
            Machines](../../using/examples/hardware_providers.html#quantum-machines){.reference
            .internal}
        -   [QuEra
            Computing](../../using/examples/hardware_providers.html#quera-computing){.reference
            .internal}
    -   [Dynamics
        Examples](../../using/examples/dynamics_examples.html){.reference
        .internal}
        -   [Introduction to CUDA-Q Dynamics (Jaynes-Cummings
            Model)](../../examples/python/dynamics/dynamics_intro_1.html){.reference
            .internal}
            -   [Why dynamics simulations vs. circuit
                simulations?](../../examples/python/dynamics/dynamics_intro_1.html#Why-dynamics-simulations-vs.-circuit-simulations?){.reference
                .internal}
            -   [Functionality](../../examples/python/dynamics/dynamics_intro_1.html#Functionality){.reference
                .internal}
            -   [Performance](../../examples/python/dynamics/dynamics_intro_1.html#Performance){.reference
                .internal}
            -   [Section 1 - Simulating the Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Section-1---Simulating-the-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Exercise 1 - Simulating a many-photon Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-1---Simulating-a-many-photon-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Section 2 - Simulating open quantum systems with the
                [`collapse_operators`{.docutils .literal
                .notranslate}]{.pre}](../../examples/python/dynamics/dynamics_intro_1.html#Section-2---Simulating-open-quantum-systems-with-the-collapse_operators){.reference
                .internal}
            -   [Exercise 2 - Adding additional jump operators
                [\\(L_i\\)]{.math .notranslate
                .nohighlight}](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-2---Adding-additional-jump-operators-L_i){.reference
                .internal}
            -   [Section 3 - Many qubits coupled to the
                resonator](../../examples/python/dynamics/dynamics_intro_1.html#Section-3---Many-qubits-coupled-to-the-resonator){.reference
                .internal}
        -   [Introduction to CUDA-Q Dynamics (Time Dependent
            Hamiltonians)](../../examples/python/dynamics/dynamics_intro_2.html){.reference
            .internal}
            -   [The Landau-Zener
                model](../../examples/python/dynamics/dynamics_intro_2.html#The-Landau-Zener-model){.reference
                .internal}
            -   [Section 1 - Implementing time dependent
                terms](../../examples/python/dynamics/dynamics_intro_2.html#Section-1---Implementing-time-dependent-terms){.reference
                .internal}
            -   [Section 2 - Implementing custom
                operators](../../examples/python/dynamics/dynamics_intro_2.html#Section-2---Implementing-custom-operators){.reference
                .internal}
            -   [Section 3 - Heisenberg Model with a time-varying
                magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Section-3---Heisenberg-Model-with-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 1 - Define a time-varying magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-1---Define-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 2
                (Optional)](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-2-(Optional)){.reference
                .internal}
        -   [Superconducting
            Qubits](../../examples/python/dynamics/superconducting.html){.reference
            .internal}
            -   [Cavity
                QED](../../examples/python/dynamics/superconducting.html#Cavity-QED){.reference
                .internal}
            -   [Cross
                Resonance](../../examples/python/dynamics/superconducting.html#Cross-Resonance){.reference
                .internal}
            -   [Transmon
                Resonator](../../examples/python/dynamics/superconducting.html#Transmon-Resonator){.reference
                .internal}
        -   [Spin
            Qubits](../../examples/python/dynamics/spinqubits.html){.reference
            .internal}
            -   [Silicon Spin
                Qubit](../../examples/python/dynamics/spinqubits.html#Silicon-Spin-Qubit){.reference
                .internal}
            -   [Heisenberg
                Model](../../examples/python/dynamics/spinqubits.html#Heisenberg-Model){.reference
                .internal}
        -   [Trapped Ion
            Qubits](../../examples/python/dynamics/iontrap.html){.reference
            .internal}
            -   [GHZ
                state](../../examples/python/dynamics/iontrap.html#GHZ-state){.reference
                .internal}
        -   [Control](../../examples/python/dynamics/control.html){.reference
            .internal}
            -   [Gate
                Calibration](../../examples/python/dynamics/control.html#Gate-Calibration){.reference
                .internal}
            -   [Pulse](../../examples/python/dynamics/control.html#Pulse){.reference
                .internal}
            -   [Qubit
                Control](../../examples/python/dynamics/control.html#Qubit-Control){.reference
                .internal}
            -   [Qubit
                Dynamics](../../examples/python/dynamics/control.html#Qubit-Dynamics){.reference
                .internal}
            -   [Landau-Zenner](../../examples/python/dynamics/control.html#Landau-Zenner){.reference
                .internal}
-   [Applications](../../using/applications.html){.reference .internal}
    -   [Max-Cut with
        QAOA](../../applications/python/qaoa.html){.reference .internal}
    -   [Molecular docking via
        DC-QAOA](../../applications/python/digitized_counterdiabatic_qaoa.html){.reference
        .internal}
        -   [Setting up the Molecular Docking
            Problem](../../applications/python/digitized_counterdiabatic_qaoa.html#Setting-up-the-Molecular-Docking-Problem){.reference
            .internal}
        -   [CUDA-Q
            Implementation](../../applications/python/digitized_counterdiabatic_qaoa.html#CUDA-Q-Implementation){.reference
            .internal}
    -   [Multi-reference Quantum Krylov Algorithm - [\\(H_2\\)]{.math
        .notranslate .nohighlight}
        Molecule](../../applications/python/krylov.html){.reference
        .internal}
        -   [Setup](../../applications/python/krylov.html#Setup){.reference
            .internal}
        -   [Computing the matrix
            elements](../../applications/python/krylov.html#Computing-the-matrix-elements){.reference
            .internal}
        -   [Determining the ground state energy of the
            subspace](../../applications/python/krylov.html#Determining-the-ground-state-energy-of-the-subspace){.reference
            .internal}
    -   [Quantum-Selected Configuration Interaction
        (QSCI)](../../applications/python/qsci.html){.reference
        .internal}
        -   [0. Problem
            definition](../../applications/python/qsci.html#0.-Problem-definition){.reference
            .internal}
        -   [1. Prepare an Approximate Quantum
            State](../../applications/python/qsci.html#1.-Prepare-an-Approximate-Quantum-State){.reference
            .internal}
        -   [2 Quantum Sampling to Select
            Configuration](../../applications/python/qsci.html#2-Quantum-Sampling-to-Select-Configuration){.reference
            .internal}
        -   [3. Classical Diagonalization on the Selected
            Subspace](../../applications/python/qsci.html#3.-Classical-Diagonalization-on-the-Selected-Subspace){.reference
            .internal}
        -   [5. Compuare
            results](../../applications/python/qsci.html#5.-Compuare-results){.reference
            .internal}
        -   [Reference](../../applications/python/qsci.html#Reference){.reference
            .internal}
    -   [Bernstein-Vazirani
        Algorithm](../../applications/python/bernstein_vazirani.html){.reference
        .internal}
        -   [Classical
            case](../../applications/python/bernstein_vazirani.html#Classical-case){.reference
            .internal}
        -   [Quantum
            case](../../applications/python/bernstein_vazirani.html#Quantum-case){.reference
            .internal}
        -   [Implementing in
            CUDA-Q](../../applications/python/bernstein_vazirani.html#Implementing-in-CUDA-Q){.reference
            .internal}
    -   [Cost
        Minimization](../../applications/python/cost_minimization.html){.reference
        .internal}
    -   [Deutsch's
        Algorithm](../../applications/python/deutsch_algorithm.html){.reference
        .internal}
        -   [XOR [\\(\\oplus\\)]{.math .notranslate
            .nohighlight}](../../applications/python/deutsch_algorithm.html#XOR-\oplus){.reference
            .internal}
        -   [Quantum
            oracles](../../applications/python/deutsch_algorithm.html#Quantum-oracles){.reference
            .internal}
        -   [Phase
            oracle](../../applications/python/deutsch_algorithm.html#Phase-oracle){.reference
            .internal}
        -   [Quantum
            parallelism](../../applications/python/deutsch_algorithm.html#Quantum-parallelism){.reference
            .internal}
        -   [Deutsch's
            Algorithm:](../../applications/python/deutsch_algorithm.html#Deutsch's-Algorithm:){.reference
            .internal}
    -   [Divisive Clustering With Coresets Using
        CUDA-Q](../../applications/python/divisive_clustering_coresets.html){.reference
        .internal}
        -   [Data
            preprocessing](../../applications/python/divisive_clustering_coresets.html#Data-preprocessing){.reference
            .internal}
        -   [Quantum
            functions](../../applications/python/divisive_clustering_coresets.html#Quantum-functions){.reference
            .internal}
        -   [Divisive Clustering
            Function](../../applications/python/divisive_clustering_coresets.html#Divisive-Clustering-Function){.reference
            .internal}
        -   [QAOA
            Implementation](../../applications/python/divisive_clustering_coresets.html#QAOA-Implementation){.reference
            .internal}
        -   [Scaling simulations with
            CUDA-Q](../../applications/python/divisive_clustering_coresets.html#Scaling-simulations-with-CUDA-Q){.reference
            .internal}
    -   [Hybrid Quantum Neural
        Networks](../../applications/python/hybrid_quantum_neural_networks.html){.reference
        .internal}
    -   [Using the Hadamard Test to Determine Quantum Krylov Subspace
        Decomposition Matrix
        Elements](../../applications/python/hadamard_test.html){.reference
        .internal}
        -   [Numerical result as a
            reference:](../../applications/python/hadamard_test.html#Numerical-result-as-a-reference:){.reference
            .internal}
        -   [Using [`Sample`{.docutils .literal .notranslate}]{.pre} to
            perform the Hadamard
            test](../../applications/python/hadamard_test.html#Using-Sample-to-perform-the-Hadamard-test){.reference
            .internal}
        -   [Multi-GPU evaluation of QKSD matrix elements using the
            Hadamard
            Test](../../applications/python/hadamard_test.html#Multi-GPU-evaluation-of-QKSD-matrix-elements-using-the-Hadamard-Test){.reference
            .internal}
            -   [Classically Diagonalize the Subspace
                Matrix](../../applications/python/hadamard_test.html#Classically-Diagonalize-the-Subspace-Matrix){.reference
                .internal}
    -   [Anderson Impurity Model ground state solver on Infleqtion's
        Sqale](../../applications/python/logical_aim_sqale.html){.reference
        .internal}
        -   [Performing logical Variational Quantum Eigensolver (VQE)
            with
            CUDA-QX](../../applications/python/logical_aim_sqale.html#Performing-logical-Variational-Quantum-Eigensolver-(VQE)-with-CUDA-QX){.reference
            .internal}
        -   [Constructing circuits in the [`[[4,2,2]]`{.docutils
            .literal .notranslate}]{.pre}
            encoding](../../applications/python/logical_aim_sqale.html#Constructing-circuits-in-the-%5B%5B4,2,2%5D%5D-encoding){.reference
            .internal}
        -   [Setting up submission and decoding
            workflow](../../applications/python/logical_aim_sqale.html#Setting-up-submission-and-decoding-workflow){.reference
            .internal}
        -   [Running a CUDA-Q noisy
            simulation](../../applications/python/logical_aim_sqale.html#Running-a-CUDA-Q-noisy-simulation){.reference
            .internal}
        -   [Running logical AIM on Infleqtion's
            hardware](../../applications/python/logical_aim_sqale.html#Running-logical-AIM-on-Infleqtion's-hardware){.reference
            .internal}
    -   [Spin-Hamiltonian Simulation Using
        CUDA-Q](../../applications/python/hamiltonian_simulation.html){.reference
        .internal}
        -   [Introduction](../../applications/python/hamiltonian_simulation.html#Introduction){.reference
            .internal}
            -   [Heisenberg
                Hamiltonian](../../applications/python/hamiltonian_simulation.html#Heisenberg-Hamiltonian){.reference
                .internal}
            -   [Transverse Field Ising Model
                (TFIM)](../../applications/python/hamiltonian_simulation.html#Transverse-Field-Ising-Model-(TFIM)){.reference
                .internal}
            -   [Time Evolution and Trotter
                Decomposition](../../applications/python/hamiltonian_simulation.html#Time-Evolution-and-Trotter-Decomposition){.reference
                .internal}
        -   [Key
            steps](../../applications/python/hamiltonian_simulation.html#Key-steps){.reference
            .internal}
            -   [1. Prepare initial
                state](../../applications/python/hamiltonian_simulation.html#1.-Prepare-initial-state){.reference
                .internal}
            -   [2. Hamiltonian
                Trotterization](../../applications/python/hamiltonian_simulation.html#2.-Hamiltonian-Trotterization){.reference
                .internal}
            -   [3. [`Compute`{.docutils .literal
                .notranslate}]{.pre}` `{.docutils .literal
                .notranslate}[`overlap`{.docutils .literal
                .notranslate}]{.pre}](../../applications/python/hamiltonian_simulation.html#3.-Compute-overlap){.reference
                .internal}
            -   [4. Construct Heisenberg
                Hamiltonian](../../applications/python/hamiltonian_simulation.html#4.-Construct-Heisenberg-Hamiltonian){.reference
                .internal}
            -   [5. Construct TFIM
                Hamiltonian](../../applications/python/hamiltonian_simulation.html#5.-Construct-TFIM-Hamiltonian){.reference
                .internal}
            -   [6. Extract coefficients and Pauli
                words](../../applications/python/hamiltonian_simulation.html#6.-Extract-coefficients-and-Pauli-words){.reference
                .internal}
        -   [Main
            code](../../applications/python/hamiltonian_simulation.html#Main-code){.reference
            .internal}
        -   [Visualization of probablity over
            time](../../applications/python/hamiltonian_simulation.html#Visualization-of-probablity-over-time){.reference
            .internal}
        -   [Expectation value over
            time:](../../applications/python/hamiltonian_simulation.html#Expectation-value-over-time:){.reference
            .internal}
        -   [Visualization of expectation over
            time](../../applications/python/hamiltonian_simulation.html#Visualization-of-expectation-over-time){.reference
            .internal}
        -   [Additional
            information](../../applications/python/hamiltonian_simulation.html#Additional-information){.reference
            .internal}
        -   [Relevant
            references](../../applications/python/hamiltonian_simulation.html#Relevant-references){.reference
            .internal}
    -   [Quantum Fourier
        Transform](../../applications/python/quantum_fourier_transform.html){.reference
        .internal}
        -   [Quantum Fourier Transform
            revisited](../../applications/python/quantum_fourier_transform.html#Quantum-Fourier-Transform-revisited){.reference
            .internal}
    -   [Quantum
        Teleporation](../../applications/python/quantum_teleportation.html){.reference
        .internal}
        -   [Teleportation
            explained](../../applications/python/quantum_teleportation.html#Teleportation-explained){.reference
            .internal}
    -   [Quantum
        Volume](../../applications/python/quantum_volume.html){.reference
        .internal}
    -   [Readout Error
        Mitigation](../../applications/python/readout_error_mitigation.html){.reference
        .internal}
        -   [Inverse confusion matrix from single-qubit noise
            model](../../applications/python/readout_error_mitigation.html#Inverse-confusion-matrix-from-single-qubit-noise-model){.reference
            .internal}
        -   [Inverse confusion matrix from k local confusion
            matrices](../../applications/python/readout_error_mitigation.html#Inverse-confusion-matrix-from-k-local-confusion-matrices){.reference
            .internal}
        -   [Inverse of full confusion
            matrix](../../applications/python/readout_error_mitigation.html#Inverse-of-full-confusion-matrix){.reference
            .internal}
    -   [Compiling Unitaries Using Diffusion
        Models](../../applications/python/unitary_compilation_diffusion_models.html){.reference
        .internal}
        -   [Diffusion model
            pipeline](../../applications/python/unitary_compilation_diffusion_models.html#Diffusion-model-pipeline){.reference
            .internal}
        -   [Setup and load
            models](../../applications/python/unitary_compilation_diffusion_models.html#Setup-and-load-models){.reference
            .internal}
            -   [Load discrete
                model](../../applications/python/unitary_compilation_diffusion_models.html#Load-discrete-model){.reference
                .internal}
            -   [Load continuous
                model](../../applications/python/unitary_compilation_diffusion_models.html#Load-continuous-model){.reference
                .internal}
            -   [Create helper
                functions](../../applications/python/unitary_compilation_diffusion_models.html#Create-helper-functions){.reference
                .internal}
        -   [Unitary
            compilation](../../applications/python/unitary_compilation_diffusion_models.html#Unitary-compilation){.reference
            .internal}
            -   [Random
                unitary](../../applications/python/unitary_compilation_diffusion_models.html#Random-unitary){.reference
                .internal}
            -   [Discrete
                model](../../applications/python/unitary_compilation_diffusion_models.html#Discrete-model){.reference
                .internal}
            -   [Continuous
                model](../../applications/python/unitary_compilation_diffusion_models.html#Continuous-model){.reference
                .internal}
            -   [Quantum Fourier
                transform](../../applications/python/unitary_compilation_diffusion_models.html#Quantum-Fourier-transform){.reference
                .internal}
            -   [XXZ-Hamiltonian
                evolution](../../applications/python/unitary_compilation_diffusion_models.html#XXZ-Hamiltonian-evolution){.reference
                .internal}
        -   [Choosing the circuit you
            need](../../applications/python/unitary_compilation_diffusion_models.html#Choosing-the-circuit-you-need){.reference
            .internal}
    -   [VQE with gradients, active spaces, and gate
        fusion](../../applications/python/vqe_advanced.html){.reference
        .internal}
        -   [The Basics of
            VQE](../../applications/python/vqe_advanced.html#The-Basics-of-VQE){.reference
            .internal}
        -   [Installing/Loading Relevant
            Packages](../../applications/python/vqe_advanced.html#Installing/Loading-Relevant-Packages){.reference
            .internal}
        -   [Implementing VQE in
            CUDA-Q](../../applications/python/vqe_advanced.html#Implementing-VQE-in-CUDA-Q){.reference
            .internal}
        -   [Parallel Parameter Shift
            Gradients](../../applications/python/vqe_advanced.html#Parallel-Parameter-Shift-Gradients){.reference
            .internal}
        -   [Using an Active
            Space](../../applications/python/vqe_advanced.html#Using-an-Active-Space){.reference
            .internal}
        -   [Gate Fusion for Larger
            Circuits](../../applications/python/vqe_advanced.html#Gate-Fusion-for-Larger-Circuits){.reference
            .internal}
    -   [Quantum
        Transformer](../../applications/python/quantum_transformer.html){.reference
        .internal}
        -   [Installation](../../applications/python/quantum_transformer.html#Installation){.reference
            .internal}
        -   [Algorithm and
            Example](../../applications/python/quantum_transformer.html#Algorithm-and-Example){.reference
            .internal}
            -   [Creating the self-attention
                circuits](../../applications/python/quantum_transformer.html#Creating-the-self-attention-circuits){.reference
                .internal}
        -   [Usage](../../applications/python/quantum_transformer.html#Usage){.reference
            .internal}
            -   [Model
                Training](../../applications/python/quantum_transformer.html#Model-Training){.reference
                .internal}
            -   [Generating
                Molecules](../../applications/python/quantum_transformer.html#Generating-Molecules){.reference
                .internal}
            -   [Attention
                Maps](../../applications/python/quantum_transformer.html#Attention-Maps){.reference
                .internal}
    -   [Quantum Enhanced Auxiliary Field Quantum Monte
        Carlo](../../applications/python/afqmc.html){.reference
        .internal}
        -   [Hamiltonian preparation for
            VQE](../../applications/python/afqmc.html#Hamiltonian-preparation-for-VQE){.reference
            .internal}
        -   [Run VQE with
            CUDA-Q](../../applications/python/afqmc.html#Run-VQE-with-CUDA-Q){.reference
            .internal}
        -   [Auxiliary Field Quantum Monte Carlo
            (AFQMC)](../../applications/python/afqmc.html#Auxiliary-Field-Quantum-Monte-Carlo-(AFQMC)){.reference
            .internal}
        -   [Preparation of the molecular
            Hamiltonian](../../applications/python/afqmc.html#Preparation-of-the-molecular-Hamiltonian){.reference
            .internal}
        -   [Preparation of the trial wave
            function](../../applications/python/afqmc.html#Preparation-of-the-trial-wave-function){.reference
            .internal}
        -   [Setup of the AFQMC
            parameters](../../applications/python/afqmc.html#Setup-of-the-AFQMC-parameters){.reference
            .internal}
    -   [ADAPT-QAOA
        algorithm](../../applications/python/adapt_qaoa.html){.reference
        .internal}
        -   [Simulation
            input:](../../applications/python/adapt_qaoa.html#Simulation-input:){.reference
            .internal}
        -   [The problem Hamiltonian [\\(H_C\\)]{.math .notranslate
            .nohighlight} of the max-cut
            graph:](../../applications/python/adapt_qaoa.html#The-problem-Hamiltonian-H_C-of-the-max-cut-graph:){.reference
            .internal}
        -   [Th operator pool [\\(A_j\\)]{.math .notranslate
            .nohighlight}:](../../applications/python/adapt_qaoa.html#Th-operator-pool-A_j:){.reference
            .internal}
        -   [The commutator [\\(\[H_C,A_j\]\\)]{.math .notranslate
            .nohighlight}:](../../applications/python/adapt_qaoa.html#The-commutator-%5BH_C,A_j%5D:){.reference
            .internal}
        -   [Beginning of ADAPT-QAOA
            iteration:](../../applications/python/adapt_qaoa.html#Beginning-of-ADAPT-QAOA-iteration:){.reference
            .internal}
    -   [ADAPT-VQE
        algorithm](../../applications/python/adapt_vqe.html){.reference
        .internal}
        -   [Classical
            pre-processing](../../applications/python/adapt_vqe.html#Classical-pre-processing){.reference
            .internal}
        -   [Jordan
            Wigner:](../../applications/python/adapt_vqe.html#Jordan-Wigner:){.reference
            .internal}
        -   [UCCSD operator
            pool](../../applications/python/adapt_vqe.html#UCCSD-operator-pool){.reference
            .internal}
            -   [Single
                excitation](../../applications/python/adapt_vqe.html#Single-excitation){.reference
                .internal}
            -   [Double
                excitation](../../applications/python/adapt_vqe.html#Double-excitation){.reference
                .internal}
        -   [Commutator \[[\\(H\\)]{.math .notranslate .nohighlight},
            [\\(A_i\\)]{.math .notranslate
            .nohighlight}\]](../../applications/python/adapt_vqe.html#Commutator-%5BH,-A_i%5D){.reference
            .internal}
        -   [Reference
            State:](../../applications/python/adapt_vqe.html#Reference-State:){.reference
            .internal}
        -   [Quantum
            kernels:](../../applications/python/adapt_vqe.html#Quantum-kernels:){.reference
            .internal}
        -   [Beginning of
            ADAPT-VQE:](../../applications/python/adapt_vqe.html#Beginning-of-ADAPT-VQE:){.reference
            .internal}
    -   [Quantum edge
        detection](../../applications/python/edge_detection.html){.reference
        .internal}
        -   [Image](../../applications/python/edge_detection.html#Image){.reference
            .internal}
        -   [Quantum Probability Image Encoding
            (QPIE):](../../applications/python/edge_detection.html#Quantum-Probability-Image-Encoding-(QPIE):){.reference
            .internal}
            -   [Below we show how to encode an image using QPIE in
                cudaq.](../../applications/python/edge_detection.html#Below-we-show-how-to-encode-an-image-using-QPIE-in-cudaq.){.reference
                .internal}
        -   [Flexible Representation of Quantum Images
            (FRQI):](../../applications/python/edge_detection.html#Flexible-Representation-of-Quantum-Images-(FRQI):){.reference
            .internal}
            -   [Building the FRQI
                State:](../../applications/python/edge_detection.html#Building-the-FRQI-State:){.reference
                .internal}
        -   [Quantum Hadamard Edge Detection
            (QHED)](../../applications/python/edge_detection.html#Quantum-Hadamard-Edge-Detection-(QHED)){.reference
            .internal}
            -   [Post-processing](../../applications/python/edge_detection.html#Post-processing){.reference
                .internal}
    -   [Factoring Integers With Shor's
        Algorithm](../../applications/python/shors.html){.reference
        .internal}
        -   [Shor's
            algorithm](../../applications/python/shors.html#Shor's-algorithm){.reference
            .internal}
            -   [Solving the order-finding problem
                classically](../../applications/python/shors.html#Solving-the-order-finding-problem-classically){.reference
                .internal}
            -   [Solving the order-finding problem with a quantum
                algorithm](../../applications/python/shors.html#Solving-the-order-finding-problem-with-a-quantum-algorithm){.reference
                .internal}
            -   [Determining the order from the measurement results of
                the phase
                kernel](../../applications/python/shors.html#Determining-the-order-from-the-measurement-results-of-the-phase-kernel){.reference
                .internal}
            -   [Postscript](../../applications/python/shors.html#Postscript){.reference
                .internal}
    -   [Generating the electronic
        Hamiltonian](../../applications/python/generate_fermionic_ham.html){.reference
        .internal}
        -   [Second Quantized
            formulation.](../../applications/python/generate_fermionic_ham.html#Second-Quantized-formulation.){.reference
            .internal}
            -   [Computational
                Implementation](../../applications/python/generate_fermionic_ham.html#Computational-Implementation){.reference
                .internal}
            -   [(a) Generate the molecular Hamiltonian using Restricted
                Hartree Fock molecular
                orbitals](../../applications/python/generate_fermionic_ham.html#(a)-Generate-the-molecular-Hamiltonian-using-Restricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(b) Generate the molecular Hamiltonian using
                Unrestricted Hartree Fock molecular
                orbitals](../../applications/python/generate_fermionic_ham.html#(b)-Generate-the-molecular-Hamiltonian-using-Unrestricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(a) Generate the active space hamiltonian using RHF
                molecular
                orbitals.](../../applications/python/generate_fermionic_ham.html#(a)-Generate-the-active-space-hamiltonian-using-RHF-molecular-orbitals.){.reference
                .internal}
            -   [(b) Generate the active space Hamiltonian using the
                natural orbitals computed from MP2
                simulation](../../applications/python/generate_fermionic_ham.html#(b)-Generate-the-active-space-Hamiltonian-using-the-natural-orbitals-computed-from-MP2-simulation){.reference
                .internal}
            -   [(c) Generate the active space Hamiltonian computed from
                the CASSCF molecular
                orbitals](../../applications/python/generate_fermionic_ham.html#(c)-Generate-the-active-space-Hamiltonian-computed-from-the-CASSCF-molecular-orbitals){.reference
                .internal}
            -   [(d) Generate the electronic Hamiltonian using
                ROHF](../../applications/python/generate_fermionic_ham.html#(d)-Generate-the-electronic-Hamiltonian-using-ROHF){.reference
                .internal}
            -   [(e) Generate electronic Hamiltonian using
                UHF](../../applications/python/generate_fermionic_ham.html#(e)-Generate-electronic-Hamiltonian-using-UHF){.reference
                .internal}
    -   [Grover's
        Algorithm](../../applications/python/grovers.html){.reference
        .internal}
        -   [Overview](../../applications/python/grovers.html#Overview){.reference
            .internal}
        -   [Problem](../../applications/python/grovers.html#Problem){.reference
            .internal}
        -   [Structure of Grover's
            Algorithm](../../applications/python/grovers.html#Structure-of-Grover's-Algorithm){.reference
            .internal}
            -   [Step 1:
                Preparation](../../applications/python/grovers.html#Step-1:-Preparation){.reference
                .internal}
            -   [Good and Bad
                States](../../applications/python/grovers.html#Good-and-Bad-States){.reference
                .internal}
            -   [Step 2: Oracle
                application](../../applications/python/grovers.html#Step-2:-Oracle-application){.reference
                .internal}
            -   [Step 3: Amplitude
                amplification](../../applications/python/grovers.html#Step-3:-Amplitude-amplification){.reference
                .internal}
            -   [Steps 4 and 5: Iteration and
                measurement](../../applications/python/grovers.html#Steps-4-and-5:-Iteration-and-measurement){.reference
                .internal}
    -   [Quantum
        PageRank](../../applications/python/quantum_pagerank.html){.reference
        .internal}
        -   [Problem
            Definition](../../applications/python/quantum_pagerank.html#Problem-Definition){.reference
            .internal}
        -   [Simulating Quantum PageRank by CUDA-Q
            dynamics](../../applications/python/quantum_pagerank.html#Simulating-Quantum-PageRank-by-CUDA-Q-dynamics){.reference
            .internal}
        -   [Breakdown of
            Terms](../../applications/python/quantum_pagerank.html#Breakdown-of-Terms){.reference
            .internal}
    -   [The UCCSD Wavefunction
        ansatz](../../applications/python/uccsd_wf_ansatz.html){.reference
        .internal}
        -   [What is
            UCCSD?](../../applications/python/uccsd_wf_ansatz.html#What-is-UCCSD?){.reference
            .internal}
        -   [Implementation in Quantum
            Computing](../../applications/python/uccsd_wf_ansatz.html#Implementation-in-Quantum-Computing){.reference
            .internal}
        -   [Run
            VQE](../../applications/python/uccsd_wf_ansatz.html#Run-VQE){.reference
            .internal}
        -   [Challenges and
            consideration](../../applications/python/uccsd_wf_ansatz.html#Challenges-and-consideration){.reference
            .internal}
    -   [Approximate State Preparation using MPS Sequential
        Encoding](../../applications/python/mps_encoding.html){.reference
        .internal}
        -   [Ran's
            approach](../../applications/python/mps_encoding.html#Ran's-approach){.reference
            .internal}
    -   [QM/MM simulation: VQE within a Polarizable Embedded
        Framework.](../../applications/python/qm_mm_pe.html){.reference
        .internal}
        -   [Key
            concepts:](../../applications/python/qm_mm_pe.html#Key-concepts:){.reference
            .internal}
        -   [PE-VQE-SCF Algorithm
            Steps](../../applications/python/qm_mm_pe.html#PE-VQE-SCF-Algorithm-Steps){.reference
            .internal}
            -   [Step 1: Initialize (Classical
                pre-processing)](../../applications/python/qm_mm_pe.html#Step-1:-Initialize-(Classical-pre-processing)){.reference
                .internal}
            -   [Step 2: Build the
                Hamiltonian](../../applications/python/qm_mm_pe.html#Step-2:-Build-the-Hamiltonian){.reference
                .internal}
            -   [Step 3: Run
                VQE](../../applications/python/qm_mm_pe.html#Step-3:-Run-VQE){.reference
                .internal}
            -   [Step 4: Update
                Environment](../../applications/python/qm_mm_pe.html#Step-4:-Update-Environment){.reference
                .internal}
            -   [Step 5: Self-Consistency
                Loop](../../applications/python/qm_mm_pe.html#Step-5:-Self-Consistency-Loop){.reference
                .internal}
            -   [Requirments:](../../applications/python/qm_mm_pe.html#Requirments:){.reference
                .internal}
            -   [Example 1: LiH with 2 water
                molecules.](../../applications/python/qm_mm_pe.html#Example-1:-LiH-with-2-water-molecules.){.reference
                .internal}
            -   [VQE, update environment, and scf
                loop.](../../applications/python/qm_mm_pe.html#VQE,-update-environment,-and-scf-loop.){.reference
                .internal}
            -   [Example 2: NH3 with 46 water molecule using active
                space.](../../applications/python/qm_mm_pe.html#Example-2:-NH3-with-46-water-molecule-using-active-space.){.reference
                .internal}
    -   [Sample-Based Krylov Quantum Diagonalization
        (SKQD)](../../applications/python/skqd.html){.reference
        .internal}
        -   [Why
            SKQD?](../../applications/python/skqd.html#Why-SKQD?){.reference
            .internal}
        -   [Setup and
            Imports](../../applications/python/skqd.html#Setup-and-Imports){.reference
            .internal}
        -   [Understanding Krylov
            Subspaces](../../applications/python/skqd.html#Understanding-Krylov-Subspaces){.reference
            .internal}
            -   [What is a Krylov
                Subspace?](../../applications/python/skqd.html#What-is-a-Krylov-Subspace?){.reference
                .internal}
            -   [The SKQD
                Algorithm](../../applications/python/skqd.html#The-SKQD-Algorithm){.reference
                .internal}
        -   [Krylov State Generation via Repeated
            Evolution](../../applications/python/skqd.html#Krylov-State-Generation-via-Repeated-Evolution){.reference
            .internal}
        -   [Quantum Measurements and
            Sampling](../../applications/python/skqd.html#Quantum-Measurements-and-Sampling){.reference
            .internal}
            -   [The Sampling
                Process](../../applications/python/skqd.html#The-Sampling-Process){.reference
                .internal}
        -   [Classical Post-Processing and
            Diagonalization](../../applications/python/skqd.html#Classical-Post-Processing-and-Diagonalization){.reference
            .internal}
            -   [The SKQD Algorithm: Matrix Construction
                Details](../../applications/python/skqd.html#The-SKQD-Algorithm:-Matrix-Construction-Details){.reference
                .internal}
        -   [Results Analysis and
            Convergence](../../applications/python/skqd.html#Results-Analysis-and-Convergence){.reference
            .internal}
            -   [What to
                Expect:](../../applications/python/skqd.html#What-to-Expect:){.reference
                .internal}
    -   [Entanglement Accelerates Quantum
        Simulation](../../applications/python/entanglement_acc_hamiltonian_simulation.html){.reference
        .internal}
        -   [2. Model
            Definition](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.-Model-Definition){.reference
            .internal}
            -   [2.1 Initial product
                state](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.1-Initial-product-state){.reference
                .internal}
            -   [2.2 QIMF
                Hamiltonian](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.2-QIMF-Hamiltonian){.reference
                .internal}
            -   [2.3 First-Order Trotter Formula
                (PF1)](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.3-First-Order-Trotter-Formula-(PF1)){.reference
                .internal}
            -   [2.4 PF1 step for the QIMF
                partition](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.4-PF1-step-for-the-QIMF-partition){.reference
                .internal}
            -   [2.5 Hamiltonian
                helpers](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.5-Hamiltonian-helpers){.reference
                .internal}
        -   [3. Entanglement
            metrics](../../applications/python/entanglement_acc_hamiltonian_simulation.html#3.-Entanglement-metrics){.reference
            .internal}
        -   [4. Simulation
            workflow](../../applications/python/entanglement_acc_hamiltonian_simulation.html#4.-Simulation-workflow){.reference
            .internal}
            -   [4.1 Single-step Trotter
                error](../../applications/python/entanglement_acc_hamiltonian_simulation.html#4.1-Single-step-Trotter-error){.reference
                .internal}
            -   [4.2 Dual trajectory
                update](../../applications/python/entanglement_acc_hamiltonian_simulation.html#4.2-Dual-trajectory-update){.reference
                .internal}
        -   [5. Reproducing the paper's Figure
            1a](../../applications/python/entanglement_acc_hamiltonian_simulation.html#5.-Reproducing-the-papers-Figure-1a){.reference
            .internal}
            -   [5.1 Visualising the joint
                behaviour](../../applications/python/entanglement_acc_hamiltonian_simulation.html#5.1-Visualising-the-joint-behaviour){.reference
                .internal}
            -   [5.2 Interpreting the
                result](../../applications/python/entanglement_acc_hamiltonian_simulation.html#5.2-Interpreting-the-result){.reference
                .internal}
        -   [6. References and further
            reading](../../applications/python/entanglement_acc_hamiltonian_simulation.html#6.-References-and-further-reading){.reference
            .internal}
-   [Backends](../../using/backends/backends.html){.reference .internal}
    -   [Circuit
        Simulation](../../using/backends/simulators.html){.reference
        .internal}
        -   [State Vector
            Simulators](../../using/backends/sims/svsims.html){.reference
            .internal}
            -   [CPU](../../using/backends/sims/svsims.html#cpu){.reference
                .internal}
            -   [Single-GPU](../../using/backends/sims/svsims.html#single-gpu){.reference
                .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/svsims.html#multi-gpu-multi-node){.reference
                .internal}
        -   [Tensor Network
            Simulators](../../using/backends/sims/tnsims.html){.reference
            .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/tnsims.html#multi-gpu-multi-node){.reference
                .internal}
            -   [Matrix product
                state](../../using/backends/sims/tnsims.html#matrix-product-state){.reference
                .internal}
            -   [Fermioniq](../../using/backends/sims/tnsims.html#fermioniq){.reference
                .internal}
        -   [Multi-QPU
            Simulators](../../using/backends/sims/mqpusims.html){.reference
            .internal}
            -   [Simulate Multiple QPUs in
                Parallel](../../using/backends/sims/mqpusims.html#simulate-multiple-qpus-in-parallel){.reference
                .internal}
            -   [Multi-QPU + Other
                Backends](../../using/backends/sims/mqpusims.html#multi-qpu-other-backends){.reference
                .internal}
        -   [Noisy
            Simulators](../../using/backends/sims/noisy.html){.reference
            .internal}
            -   [Trajectory Noisy
                Simulation](../../using/backends/sims/noisy.html#trajectory-noisy-simulation){.reference
                .internal}
            -   [Density
                Matrix](../../using/backends/sims/noisy.html#density-matrix){.reference
                .internal}
            -   [Stim](../../using/backends/sims/noisy.html#stim){.reference
                .internal}
        -   [Photonics
            Simulators](../../using/backends/sims/photonics.html){.reference
            .internal}
            -   [orca-photonics](../../using/backends/sims/photonics.html#orca-photonics){.reference
                .internal}
    -   [Quantum Hardware
        (QPUs)](../../using/backends/hardware.html){.reference
        .internal}
        -   [Ion Trap
            QPUs](../../using/backends/hardware/iontrap.html){.reference
            .internal}
            -   [IonQ](../../using/backends/hardware/iontrap.html#ionq){.reference
                .internal}
            -   [Quantinuum](../../using/backends/hardware/iontrap.html#quantinuum){.reference
                .internal}
        -   [Superconducting
            QPUs](../../using/backends/hardware/superconducting.html){.reference
            .internal}
            -   [Anyon Technologies/Anyon
                Computing](../../using/backends/hardware/superconducting.html#anyon-technologies-anyon-computing){.reference
                .internal}
            -   [IQM](../../using/backends/hardware/superconducting.html#iqm){.reference
                .internal}
            -   [OQC](../../using/backends/hardware/superconducting.html#oqc){.reference
                .internal}
            -   [Quantum Circuits,
                Inc.](../../using/backends/hardware/superconducting.html#quantum-circuits-inc){.reference
                .internal}
        -   [Neutral Atom
            QPUs](../../using/backends/hardware/neutralatom.html){.reference
            .internal}
            -   [Infleqtion](../../using/backends/hardware/neutralatom.html#infleqtion){.reference
                .internal}
            -   [Pasqal](../../using/backends/hardware/neutralatom.html#pasqal){.reference
                .internal}
            -   [QuEra
                Computing](../../using/backends/hardware/neutralatom.html#quera-computing){.reference
                .internal}
        -   [Photonic
            QPUs](../../using/backends/hardware/photonic.html){.reference
            .internal}
            -   [ORCA
                Computing](../../using/backends/hardware/photonic.html#orca-computing){.reference
                .internal}
        -   [Quantum Control
            Systems](../../using/backends/hardware/qcontrol.html){.reference
            .internal}
            -   [Quantum
                Machines](../../using/backends/hardware/qcontrol.html#quantum-machines){.reference
                .internal}
    -   [Dynamics
        Simulation](../../using/backends/dynamics_backends.html){.reference
        .internal}
    -   [Cloud](../../using/backends/cloud.html){.reference .internal}
        -   [Amazon Braket
            (braket)](../../using/backends/cloud/braket.html){.reference
            .internal}
            -   [Setting
                Credentials](../../using/backends/cloud/braket.html#setting-credentials){.reference
                .internal}
            -   [Submission from
                C++](../../using/backends/cloud/braket.html#submission-from-c){.reference
                .internal}
            -   [Submission from
                Python](../../using/backends/cloud/braket.html#submission-from-python){.reference
                .internal}
        -   [NVIDIA Quantum Cloud
            (nvqc)](../../using/backends/cloud/nvqc.html){.reference
            .internal}
            -   [Quick
                Start](../../using/backends/cloud/nvqc.html#quick-start){.reference
                .internal}
            -   [Simulator Backend
                Selection](../../using/backends/cloud/nvqc.html#simulator-backend-selection){.reference
                .internal}
            -   [Multiple
                GPUs](../../using/backends/cloud/nvqc.html#multiple-gpus){.reference
                .internal}
            -   [Multiple QPUs Asynchronous
                Execution](../../using/backends/cloud/nvqc.html#multiple-qpus-asynchronous-execution){.reference
                .internal}
            -   [FAQ](../../using/backends/cloud/nvqc.html#faq){.reference
                .internal}
-   [Dynamics](../../using/dynamics.html){.reference .internal}
    -   [Quick Start](../../using/dynamics.html#quick-start){.reference
        .internal}
    -   [Operator](../../using/dynamics.html#operator){.reference
        .internal}
    -   [Time-Dependent
        Dynamics](../../using/dynamics.html#time-dependent-dynamics){.reference
        .internal}
    -   [Super-operator
        Representation](../../using/dynamics.html#super-operator-representation){.reference
        .internal}
    -   [Numerical
        Integrators](../../using/dynamics.html#numerical-integrators){.reference
        .internal}
    -   [Batch
        simulation](../../using/dynamics.html#batch-simulation){.reference
        .internal}
    -   [Multi-GPU Multi-Node
        Execution](../../using/dynamics.html#multi-gpu-multi-node-execution){.reference
        .internal}
    -   [Examples](../../using/dynamics.html#examples){.reference
        .internal}
-   [CUDA-QX](../../using/cudaqx/cudaqx.html){.reference .internal}
    -   [CUDA-Q
        Solvers](../../using/cudaqx/cudaqx.html#cuda-q-solvers){.reference
        .internal}
    -   [CUDA-Q
        QEC](../../using/cudaqx/cudaqx.html#cuda-q-qec){.reference
        .internal}
-   [Installation](../../using/install/install.html){.reference
    .internal}
    -   [Local
        Installation](../../using/install/local_installation.html){.reference
        .internal}
        -   [Introduction](../../using/install/local_installation.html#introduction){.reference
            .internal}
            -   [Docker](../../using/install/local_installation.html#docker){.reference
                .internal}
            -   [Known Blackwell
                Issues](../../using/install/local_installation.html#known-blackwell-issues){.reference
                .internal}
            -   [Singularity](../../using/install/local_installation.html#singularity){.reference
                .internal}
            -   [Python
                wheels](../../using/install/local_installation.html#python-wheels){.reference
                .internal}
            -   [Pre-built
                binaries](../../using/install/local_installation.html#pre-built-binaries){.reference
                .internal}
        -   [Development with VS
            Code](../../using/install/local_installation.html#development-with-vs-code){.reference
            .internal}
            -   [Using a Docker
                container](../../using/install/local_installation.html#using-a-docker-container){.reference
                .internal}
            -   [Using a Singularity
                container](../../using/install/local_installation.html#using-a-singularity-container){.reference
                .internal}
        -   [Connecting to a Remote
            Host](../../using/install/local_installation.html#connecting-to-a-remote-host){.reference
            .internal}
            -   [Developing with Remote
                Tunnels](../../using/install/local_installation.html#developing-with-remote-tunnels){.reference
                .internal}
            -   [Remote Access via
                SSH](../../using/install/local_installation.html#remote-access-via-ssh){.reference
                .internal}
        -   [DGX
            Cloud](../../using/install/local_installation.html#dgx-cloud){.reference
            .internal}
            -   [Get
                Started](../../using/install/local_installation.html#get-started){.reference
                .internal}
            -   [Use
                JupyterLab](../../using/install/local_installation.html#use-jupyterlab){.reference
                .internal}
            -   [Use VS
                Code](../../using/install/local_installation.html#use-vs-code){.reference
                .internal}
        -   [Additional CUDA
            Tools](../../using/install/local_installation.html#additional-cuda-tools){.reference
            .internal}
            -   [Installation via
                PyPI](../../using/install/local_installation.html#installation-via-pypi){.reference
                .internal}
            -   [Installation In Container
                Images](../../using/install/local_installation.html#installation-in-container-images){.reference
                .internal}
            -   [Installing Pre-built
                Binaries](../../using/install/local_installation.html#installing-pre-built-binaries){.reference
                .internal}
        -   [Distributed Computing with
            MPI](../../using/install/local_installation.html#distributed-computing-with-mpi){.reference
            .internal}
        -   [Updating
            CUDA-Q](../../using/install/local_installation.html#updating-cuda-q){.reference
            .internal}
        -   [Dependencies and
            Compatibility](../../using/install/local_installation.html#dependencies-and-compatibility){.reference
            .internal}
        -   [Next
            Steps](../../using/install/local_installation.html#next-steps){.reference
            .internal}
    -   [Data Center
        Installation](../../using/install/data_center_install.html){.reference
        .internal}
        -   [Prerequisites](../../using/install/data_center_install.html#prerequisites){.reference
            .internal}
        -   [Build
            Dependencies](../../using/install/data_center_install.html#build-dependencies){.reference
            .internal}
            -   [CUDA](../../using/install/data_center_install.html#cuda){.reference
                .internal}
            -   [Toolchain](../../using/install/data_center_install.html#toolchain){.reference
                .internal}
        -   [Building
            CUDA-Q](../../using/install/data_center_install.html#building-cuda-q){.reference
            .internal}
        -   [Python
            Support](../../using/install/data_center_install.html#python-support){.reference
            .internal}
        -   [C++
            Support](../../using/install/data_center_install.html#c-support){.reference
            .internal}
        -   [Installation on the
            Host](../../using/install/data_center_install.html#installation-on-the-host){.reference
            .internal}
            -   [CUDA Runtime
                Libraries](../../using/install/data_center_install.html#cuda-runtime-libraries){.reference
                .internal}
            -   [MPI](../../using/install/data_center_install.html#mpi){.reference
                .internal}
-   [Integration](../../using/integration/integration.html){.reference
    .internal}
    -   [Downstream CMake
        Integration](../../using/integration/cmake_app.html){.reference
        .internal}
    -   [Combining CUDA with
        CUDA-Q](../../using/integration/cuda_gpu.html){.reference
        .internal}
    -   [Integrating with Third-Party
        Libraries](../../using/integration/libraries.html){.reference
        .internal}
        -   [Calling a CUDA-Q library from
            C++](../../using/integration/libraries.html#calling-a-cuda-q-library-from-c){.reference
            .internal}
        -   [Calling an C++ library from
            CUDA-Q](../../using/integration/libraries.html#calling-an-c-library-from-cuda-q){.reference
            .internal}
        -   [Interfacing between binaries compiled with a different
            toolchains](../../using/integration/libraries.html#interfacing-between-binaries-compiled-with-a-different-toolchains){.reference
            .internal}
-   [Extending](../../using/extending/extending.html){.reference
    .internal}
    -   [Add a new Hardware
        Backend](../../using/extending/backend.html){.reference
        .internal}
        -   [Overview](../../using/extending/backend.html#overview){.reference
            .internal}
        -   [Server Helper
            Implementation](../../using/extending/backend.html#server-helper-implementation){.reference
            .internal}
            -   [Directory
                Structure](../../using/extending/backend.html#directory-structure){.reference
                .internal}
            -   [Server Helper
                Class](../../using/extending/backend.html#server-helper-class){.reference
                .internal}
            -   [[`CMakeLists.txt`{.docutils .literal
                .notranslate}]{.pre}](../../using/extending/backend.html#cmakelists-txt){.reference
                .internal}
        -   [Target
            Configuration](../../using/extending/backend.html#target-configuration){.reference
            .internal}
            -   [Update Parent [`CMakeLists.txt`{.docutils .literal
                .notranslate}]{.pre}](../../using/extending/backend.html#update-parent-cmakelists-txt){.reference
                .internal}
        -   [Testing](../../using/extending/backend.html#testing){.reference
            .internal}
            -   [Unit
                Tests](../../using/extending/backend.html#unit-tests){.reference
                .internal}
            -   [Mock
                Server](../../using/extending/backend.html#mock-server){.reference
                .internal}
            -   [Python
                Tests](../../using/extending/backend.html#python-tests){.reference
                .internal}
            -   [Integration
                Tests](../../using/extending/backend.html#integration-tests){.reference
                .internal}
        -   [Documentation](../../using/extending/backend.html#documentation){.reference
            .internal}
        -   [Example
            Usage](../../using/extending/backend.html#example-usage){.reference
            .internal}
        -   [Code
            Review](../../using/extending/backend.html#code-review){.reference
            .internal}
        -   [Maintaining a
            Backend](../../using/extending/backend.html#maintaining-a-backend){.reference
            .internal}
        -   [Conclusion](../../using/extending/backend.html#conclusion){.reference
            .internal}
    -   [Create a new NVQIR
        Simulator](../../using/extending/nvqir_simulator.html){.reference
        .internal}
        -   [[`CircuitSimulator`{.code .docutils .literal
            .notranslate}]{.pre}](../../using/extending/nvqir_simulator.html#circuitsimulator){.reference
            .internal}
        -   [Let's see this in
            action](../../using/extending/nvqir_simulator.html#let-s-see-this-in-action){.reference
            .internal}
    -   [Working with CUDA-Q
        IR](../../using/extending/cudaq_ir.html){.reference .internal}
    -   [Create an MLIR Pass for
        CUDA-Q](../../using/extending/mlir_pass.html){.reference
        .internal}
-   [Specifications](../index.html){.reference .internal}
    -   [Language Specification](../cudaq.html){.reference .internal}
        -   [1. Machine Model](machine_model.html){.reference .internal}
        -   [2. Namespace and Standard](namespace.html){.reference
            .internal}
        -   [3. Quantum Types](types.html){.reference .internal}
            -   [3.1. [`cudaq::qudit<Levels>`{.code .docutils .literal
                .notranslate}]{.pre}](types.html#cudaq-qudit-levels){.reference
                .internal}
            -   [3.2. [`cudaq::qubit`{.code .docutils .literal
                .notranslate}]{.pre}](types.html#cudaq-qubit){.reference
                .internal}
            -   [3.3. Quantum
                Containers](types.html#quantum-containers){.reference
                .internal}
        -   [4. Quantum Operators](operators.html){.reference .internal}
            -   [4.1. [`cudaq::spin_op`{.code .docutils .literal
                .notranslate}]{.pre}](operators.html#cudaq-spin-op){.reference
                .internal}
        -   [5. Quantum Operations](operations.html){.reference
            .internal}
            -   [5.1. Operations on [`cudaq::qubit`{.code .docutils
                .literal
                .notranslate}]{.pre}](operations.html#operations-on-cudaq-qubit){.reference
                .internal}
        -   [6. Quantum Kernels](kernels.html){.reference .internal}
        -   [7. Sub-circuit Synthesis](synthesis.html){.reference
            .internal}
        -   [8. Control Flow](control_flow.html){.reference .internal}
        -   [9. Just-in-Time Kernel
            Creation](dynamic_kernels.html){.reference .internal}
        -   [10. Quantum Patterns](patterns.html){.reference .internal}
            -   [10.1.
                Compute-Action-Uncompute](patterns.html#compute-action-uncompute){.reference
                .internal}
        -   [11. Platform](platform.html){.reference .internal}
        -   [12. Algorithmic Primitives](#){.current .reference
            .internal}
            -   [12.1. [`cudaq::sample`{.code .docutils .literal
                .notranslate}]{.pre}](#cudaq-sample){.reference
                .internal}
            -   [12.2. [`cudaq::run`{.code .docutils .literal
                .notranslate}]{.pre}](#cudaq-run){.reference .internal}
            -   [12.3. [`cudaq::observe`{.code .docutils .literal
                .notranslate}]{.pre}](#cudaq-observe){.reference
                .internal}
            -   [12.4. [`cudaq::optimizer`{.code .docutils .literal
                .notranslate}]{.pre} (deprecated, functionality moved to
                CUDA-Q
                libraries)](#cudaq-optimizer-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
            -   [12.5. [`cudaq::gradient`{.code .docutils .literal
                .notranslate}]{.pre} (deprecated, functionality moved to
                CUDA-Q
                libraries)](#cudaq-gradient-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
        -   [13. Example Programs](examples.html){.reference .internal}
            -   [13.1. Hello World - Simple Bell
                State](examples.html#hello-world-simple-bell-state){.reference
                .internal}
            -   [13.2. GHZ State Preparation and
                Sampling](examples.html#ghz-state-preparation-and-sampling){.reference
                .internal}
            -   [13.3. Quantum Phase
                Estimation](examples.html#quantum-phase-estimation){.reference
                .internal}
            -   [13.4. Deuteron Binding Energy Parameter
                Sweep](examples.html#deuteron-binding-energy-parameter-sweep){.reference
                .internal}
            -   [13.5. Grover's
                Algorithm](examples.html#grover-s-algorithm){.reference
                .internal}
            -   [13.6. Iterative Phase
                Estimation](examples.html#iterative-phase-estimation){.reference
                .internal}
    -   [Quake Specification](../quake-dialect.html){.reference
        .internal}
        -   [General
            Introduction](../quake-dialect.html#general-introduction){.reference
            .internal}
        -   [Motivation](../quake-dialect.html#motivation){.reference
            .internal}
-   [API Reference](../../api/api.html){.reference .internal}
    -   [C++ API](../../api/languages/cpp_api.html){.reference
        .internal}
        -   [Operators](../../api/languages/cpp_api.html#operators){.reference
            .internal}
        -   [Quantum](../../api/languages/cpp_api.html#quantum){.reference
            .internal}
        -   [Common](../../api/languages/cpp_api.html#common){.reference
            .internal}
        -   [Noise
            Modeling](../../api/languages/cpp_api.html#noise-modeling){.reference
            .internal}
        -   [Kernel
            Builder](../../api/languages/cpp_api.html#kernel-builder){.reference
            .internal}
        -   [Algorithms](../../api/languages/cpp_api.html#algorithms){.reference
            .internal}
        -   [Platform](../../api/languages/cpp_api.html#platform){.reference
            .internal}
        -   [Utilities](../../api/languages/cpp_api.html#utilities){.reference
            .internal}
        -   [Namespaces](../../api/languages/cpp_api.html#namespaces){.reference
            .internal}
    -   [Python API](../../api/languages/python_api.html){.reference
        .internal}
        -   [Program
            Construction](../../api/languages/python_api.html#program-construction){.reference
            .internal}
            -   [[`make_kernel()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.make_kernel){.reference
                .internal}
            -   [[`PyKernel`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.PyKernel){.reference
                .internal}
            -   [[`Kernel`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Kernel){.reference
                .internal}
            -   [[`PyKernelDecorator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.PyKernelDecorator){.reference
                .internal}
            -   [[`kernel()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.kernel){.reference
                .internal}
        -   [Kernel
            Execution](../../api/languages/python_api.html#kernel-execution){.reference
            .internal}
            -   [[`sample()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.sample){.reference
                .internal}
            -   [[`sample_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.sample_async){.reference
                .internal}
            -   [[`run()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.run){.reference
                .internal}
            -   [[`run_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.run_async){.reference
                .internal}
            -   [[`observe()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.observe){.reference
                .internal}
            -   [[`observe_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.observe_async){.reference
                .internal}
            -   [[`get_state()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_state){.reference
                .internal}
            -   [[`get_state_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_state_async){.reference
                .internal}
            -   [[`vqe()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.vqe){.reference
                .internal}
            -   [[`draw()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.draw){.reference
                .internal}
            -   [[`translate()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.translate){.reference
                .internal}
            -   [[`estimate_resources()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.estimate_resources){.reference
                .internal}
        -   [Backend
            Configuration](../../api/languages/python_api.html#backend-configuration){.reference
            .internal}
            -   [[`has_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.has_target){.reference
                .internal}
            -   [[`get_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_target){.reference
                .internal}
            -   [[`get_targets()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_targets){.reference
                .internal}
            -   [[`set_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.set_target){.reference
                .internal}
            -   [[`reset_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.reset_target){.reference
                .internal}
            -   [[`set_noise()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.set_noise){.reference
                .internal}
            -   [[`unset_noise()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.unset_noise){.reference
                .internal}
            -   [[`register_set_target_callback()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.register_set_target_callback){.reference
                .internal}
            -   [[`unregister_set_target_callback()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.unregister_set_target_callback){.reference
                .internal}
            -   [[`cudaq.apply_noise()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.cudaq.apply_noise){.reference
                .internal}
            -   [[`initialize_cudaq()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.initialize_cudaq){.reference
                .internal}
            -   [[`num_available_gpus()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.num_available_gpus){.reference
                .internal}
            -   [[`set_random_seed()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.set_random_seed){.reference
                .internal}
        -   [Dynamics](../../api/languages/python_api.html#dynamics){.reference
            .internal}
            -   [[`evolve()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.evolve){.reference
                .internal}
            -   [[`evolve_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.evolve_async){.reference
                .internal}
            -   [[`Schedule`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Schedule){.reference
                .internal}
            -   [[`BaseIntegrator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.dynamics.integrator.BaseIntegrator){.reference
                .internal}
            -   [[`InitialState`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.dynamics.helpers.InitialState){.reference
                .internal}
            -   [[`InitialStateType`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.InitialStateType){.reference
                .internal}
            -   [[`IntermediateResultSave`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.IntermediateResultSave){.reference
                .internal}
        -   [Operators](../../api/languages/python_api.html#operators){.reference
            .internal}
            -   [[`OperatorSum`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.OperatorSum){.reference
                .internal}
            -   [[`ProductOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.ProductOperator){.reference
                .internal}
            -   [[`ElementaryOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.ElementaryOperator){.reference
                .internal}
            -   [[`ScalarOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.ScalarOperator){.reference
                .internal}
            -   [[`RydbergHamiltonian`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.RydbergHamiltonian){.reference
                .internal}
            -   [[`SuperOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.SuperOperator){.reference
                .internal}
            -   [[`operators.define()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.define){.reference
                .internal}
            -   [[`operators.instantiate()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.instantiate){.reference
                .internal}
            -   [Spin
                Operators](../../api/languages/python_api.html#spin-operators){.reference
                .internal}
            -   [Fermion
                Operators](../../api/languages/python_api.html#fermion-operators){.reference
                .internal}
            -   [Boson
                Operators](../../api/languages/python_api.html#boson-operators){.reference
                .internal}
            -   [General
                Operators](../../api/languages/python_api.html#general-operators){.reference
                .internal}
        -   [Data
            Types](../../api/languages/python_api.html#data-types){.reference
            .internal}
            -   [[`SimulationPrecision`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.SimulationPrecision){.reference
                .internal}
            -   [[`Target`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Target){.reference
                .internal}
            -   [[`State`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.State){.reference
                .internal}
            -   [[`Tensor`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Tensor){.reference
                .internal}
            -   [[`QuakeValue`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.QuakeValue){.reference
                .internal}
            -   [[`qubit`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.qubit){.reference
                .internal}
            -   [[`qreg`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.qreg){.reference
                .internal}
            -   [[`qvector`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.qvector){.reference
                .internal}
            -   [[`ComplexMatrix`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.ComplexMatrix){.reference
                .internal}
            -   [[`SampleResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.SampleResult){.reference
                .internal}
            -   [[`AsyncSampleResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncSampleResult){.reference
                .internal}
            -   [[`ObserveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.ObserveResult){.reference
                .internal}
            -   [[`AsyncObserveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncObserveResult){.reference
                .internal}
            -   [[`AsyncStateResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncStateResult){.reference
                .internal}
            -   [[`OptimizationResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.OptimizationResult){.reference
                .internal}
            -   [[`EvolveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.EvolveResult){.reference
                .internal}
            -   [[`AsyncEvolveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncEvolveResult){.reference
                .internal}
            -   [[`Resources`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Resources){.reference
                .internal}
            -   [Optimizers](../../api/languages/python_api.html#optimizers){.reference
                .internal}
            -   [Gradients](../../api/languages/python_api.html#gradients){.reference
                .internal}
            -   [Noisy
                Simulation](../../api/languages/python_api.html#noisy-simulation){.reference
                .internal}
        -   [MPI
            Submodule](../../api/languages/python_api.html#mpi-submodule){.reference
            .internal}
            -   [[`initialize()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.initialize){.reference
                .internal}
            -   [[`rank()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.rank){.reference
                .internal}
            -   [[`num_ranks()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.num_ranks){.reference
                .internal}
            -   [[`all_gather()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.all_gather){.reference
                .internal}
            -   [[`broadcast()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.broadcast){.reference
                .internal}
            -   [[`is_initialized()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.is_initialized){.reference
                .internal}
            -   [[`finalize()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.finalize){.reference
                .internal}
        -   [ORCA
            Submodule](../../api/languages/python_api.html#orca-submodule){.reference
            .internal}
            -   [[`sample()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.orca.sample){.reference
                .internal}
    -   [Quantum Operations](../../api/default_ops.html){.reference
        .internal}
        -   [Unitary Operations on
            Qubits](../../api/default_ops.html#unitary-operations-on-qubits){.reference
            .internal}
            -   [[`x`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#x){.reference
                .internal}
            -   [[`y`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#y){.reference
                .internal}
            -   [[`z`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#z){.reference
                .internal}
            -   [[`h`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#h){.reference
                .internal}
            -   [[`r1`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#r1){.reference
                .internal}
            -   [[`rx`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#rx){.reference
                .internal}
            -   [[`ry`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#ry){.reference
                .internal}
            -   [[`rz`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#rz){.reference
                .internal}
            -   [[`s`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#s){.reference
                .internal}
            -   [[`t`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#t){.reference
                .internal}
            -   [[`swap`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#swap){.reference
                .internal}
            -   [[`u3`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#u3){.reference
                .internal}
        -   [Adjoint and Controlled
            Operations](../../api/default_ops.html#adjoint-and-controlled-operations){.reference
            .internal}
        -   [Measurements on
            Qubits](../../api/default_ops.html#measurements-on-qubits){.reference
            .internal}
            -   [[`mz`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#mz){.reference
                .internal}
            -   [[`mx`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#mx){.reference
                .internal}
            -   [[`my`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#my){.reference
                .internal}
        -   [User-Defined Custom
            Operations](../../api/default_ops.html#user-defined-custom-operations){.reference
            .internal}
        -   [Photonic Operations on
            Qudits](../../api/default_ops.html#photonic-operations-on-qudits){.reference
            .internal}
            -   [[`create`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#create){.reference
                .internal}
            -   [[`annihilate`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#annihilate){.reference
                .internal}
            -   [[`phase_shift`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#phase-shift){.reference
                .internal}
            -   [[`beam_splitter`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#beam-splitter){.reference
                .internal}
            -   [[`mz`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#id1){.reference
                .internal}
-   [Other Versions](../../versions.html){.reference .internal}
:::
:::

::: {.section .wy-nav-content-wrap toggle="wy-nav-shift"}
[NVIDIA CUDA-Q](../../index.html)

::: wy-nav-content
::: rst-content
::: {role="navigation" aria-label="Page navigation"}
-   [](../../index.html){.icon .icon-home aria-label="Home"}
-   [Specifications](../index.html)
-   [Language Specification](../cudaq.html)
-   [12. ]{.section-number}Quantum Algorithmic Primitives
-   

::: {.rst-breadcrumbs-buttons role="navigation" aria-label="Sequential page navigation"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](platform.html "11. Quantum Platform"){.btn .btn-neutral
.float-left accesskey="p"} [Next []{.fa .fa-arrow-circle-right
aria-hidden="true"}](examples.html "13. Example Programs"){.btn
.btn-neutral .float-right accesskey="n"}
:::

------------------------------------------------------------------------
:::

::: {.document role="main" itemscope="itemscope" itemtype="http://schema.org/Article"}
::: {itemprop="articleBody"}
::: {#quantum-algorithmic-primitives .section}
# [12. ]{.section-number}Quantum Algorithmic Primitives[](#quantum-algorithmic-primitives "Permalink to this heading"){.headerlink}

**\[1\]** The general philosophy of the CUDA-Q specification is that
quantum device code should be encapsulated as stand-alone callable
instances of generic signature, and that operations or primitive
algorithms targeting a quantum coprocessor be implemented as adaptors on
those callable instances. Adaptors, by definition, are generic functions
that take any quantum kernel as input along with the runtime arguments
for that kernel. Runtime arguments passed to adaptor functions flow
through the adaptor to the provided kernel. This pattern allows general
pre- and post-processing around concrete kernel execution.

::: {#cudaq-sample .section}
[]{#cudaq-sample-spec}

## [12.1. ]{.section-number}[`cudaq::sample`{.code .docutils .literal .notranslate}]{.pre}[](#cudaq-sample "Permalink to this heading"){.headerlink}

**\[1\]** A common task for near-term quantum execution is to sample the
state of a given quantum circuit for a specified number of shots
(circuit executions). The result of this task is typically a mapping of
observed measurement bit strings to the number of times each was
observed. This is typically termed the counts dictionary in the
community.

**\[2\]** The CUDA-Q model enables this functionality via template
functions within the [`cudaq`{.code .docutils .literal
.notranslate}]{.pre} namespace with the following structure:

::: {.highlight-cpp .notranslate}
::: highlight
    template <typename ReturnType>
    concept HasVoidReturnType = std::is_void_v<ReturnType>;

    // Kernel only
    template<typename QuantumKernel, typename... Args>
      requires HasVoidReturnType<QuantumKernel, Args...>
    sample_result sample(QuantumKernel&& kernel, Args&&... args);

    // Specify shots
    template<typename QuantumKernel, typename... Args>
      requires HasVoidReturnType<QuantumKernel, Args...>
    sample_result sample(std::size_t shots, QuantumKernel&& kernel, Args&&... args);

    // Specify sample options (including shots and noise model)
    template<typename QuantumKernel, typename... Args>
      requires HasVoidReturnType<QuantumKernel, Args...>
    sample_result sample(const sample_options &options,
                         QuantumKernel&& kernel, Args&&... args);
:::
:::

**\[3\]** This function takes as input a quantum kernel instance
followed by the concrete arguments at which the kernel should be
invoked. CUDA-Q kernels passed to this function must be entry-point
kernels and return [`void`{.code .docutils .literal
.notranslate}]{.pre}.

**\[4\]** Overloaded functions exist for specifying the number of shots
to sample and the noise model to apply.

**\[5\]** The function returns an instance of the
[`cudaq::sample_result`{.code .docutils .literal .notranslate}]{.pre}
type which encapsulates the counts dictionary produced by the sampling
task. Programmers can extract the result information in the following
manner:

::: {.tab-set .docutils}
C++

::: {.tab-content .docutils}
::: {.highlight-cpp .notranslate}
::: highlight
    auto bell = []() __qpu__ { ... };

    // Sample the state generated by bel
    auto counts = cudaq::sample(bell)

    // Print to standard out
    counts.dump();

    // Fine-grained access to the bits and counts
    for (auto& [bits, count] : counts) {
      printf("Observed: %s, %lu\n", bits, count);
    }
:::
:::
:::

Python

::: {.tab-content .docutils}
::: {.highlight-python .notranslate}
::: highlight
    @cudaq.kernel()
    def bell():
       ...

    # Sample the state generated by bell
    counts = cudaq.sample(bell)

    # Print to standard out
    counts.dump()

    # Fine-grained access to the bits and counts
    for bits, count in counts:
        print('Observed: {}, {}'.format(bits, count))
:::
:::
:::
:::

**\[6\]** CUDA-Q specifies the following structure for
[`cudaq::sample_result`{.code .docutils .literal .notranslate}]{.pre}:

::: {.highlight-cpp .notranslate}
::: highlight
    namespace cudaq {
      using CountsDictionary = std::unordered_map<std::string, std::size_t>;
      inline static const std::string GlobalRegisterName = "__global__";
      class sample_result {
        public:
          sample_result() = default;
          sample_result(const sample_result &);
          ~sample_result();

          std::vector<std::string> register_names();

          std::size_t count(std::string_view bitString,
                      const std::string_view registerName = GlobalRegisterName);

          std::vector<std::string>
          sequential_data(const std::string_view registerName = GlobalRegisterName);

          CountsDictionary
          to_map(const std::string_view registerName = GlobalRegisterName);

          sample_result
          get_marginal(const std::vector<std::size_t> &&marginalIndices,
                 const std::string_view registerName = GlobalRegisterName);

          double expectation(const std::string_view registerName == GlobalRegisterName);
          double probability(std::string_view bitString, const std::string_view registerName == GlobalRegisterName);
          std::size_t size(const std::string_view registerName == GlobalRegisterName);

          void dump();
          void clear();

          CountsDictionary::iterator begin();
          CountsDictionary::iterator end();
      };
    }
:::
:::

**\[7\]** By default the [`sample_result`{.code .docutils .literal
.notranslate}]{.pre} type enables one to encode measurement results from
a quantum circuit sampling task. It keeps track of a list of sample
results, each one corresponding to a measurement action during the
sampling process and represented by a unique register name. It also
tracks a unique global register, which by default, contains the implicit
sampling of the state at the end of circuit execution. If the
[`explicit_measurements`{.code .docutils .literal .notranslate}]{.pre}
sample option is enabled, the global register contains all measurements
concatenated together in the order the measurements occurred in the
kernel. The API gives fine-grain access to the measurement results for
each register. To illustrate this, observe

::: {.tab-set .docutils}
C++

::: {.tab-content .docutils}
::: {.highlight-cpp .notranslate}
::: highlight
    auto kernel = []() __qpu__ {
      cudaq::qubit q;
      h(q);
      auto reg1 = mz(q);
      reset (q);
      x(q);
    };

    printf("Default - no explicit measurements\n");
    cudaq::sample(kernel).dump();

    cudaq::sample_options options{.explicit_measurements = true};
    printf("Setting `explicit_measurements` option\n");
    cudaq::sample(options, kernel).dump();
:::
:::
:::

Python

::: {.tab-content .docutils}
::: {.highlight-python .notranslate}
::: highlight
    @cudaq.kernel()
    def kernel():
       q = cudaq.qubit()
       h(q)
       reg1 = mz(q)
       reset(q)
       x(q)

    print("Default - no explicit measurements")
    cudaq.sample(kernel).dump()

    print("Setting `explicit_measurements` option")
    cudaq.sample(kernel, explicit_measurements=True).dump()
:::
:::
:::
:::

should produce

::: {.highlight-bash .notranslate}
::: highlight
    Default - no explicit measurements
    {
      __global__ : { 1:1000 }
      reg1 : { 0:506 1:494 }
    }

    Setting `explicit_measurements` option
    { 0:479 1:521 }
:::
:::

Here we see that we have measured a qubit in a uniform superposition to
a register named [`reg1`{.code .docutils .literal .notranslate}]{.pre},
and followed it with a reset and the application of an NOT operation. By
default the [`sample_result`{.code .docutils .literal
.notranslate}]{.pre} returned for this sampling tasks contains the
default [`__global__`{.code .docutils .literal .notranslate}]{.pre}
register as well as the user specified [`reg1`{.code .docutils .literal
.notranslate}]{.pre} register.

The contents of the [`__global__`{.code .docutils .literal
.notranslate}]{.pre} register will depend on how your kernel is written:

1.  If no measurements appear in the kernel, then the
    [`__global__`{.code .docutils .literal .notranslate}]{.pre} register
    is formed with implicit measurements being added for *all* the
    qubits defined in the kernel, and the measurements all occur at the
    end of the kernel. This is not supported when sampling with the
    [`explicit_measurements`{.code .docutils .literal
    .notranslate}]{.pre} option; kernels executed with
    [`explicit_measurements`{.code .docutils .literal
    .notranslate}]{.pre} mode must contain measurements. The order of
    the bits in the bitstring corresponds to the qubit allocation order
    specified in the kernel. That is - the [`[0]`{.code .docutils
    .literal .notranslate}]{.pre} element in the [`__global__`{.code
    .docutils .literal .notranslate}]{.pre} bitstring corresponds with
    the first declared qubit in the kernel. For example,

::: {.tab-set .docutils}
C++

::: {.tab-content .docutils}
::: {.highlight-cpp .notranslate}
::: highlight
    auto kernel = []() __qpu__ {
      cudaq::qubit a, b;
      x(a);
    };
    cudaq::sample(kernel).dump();
:::
:::
:::

Python

::: {.tab-content .docutils}
::: {.highlight-python .notranslate}
::: highlight
    @cudaq.kernel
    def kernel():
        a, b = cudaq.qubit(), cudaq.qubit()
        x(a)

    cudaq.sample(kernel).dump()
:::
:::
:::
:::

should produce

> <div>
>
> ::: {.highlight-bash .notranslate}
> ::: highlight
>     {
>       __global__ : { 10:1000 }
>     }
> :::
> :::
>
> </div>

2.  Conversely, if any measurements appear in the kernel, then only the
    measured qubits will appear in the [`__global__`{.code .docutils
    .literal .notranslate}]{.pre} register. Similar to #1, the bitstring
    corresponds to the qubit allocation order specified in the kernel.
    Also (again, similar to #1), the values of the sampled qubits always
    correspond to the values *at the end of the kernel execution*,
    unless the [`explicit_measurements`{.code .docutils .literal
    .notranslate}]{.pre} option is enabled. That is - if a qubit is
    measured in the middle of a kernel and subsequent operations change
    the state of the qubit, the qubit will be implicitly re-measured at
    the end of the kernel, and that re-measured value is the value that
    will appear in the [`__global__`{.code .docutils .literal
    .notranslate}]{.pre} register. If the sampling option
    [`explicit_measurements`{.code .docutils .literal
    .notranslate}]{.pre} is enabled, then no re-measurements occur, and
    the global register contains the concatenated measurements in the
    order they were executed in the kernel.

::: {.tab-set .docutils}
C++

::: {.tab-content .docutils}
::: {.highlight-cpp .notranslate}
::: highlight
    auto kernel = []() __qpu__ {
      cudaq::qubit a, b;
      x(a);
      mz(b);
      mz(a);
    };

    printf("Default - no explicit measurements\n");
    cudaq::sample(kernel).dump();

    cudaq::sample_options options{.explicit_measurements = true};
    printf("Setting `explicit_measurements` option\n");
    cudaq::sample(options, kernel).dump();
:::
:::
:::

Python

::: {.tab-content .docutils}
::: {.highlight-python .notranslate}
::: highlight
    @cudaq.kernel
    def kernel():
        a, b = cudaq.qubit(), cudaq.qubit()
        x(a)
        mz(b)
        mz(a)

    print("Default - no explicit measurements")
    cudaq.sample(kernel).dump()

    print("Setting `explicit_measurements` option")
    cudaq.sample(kernel, explicit_measurements=True).dump()
:::
:::
:::
:::

should produce

> <div>
>
> ::: {.highlight-bash .notranslate}
> ::: highlight
>     Default - no explicit measurements
>     { 10:1000 }
>
>     Setting `explicit_measurements` option
>     { 01:1000 }
> :::
> :::
>
> </div>

::: {.admonition .note}
Note

If you don't specify any measurements in your kernel and allow the
[`nvq++`{.code .docutils .literal .notranslate}]{.pre} compiler to
perform passes that introduce ancilla qubits into your kernel, it may be
difficult to discern which qubits are the ancilla qubits vs which ones
are your qubits. In this case, it is recommended that you provide
explicit measurements in your kernel in order to only receive
measurements from your qubits and silently discard the measurements from
the ancillary qubits.
:::

**\[8\]** The API exposed by the [`sample_result`{.code .docutils
.literal .notranslate}]{.pre} data type allows one to extract the
information contained at a variety of levels and for each available
register name. One can get the number of times a bit string was observed
via [`sample_result::count`{.code .docutils .literal
.notranslate}]{.pre}, extract a [`std::unordered_map`{.code .docutils
.literal .notranslate}]{.pre} representation via
[`sample_result::to_map`{.code .docutils .literal .notranslate}]{.pre},
get a new [`sample_result`{.code .docutils .literal .notranslate}]{.pre}
instance over a subset of measured qubits via
[`sample_result::get_marginal`{.code .docutils .literal
.notranslate}]{.pre}, and extract the measurement data as it was
produced sequentially (a vector of bit string observations for each shot
in the sampling process). One can also compute probabilities and
expectation values.

**\[9\]** There are specific requirements on input quantum kernels for
the use of the sample function which must be enforced by compiler
implementations. The kernel must be an entry-point kernel that returns
[`void`{.code .docutils .literal .notranslate}]{.pre}.

**\[10\]** CUDA-Q also provides an asynchronous version of this function
([`cudaq::sample_async`{.code .docutils .literal .notranslate}]{.pre})
which returns a [`sample_async_result`{.code .docutils .literal
.notranslate}]{.pre}.

::: {.highlight-cpp .notranslate}
::: highlight
    template<typename QuantumKernel, typename... Args>
    async_sample_result sample_async(const std::size_t qpu_id, QuantumKernel&& kernel, Args&&... args);
:::
:::

Programmers can asynchronously launch sampling tasks on any
[`qpu_id`{.code .docutils .literal .notranslate}]{.pre}.

**\[11\]** The [`async_sample_result`{.code .docutils .literal
.notranslate}]{.pre} wraps a [`std::future<sample_result>`{.code
.docutils .literal .notranslate}]{.pre} and exposes the same
[`get()`{.code .docutils .literal .notranslate}]{.pre} functionality to
extract the results after asynchronous execution.

**\[12\]** For remote QPU systems with long queue times, the
[`async_sample_result`{.code .docutils .literal .notranslate}]{.pre}
type encodes job ID information and can be persisted to file and loaded
from file at a later time. After loading from file, and when remote
queue jobs are completed, one can invoke [`get()`{.code .docutils
.literal .notranslate}]{.pre} and the results will be retrieved and
returned.
:::

::: {#cudaq-run .section}
## [12.2. ]{.section-number}[`cudaq::run`{.code .docutils .literal .notranslate}]{.pre}[](#cudaq-run "Permalink to this heading"){.headerlink}

**\[1\]** The [`cudaq::run`{.code .docutils .literal
.notranslate}]{.pre} API allows programmers to execute a kernel a
specified number of times and retrieve all the individual values
returned. Unlike [`cudaq::sample`{.code .docutils .literal
.notranslate}]{.pre}, which collects measurement statistics as a counts
dictionary mapping bit strings to frequencies, [`run`{.code .docutils
.literal .notranslate}]{.pre} preserves each individual return value
from every execution. Use [`sample`{.code .docutils .literal
.notranslate}]{.pre} when you need quantum state measurement statistics,
and use [`run`{.code .docutils .literal .notranslate}]{.pre} when you
need to analyze individual return values from each circuit execution.

**\[2\]** The CUDA-Q model provides this functionality via template
functions within the [`cudaq`{.code .docutils .literal
.notranslate}]{.pre} namespace with the following structure:

::: {.highlight-cpp .notranslate}
::: highlight
    // Run a kernel for specified number of shots
    template <typename QuantumKernel, typename... ARGS>
      requires(!std::is_void_v<std::invoke_result_t<std::decay_t<QuantumKernel>, std::decay_t<ARGS>...>>)
    std::vector<std::invoke_result_t<std::decay_t<QuantumKernel>, std::decay_t<ARGS>...>>
    run(std::size_t shots, QuantumKernel &&kernel, ARGS &&...args);

    // Run a kernel with noise model for specified number of shots
    template <typename QuantumKernel, typename... ARGS>
      requires(!std::is_void_v<std::invoke_result_t<std::decay_t<QuantumKernel>, std::decay_t<ARGS>...>>)
    std::vector<std::invoke_result_t<std::decay_t<QuantumKernel>, std::decay_t<ARGS>...>>
    run(std::size_t shots, cudaq::noise_model &noise_model, QuantumKernel &&kernel, ARGS &&...args);
:::
:::

**\[3\]** This function takes as input the number of shots, a quantum
kernel instance, and the concrete arguments with which the kernel should
be invoked. CUDA-Q kernel passed to this function must be an entry-point
kernel and must return a non-void value.

**\[4\]** Overloaded function exists for specifying a noise model to
apply during execution.

**\[5\]** The function returns a [`std::vector`{.code .docutils .literal
.notranslate}]{.pre} containing the return values from each execution of
the kernel. The vector has a length equal to the number of specified
shots, with each element representing the return value of a single
kernel execution.

**\[6\]** Programmers can extract the result information in the
following manner:

::: {.tab-set .docutils}
C++

::: {.tab-content .docutils}
::: {.highlight-cpp .notranslate}
::: highlight
    auto kernel = [](int numQubits) __qpu__ {
      // Quantum code that returns an int
      cudaq::qvector q(numQubits);
      h(q);
      // some logic...
      return result;
    };

    // Run the kernel 100 times with 4 qubits
    auto results = cudaq::run(100, kernel, 4);

    // Process the results
    for (const auto& result : results) {
      printf("Result: %d\n", result);
    }
:::
:::
:::

Python

::: {.tab-content .docutils}
::: {.highlight-python .notranslate}
::: highlight
    @cudaq.kernel
    def kernel(numQubits: int) -> int:
        # Quantum code that returns an int
        q = cudaq.qvector(numQubits)
        h(q)
        # some logic...
        return result

    # Run the kernel 100 times with 4 qubits
    results = cudaq.run(kernel, 4, shots_count=100)

    # Process the results
    for result in results:
        print(f"Result: {result}")
:::
:::
:::
:::

**\[7\]** The [`cudaq::run`{.code .docutils .literal
.notranslate}]{.pre} function supports a variety of return types from
the quantum kernel:

-   Scalar types: [`bool`{.code .docutils .literal .notranslate}]{.pre},
    [`int`{.code .docutils .literal .notranslate}]{.pre}, [`float`{.code
    .docutils .literal .notranslate}]{.pre}, and their variants
    ([`int8/16/32/64`{.code .docutils .literal .notranslate}]{.pre},
    [`float32/64`{.code .docutils .literal .notranslate}]{.pre})

-   User-defined data structures (via custom structs in C++ or
    [`dataclass`{.code .docutils .literal .notranslate}]{.pre} in
    Python)

**\[8\]** There are specific requirements on input quantum kernels for
the use of the [`run`{.code .docutils .literal .notranslate}]{.pre}
function which must be enforced by compiler implementations:

-   The kernel must be an entry-point kernel

-   The kernel must return a non-void value

-   Currently, the kernel can't return lists or tuples directly

**\[9\]** CUDA-Q also provides an asynchronous version of this function
([`cudaq::run_async`{.code .docutils .literal .notranslate}]{.pre})
which returns a [`std::future`{.code .docutils .literal
.notranslate}]{.pre}:

::: {.highlight-cpp .notranslate}
::: highlight
    template <typename QuantumKernel, typename... ARGS>
      requires(!std::is_void_v<std::invoke_result_t<std::decay_t<QuantumKernel>, std::decay_t<ARGS>...>>)
    std::future<std::vector<std::invoke_result_t<std::decay_t<QuantumKernel>, std::decay_t<ARGS>...>>>
    run_async(std::size_t qpu_id, std::size_t shots, QuantumKernel &&kernel, ARGS &&...args);
:::
:::

Programmers can asynchronously launch kernel executions on any
[`qpu_id`{.code .docutils .literal .notranslate}]{.pre} and retrieve
results when ready using the returned future's [`get()`{.code .docutils
.literal .notranslate}]{.pre} method.
:::

::: {#cudaq-observe .section}
## [12.3. ]{.section-number}[`cudaq::observe`{.code .docutils .literal .notranslate}]{.pre}[](#cudaq-observe "Permalink to this heading"){.headerlink}

**\[1\]** A common task in variational algorithms is the computation of
the expected value of a given observable with respect to a parameterized
quantum circuit ([\\(\\langle H \\rangle() = \\langle
\\psi()\|H\|\\psi() \\rangle\\)]{.math .notranslate .nohighlight}).

**\[2\]** The [`cudaq::observe`{.code .docutils .literal
.notranslate}]{.pre} function is provided to enable one to quickly
compute this expectation value via execution of the parameterized
quantum circuit with repeated measurements in the bases of the provided
[`spin_op`{.code .docutils .literal .notranslate}]{.pre} terms. The
function has the following signature:

::: {.highlight-cpp .notranslate}
::: highlight
    // Kernel only
    template<typename QuantumKernel, typename... Args>
    observe_result observe(QuantumKernel&&, cudaq::spin_op&, Args&&... args);

    // Specify shots
    template<typename QuantumKernel, typename... Args>
    observe_result observe(std::size_t shots, QuantumKernel&&, cudaq::spin_op&, Args&&... args);

    // Specify sample options (including shots and noise model)
    template<typename QuantumKernel, typename... Args>
    observe_result observe(const cudaq::observe_options &options,
                          QuantumKernel&&, cudaq::spin_op&, Args&&... args);
:::
:::

**\[3\]** [`cudaq::observe`{.code .docutils .literal
.notranslate}]{.pre} takes as input an instantiated quantum kernel, the
[`cudaq::spin_op`{.code .docutils .literal .notranslate}]{.pre} whose
expectation is requested, and the concrete arguments used as input to
the parameterized quantum kernel.

**\[4\]** [`cudaq::observe`{.code .docutils .literal
.notranslate}]{.pre} returns an instance of the [`observe_result`{.code
.docutils .literal .notranslate}]{.pre} type which can be implicitly
converted to a [`double`{.code .docutils .literal .notranslate}]{.pre}
expectation value, but also retains all data directly generated and used
as part of that expectation value computation. The
[`observe_result`{.code .docutils .literal .notranslate}]{.pre} takes on
the following form:

::: {.highlight-cpp .notranslate}
::: highlight
    class observe_result {
      public:
        observe_result(double &e, spin_op &H);
        observe_result(double &e, spin_op &H, MeasureCounts counts);

        sample_results raw_data() { return data; };
        operator double();
        double expectation();

        template <typename SpinOpType>
        double expectation(SpinOpType term);

        template <typename SpinOpType>
        sample_result counts(SpinOpType term);
        double id_coefficient()
        void dump();
    };
:::
:::

**\[5\]** The public API for [`observe_result`{.code .docutils .literal
.notranslate}]{.pre} enables one to extract the [`sample_result`{.code
.docutils .literal .notranslate}]{.pre} data for each term in the
provided [`spin_op`{.code .docutils .literal .notranslate}]{.pre}. This
return type can be used in the following way.

::: {.tab-set .docutils}
C++

::: {.tab-content .docutils}
::: {.highlight-cpp .notranslate}
::: highlight
    // I only care about the expected value, discard
    // the fine-grain data produced
    double expVal = cudaq::observe(kernel, spinOp, args...);

    // I require the result with all generated data
    auto result = cudaq::observe(kernel, spinOp, args...);
    auto expVal = result.expectation();
    auto X0X1Exp = result.expectation(x(0)*x(1));
    auto X0X1Data = result.counts(x(0)*x(1));
    result.dump();
:::
:::
:::

Python

::: {.tab-content .docutils}
::: {.highlight-python .notranslate}
::: highlight
    # I require the result with all generated data
    result = cudaq::observe(kernel, spinOp, *args)
    expVal = result.expectation()
    X0X1Exp = result.expectation(x(0)*x(1))
    X0X1Data = result.counts(x(0)*x(1))
    result.dump()
:::
:::
:::
:::

Here is an example of the utility of the [`cudaq::observe`{.code
.docutils .literal .notranslate}]{.pre} function:

::: {.tab-set .docutils}
C++

::: {.tab-content .docutils}
::: {.highlight-cpp .notranslate}
::: highlight
    struct ansatz {
      auto operator()(double theta) __qpu__ {
        cudaq::qarray<2> q;
        x(q[0]);
        ry(theta, q[1]);
        x<cudaq::ctrl>(q[1], q[0]);
      }
    };

    int main() {
      spin_op h = 5.907 - 2.1433 * cudaq::spin_op::x(0) * cudaq::spin_op::x(1) -
                  2.1433 * cudaq::spin_op::y(0) * cudaq::spin_op::y(1) +
                  .21829 * cudaq::spin_op::z(0) - 6.125 * cudaq::spin_op::z(1);

      double energy = cudaq::observe(ansatz{}, h, .59);
      printf("Energy is %lf\n", energy);
      return 0;
    }
:::
:::
:::

Python

::: {.tab-content .docutils}
::: {.highlight-python .notranslate}
::: highlight
    @cudaq.kernel()
    def ansatz(theta : float):
       q = cudaq.qvector(2)
       x(q[0])
       ry(theta, q[1])
       x.ctrl(q[1], q[0])

    h = 5.907 - 2.1433 * x(0) * x(1) - 2.1433 * y(0) * y(1) +
                    .21829 * z(0) - 6.125 * z(1)
    energy = cudaq.observe(ansatz, h, .59).expectation()
    print('Energy is {}'.format(energy))
:::
:::
:::
:::

**\[5\]** There are specific requirements on input quantum kernels for
the use of the observe function which must be enforced by compiler
implementations. The kernel must be an entry-point kernel that does not
contain any conditional or measurement statements.

**\[6\]** By default on simulation backends, [`cudaq::observe`{.code
.docutils .literal .notranslate}]{.pre} computes the true analytic
expectation value (i.e. without stochastic noise due to shots-based
sampling). If a specific shot count is provided then the returned
expectation value will contain some level of statistical noise.
Overloaded [`observe`{.code .docutils .literal .notranslate}]{.pre}
functions are provided to specify the number of shots and/or specify the
noise model to apply.

**\[7\]** CUDA-Q also provides an asynchronous version of this function
([`cudaq::observe_async`{.code .docutils .literal .notranslate}]{.pre})
which returns a [`async_observe_result`{.code .docutils .literal
.notranslate}]{.pre}.

::: {.highlight-cpp .notranslate}
::: highlight
    template<typename QuantumKernel, typename... Args>
    async_observe_result observe_async(const std::size_t qpu_id, QuantumKernel&& kernel, cudaq::spin_op&, Args&&... args);
:::
:::

Programmers can asynchronously launch sampling tasks on any
[`qpu_id`{.code .docutils .literal .notranslate}]{.pre}.

**\[8\]** For remote QPU systems with long queue times, the
[`async_observe_result`{.code .docutils .literal .notranslate}]{.pre}
type encodes job ID information for each execution and can be persisted
to file and loaded from file at a later time. After loading from file,
and when remote queue jobs are completed, one can invoke [`get()`{.code
.docutils .literal .notranslate}]{.pre} and the results will be
retrieved and returned.
:::

::: {#cudaq-optimizer-deprecated-functionality-moved-to-cuda-q-libraries .section}
## [12.4. ]{.section-number}[`cudaq::optimizer`{.code .docutils .literal .notranslate}]{.pre} (deprecated, functionality moved to CUDA-Q libraries)[](#cudaq-optimizer-deprecated-functionality-moved-to-cuda-q-libraries "Permalink to this heading"){.headerlink}

The primary use case for [`cudaq::observe`{.code .docutils .literal
.notranslate}]{.pre} is to leverage it as the core of a broader
objective function optimization workflow. [`cudaq::observe`{.code
.docutils .literal .notranslate}]{.pre} produces the expected value of a
specified [`spin_op`{.code .docutils .literal .notranslate}]{.pre} with
respect to a given parameterized ansatz at a concrete set of parameters,
and often programmers will require an extremal value of that expected
value at a specific set of concrete parameters. This will directly
require abstractions for gradient-based and gradient-free optimization
strategies.

The CUDA-Q model provides a [`cudaq::optimizer`{.code .docutils .literal
.notranslate}]{.pre} data type that exposes an [`optimize()`{.code
.docutils .literal .notranslate}]{.pre} method that takes as input an
[`optimizable_function`{.code .docutils .literal .notranslate}]{.pre} to
optimize and the number of independent function dimensions.
Implementations are free to implement this abstraction in any way that
is pertinent, but it is expected that most approaches will enable
optimization strategy extensibility. For example, programmers should be
able to instantiate a specific [`cudaq::optimizer`{.code .docutils
.literal .notranslate}]{.pre} sub-type, thereby dictating the underlying
optimization algorithm in a type-safe manner. Moreover, the optimizer
should expose a public API of pertinent optimizer-specific options that
the programmer can customize.

CUDA-Q models the [`cudaq::optimizer`{.code .docutils .literal
.notranslate}]{.pre} as follows:

::: {.highlight-cpp .notranslate}
::: highlight
    namespace cudaq {
      // Encode the optimal value and optimal parameters
      using optimization_result = std::tuple<double, std::vector<double>>;
      // Initialized with user specified callable of a specific signature
      // Clients can query if the function computes gradients or not
      class optimizable_function {
        public:
          template<typename Callable>
          optimizable_function(Callable&&);
          bool providesGradients() { return _providesGradients; }
          double operator()(const std::vector<double> &x, std::vector<double> &dx);
      };
      class optimizer {
        public:
          virtual bool requiresGradients() = 0;
          virtual optimization_result optimize(const int dimensions,
                                              optimizable_function&& opt_function) = 0;
      };
    }
:::
:::

Here, [`optimization_result`{.code .docutils .literal
.notranslate}]{.pre} should encode the optimal value and optimal
parameters achieved during the optimization workflow (i.e. a
[`tuple<double,`{.code .docutils .literal .notranslate}]{.pre}` `{.code
.docutils .literal .notranslate}[`std::vector<double>>`{.code .docutils
.literal .notranslate}]{.pre}). The optimize method takes as input the
number of parameters (or dimensions of the objective function), and a
function-like object (i.e. [`std::function`{.code .docutils .literal
.notranslate}]{.pre} or a lambda, something
[`optimizable_function`{.code .docutils .literal .notranslate}]{.pre}
can be constructed from) that takes a [`const`{.code .docutils .literal
.notranslate}]{.pre}` `{.code .docutils .literal
.notranslate}[`std::vector<double>&`{.code .docutils .literal
.notranslate}]{.pre} and [`std::vector<double>&`{.code .docutils
.literal .notranslate}]{.pre} for the function input parameters and
gradient vector, respectively. The objective function must return a
double representing the scalar cost for the objective function (e.g. the
expected value from [`cudaq::observe()`{.code .docutils .literal
.notranslate}]{.pre}).

Here is an example of how the [`cudaq::optimizer`{.code .docutils
.literal .notranslate}]{.pre} is intended to be used:

::: {.highlight-cpp .notranslate}
::: highlight
    auto ansatz = [](double theta, double phi) __qpu__ {...};
    cudaq::spin_op H = ... ;

    cudaq::optimizers::cobyla optimizer;
    optimizer.max_eval = 200;

    auto [opt_energy, opt_params] = optimizer.optimize(
          2, [&](const std::vector<double> &x, std::vector<double> &grad_vec) {
            return cudaq::observe(ansatz, H, x[0], x[1]);
          });
:::
:::
:::

::: {#cudaq-gradient-deprecated-functionality-moved-to-cuda-q-libraries .section}
## [12.5. ]{.section-number}[`cudaq::gradient`{.code .docutils .literal .notranslate}]{.pre} (deprecated, functionality moved to CUDA-Q libraries)[](#cudaq-gradient-deprecated-functionality-moved-to-cuda-q-libraries "Permalink to this heading"){.headerlink}

Typical optimization use cases will require the computation of gradients
for the specified objective function. The gradient is a vector over all
ansatz circuit parameters [\\(H() / _i\\)]{.math .notranslate
.nohighlight}. There are a number of potential strategies for computing
this gradient vector, but most require additional evaluations of the
ansatz circuit on the quantum processor.

To enable true extensibility in gradient strategies, CUDA-Q programmers
can instantiate custom sub-types of the [`cudaq::gradient`{.code
.docutils .literal .notranslate}]{.pre} type. The
[`cudaq::gradient`{.code .docutils .literal .notranslate}]{.pre} type
defines a [`compute(...)`{.code .docutils .literal .notranslate}]{.pre}
method that takes a mutable reference to the current gradient vector and
is free to update that vector in a strategy-specific way. The method
also takes the current evaluation parameter vector, the
[`cudaq::spin_op`{.code .docutils .literal .notranslate}]{.pre} used in
the current variational task, and the computed expected value at the
given parameters. The gradient strategy type takes the following form:

::: {.highlight-cpp .notranslate}
::: highlight
    namespace cudaq {
      class gradient {
        public:
          gradient(std::function<void(std::vector<double>)> &&kernel);

          template <typename QuantumKernel, typename ArgsMapper>
          gradient(QuantumKernel &&kernel, ArgsMapper &&argsMapper);

          virtual void compute(std::vector<double>& x, std::vector<double> &dx,
                            spin_op& h, double exp_h) = 0;

          virtual std::vector<double>
          compute(const std::vector<double> &x,
                  std::function<double(std::vector<double>)> &func) = 0;

      };

      // gradient is intended for subclassing
      class central_difference : public gradient {
        public:
          void compute(std::vector<double>& x, std::vector<double> &dx, spin_op& h,
                  double exp_h) override { ... }
      };
    }
:::
:::

The [`compute`{.code .docutils .literal .notranslate}]{.pre} function
can make use of the quantum kernel parameterized ansatz, the
[`spin_op`{.code .docutils .literal .notranslate}]{.pre} for which the
expected value is being computed, the pre-computed expected value at the
current iteration's parameter, and the concrete arguments for the given
quantum kernel at this iteration.

A non-trivial aspect of the computation of gradients (in an extensible
manner) is that we model the gradient as a derivative over concrete
parameters for the circuit ansatz represented as a
[`std::vector<double>`{.code .docutils .literal .notranslate}]{.pre}
when the actual quantum kernel may be defined with general variadic
[`Args...`{.code .docutils .literal .notranslate}]{.pre} types. To
address this issue, programmers can provide a default translation
mechanism for mapping common quantum kernel ansatz functional
expressions to a [`vector<double>`{.code .docutils .literal
.notranslate}]{.pre} representation - the [`ArgsMapper`{.code .docutils
.literal .notranslate}]{.pre} callable template type. This type must
implement the [`std::tuple<Args...>(std::vector<double>&)`{.code
.docutils .literal .notranslate}]{.pre} callable concept.

The overall CUDA-Q workflow for leveraging the [`cudaq::optimizer`{.code
.docutils .literal .notranslate}]{.pre} will work as follows (here we
demonstrate with an ansatz without the default
[`std::vector<double>`{.code .docutils .literal .notranslate}]{.pre}
signature):

::: {.highlight-cpp .notranslate}
::: highlight
    auto deuteron_n3_ansatz = [](double x0, double x1) __qpu__ {
      cudaq::qarray<3> q;
      x(q[0]);
      ry(x0, q[1]);
      ry(x1, q[2]);
      x<cudaq::ctrl>(q[2], q[0]);
      x<vctrl>(q[0], q[1]);
      ry(-x0, q[1]);
      x<cudaq::ctrl>(q[0], q[1]);
      x<cudaq::ctrl>(q[1], q[0]);
    };

    cudaq::spin_op h = 5.907 - 2.1433 * x(0) * x(1) - 2.1433 * y(0) * y(1) +
              .21829 * z(0) - 6.125 * z(1);
    cudaq::spin_op h3 = h + 9.625 - 9.625 * z(2) - 3.913119 * x(1) * x(2) -
                3.913119 * y(1) * y(2);

    // The above ansatz takes 2 doubles, not a single std::vector<double>, which
    // the gradient type is expecting. So we must provide an ArgsMapper callable type
    auto argsMapper = [](std::vector<double> x) {return std::make_tuple(x[0],x[1]);};

    // Create the gradient strategy
    cudaq::gradients::central_difference gradient(deuteron_n3_ansatz, argsMapper);

    // Create the L-BFGS optimizer, requires gradients
    cudaq::optimizers::lbfgs optimizer;

    // Run the optimization routine.
    auto [min_val, opt_params] = optimizer.optimize(
        2, [&](const std::vector<double>& x, std::vector<double>& grad_vec) {
          // Compute the cost, here its an energy
          auto cost = cudaq::observe(deuteron_n3_ansatz, h3, x);

          // Compute the gradient, results written to the grad_vec reference
          gradient.compute(x, grad_vec, h3, cost);

          // Return the cost to the optimizer
          return cost;
        });

    // Print the results
    printf("Optimizer found %lf at [%lf,%lf]\n", min_val, opt_params[0], opt_params[1]);
:::
:::
:::
:::
:::
:::

::: {.rst-footer-buttons role="navigation" aria-label="Footer"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](platform.html "11. Quantum Platform"){.btn .btn-neutral
.float-left accesskey="p" rel="prev"} [Next []{.fa
.fa-arrow-circle-right
aria-hidden="true"}](examples.html "13. Example Programs"){.btn
.btn-neutral .float-right accesskey="n" rel="next"}
:::

------------------------------------------------------------------------

::: {role="contentinfo"}
 Copyright 2025, NVIDIA Corporation & Affiliates.
:::

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme) provided by
[Read the Docs](https://readthedocs.org).
:::
:::
:::
:::
