diff --git a/llvm/include/llvm/Support/CommandLine.h b/llvm/include/llvm/Support/CommandLine.h
index 43c769c1fd..5aa6a4e451 100644
--- a/llvm/include/llvm/Support/CommandLine.h
+++ b/llvm/include/llvm/Support/CommandLine.h
@@ -861,7 +861,10 @@ public:
   ///
   template <class DT>
   void addLiteralOption(StringRef Name, const DT &V, StringRef HelpStr) {
-    assert(findOption(Name) == Values.size() && "Option already exists!");
+    // Allow idempotent registration - skip if option already exists.
+    // This supports macOS flat_namespace linking with multiple LLVM copies.
+    if (findOption(Name) != Values.size())
+      return;
     OptionInfo X(Name, static_cast<DataType>(V), HelpStr);
     Values.push_back(X);
     AddLiteralOption(Owner, Name);
diff --git a/llvm/lib/Support/CommandLine.cpp b/llvm/lib/Support/CommandLine.cpp
index 66632504d6..4ca9720e57 100644
--- a/llvm/lib/Support/CommandLine.cpp
+++ b/llvm/lib/Support/CommandLine.cpp
@@ -178,11 +178,11 @@ public:
   void addLiteralOption(Option &Opt, SubCommand *SC, StringRef Name) {
     if (Opt.hasArgStr())
       return;
-    if (!SC->OptionsMap.insert(std::make_pair(Name, &Opt)).second) {
-      errs() << ProgramName << ": CommandLine Error: Option '" << Name
-             << "' registered more than once!\n";
-      report_fatal_error("inconsistency in registered CommandLine options");
-    }
+    // Allow idempotent registration - skip if option already exists.
+    // This supports macOS flat_namespace linking with multiple LLVM copies.
+    if (SC->OptionsMap.find(Name) != SC->OptionsMap.end())
+      return;
+    SC->OptionsMap.insert(std::make_pair(Name, &Opt));
 
     // If we're adding this to all sub-commands, add it to the ones that have
     // already been registered.
@@ -207,17 +207,13 @@ public:
   void addOption(Option *O, SubCommand *SC) {
     bool HadErrors = false;
     if (O->hasArgStr()) {
-      // If it's a DefaultOption, check to make sure it isn't already there.
-      if (O->isDefaultOption() &&
-          SC->OptionsMap.find(O->ArgStr) != SC->OptionsMap.end())
+      // Allow idempotent registration - skip if option already exists.
+      // This supports macOS flat_namespace linking with multiple LLVM copies.
+      if (SC->OptionsMap.find(O->ArgStr) != SC->OptionsMap.end())
         return;
 
       // Add argument to the argument map!
-      if (!SC->OptionsMap.insert(std::make_pair(O->ArgStr, O)).second) {
-        errs() << ProgramName << ": CommandLine Error: Option '" << O->ArgStr
-               << "' registered more than once!\n";
-        HadErrors = true;
-      }
+      SC->OptionsMap.insert(std::make_pair(O->ArgStr, O));
     }
 
     // Remember information about positional options.
@@ -354,13 +350,14 @@ public:
   void printOptionValues();
 
   void registerCategory(OptionCategory *cat) {
-    assert(count_if(RegisteredOptionCategories,
-                    [cat](const OptionCategory *Category) {
-             return cat->getName() == Category->getName();
-           }) == 0 &&
-           "Duplicate option categories");
-
-    RegisteredOptionCategories.insert(cat);
+    // Allow idempotent registration - if a category with this name already
+    // exists, skip registration. This supports scenarios where multiple
+    // libraries may each have their own copy of LLVM globals.
+    if (count_if(RegisteredOptionCategories,
+                 [cat](const OptionCategory *Category) {
+           return cat->getName() == Category->getName();
+         }) == 0)
+      RegisteredOptionCategories.insert(cat);
   }
 
   void registerSubCommand(SubCommand *sub) {
