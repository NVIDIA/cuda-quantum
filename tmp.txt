module attributes {cc.sizeof_string = 32 : i64, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.triple = "x86_64-unknown-linux-gnu", quake.mangled_name_map = {__nvqpp__mlirgen__testBool = "_ZN8testBoolclEv", __nvqpp__mlirgen__testConsecutiveCasts = "_ZN20testConsecutiveCastsclEv", __nvqpp__mlirgen__testInt16 = "_ZN9testInt16clEv", __nvqpp__mlirgen__testInt32 = "_ZN9testInt32clEv", __nvqpp__mlirgen__testInt64 = "_ZN9testInt64clEv", __nvqpp__mlirgen__testInt8 = "_ZN8testInt8clEv"}} {
  func.func @__nvqpp__mlirgen__testBool() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
    %c1_i64 = arith.constant 1 : i64
    %c1_i16 = arith.constant 1 : i16
    %c1_i8 = arith.constant 1 : i8
    %true = arith.constant true
    %c1_i32 = arith.constant 1 : i32
    %0 = quake.alloca !quake.ref
    %1 = cc.alloca i1
    cc.store %true, %1 : !cc.ptr<i1>
    %2 = cc.load %1 : !cc.ptr<i1>
    %3 = cc.cast unsigned %2 : (i1) -> i32
    %4 = arith.cmpi eq, %3, %c1_i32 : i32
    cc.if(%4) {
      quake.x %0 : (!quake.ref) -> ()
    }
    %5 = quake.alloca !quake.ref
    %6 = cc.alloca i1
    cc.store %true, %6 : !cc.ptr<i1>
    %7 = cc.load %6 : !cc.ptr<i1>
    %8 = cc.cast unsigned %7 : (i1) -> i32
    %9 = arith.cmpi eq, %8, %c1_i32 : i32
    cc.if(%9) {
      quake.x %5 : (!quake.ref) -> ()
    }
    %10 = quake.alloca !quake.ref
    %11 = cc.alloca i1
    cc.store %true, %11 : !cc.ptr<i1>
    %12 = cc.load %11 : !cc.ptr<i1>
    %13 = cc.cast unsigned %12 : (i1) -> i32
    %14 = arith.cmpi eq, %13, %c1_i32 : i32
    cc.if(%14) {
      quake.x %10 : (!quake.ref) -> ()
    }
    %15 = quake.alloca !quake.ref
    %16 = cc.alloca i8
    cc.store %c1_i8, %16 : !cc.ptr<i8>
    %17 = cc.load %16 : !cc.ptr<i8>
    %18 = cc.cast unsigned %17 : (i8) -> i32
    %19 = arith.cmpi eq, %18, %c1_i32 : i32
    cc.if(%19) {
      quake.x %15 : (!quake.ref) -> ()
    }
    %20 = quake.alloca !quake.ref
    %21 = cc.alloca i8
    cc.store %c1_i8, %21 : !cc.ptr<i8>
    %22 = cc.load %21 : !cc.ptr<i8>
    %23 = cc.cast signed %22 : (i8) -> i32
    %24 = arith.cmpi eq, %23, %c1_i32 : i32
    cc.if(%24) {
      quake.x %20 : (!quake.ref) -> ()
    }
    %25 = quake.alloca !quake.ref
    %26 = cc.alloca i16
    cc.store %c1_i16, %26 : !cc.ptr<i16>
    %27 = cc.load %26 : !cc.ptr<i16>
    %28 = cc.cast unsigned %27 : (i16) -> i32
    %29 = arith.cmpi eq, %28, %c1_i32 : i32
    cc.if(%29) {
      quake.x %25 : (!quake.ref) -> ()
    }
    %30 = quake.alloca !quake.ref
    %31 = cc.alloca i16
    cc.store %c1_i16, %31 : !cc.ptr<i16>
    %32 = cc.load %31 : !cc.ptr<i16>
    %33 = cc.cast signed %32 : (i16) -> i32
    %34 = arith.cmpi eq, %33, %c1_i32 : i32
    cc.if(%34) {
      quake.x %30 : (!quake.ref) -> ()
    }
    %35 = quake.alloca !quake.ref
    %36 = cc.alloca i32
    cc.store %c1_i32, %36 : !cc.ptr<i32>
    %37 = cc.load %36 : !cc.ptr<i32>
    %38 = arith.cmpi eq, %37, %c1_i32 : i32
    cc.if(%38) {
      quake.x %35 : (!quake.ref) -> ()
    }
    %39 = quake.alloca !quake.ref
    %40 = cc.alloca i32
    cc.store %c1_i32, %40 : !cc.ptr<i32>
    %41 = cc.load %40 : !cc.ptr<i32>
    %42 = arith.cmpi eq, %41, %c1_i32 : i32
    cc.if(%42) {
      quake.x %39 : (!quake.ref) -> ()
    }
    %43 = quake.alloca !quake.ref
    %44 = cc.alloca i64
    cc.store %c1_i64, %44 : !cc.ptr<i64>
    %45 = cc.load %44 : !cc.ptr<i64>
    %46 = arith.cmpi eq, %45, %c1_i64 : i64
    cc.if(%46) {
      quake.x %43 : (!quake.ref) -> ()
    }
    %47 = quake.alloca !quake.ref
    %48 = cc.alloca i64
    cc.store %c1_i64, %48 : !cc.ptr<i64>
    %49 = cc.load %48 : !cc.ptr<i64>
    %50 = arith.cmpi eq, %49, %c1_i64 : i64
    cc.if(%50) {
      quake.x %47 : (!quake.ref) -> ()
    }
    return
  }
  func.func @__nvqpp__mlirgen__testInt8() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
    %c-1_i16 = arith.constant -1 : i16
    %c-1_i8 = arith.constant -1 : i8
    %c1_i32 = arith.constant 1 : i32
    %c-1_i32 = arith.constant -1 : i32
    %true = arith.constant true
    %c-1_i64 = arith.constant -1 : i64
    %c4294967295_i64 = arith.constant 4294967295 : i64
    %c65535_i32 = arith.constant 65535 : i32
    %c255_i32 = arith.constant 255 : i32
    %0 = quake.alloca !quake.ref
    %1 = cc.alloca i1
    cc.store %true, %1 : !cc.ptr<i1>
    %2 = cc.load %1 : !cc.ptr<i1>
    %3 = cc.cast unsigned %2 : (i1) -> i32
    %4 = arith.cmpi eq, %3, %c1_i32 : i32
    cc.if(%4) {
      quake.x %0 : (!quake.ref) -> ()
    }
    %5 = quake.alloca !quake.ref
    %6 = cc.alloca i8
    cc.store %c-1_i8, %6 : !cc.ptr<i8>
    %7 = cc.load %6 : !cc.ptr<i8>
    %8 = cc.cast unsigned %7 : (i8) -> i32
    %9 = arith.cmpi eq, %8, %c255_i32 : i32
    cc.if(%9) {
      quake.x %5 : (!quake.ref) -> ()
    }
    %10 = quake.alloca !quake.ref
    %11 = cc.alloca i8
    cc.store %c-1_i8, %11 : !cc.ptr<i8>
    %12 = cc.load %11 : !cc.ptr<i8>
    %13 = cc.cast signed %12 : (i8) -> i32
    %14 = arith.cmpi eq, %13, %c-1_i32 : i32
    cc.if(%14) {
      quake.x %10 : (!quake.ref) -> ()
    }
    %15 = quake.alloca !quake.ref
    %16 = cc.alloca i16
    cc.store %c-1_i16, %16 : !cc.ptr<i16>
    %17 = cc.load %16 : !cc.ptr<i16>
    %18 = cc.cast unsigned %17 : (i16) -> i32
    %19 = arith.cmpi eq, %18, %c65535_i32 : i32
    cc.if(%19) {
      quake.x %15 : (!quake.ref) -> ()
    }
    %20 = quake.alloca !quake.ref
    %21 = cc.alloca i16
    cc.store %c-1_i16, %21 : !cc.ptr<i16>
    %22 = cc.load %21 : !cc.ptr<i16>
    %23 = cc.cast signed %22 : (i16) -> i32
    %24 = arith.cmpi eq, %23, %c-1_i32 : i32
    cc.if(%24) {
      quake.x %20 : (!quake.ref) -> ()
    }
    %25 = quake.alloca !quake.ref
    %26 = cc.alloca i32
    cc.store %c-1_i32, %26 : !cc.ptr<i32>
    %27 = cc.load %26 : !cc.ptr<i32>
    %28 = cc.cast unsigned %27 : (i32) -> i64
    %29 = arith.cmpi eq, %28, %c4294967295_i64 : i64
    cc.if(%29) {
      quake.x %25 : (!quake.ref) -> ()
    }
    %30 = quake.alloca !quake.ref
    %31 = cc.alloca i32
    cc.store %c-1_i32, %31 : !cc.ptr<i32>
    %32 = cc.load %31 : !cc.ptr<i32>
    %33 = arith.cmpi eq, %32, %c-1_i32 : i32
    cc.if(%33) {
      quake.x %30 : (!quake.ref) -> ()
    }
    %34 = quake.alloca !quake.ref
    %35 = cc.alloca i64
    cc.store %c-1_i64, %35 : !cc.ptr<i64>
    %36 = cc.load %35 : !cc.ptr<i64>
    %37 = arith.cmpi eq, %36, %c-1_i64 : i64
    cc.if(%37) {
      quake.x %34 : (!quake.ref) -> ()
    }
    %38 = quake.alloca !quake.ref
    %39 = cc.alloca i64
    cc.store %c-1_i64, %39 : !cc.ptr<i64>
    %40 = cc.load %39 : !cc.ptr<i64>
    %41 = arith.cmpi eq, %40, %c-1_i64 : i64
    cc.if(%41) {
      quake.x %38 : (!quake.ref) -> ()
    }
    return
  }
  func.func @__nvqpp__mlirgen__testInt16() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
    %c-1_i16 = arith.constant -1 : i16
    %c-1_i8 = arith.constant -1 : i8
    %c1_i32 = arith.constant 1 : i32
    %c-1_i32 = arith.constant -1 : i32
    %true = arith.constant true
    %c-1_i64 = arith.constant -1 : i64
    %c4294967295_i64 = arith.constant 4294967295 : i64
    %c65535_i32 = arith.constant 65535 : i32
    %c255_i32 = arith.constant 255 : i32
    %0 = quake.alloca !quake.ref
    %1 = cc.alloca i1
    cc.store %true, %1 : !cc.ptr<i1>
    %2 = cc.load %1 : !cc.ptr<i1>
    %3 = cc.cast unsigned %2 : (i1) -> i32
    %4 = arith.cmpi eq, %3, %c1_i32 : i32
    cc.if(%4) {
      quake.x %0 : (!quake.ref) -> ()
    }
    %5 = quake.alloca !quake.ref
    %6 = cc.alloca i8
    cc.store %c-1_i8, %6 : !cc.ptr<i8>
    %7 = cc.load %6 : !cc.ptr<i8>
    %8 = cc.cast unsigned %7 : (i8) -> i32
    %9 = arith.cmpi eq, %8, %c255_i32 : i32
    cc.if(%9) {
      quake.x %5 : (!quake.ref) -> ()
    }
    %10 = quake.alloca !quake.ref
    %11 = cc.alloca i8
    cc.store %c-1_i8, %11 : !cc.ptr<i8>
    %12 = cc.load %11 : !cc.ptr<i8>
    %13 = cc.cast signed %12 : (i8) -> i32
    %14 = arith.cmpi eq, %13, %c-1_i32 : i32
    cc.if(%14) {
      quake.x %10 : (!quake.ref) -> ()
    }
    %15 = quake.alloca !quake.ref
    %16 = cc.alloca i16
    cc.store %c-1_i16, %16 : !cc.ptr<i16>
    %17 = cc.load %16 : !cc.ptr<i16>
    %18 = cc.cast unsigned %17 : (i16) -> i32
    %19 = arith.cmpi eq, %18, %c65535_i32 : i32
    cc.if(%19) {
      quake.x %15 : (!quake.ref) -> ()
    }
    %20 = quake.alloca !quake.ref
    %21 = cc.alloca i16
    cc.store %c-1_i16, %21 : !cc.ptr<i16>
    %22 = cc.load %21 : !cc.ptr<i16>
    %23 = cc.cast signed %22 : (i16) -> i32
    %24 = arith.cmpi eq, %23, %c-1_i32 : i32
    cc.if(%24) {
      quake.x %20 : (!quake.ref) -> ()
    }
    %25 = quake.alloca !quake.ref
    %26 = cc.alloca i32
    cc.store %c-1_i32, %26 : !cc.ptr<i32>
    %27 = cc.load %26 : !cc.ptr<i32>
    %28 = cc.cast unsigned %27 : (i32) -> i64
    %29 = arith.cmpi eq, %28, %c4294967295_i64 : i64
    cc.if(%29) {
      quake.x %25 : (!quake.ref) -> ()
    }
    %30 = quake.alloca !quake.ref
    %31 = cc.alloca i32
    cc.store %c-1_i32, %31 : !cc.ptr<i32>
    %32 = cc.load %31 : !cc.ptr<i32>
    %33 = arith.cmpi eq, %32, %c-1_i32 : i32
    cc.if(%33) {
      quake.x %30 : (!quake.ref) -> ()
    }
    %34 = quake.alloca !quake.ref
    %35 = cc.alloca i64
    cc.store %c-1_i64, %35 : !cc.ptr<i64>
    %36 = cc.load %35 : !cc.ptr<i64>
    %37 = arith.cmpi eq, %36, %c-1_i64 : i64
    cc.if(%37) {
      quake.x %34 : (!quake.ref) -> ()
    }
    %38 = quake.alloca !quake.ref
    %39 = cc.alloca i64
    cc.store %c-1_i64, %39 : !cc.ptr<i64>
    %40 = cc.load %39 : !cc.ptr<i64>
    %41 = arith.cmpi eq, %40, %c-1_i64 : i64
    cc.if(%41) {
      quake.x %38 : (!quake.ref) -> ()
    }
    return
  }
  func.func @__nvqpp__mlirgen__testInt32() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
    %c-1_i16 = arith.constant -1 : i16
    %c-1_i8 = arith.constant -1 : i8
    %c1_i32 = arith.constant 1 : i32
    %c-1_i32 = arith.constant -1 : i32
    %true = arith.constant true
    %c-1_i64 = arith.constant -1 : i64
    %c4294967295_i64 = arith.constant 4294967295 : i64
    %c65535_i32 = arith.constant 65535 : i32
    %c255_i32 = arith.constant 255 : i32
    %0 = quake.alloca !quake.ref
    %1 = cc.alloca i1
    cc.store %true, %1 : !cc.ptr<i1>
    %2 = cc.load %1 : !cc.ptr<i1>
    %3 = cc.cast unsigned %2 : (i1) -> i32
    %4 = arith.cmpi eq, %3, %c1_i32 : i32
    cc.if(%4) {
      quake.x %0 : (!quake.ref) -> ()
    }
    %5 = quake.alloca !quake.ref
    %6 = cc.alloca i8
    cc.store %c-1_i8, %6 : !cc.ptr<i8>
    %7 = cc.load %6 : !cc.ptr<i8>
    %8 = cc.cast unsigned %7 : (i8) -> i32
    %9 = arith.cmpi eq, %8, %c255_i32 : i32
    cc.if(%9) {
      quake.x %5 : (!quake.ref) -> ()
    }
    %10 = quake.alloca !quake.ref
    %11 = cc.alloca i8
    cc.store %c-1_i8, %11 : !cc.ptr<i8>
    %12 = cc.load %11 : !cc.ptr<i8>
    %13 = cc.cast signed %12 : (i8) -> i32
    %14 = arith.cmpi eq, %13, %c-1_i32 : i32
    cc.if(%14) {
      quake.x %10 : (!quake.ref) -> ()
    }
    %15 = quake.alloca !quake.ref
    %16 = cc.alloca i16
    cc.store %c-1_i16, %16 : !cc.ptr<i16>
    %17 = cc.load %16 : !cc.ptr<i16>
    %18 = cc.cast unsigned %17 : (i16) -> i32
    %19 = arith.cmpi eq, %18, %c65535_i32 : i32
    cc.if(%19) {
      quake.x %15 : (!quake.ref) -> ()
    }
    %20 = quake.alloca !quake.ref
    %21 = cc.alloca i16
    cc.store %c-1_i16, %21 : !cc.ptr<i16>
    %22 = cc.load %21 : !cc.ptr<i16>
    %23 = cc.cast signed %22 : (i16) -> i32
    %24 = arith.cmpi eq, %23, %c-1_i32 : i32
    cc.if(%24) {
      quake.x %20 : (!quake.ref) -> ()
    }
    %25 = quake.alloca !quake.ref
    %26 = cc.alloca i32
    cc.store %c-1_i32, %26 : !cc.ptr<i32>
    %27 = cc.load %26 : !cc.ptr<i32>
    %28 = cc.cast unsigned %27 : (i32) -> i64
    %29 = arith.cmpi eq, %28, %c4294967295_i64 : i64
    cc.if(%29) {
      quake.x %25 : (!quake.ref) -> ()
    }
    %30 = quake.alloca !quake.ref
    %31 = cc.alloca i32
    cc.store %c-1_i32, %31 : !cc.ptr<i32>
    %32 = cc.load %31 : !cc.ptr<i32>
    %33 = arith.cmpi eq, %32, %c-1_i32 : i32
    cc.if(%33) {
      quake.x %30 : (!quake.ref) -> ()
    }
    %34 = quake.alloca !quake.ref
    %35 = cc.alloca i64
    cc.store %c-1_i64, %35 : !cc.ptr<i64>
    %36 = cc.load %35 : !cc.ptr<i64>
    %37 = arith.cmpi eq, %36, %c-1_i64 : i64
    cc.if(%37) {
      quake.x %34 : (!quake.ref) -> ()
    }
    %38 = quake.alloca !quake.ref
    %39 = cc.alloca i64
    cc.store %c-1_i64, %39 : !cc.ptr<i64>
    %40 = cc.load %39 : !cc.ptr<i64>
    %41 = arith.cmpi eq, %40, %c-1_i64 : i64
    cc.if(%41) {
      quake.x %38 : (!quake.ref) -> ()
    }
    return
  }
  func.func @__nvqpp__mlirgen__testInt64() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
    %c-1_i16 = arith.constant -1 : i16
    %c-1_i8 = arith.constant -1 : i8
    %c1_i32 = arith.constant 1 : i32
    %c-1_i32 = arith.constant -1 : i32
    %true = arith.constant true
    %c-1_i64 = arith.constant -1 : i64
    %c4294967295_i64 = arith.constant 4294967295 : i64
    %c65535_i32 = arith.constant 65535 : i32
    %c255_i32 = arith.constant 255 : i32
    %0 = quake.alloca !quake.ref
    %1 = cc.alloca i1
    cc.store %true, %1 : !cc.ptr<i1>
    %2 = cc.load %1 : !cc.ptr<i1>
    %3 = cc.cast unsigned %2 : (i1) -> i32
    %4 = arith.cmpi eq, %3, %c1_i32 : i32
    cc.if(%4) {
      quake.x %0 : (!quake.ref) -> ()
    }
    %5 = quake.alloca !quake.ref
    %6 = cc.alloca i8
    cc.store %c-1_i8, %6 : !cc.ptr<i8>
    %7 = cc.load %6 : !cc.ptr<i8>
    %8 = cc.cast unsigned %7 : (i8) -> i32
    %9 = arith.cmpi eq, %8, %c255_i32 : i32
    cc.if(%9) {
      quake.x %5 : (!quake.ref) -> ()
    }
    %10 = quake.alloca !quake.ref
    %11 = cc.alloca i8
    cc.store %c-1_i8, %11 : !cc.ptr<i8>
    %12 = cc.load %11 : !cc.ptr<i8>
    %13 = cc.cast signed %12 : (i8) -> i32
    %14 = arith.cmpi eq, %13, %c-1_i32 : i32
    cc.if(%14) {
      quake.x %10 : (!quake.ref) -> ()
    }
    %15 = quake.alloca !quake.ref
    %16 = cc.alloca i16
    cc.store %c-1_i16, %16 : !cc.ptr<i16>
    %17 = cc.load %16 : !cc.ptr<i16>
    %18 = cc.cast unsigned %17 : (i16) -> i32
    %19 = arith.cmpi eq, %18, %c65535_i32 : i32
    cc.if(%19) {
      quake.x %15 : (!quake.ref) -> ()
    }
    %20 = quake.alloca !quake.ref
    %21 = cc.alloca i16
    cc.store %c-1_i16, %21 : !cc.ptr<i16>
    %22 = cc.load %21 : !cc.ptr<i16>
    %23 = cc.cast signed %22 : (i16) -> i32
    %24 = arith.cmpi eq, %23, %c-1_i32 : i32
    cc.if(%24) {
      quake.x %20 : (!quake.ref) -> ()
    }
    %25 = quake.alloca !quake.ref
    %26 = cc.alloca i32
    cc.store %c-1_i32, %26 : !cc.ptr<i32>
    %27 = cc.load %26 : !cc.ptr<i32>
    %28 = cc.cast unsigned %27 : (i32) -> i64
    %29 = arith.cmpi eq, %28, %c4294967295_i64 : i64
    cc.if(%29) {
      quake.x %25 : (!quake.ref) -> ()
    }
    %30 = quake.alloca !quake.ref
    %31 = cc.alloca i32
    cc.store %c-1_i32, %31 : !cc.ptr<i32>
    %32 = cc.load %31 : !cc.ptr<i32>
    %33 = arith.cmpi eq, %32, %c-1_i32 : i32
    cc.if(%33) {
      quake.x %30 : (!quake.ref) -> ()
    }
    %34 = quake.alloca !quake.ref
    %35 = cc.alloca i64
    cc.store %c-1_i64, %35 : !cc.ptr<i64>
    %36 = cc.load %35 : !cc.ptr<i64>
    %37 = arith.cmpi eq, %36, %c-1_i64 : i64
    cc.if(%37) {
      quake.x %34 : (!quake.ref) -> ()
    }
    %38 = quake.alloca !quake.ref
    %39 = cc.alloca i64
    cc.store %c-1_i64, %39 : !cc.ptr<i64>
    %40 = cc.load %39 : !cc.ptr<i64>
    %41 = arith.cmpi eq, %40, %c-1_i64 : i64
    cc.if(%41) {
      quake.x %38 : (!quake.ref) -> ()
    }
    return
  }
  func.func @__nvqpp__mlirgen__testConsecutiveCasts() attributes {"cudaq-entrypoint", "cudaq-kernel"} {
    %c65535_i64 = arith.constant 65535 : i64
    %c-1_i64 = arith.constant -1 : i64
    %0 = quake.alloca !quake.ref
    %1 = cc.alloca i64
    cc.store %c-1_i64, %1 : !cc.ptr<i64>
    %2 = cc.load %1 : !cc.ptr<i64>
    %3 = arith.cmpi eq, %2, %c-1_i64 : i64
    cc.if(%3) {
      quake.x %0 : (!quake.ref) -> ()
    }
    %4 = quake.alloca !quake.ref
    %5 = cc.alloca i64
    cc.store %c-1_i64, %5 : !cc.ptr<i64>
    %6 = cc.load %5 : !cc.ptr<i64>
    %7 = arith.cmpi eq, %6, %c-1_i64 : i64
    cc.if(%7) {
      quake.x %4 : (!quake.ref) -> ()
    }
    %8 = quake.alloca !quake.ref
    %9 = cc.alloca i64
    cc.store %c-1_i64, %9 : !cc.ptr<i64>
    %10 = cc.load %9 : !cc.ptr<i64>
    %11 = arith.cmpi eq, %10, %c-1_i64 : i64
    cc.if(%11) {
      quake.x %8 : (!quake.ref) -> ()
    }
    %12 = quake.alloca !quake.ref
    %13 = cc.alloca i64
    cc.store %c65535_i64, %13 : !cc.ptr<i64>
    %14 = cc.load %13 : !cc.ptr<i64>
    %15 = arith.cmpi eq, %14, %c65535_i64 : i64
    cc.if(%15) {
      quake.x %12 : (!quake.ref) -> ()
    }
    return
  }
  func.func @_ZN8testBoolclEv(%arg0: !cc.ptr<i8>) {
    return
  }
  func.func @_ZN8testInt8clEv(%arg0: !cc.ptr<i8>) {
    return
  }
  func.func @_ZN9testInt16clEv(%arg0: !cc.ptr<i8>) {
    return
  }
  func.func @_ZN9testInt32clEv(%arg0: !cc.ptr<i8>) {
    return
  }
  func.func @_ZN9testInt64clEv(%arg0: !cc.ptr<i8>) {
    return
  }
  func.func @_ZN20testConsecutiveCastsclEv(%arg0: !cc.ptr<i8>) {
    return
  }
}

