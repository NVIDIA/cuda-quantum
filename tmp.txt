// -----// IR Dump Before LambdaLifting (lambda-lifting) ('builtin.module' operation) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c4_i64 = arith.constant 4 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = cc.alloca i64
    cc.store %c5_i64, %0 : !cc.ptr<i64>
    %1 = cc.load %0 : !cc.ptr<i64>
    %2 = quake.alloca !quake.veq<?>[%1 : i64]
    %3 = quake.veq_size %2 : (!quake.veq<?>) -> i64
    %4 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %3 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      quake.h %8 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    %5 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %c4_i64 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %9 = arith.addi %arg0, %c1_i64 : i64
      %10 = quake.extract_ref %2[%9] : (!quake.veq<?>, i64) -> !quake.ref
      quake.x [%8] %10 : (!quake.ref, !quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    %6 = cc.load %0 : !cc.ptr<i64>
    %7 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %6 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %measOut = quake.mz %8 : (!quake.ref) -> !quake.measure
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    return
  }
}


// -----// IR Dump Before Canonicalizer (canonicalize) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c4_i64 = arith.constant 4 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = cc.alloca i64
    cc.store %c5_i64, %0 : !cc.ptr<i64>
    %1 = cc.load %0 : !cc.ptr<i64>
    %2 = quake.alloca !quake.veq<?>[%1 : i64]
    %3 = quake.veq_size %2 : (!quake.veq<?>) -> i64
    %4 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %3 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      quake.h %8 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    %5 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %c4_i64 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %9 = arith.addi %arg0, %c1_i64 : i64
      %10 = quake.extract_ref %2[%9] : (!quake.veq<?>, i64) -> !quake.ref
      quake.x [%8] %10 : (!quake.ref, !quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    %6 = cc.load %0 : !cc.ptr<i64>
    %7 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %6 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %measOut = quake.mz %8 : (!quake.ref) -> !quake.measure
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    return
  }
}


// -----// IR Dump Before CSE (cse) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c4_i64 = arith.constant 4 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = cc.alloca i64
    cc.store %c5_i64, %0 : !cc.ptr<i64>
    %1 = cc.load %0 : !cc.ptr<i64>
    %2 = quake.alloca !quake.veq<?>[%1 : i64]
    %3 = quake.veq_size %2 : (!quake.veq<?>) -> i64
    %4 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %3 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      quake.h %8 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    %5 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %c4_i64 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %9 = arith.addi %arg0, %c1_i64 : i64
      %10 = quake.extract_ref %2[%9] : (!quake.veq<?>, i64) -> !quake.ref
      quake.x [%8] %10 : (!quake.ref, !quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    %6 = cc.load %0 : !cc.ptr<i64>
    %7 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %6 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %measOut = quake.mz %8 : (!quake.ref) -> !quake.measure
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    return
  }
}


// -----// IR Dump Before MemToReg (memtoreg) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c4_i64 = arith.constant 4 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = cc.alloca i64
    cc.store %c5_i64, %0 : !cc.ptr<i64>
    %1 = cc.load %0 : !cc.ptr<i64>
    %2 = quake.alloca !quake.veq<?>[%1 : i64]
    %3 = quake.veq_size %2 : (!quake.veq<?>) -> i64
    %4 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %3 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      quake.h %8 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    %5 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %c4_i64 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %9 = arith.addi %arg0, %c1_i64 : i64
      %10 = quake.extract_ref %2[%9] : (!quake.veq<?>, i64) -> !quake.ref
      quake.x [%8] %10 : (!quake.ref, !quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    %6 = cc.load %0 : !cc.ptr<i64>
    %7 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %8 = arith.cmpi slt, %arg0, %6 : i64
      cc.condition %8(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %8 = quake.extract_ref %2[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %measOut = quake.mz %8 : (!quake.ref) -> !quake.measure
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %8 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %8 : i64
    } {invariant}
    return
  }
}


// -----// IR Dump After MemToReg (memtoreg) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c4_i64 = arith.constant 4 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = cc.undef i64
    %1 = quake.alloca !quake.veq<?>[%c5_i64 : i64]
    %2 = quake.veq_size %1 : (!quake.veq<?>) -> i64
    %3 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %6 = arith.cmpi slt, %arg0, %2 : i64
      cc.condition %6(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %6 = quake.extract_ref %1[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      quake.h %6 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %6 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %6 : i64
    } {invariant}
    %4 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %6 = arith.cmpi slt, %arg0, %c4_i64 : i64
      cc.condition %6(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %6 = quake.extract_ref %1[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %7 = arith.addi %arg0, %c1_i64 : i64
      %8 = quake.extract_ref %1[%7] : (!quake.veq<?>, i64) -> !quake.ref
      quake.x [%6] %8 : (!quake.ref, !quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %6 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %6 : i64
    } {invariant}
    %5 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %6 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %6(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %6 = quake.extract_ref %1[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %measOut = quake.mz %6 : (!quake.ref) -> !quake.measure
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %6 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %6 : i64
    } {invariant}
    return
  }
}


// -----// IR Dump Before LoopNormalize (cc-loop-normalize) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c4_i64 = arith.constant 4 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = cc.undef i64
    %1 = quake.alloca !quake.veq<?>[%c5_i64 : i64]
    %2 = quake.veq_size %1 : (!quake.veq<?>) -> i64
    %3 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %6 = arith.cmpi slt, %arg0, %2 : i64
      cc.condition %6(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %6 = quake.extract_ref %1[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      quake.h %6 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %6 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %6 : i64
    } {invariant}
    %4 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %6 = arith.cmpi slt, %arg0, %c4_i64 : i64
      cc.condition %6(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %6 = quake.extract_ref %1[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %7 = arith.addi %arg0, %c1_i64 : i64
      %8 = quake.extract_ref %1[%7] : (!quake.veq<?>, i64) -> !quake.ref
      quake.x [%6] %8 : (!quake.ref, !quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %6 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %6 : i64
    } {invariant}
    %5 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %6 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %6(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %6 = quake.extract_ref %1[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %measOut = quake.mz %6 : (!quake.ref) -> !quake.measure
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %6 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %6 : i64
    } {invariant}
    return
  }
}


// -----// IR Dump After LoopNormalize (cc-loop-normalize) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c4_i64 = arith.constant 4 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = quake.alloca !quake.veq<?>[%c5_i64 : i64]
    %1 = quake.veq_size %0 : (!quake.veq<?>) -> i64
    %2 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %5 = arith.cmpi slt, %arg0, %1 : i64
      cc.condition %5(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %5 = quake.extract_ref %0[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      quake.h %5 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %5 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %5 : i64
    } {invariant}
    %3 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %5 = arith.cmpi slt, %arg0, %c4_i64 : i64
      cc.condition %5(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %5 = quake.extract_ref %0[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %6 = arith.addi %arg0, %c1_i64 : i64
      %7 = quake.extract_ref %0[%6] : (!quake.veq<?>, i64) -> !quake.ref
      quake.x [%5] %7 : (!quake.ref, !quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %5 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %5 : i64
    } {invariant}
    %4 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %5 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %5(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %5 = quake.extract_ref %0[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %measOut = quake.mz %5 : (!quake.ref) -> !quake.measure
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %5 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %5 : i64
    } {invariant}
    return
  }
}


// -----// IR Dump Before LoopUnroll (cc-loop-unroll) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c4_i64 = arith.constant 4 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = quake.alloca !quake.veq<?>[%c5_i64 : i64]
    %1 = quake.veq_size %0 : (!quake.veq<?>) -> i64
    %2 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %5 = arith.cmpi slt, %arg0, %1 : i64
      cc.condition %5(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %5 = quake.extract_ref %0[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      quake.h %5 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %5 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %5 : i64
    } {invariant}
    %3 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %5 = arith.cmpi slt, %arg0, %c4_i64 : i64
      cc.condition %5(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %5 = quake.extract_ref %0[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %6 = arith.addi %arg0, %c1_i64 : i64
      %7 = quake.extract_ref %0[%6] : (!quake.veq<?>, i64) -> !quake.ref
      quake.x [%5] %7 : (!quake.ref, !quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %5 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %5 : i64
    } {invariant}
    %4 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %5 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %5(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %5 = quake.extract_ref %0[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      %measOut = quake.mz %5 : (!quake.ref) -> !quake.measure
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %5 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %5 : i64
    } {invariant}
    return
  }
}


error: can't run 'builtin.module' pass manager on 'func.func' op
// -----// IR Dump After LoopUnroll (cc-loop-unroll) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c0_i64 = arith.constant 0 : i64
    %c2_i64 = arith.constant 2 : i64
    %c3_i64 = arith.constant 3 : i64
    %c4_i64 = arith.constant 4 : i64
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = quake.alloca !quake.veq<?>[%c5_i64 : i64]
    %1 = quake.veq_size %0 : (!quake.veq<?>) -> i64
    %2 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %38 = arith.cmpi slt, %arg0, %1 : i64
      cc.condition %38(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %38 = quake.extract_ref %0[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      quake.h %38 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %38 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %38 : i64
    } {invariant}
    cf.br ^bb1(%c0_i64 : i64)
  ^bb1(%3: i64):  // pred: ^bb0
    cf.br ^bb2(%3 : i64)
  ^bb2(%4: i64):  // pred: ^bb1
    %5 = quake.extract_ref %0[%4] : (!quake.veq<?>, i64) -> !quake.ref
    %6 = arith.addi %4, %c1_i64 : i64
    %7 = quake.extract_ref %0[%6] : (!quake.veq<?>, i64) -> !quake.ref
    quake.x [%5] %7 : (!quake.ref, !quake.ref) -> ()
    cf.br ^bb3
  ^bb3:  // pred: ^bb2
    cf.br ^bb4
  ^bb4:  // pred: ^bb3
    cf.br ^bb5(%c1_i64 : i64)
  ^bb5(%8: i64):  // pred: ^bb4
    cf.br ^bb6(%8 : i64)
  ^bb6(%9: i64):  // pred: ^bb5
    %10 = quake.extract_ref %0[%9] : (!quake.veq<?>, i64) -> !quake.ref
    %11 = arith.addi %9, %c1_i64 : i64
    %12 = quake.extract_ref %0[%11] : (!quake.veq<?>, i64) -> !quake.ref
    quake.x [%10] %12 : (!quake.ref, !quake.ref) -> ()
    cf.br ^bb7
  ^bb7:  // pred: ^bb6
    cf.br ^bb8
  ^bb8:  // pred: ^bb7
    cf.br ^bb9(%c2_i64 : i64)
  ^bb9(%13: i64):  // pred: ^bb8
    cf.br ^bb10(%13 : i64)
  ^bb10(%14: i64):  // pred: ^bb9
    %15 = quake.extract_ref %0[%14] : (!quake.veq<?>, i64) -> !quake.ref
    %16 = arith.addi %14, %c1_i64 : i64
    %17 = quake.extract_ref %0[%16] : (!quake.veq<?>, i64) -> !quake.ref
    quake.x [%15] %17 : (!quake.ref, !quake.ref) -> ()
    cf.br ^bb11
  ^bb11:  // pred: ^bb10
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    cf.br ^bb13(%c3_i64 : i64)
  ^bb13(%18: i64):  // pred: ^bb12
    cf.br ^bb14(%18 : i64)
  ^bb14(%19: i64):  // pred: ^bb13
    %20 = quake.extract_ref %0[%19] : (!quake.veq<?>, i64) -> !quake.ref
    %21 = arith.addi %19, %c1_i64 : i64
    %22 = quake.extract_ref %0[%21] : (!quake.veq<?>, i64) -> !quake.ref
    quake.x [%20] %22 : (!quake.ref, !quake.ref) -> ()
    cf.br ^bb15
  ^bb15:  // pred: ^bb14
    cf.br ^bb16
  ^bb16:  // pred: ^bb15
    cf.br ^bb17
  ^bb17:  // pred: ^bb16
    cf.br ^bb18(%c0_i64 : i64)
  ^bb18(%23: i64):  // pred: ^bb17
    cf.br ^bb19(%23 : i64)
  ^bb19(%24: i64):  // pred: ^bb18
    %25 = quake.extract_ref %0[%24] : (!quake.veq<?>, i64) -> !quake.ref
    %measOut = quake.mz %25 : (!quake.ref) -> !quake.measure
    cf.br ^bb20
  ^bb20:  // pred: ^bb19
    cf.br ^bb21
  ^bb21:  // pred: ^bb20
    cf.br ^bb22(%c1_i64 : i64)
  ^bb22(%26: i64):  // pred: ^bb21
    cf.br ^bb23(%26 : i64)
  ^bb23(%27: i64):  // pred: ^bb22
    %28 = quake.extract_ref %0[%27] : (!quake.veq<?>, i64) -> !quake.ref
    %measOut_0 = quake.mz %28 : (!quake.ref) -> !quake.measure
    cf.br ^bb24
  ^bb24:  // pred: ^bb23
    cf.br ^bb25
  ^bb25:  // pred: ^bb24
    cf.br ^bb26(%c2_i64 : i64)
  ^bb26(%29: i64):  // pred: ^bb25
    cf.br ^bb27(%29 : i64)
  ^bb27(%30: i64):  // pred: ^bb26
    %31 = quake.extract_ref %0[%30] : (!quake.veq<?>, i64) -> !quake.ref
    %measOut_1 = quake.mz %31 : (!quake.ref) -> !quake.measure
    cf.br ^bb28
  ^bb28:  // pred: ^bb27
    cf.br ^bb29
  ^bb29:  // pred: ^bb28
    cf.br ^bb30(%c3_i64 : i64)
  ^bb30(%32: i64):  // pred: ^bb29
    cf.br ^bb31(%32 : i64)
  ^bb31(%33: i64):  // pred: ^bb30
    %34 = quake.extract_ref %0[%33] : (!quake.veq<?>, i64) -> !quake.ref
    %measOut_2 = quake.mz %34 : (!quake.ref) -> !quake.measure
    cf.br ^bb32
  ^bb32:  // pred: ^bb31
    cf.br ^bb33
  ^bb33:  // pred: ^bb32
    cf.br ^bb34(%c4_i64 : i64)
  ^bb34(%35: i64):  // pred: ^bb33
    cf.br ^bb35(%35 : i64)
  ^bb35(%36: i64):  // pred: ^bb34
    %37 = quake.extract_ref %0[%36] : (!quake.veq<?>, i64) -> !quake.ref
    %measOut_3 = quake.mz %37 : (!quake.ref) -> !quake.measure
    cf.br ^bb36
  ^bb36:  // pred: ^bb35
    cf.br ^bb37
  ^bb37:  // pred: ^bb36
    cf.br ^bb38
  ^bb38:  // pred: ^bb37
    return
  }
}


// -----// IR Dump Before Canonicalizer (canonicalize) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c0_i64 = arith.constant 0 : i64
    %c2_i64 = arith.constant 2 : i64
    %c3_i64 = arith.constant 3 : i64
    %c4_i64 = arith.constant 4 : i64
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = quake.alloca !quake.veq<?>[%c5_i64 : i64]
    %1 = quake.veq_size %0 : (!quake.veq<?>) -> i64
    %2 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %38 = arith.cmpi slt, %arg0, %1 : i64
      cc.condition %38(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %38 = quake.extract_ref %0[%arg0] : (!quake.veq<?>, i64) -> !quake.ref
      quake.h %38 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %38 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %38 : i64
    } {invariant}
    cf.br ^bb1(%c0_i64 : i64)
  ^bb1(%3: i64):  // pred: ^bb0
    cf.br ^bb2(%3 : i64)
  ^bb2(%4: i64):  // pred: ^bb1
    %5 = quake.extract_ref %0[%4] : (!quake.veq<?>, i64) -> !quake.ref
    %6 = arith.addi %4, %c1_i64 : i64
    %7 = quake.extract_ref %0[%6] : (!quake.veq<?>, i64) -> !quake.ref
    quake.x [%5] %7 : (!quake.ref, !quake.ref) -> ()
    cf.br ^bb3
  ^bb3:  // pred: ^bb2
    cf.br ^bb4
  ^bb4:  // pred: ^bb3
    cf.br ^bb5(%c1_i64 : i64)
  ^bb5(%8: i64):  // pred: ^bb4
    cf.br ^bb6(%8 : i64)
  ^bb6(%9: i64):  // pred: ^bb5
    %10 = quake.extract_ref %0[%9] : (!quake.veq<?>, i64) -> !quake.ref
    %11 = arith.addi %9, %c1_i64 : i64
    %12 = quake.extract_ref %0[%11] : (!quake.veq<?>, i64) -> !quake.ref
    quake.x [%10] %12 : (!quake.ref, !quake.ref) -> ()
    cf.br ^bb7
  ^bb7:  // pred: ^bb6
    cf.br ^bb8
  ^bb8:  // pred: ^bb7
    cf.br ^bb9(%c2_i64 : i64)
  ^bb9(%13: i64):  // pred: ^bb8
    cf.br ^bb10(%13 : i64)
  ^bb10(%14: i64):  // pred: ^bb9
    %15 = quake.extract_ref %0[%14] : (!quake.veq<?>, i64) -> !quake.ref
    %16 = arith.addi %14, %c1_i64 : i64
    %17 = quake.extract_ref %0[%16] : (!quake.veq<?>, i64) -> !quake.ref
    quake.x [%15] %17 : (!quake.ref, !quake.ref) -> ()
    cf.br ^bb11
  ^bb11:  // pred: ^bb10
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    cf.br ^bb13(%c3_i64 : i64)
  ^bb13(%18: i64):  // pred: ^bb12
    cf.br ^bb14(%18 : i64)
  ^bb14(%19: i64):  // pred: ^bb13
    %20 = quake.extract_ref %0[%19] : (!quake.veq<?>, i64) -> !quake.ref
    %21 = arith.addi %19, %c1_i64 : i64
    %22 = quake.extract_ref %0[%21] : (!quake.veq<?>, i64) -> !quake.ref
    quake.x [%20] %22 : (!quake.ref, !quake.ref) -> ()
    cf.br ^bb15
  ^bb15:  // pred: ^bb14
    cf.br ^bb16
  ^bb16:  // pred: ^bb15
    cf.br ^bb17
  ^bb17:  // pred: ^bb16
    cf.br ^bb18(%c0_i64 : i64)
  ^bb18(%23: i64):  // pred: ^bb17
    cf.br ^bb19(%23 : i64)
  ^bb19(%24: i64):  // pred: ^bb18
    %25 = quake.extract_ref %0[%24] : (!quake.veq<?>, i64) -> !quake.ref
    %measOut = quake.mz %25 : (!quake.ref) -> !quake.measure
    cf.br ^bb20
  ^bb20:  // pred: ^bb19
    cf.br ^bb21
  ^bb21:  // pred: ^bb20
    cf.br ^bb22(%c1_i64 : i64)
  ^bb22(%26: i64):  // pred: ^bb21
    cf.br ^bb23(%26 : i64)
  ^bb23(%27: i64):  // pred: ^bb22
    %28 = quake.extract_ref %0[%27] : (!quake.veq<?>, i64) -> !quake.ref
    %measOut_0 = quake.mz %28 : (!quake.ref) -> !quake.measure
    cf.br ^bb24
  ^bb24:  // pred: ^bb23
    cf.br ^bb25
  ^bb25:  // pred: ^bb24
    cf.br ^bb26(%c2_i64 : i64)
  ^bb26(%29: i64):  // pred: ^bb25
    cf.br ^bb27(%29 : i64)
  ^bb27(%30: i64):  // pred: ^bb26
    %31 = quake.extract_ref %0[%30] : (!quake.veq<?>, i64) -> !quake.ref
    %measOut_1 = quake.mz %31 : (!quake.ref) -> !quake.measure
    cf.br ^bb28
  ^bb28:  // pred: ^bb27
    cf.br ^bb29
  ^bb29:  // pred: ^bb28
    cf.br ^bb30(%c3_i64 : i64)
  ^bb30(%32: i64):  // pred: ^bb29
    cf.br ^bb31(%32 : i64)
  ^bb31(%33: i64):  // pred: ^bb30
    %34 = quake.extract_ref %0[%33] : (!quake.veq<?>, i64) -> !quake.ref
    %measOut_2 = quake.mz %34 : (!quake.ref) -> !quake.measure
    cf.br ^bb32
  ^bb32:  // pred: ^bb31
    cf.br ^bb33
  ^bb33:  // pred: ^bb32
    cf.br ^bb34(%c4_i64 : i64)
  ^bb34(%35: i64):  // pred: ^bb33
    cf.br ^bb35(%35 : i64)
  ^bb35(%36: i64):  // pred: ^bb34
    %37 = quake.extract_ref %0[%36] : (!quake.veq<?>, i64) -> !quake.ref
    %measOut_3 = quake.mz %37 : (!quake.ref) -> !quake.measure
    cf.br ^bb36
  ^bb36:  // pred: ^bb35
    cf.br ^bb37
  ^bb37:  // pred: ^bb36
    cf.br ^bb38
  ^bb38:  // pred: ^bb37
    return
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before LiftArrayAlloc (lift-array-alloc) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before GlobalizeArrayValues (globalize-array-values) ('builtin.module' operation) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before StatePreparation (state-prep) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before GetConcreteMatrix (get-concrete-matrix) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before UnitarySynthesis (unitary-synthesis) ('builtin.module' operation) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before ApplySpecialization (apply-op-specialization) ('builtin.module' operation) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before ConvertToDirectCalls (indirect-to-direct-calls) ('builtin.module' operation) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before Inliner (inline) ('builtin.module' operation) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before Canonicalizer (canonicalize) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before CheckKernelCalls (check-kernel-calls) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before SymbolDCE (symbol-dce) ('builtin.module' operation) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before Canonicalizer (canonicalize) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before CSE (cse) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %15 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %15(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %15 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %15 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %15 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %15 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %5 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %7 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%6] %7 : (!quake.ref, !quake.ref) -> ()
    %8 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %9 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%8] %9 : (!quake.ref, !quake.ref) -> ()
    %10 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %measOut = quake.mz %10 : (!quake.ref) -> !quake.measure
    %11 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    %measOut_0 = quake.mz %11 : (!quake.ref) -> !quake.measure
    %12 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    %measOut_1 = quake.mz %12 : (!quake.ref) -> !quake.measure
    %13 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    %measOut_2 = quake.mz %13 : (!quake.ref) -> !quake.measure
    %14 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    %measOut_3 = quake.mz %14 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump After CSE (cse) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before MultiControlDecompositionPass (multicontrol-decomposition) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before DecompositionPass (decomposition) ('builtin.module' operation) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before Canonicalizer (canonicalize) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before ExpandControlVeqs (expand-control-veqs) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before CombineQuantumAllocations (combine-quantum-alloc) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c5_i64 = arith.constant 5 : i64
    %c0_i64 = arith.constant 0 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump After CombineQuantumAllocations (combine-quantum-alloc) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c4_i64 = arith.constant 4 : i64
    %c3_i64 = arith.constant 3 : i64
    %c2_i64 = arith.constant 2 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[%c0_i64] : (!quake.veq<5>, i64) -> !quake.ref
    %3 = quake.extract_ref %0[%c1_i64] : (!quake.veq<5>, i64) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[%c2_i64] : (!quake.veq<5>, i64) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[%c3_i64] : (!quake.veq<5>, i64) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[%c4_i64] : (!quake.veq<5>, i64) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before Canonicalizer (canonicalize) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c4_i64 = arith.constant 4 : i64
    %c3_i64 = arith.constant 3 : i64
    %c2_i64 = arith.constant 2 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[%c0_i64] : (!quake.veq<5>, i64) -> !quake.ref
    %3 = quake.extract_ref %0[%c1_i64] : (!quake.veq<5>, i64) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[%c2_i64] : (!quake.veq<5>, i64) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[%c3_i64] : (!quake.veq<5>, i64) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[%c4_i64] : (!quake.veq<5>, i64) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before CSE (cse) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before MemToReg (memtoreg) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before Canonicalizer (canonicalize) ('func.func' operation: @__nvqpp__mlirgen__kernel_loop) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


// -----// IR Dump Before SymbolDCE (symbol-dce) ('builtin.module' operation) //----- //
module attributes {quake.mangled_name_map = {__nvqpp__mlirgen__kernel_loop = "__nvqpp__mlirgen__kernel_loop_PyKernelEntryPointRewrite"}} {
  func.func @__nvqpp__mlirgen__kernel_loop() attributes {"cudaq-entrypoint"} {
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c5_i64 = arith.constant 5 : i64
    %0 = quake.alloca !quake.veq<5>
    %1 = cc.loop while ((%arg0 = %c0_i64) -> (i64)) {
      %7 = arith.cmpi slt, %arg0, %c5_i64 : i64
      cc.condition %7(%arg0 : i64)
    } do {
    ^bb0(%arg0: i64):
      %7 = quake.extract_ref %0[%arg0] : (!quake.veq<5>, i64) -> !quake.ref
      quake.h %7 : (!quake.ref) -> ()
      cc.continue %arg0 : i64
    } step {
    ^bb0(%arg0: i64):
      %7 = arith.addi %arg0, %c1_i64 : i64
      cc.continue %7 : i64
    } {invariant}
    %2 = quake.extract_ref %0[0] : (!quake.veq<5>) -> !quake.ref
    %3 = quake.extract_ref %0[1] : (!quake.veq<5>) -> !quake.ref
    quake.x [%2] %3 : (!quake.ref, !quake.ref) -> ()
    %4 = quake.extract_ref %0[2] : (!quake.veq<5>) -> !quake.ref
    quake.x [%3] %4 : (!quake.ref, !quake.ref) -> ()
    %5 = quake.extract_ref %0[3] : (!quake.veq<5>) -> !quake.ref
    quake.x [%4] %5 : (!quake.ref, !quake.ref) -> ()
    %6 = quake.extract_ref %0[4] : (!quake.veq<5>) -> !quake.ref
    quake.x [%5] %6 : (!quake.ref, !quake.ref) -> ()
    %measOut = quake.mz %2 : (!quake.ref) -> !quake.measure
    %measOut_0 = quake.mz %3 : (!quake.ref) -> !quake.measure
    %measOut_1 = quake.mz %4 : (!quake.ref) -> !quake.measure
    %measOut_2 = quake.mz %5 : (!quake.ref) -> !quake.measure
    %measOut_3 = quake.mz %6 : (!quake.ref) -> !quake.measure
    return
  }
}


error: 'cc.loop' op unable to translate op to OpenQASM 2.0
RuntimeError: getASM: failed to translate to OpenQASM.
