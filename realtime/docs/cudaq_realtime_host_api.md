# CUDA-Q Realtime Host API

This document explains the C host API for realtime dispatch, the RPC wire
protocol, and complete wiring examples. It is written for external partners
integrating CUDA-QX decoders with their own transport mechanisms. The API and
protocol are **transport-agnostic** and support multiple data transport options,
including NVIDIA Hololink (RDMA via ConnectX NIC's), `libibverbs`, and proprietary
transport layers. Handlers can execute on GPU (via CUDA kernels) or CPU (via
host threads). Examples in this document use Hololink's 3-kernel workflow (RX
kernel/dispatch/TX kernel) for illustration, but the same principles apply to
other transport mechanisms.

## What is Hololink?

**Hololink** is NVIDIA's low-latency sensor bridge framework that enables
direct GPU memory access from external devices (FPGAs, sensors) over Ethernet
using RDMA (Remote Direct Memory Access) via ConnectX NIC's. In the context of
quantum error correction, Hololink is one example of a transport mechanism that
connects the quantum control system (typically an FPGA) to GPU-based decoders.

**Repository**: [`nvidia-holoscan`/`holoscan-sensor-bridge` (`nvqlink` branch)](https://github.com/nvidia-holoscan/holoscan-sensor-bridge/tree/nvqlink)

Hololink handles:

- **RX (Receive)**: RX kernel receives data from the FPGA directly
into GPU memory via RDMA
- **TX (Transmit)**: TX kernel sends results back
to the FPGA via RDMA
- **RDMA transport**: Zero-copy data movement using
ConnectX-7 NIC's with GPUDirect support

The CUDA-Q Realtime Host API provides the **middle component**
(dispatch kernel or thread) that sits between
the transport's RX and TX components, executing the actual decoder logic.

## Transport Mechanisms

The realtime dispatch API is designed to work with multiple transport mechanisms
that move data between the quantum control system (FPGA) and the decoder. The
transport mechanism handles getting RPC messages into RX ring buffer slots and
sending responses from TX ring buffer slots back to the FPGA.

### Supported Transport Options

**Hololink (GPU-based with GPUDirect)**:

- Uses ConnectX-7 NICs with RDMA for zero-copy data movement
- RX and TX are persistent GPU kernels that directly access GPU memory
- Requires GPUDirect support
- Lowest latency option for GPU-based decoders

**`libibverbs` (CPU-based)**:

- Standard InfiniBand Verbs API for RDMA on the CPU
- RX and TX are host threads that poll CPU-accessible memory
- Works with CPU-based dispatchers
- Ring buffers reside in host memory (`cudaHostAlloc` or regular `malloc`)

**Proprietary Transport Mechanisms**:

- Custom implementations with or without GPUDirect support
- May use different networking technologies or memory transfer methods
- Must implement the ring buffer + flag protocol defined in this document
- Can target either GPU (with suitable memory access) or CPU execution

The key requirement is that the transport mechanism implements the ring buffer
slot + flag protocol: writing RPC messages to RX slots and setting `rx_flags`,
then reading TX slots after `tx_flags` are set.

## The 3-Kernel Architecture (Hololink Example) {#three-kernel-architecture}

The Hololink workflow separates concerns into three persistent GPU kernels that
communicate via shared ring buffers:

<!-- markdownlint-disable-next-line -->
<img src="data:image/svg+xml;base64,PHN2ZyBpZD0ibWVybWFpZC1zdmciIHdpZHRoPSIxMDAlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGNsYXNzPSJmbG93Y2hhcnQiIHN0eWxlPSJtYXgtd2lkdGg6IDU1Mi42MDE1NjI1cHg7IiB2aWV3Qm94PSIwIDAgNTUyLjYwMTU2MjUgODg2IiByb2xlPSJncmFwaGljcy1kb2N1bWVudCBkb2N1bWVudCIgYXJpYS1yb2xlZGVzY3JpcHRpb249ImZsb3djaGFydC12MiIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxzdHlsZSB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+QGltcG9ydCB1cmwoImh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL2ZvbnQtYXdlc29tZS82LjcuMi9jc3MvYWxsLm1pbi5jc3MiKTs8L3N0eWxlPjxzdHlsZT4jbWVybWFpZC1zdmd7Zm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxNnB4O2ZpbGw6IzMzMzt9QGtleWZyYW1lcyBlZGdlLWFuaW1hdGlvbi1mcmFtZXtmcm9te3N0cm9rZS1kYXNob2Zmc2V0OjA7fX1Aa2V5ZnJhbWVzIGRhc2h7dG97c3Ryb2tlLWRhc2hvZmZzZXQ6MDt9fSNtZXJtYWlkLXN2ZyAuZWRnZS1hbmltYXRpb24tc2xvd3tzdHJva2UtZGFzaGFycmF5OjksNSFpbXBvcnRhbnQ7c3Ryb2tlLWRhc2hvZmZzZXQ6OTAwO2FuaW1hdGlvbjpkYXNoIDUwcyBsaW5lYXIgaW5maW5pdGU7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7fSNtZXJtYWlkLXN2ZyAuZWRnZS1hbmltYXRpb24tZmFzdHtzdHJva2UtZGFzaGFycmF5OjksNSFpbXBvcnRhbnQ7c3Ryb2tlLWRhc2hvZmZzZXQ6OTAwO2FuaW1hdGlvbjpkYXNoIDIwcyBsaW5lYXIgaW5maW5pdGU7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7fSNtZXJtYWlkLXN2ZyAuZXJyb3ItaWNvbntmaWxsOiM1NTIyMjI7fSNtZXJtYWlkLXN2ZyAuZXJyb3ItdGV4dHtmaWxsOiM1NTIyMjI7c3Ryb2tlOiM1NTIyMjI7fSNtZXJtYWlkLXN2ZyAuZWRnZS10aGlja25lc3Mtbm9ybWFse3N0cm9rZS13aWR0aDoxcHg7fSNtZXJtYWlkLXN2ZyAuZWRnZS10aGlja25lc3MtdGhpY2t7c3Ryb2tlLXdpZHRoOjMuNXB4O30jbWVybWFpZC1zdmcgLmVkZ2UtcGF0dGVybi1zb2xpZHtzdHJva2UtZGFzaGFycmF5OjA7fSNtZXJtYWlkLXN2ZyAuZWRnZS10aGlja25lc3MtaW52aXNpYmxle3N0cm9rZS13aWR0aDowO2ZpbGw6bm9uZTt9I21lcm1haWQtc3ZnIC5lZGdlLXBhdHRlcm4tZGFzaGVke3N0cm9rZS1kYXNoYXJyYXk6Mzt9I21lcm1haWQtc3ZnIC5lZGdlLXBhdHRlcm4tZG90dGVke3N0cm9rZS1kYXNoYXJyYXk6Mjt9I21lcm1haWQtc3ZnIC5tYXJrZXJ7ZmlsbDojMzMzMzMzO3N0cm9rZTojMzMzMzMzO30jbWVybWFpZC1zdmcgLm1hcmtlci5jcm9zc3tzdHJva2U6IzMzMzMzMzt9I21lcm1haWQtc3ZnIHN2Z3tmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7fSNtZXJtYWlkLXN2ZyBwe21hcmdpbjowO30jbWVybWFpZC1zdmcgLmxhYmVse2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtjb2xvcjojMzMzO30jbWVybWFpZC1zdmcgLmNsdXN0ZXItbGFiZWwgdGV4dHtmaWxsOiMzMzM7fSNtZXJtYWlkLXN2ZyAuY2x1c3Rlci1sYWJlbCBzcGFue2NvbG9yOiMzMzM7fSNtZXJtYWlkLXN2ZyAuY2x1c3Rlci1sYWJlbCBzcGFuIHB7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDt9I21lcm1haWQtc3ZnIC5sYWJlbCB0ZXh0LCNtZXJtYWlkLXN2ZyBzcGFue2ZpbGw6IzMzMztjb2xvcjojMzMzO30jbWVybWFpZC1zdmcgLm5vZGUgcmVjdCwjbWVybWFpZC1zdmcgLm5vZGUgY2lyY2xlLCNtZXJtYWlkLXN2ZyAubm9kZSBlbGxpcHNlLCNtZXJtYWlkLXN2ZyAubm9kZSBwb2x5Z29uLCNtZXJtYWlkLXN2ZyAubm9kZSBwYXRoe2ZpbGw6I0VDRUNGRjtzdHJva2U6IzkzNzBEQjtzdHJva2Utd2lkdGg6MXB4O30jbWVybWFpZC1zdmcgLnJvdWdoLW5vZGUgLmxhYmVsIHRleHQsI21lcm1haWQtc3ZnIC5ub2RlIC5sYWJlbCB0ZXh0LCNtZXJtYWlkLXN2ZyAuaW1hZ2Utc2hhcGUgLmxhYmVsLCNtZXJtYWlkLXN2ZyAuaWNvbi1zaGFwZSAubGFiZWx7dGV4dC1hbmNob3I6bWlkZGxlO30jbWVybWFpZC1zdmcgLm5vZGUgLmthdGV4IHBhdGh7ZmlsbDojMDAwO3N0cm9rZTojMDAwO3N0cm9rZS13aWR0aDoxcHg7fSNtZXJtYWlkLXN2ZyAucm91Z2gtbm9kZSAubGFiZWwsI21lcm1haWQtc3ZnIC5ub2RlIC5sYWJlbCwjbWVybWFpZC1zdmcgLmltYWdlLXNoYXBlIC5sYWJlbCwjbWVybWFpZC1zdmcgLmljb24tc2hhcGUgLmxhYmVse3RleHQtYWxpZ246Y2VudGVyO30jbWVybWFpZC1zdmcgLm5vZGUuY2xpY2thYmxle2N1cnNvcjpwb2ludGVyO30jbWVybWFpZC1zdmcgLnJvb3QgLmFuY2hvciBwYXRoe2ZpbGw6IzMzMzMzMyFpbXBvcnRhbnQ7c3Ryb2tlLXdpZHRoOjA7c3Ryb2tlOiMzMzMzMzM7fSNtZXJtYWlkLXN2ZyAuYXJyb3doZWFkUGF0aHtmaWxsOiMzMzMzMzM7fSNtZXJtYWlkLXN2ZyAuZWRnZVBhdGggLnBhdGh7c3Ryb2tlOiMzMzMzMzM7c3Ryb2tlLXdpZHRoOjIuMHB4O30jbWVybWFpZC1zdmcgLmZsb3djaGFydC1saW5re3N0cm9rZTojMzMzMzMzO2ZpbGw6bm9uZTt9I21lcm1haWQtc3ZnIC5lZGdlTGFiZWx7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO3RleHQtYWxpZ246Y2VudGVyO30jbWVybWFpZC1zdmcgLmVkZ2VMYWJlbCBwe2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt9I21lcm1haWQtc3ZnIC5lZGdlTGFiZWwgcmVjdHtvcGFjaXR5OjAuNTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7ZmlsbDpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO30jbWVybWFpZC1zdmcgLmxhYmVsQmtne2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsIDIzMiwgMjMyLCAwLjUpO30jbWVybWFpZC1zdmcgLmNsdXN0ZXIgcmVjdHtmaWxsOiNmZmZmZGU7c3Ryb2tlOiNhYWFhMzM7c3Ryb2tlLXdpZHRoOjFweDt9I21lcm1haWQtc3ZnIC5jbHVzdGVyIHRleHR7ZmlsbDojMzMzO30jbWVybWFpZC1zdmcgLmNsdXN0ZXIgc3Bhbntjb2xvcjojMzMzO30jbWVybWFpZC1zdmcgZGl2Lm1lcm1haWRUb29sdGlwe3Bvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246Y2VudGVyO21heC13aWR0aDoyMDBweDtwYWRkaW5nOjJweDtmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjEycHg7YmFja2dyb3VuZDpoc2woODAsIDEwMCUsIDk2LjI3NDUwOTgwMzklKTtib3JkZXI6MXB4IHNvbGlkICNhYWFhMzM7Ym9yZGVyLXJhZGl1czoycHg7cG9pbnRlci1ldmVudHM6bm9uZTt6LWluZGV4OjEwMDt9I21lcm1haWQtc3ZnIC5mbG93Y2hhcnRUaXRsZVRleHR7dGV4dC1hbmNob3I6bWlkZGxlO2ZvbnQtc2l6ZToxOHB4O2ZpbGw6IzMzMzt9I21lcm1haWQtc3ZnIHJlY3QudGV4dHtmaWxsOm5vbmU7c3Ryb2tlLXdpZHRoOjA7fSNtZXJtYWlkLXN2ZyAuaWNvbi1zaGFwZSwjbWVybWFpZC1zdmcgLmltYWdlLXNoYXBle2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt0ZXh0LWFsaWduOmNlbnRlcjt9I21lcm1haWQtc3ZnIC5pY29uLXNoYXBlIHAsI21lcm1haWQtc3ZnIC5pbWFnZS1zaGFwZSBwe2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTtwYWRkaW5nOjJweDt9I21lcm1haWQtc3ZnIC5pY29uLXNoYXBlIHJlY3QsI21lcm1haWQtc3ZnIC5pbWFnZS1zaGFwZSByZWN0e29wYWNpdHk6MC41O2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTtmaWxsOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7fSNtZXJtYWlkLXN2ZyAubGFiZWwtaWNvbntkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MWVtO292ZXJmbG93OnZpc2libGU7dmVydGljYWwtYWxpZ246LTAuMTI1ZW07fSNtZXJtYWlkLXN2ZyAubm9kZSAubGFiZWwtaWNvbiBwYXRoe2ZpbGw6Y3VycmVudENvbG9yO3N0cm9rZTpyZXZlcnQ7c3Ryb2tlLXdpZHRoOnJldmVydDt9I21lcm1haWQtc3ZnIDpyb290ey0tbWVybWFpZC1mb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7fTwvc3R5bGU+PGc+PG1hcmtlciBpZD0ibWVybWFpZC1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kIiBjbGFzcz0ibWFya2VyIGZsb3djaGFydC12MiIgdmlld0JveD0iMCAwIDEwIDEwIiByZWZYPSI1IiByZWZZPSI1IiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hcmtlcldpZHRoPSI4IiBtYXJrZXJIZWlnaHQ9IjgiIG9yaWVudD0iYXV0byI+PHBhdGggZD0iTSAwIDAgTCAxMCA1IEwgMCAxMCB6IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIvPjwvbWFya2VyPjxtYXJrZXIgaWQ9Im1lcm1haWQtc3ZnX2Zsb3djaGFydC12Mi1wb2ludFN0YXJ0IiBjbGFzcz0ibWFya2VyIGZsb3djaGFydC12MiIgdmlld0JveD0iMCAwIDEwIDEwIiByZWZYPSI0LjUiIHJlZlk9IjUiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFya2VyV2lkdGg9IjgiIG1hcmtlckhlaWdodD0iOCIgb3JpZW50PSJhdXRvIj48cGF0aCBkPSJNIDAgNSBMIDEwIDEwIEwgMTAgMCB6IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIvPjwvbWFya2VyPjxtYXJrZXIgaWQ9Im1lcm1haWQtc3ZnX2Zsb3djaGFydC12Mi1jaXJjbGVFbmQiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0LXYyIiB2aWV3Qm94PSIwIDAgMTAgMTAiIHJlZlg9IjExIiByZWZZPSI1IiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VySGVpZ2h0PSIxMSIgb3JpZW50PSJhdXRvIj48Y2lyY2xlIGN4PSI1IiBjeT0iNSIgcj0iNSIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiLz48L21hcmtlcj48bWFya2VyIGlkPSJtZXJtYWlkLXN2Z19mbG93Y2hhcnQtdjItY2lyY2xlU3RhcnQiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0LXYyIiB2aWV3Qm94PSIwIDAgMTAgMTAiIHJlZlg9Ii0xIiByZWZZPSI1IiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VySGVpZ2h0PSIxMSIgb3JpZW50PSJhdXRvIj48Y2lyY2xlIGN4PSI1IiBjeT0iNSIgcj0iNSIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiLz48L21hcmtlcj48bWFya2VyIGlkPSJtZXJtYWlkLXN2Z19mbG93Y2hhcnQtdjItY3Jvc3NFbmQiIGNsYXNzPSJtYXJrZXIgY3Jvc3MgZmxvd2NoYXJ0LXYyIiB2aWV3Qm94PSIwIDAgMTEgMTEiIHJlZlg9IjEyIiByZWZZPSI1LjIiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJIZWlnaHQ9IjExIiBvcmllbnQ9ImF1dG8iPjxwYXRoIGQ9Ik0gMSwxIGwgOSw5IE0gMTAsMSBsIC05LDkiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIHN0eWxlPSJzdHJva2Utd2lkdGg6IDI7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7Ii8+PC9tYXJrZXI+PG1hcmtlciBpZD0ibWVybWFpZC1zdmdfZmxvd2NoYXJ0LXYyLWNyb3NzU3RhcnQiIGNsYXNzPSJtYXJrZXIgY3Jvc3MgZmxvd2NoYXJ0LXYyIiB2aWV3Qm94PSIwIDAgMTEgMTEiIHJlZlg9Ii0xIiByZWZZPSI1LjIiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJIZWlnaHQ9IjExIiBvcmllbnQ9ImF1dG8iPjxwYXRoIGQ9Ik0gMSwxIGwgOSw5IE0gMTAsMSBsIC05LDkiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIHN0eWxlPSJzdHJva2Utd2lkdGg6IDI7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7Ii8+PC9tYXJrZXI+PGcgY2xhc3M9InJvb3QiPjxnIGNsYXNzPSJjbHVzdGVycyIvPjxnIGNsYXNzPSJlZGdlUGF0aHMiPjxwYXRoIGQ9Ik0zMjMuMDA4LDYyTDMxNC43ODIsNjguMTY3QzMwNi41NTYsNzQuMzMzLDI5MC4xMDQsODYuNjY3LDI4OS41NzEsOTguNkMyODkuMDM3LDExMC41MzQsMzA0LjQyMiwxMjIuMDY3LDMxMi4xMTUsMTI3LjgzNEwzMTkuODA3LDEzMy42MDEiIGlkPSJMX0ZQR0FfUkRNQV8wIiBjbGFzcz0iIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgc3R5bGU9IjsiIGRhdGEtZWRnZT0idHJ1ZSIgZGF0YS1ldD0iZWRnZSIgZGF0YS1pZD0iTF9GUEdBX1JETUFfMCIgZGF0YS1wb2ludHM9Ilczc2llQ0k2TXpJekxqQXdOelV3TnpNeU5ESXhPRGMxTENKNUlqbzJNbjBzZXlKNElqb3lOek11TmpVeU16UXpOelVzSW5raU9qazVmU3g3SW5naU9qTXlNeTR3TURjMU1EY3pNalF5TVRnM05Td2llU0k2TVRNMmZWMD0iIG1hcmtlci1lbmQ9InVybCgjbWVybWFpZC1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIvPjxwYXRoIGQ9Ik0zMDEuOTI5LDE5MEwyODguODg4LDE5Ni4xNjdDMjc1Ljg0OCwyMDIuMzMzLDI0OS43NjgsMjE0LjY2NywyMzYuNzI4LDIyNi4zMzNDMjIzLjY4OCwyMzgsMjIzLjY4OCwyNDksMjIzLjY4OCwyNTQuNUwyMjMuNjg4LDI2MCIgaWQ9IkxfUkRNQV9SWF8wIiBjbGFzcz0iIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgc3R5bGU9IjsiIGRhdGEtZWRnZT0idHJ1ZSIgZGF0YS1ldD0iZWRnZSIgZGF0YS1pZD0iTF9SRE1BX1JYXzAiIGRhdGEtcG9pbnRzPSJXM3NpZUNJNk16QXhMamt5T0RVNE9EZzJOekU0TnpVc0lua2lPakU1TUgwc2V5SjRJam95TWpNdU5qZzNOU3dpZVNJNk1qSTNmU3g3SW5naU9qSXlNeTQyT0RjMUxDSjVJam95TmpSOVhRPT0iIG1hcmtlci1lbmQ9InVybCgjbWVybWFpZC1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIvPjxwYXRoIGQ9Ik0yMjMuNjg4LDMxOEwyMjMuNjg4LDMyNC4xNjdDMjIzLjY4OCwzMzAuMzMzLDIyMy42ODgsMzQyLjY2NywyMjMuNjg4LDM1NC4zMzNDMjIzLjY4OCwzNjYsMjIzLjY4OCwzNzcsMjIzLjY4OCwzODIuNUwyMjMuNjg4LDM4OCIgaWQ9IkxfUlhfUlhfQlVGXzAiIGNsYXNzPSIgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBzdHlsZT0iOyIgZGF0YS1lZGdlPSJ0cnVlIiBkYXRhLWV0PSJlZGdlIiBkYXRhLWlkPSJMX1JYX1JYX0JVRl8wIiBkYXRhLXBvaW50cz0iVzNzaWVDSTZNakl6TGpZNE56VXNJbmtpT2pNeE9IMHNleUo0SWpveU1qTXVOamczTlN3aWVTSTZNelUxZlN4N0luZ2lPakl5TXk0Mk9EYzFMQ0o1SWpvek9USjlYUT09IiBtYXJrZXItZW5kPSJ1cmwoI21lcm1haWQtc3ZnX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiLz48cGF0aCBkPSJNMjIzLjY4OCw0NDZMMjIzLjY4OCw0NTIuMTY3QzIyMy42ODgsNDU4LjMzMywyMjMuNjg4LDQ3MC42NjcsMjIzLjY4OCw0ODIuMzMzQzIyMy42ODgsNDk0LDIyMy42ODgsNTA1LDIyMy42ODgsNTEwLjVMMjIzLjY4OCw1MTYiIGlkPSJMX1JYX0JVRl9ESVNQQVRDSF8wIiBjbGFzcz0iIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgc3R5bGU9IjsiIGRhdGEtZWRnZT0idHJ1ZSIgZGF0YS1ldD0iZWRnZSIgZGF0YS1pZD0iTF9SWF9CVUZfRElTUEFUQ0hfMCIgZGF0YS1wb2ludHM9Ilczc2llQ0k2TWpJekxqWTROelVzSW5raU9qUTBObjBzZXlKNElqb3lNak11TmpnM05Td2llU0k2TkRnemZTeDdJbmdpT2pJeU15NDJPRGMxTENKNUlqbzFNakI5WFE9PSIgbWFya2VyLWVuZD0idXJsKCNtZXJtYWlkLXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIi8+PHBhdGggZD0iTTE3MS40NjEsNTk4TDE2MC41MjUsNjA2LjE2N0MxNDkuNTg5LDYxNC4zMzMsMTI3LjcxNiw2MzAuNjY3LDExNi43OCw2NTEuNDkyQzEwNS44NDQsNjcyLjMxNywxMDUuODQ0LDY5Ny42MzMsMTA1Ljg0NCw3MTAuMjkyTDEwNS44NDQsNzIyLjk1IiBpZD0iRElTUEFUQ0gtY3ljbGljLXNwZWNpYWwtMSIgY2xhc3M9IiBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIHN0eWxlPSI7IiBkYXRhLWVkZ2U9InRydWUiIGRhdGEtZXQ9ImVkZ2UiIGRhdGEtaWQ9IkRJU1BBVENILWN5Y2xpYy1zcGVjaWFsLTEiIGRhdGEtcG9pbnRzPSJXM3NpZUNJNk1UY3hMalEyTVRJNU1qWXhNell6TmpNM0xDSjVJam8xT1RoOUxIc2llQ0k2TVRBMUxqZzBNemMxTENKNUlqbzJORGQ5TEhzaWVDSTZNVEExTGpnME16YzFMQ0o1SWpvM01qSXVPVFE1T1RrNU9UazVNalUwT1gxZCIvPjxwYXRoIGQ9Ik0xMDUuODQ0LDcyMy4wNUwxMDUuODQ0LDczMy43MDhDMTA1Ljg0NCw3NDQuMzY3LDEwNS44NDQsNzY1LjY4MywxMTMuMTg2LDc4N0MxMjAuNTI5LDgwOC4zMTcsMTM1LjIxNCw4MjkuNjMzLDE0Mi41NTcsODQwLjI5MkwxNDkuODk5LDg1MC45NSIgaWQ9IkRJU1BBVENILWN5Y2xpYy1zcGVjaWFsLW1pZCIgY2xhc3M9IiBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIHN0eWxlPSI7IiBkYXRhLWVkZ2U9InRydWUiIGRhdGEtZXQ9ImVkZ2UiIGRhdGEtaWQ9IkRJU1BBVENILWN5Y2xpYy1zcGVjaWFsLW1pZCIgZGF0YS1wb2ludHM9Ilczc2llQ0k2TVRBMUxqZzBNemMxTENKNUlqbzNNak11TURVd01EQXdNREF3TnpRMU1YMHNleUo0SWpveE1EVXVPRFF6TnpVc0lua2lPamM0TjMwc2V5SjRJam94TkRrdU9EazVNVFE0TlRVNU1EVTNNRFFzSW5raU9qZzFNQzQ1TkRrNU9UazVPVGt5TlRRNWZWMD0iLz48cGF0aCBkPSJNMTQ5Ljk4NCw4NTAuOTU3TDE2Mi4yNjgsODQwLjI5N0MxNzQuNTUyLDgyOS42MzgsMTk5LjEyLDgwOC4zMTksMjExLjQwNCw3ODYuOTkzQzIyMy42ODgsNzY1LjY2NywyMjMuNjg4LDc0NC4zMzMsMjIzLjY4OCw3MjFDMjIzLjY4OCw2OTcuNjY3LDIyMy42ODgsNjcyLjMzMywyMjMuNjg4LDY1Mi4xNjdDMjIzLjY4OCw2MzIsMjIzLjY4OCw2MTcsMjIzLjY4OCw2MDkuNUwyMjMuNjg4LDYwMiIgaWQ9IkRJU1BBVENILWN5Y2xpYy1zcGVjaWFsLTIiIGNsYXNzPSIgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBzdHlsZT0iOyIgZGF0YS1lZGdlPSJ0cnVlIiBkYXRhLWV0PSJlZGdlIiBkYXRhLWlkPSJESVNQQVRDSC1jeWNsaWMtc3BlY2lhbC0yIiBkYXRhLXBvaW50cz0iVzNzaWVDSTZNVFE1TGprNE16VTVNemMxTURjME5UQTJMQ0o1SWpvNE5UQXVPVFUyTmpFeU5EWTJPVEV6Tlgwc2V5SjRJam95TWpNdU5qZzNOU3dpZVNJNk56ZzNmU3g3SW5naU9qSXlNeTQyT0RjMUxDSjVJam8zTWpOOUxIc2llQ0k2TWpJekxqWTROelVzSW5raU9qWTBOMzBzZXlKNElqb3lNak11TmpnM05Td2llU0k2TlRrNGZWMD0iIG1hcmtlci1lbmQ9InVybCgjbWVybWFpZC1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIvPjxwYXRoIGQ9Ik0yODMuNjY2LDU5OEwyOTYuMjI2LDYwNi4xNjdDMzA4Ljc4NSw2MTQuMzMzLDMzMy45MDQsNjMwLjY2NywzNDYuNDY0LDY0Ni4zMzNDMzU5LjAyMyw2NjIsMzU5LjAyMyw2NzcsMzU5LjAyMyw2ODQuNUwzNTkuMDIzLDY5MiIgaWQ9IkxfRElTUEFUQ0hfVFhfQlVGXzAiIGNsYXNzPSIgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBzdHlsZT0iOyIgZGF0YS1lZGdlPSJ0cnVlIiBkYXRhLWV0PSJlZGdlIiBkYXRhLWlkPSJMX0RJU1BBVENIX1RYX0JVRl8wIiBkYXRhLXBvaW50cz0iVzNzaWVDSTZNamd6TGpZMk5Ua3lOamcwTmpVNU1Ea3NJbmtpT2pVNU9IMHNleUo0SWpvek5Ua3VNREl6TkRNM05Td2llU0k2TmpRM2ZTeDdJbmdpT2pNMU9TNHdNak0wTXpjMUxDSjVJam8yT1RaOVhRPT0iIG1hcmtlci1lbmQ9InVybCgjbWVybWFpZC1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIvPjxwYXRoIGQ9Ik0zNTkuMDIzLDc1MEwzNTkuMDIzLDc1Ni4xNjdDMzU5LjAyMyw3NjIuMzMzLDM1OS4wMjMsNzc0LjY2NywzNjUuMDU5LDc4Ni41NDJDMzcxLjA5NSw3OTguNDE3LDM4My4xNjYsODA5LjgzNCwzODkuMjAyLDgxNS41NDNMMzk1LjIzOCw4MjEuMjUxIiBpZD0iTF9UWF9CVUZfVFhfMCIgY2xhc3M9IiBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIHN0eWxlPSI7IiBkYXRhLWVkZ2U9InRydWUiIGRhdGEtZXQ9ImVkZ2UiIGRhdGEtaWQ9IkxfVFhfQlVGX1RYXzAiIGRhdGEtcG9pbnRzPSJXM3NpZUNJNk16VTVMakF5TXpRek56VXNJbmtpT2pjMU1IMHNleUo0SWpvek5Ua3VNREl6TkRNM05Td2llU0k2TnpnM2ZTeDdJbmdpT2pNNU9DNHhORE01T0RFNU16TTFPVE0zTlN3aWVTSTZPREkwZlYwPSIgbWFya2VyLWVuZD0idXJsKCNtZXJtYWlkLXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIi8+PHBhdGggZD0iTTQ1NS4yMzksODI0TDQ2MS43NTksODE3LjgzM0M0NjguMjc5LDgxMS42NjcsNDgxLjMxOSw3OTkuMzMzLDQ4Ny44MzksNzgyLjVDNDk0LjM1OSw3NjUuNjY3LDQ5NC4zNTksNzQ0LjMzMyw0OTQuMzU5LDcyMUM0OTQuMzU5LDY5Ny42NjcsNDk0LjM1OSw2NzIuMzMzLDQ5NC4zNTksNjQ1QzQ5NC4zNTksNjE3LjY2Nyw0OTQuMzU5LDU4OC4zMzMsNDk0LjM1OSw1NjFDNDk0LjM1OSw1MzMuNjY3LDQ5NC4zNTksNTA4LjMzMyw0OTQuMzU5LDQ4NUM0OTQuMzU5LDQ2MS42NjcsNDk0LjM1OSw0NDAuMzMzLDQ5NC4zNTksNDE5QzQ5NC4zNTksMzk3LjY2Nyw0OTQuMzU5LDM3Ni4zMzMsNDk0LjM1OSwzNTVDNDk0LjM1OSwzMzMuNjY3LDQ5NC4zNTksMzEyLjMzMyw0OTQuMzU5LDI5MUM0OTQuMzU5LDI2OS42NjcsNDk0LjM1OSwyNDguMzMzLDQ4MS45MjIsMjMxLjc4NUM0NjkuNDg0LDIxNS4yMzcsNDQ0LjYwOSwyMDMuNDczLDQzMi4xNzIsMTk3LjU5Mkw0MTkuNzM0LDE5MS43MSIgaWQ9IkxfVFhfUkRNQV8wIiBjbGFzcz0iIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgc3R5bGU9IjsiIGRhdGEtZWRnZT0idHJ1ZSIgZGF0YS1ldD0iZWRnZSIgZGF0YS1pZD0iTF9UWF9SRE1BXzAiIGRhdGEtcG9pbnRzPSJXM3NpZUNJNk5EVTFMakl6T0Rnek1EVTJOalF3TmpJMUxDSjVJam80TWpSOUxIc2llQ0k2TkRrMExqTTFPVE0zTlN3aWVTSTZOemczZlN4N0luZ2lPalE1TkM0ek5Ua3pOelVzSW5raU9qY3lNMzBzZXlKNElqbzBPVFF1TXpVNU16YzFMQ0o1SWpvMk5EZDlMSHNpZUNJNk5EazBMak0xT1RNM05Td2llU0k2TlRVNWZTeDdJbmdpT2pRNU5DNHpOVGt6TnpVc0lua2lPalE0TTMwc2V5SjRJam8wT1RRdU16VTVNemMxTENKNUlqbzBNVGw5TEhzaWVDSTZORGswTGpNMU9UTTNOU3dpZVNJNk16VTFmU3g3SW5naU9qUTVOQzR6TlRrek56VXNJbmtpT2pJNU1YMHNleUo0SWpvME9UUXVNelU1TXpjMUxDSjVJam95TWpkOUxIc2llQ0k2TkRFMkxqRXhPREk0TmpFek1qZ3hNalVzSW5raU9qRTVNSDFkIiBtYXJrZXItZW5kPSJ1cmwoI21lcm1haWQtc3ZnX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiLz48cGF0aCBkPSJNMzk1LjAzOSwxMzZMNDAzLjI2NSwxMjkuODMzQzQxMS40OTEsMTIzLjY2Nyw0MjcuOTQzLDExMS4zMzMsNDI4LjQ3Niw5OS40QzQyOS4wMSw4Ny40NjYsNDEzLjYyNSw3NS45MzMsNDA1LjkzMiw3MC4xNjZMMzk4LjI0LDY0LjM5OSIgaWQ9IkxfUkRNQV9GUEdBXzAiIGNsYXNzPSIgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBzdHlsZT0iOyIgZGF0YS1lZGdlPSJ0cnVlIiBkYXRhLWV0PSJlZGdlIiBkYXRhLWlkPSJMX1JETUFfRlBHQV8wIiBkYXRhLXBvaW50cz0iVzNzaWVDSTZNemsxTGpBek9UTTJOelkzTlRjNE1USTFMQ0o1SWpveE16WjlMSHNpZUNJNk5EUTBMak01TkRVek1USTFMQ0o1SWpvNU9YMHNleUo0SWpvek9UVXVNRE01TXpZM05qYzFOemd4TWpVc0lua2lPall5ZlYwPSIgbWFya2VyLWVuZD0idXJsKCNtZXJtYWlkLXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIi8+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWxzIj48ZyBjbGFzcz0iZWRnZUxhYmVsIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNzMuNjUyMzQzNzUsIDk5KSI+PGcgY2xhc3M9ImxhYmVsIiBkYXRhLWlkPSJMX0ZQR0FfUkRNQV8wIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNzUuMTQ4NDM3NSwgLTEyKSI+PGZvcmVpZ25PYmplY3Qgd2lkdGg9IjE1MC4yOTY4NzUiIGhlaWdodD0iMjQiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIGNsYXNzPSJsYWJlbEJrZyIgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwgIj4xLiBTeW5kcm9tZSBwYWNrZXRzPC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIyMy42ODc1LCAyMjcpIj48ZyBjbGFzcz0ibGFiZWwiIGRhdGEtaWQ9IkxfUkRNQV9SWF8wIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTEuMTI1LCAtMTIpIj48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMTAyLjI1IiBoZWlnaHQ9IjI0Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBjbGFzcz0ibGFiZWxCa2ciIHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48c3BhbiBjbGFzcz0iZWRnZUxhYmVsICI+Mi4gUkRNQSB3cml0ZTwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMjMuNjg3NSwgMzU1KSI+PGcgY2xhc3M9ImxhYmVsIiBkYXRhLWlkPSJMX1JYX1JYX0JVRl8wIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtODguMTA5Mzc1LCAtMTIpIj48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMTc2LjIxODc1IiBoZWlnaHQ9IjI0Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBjbGFzcz0ibGFiZWxCa2ciIHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48c3BhbiBjbGFzcz0iZWRnZUxhYmVsICI+My4gV3JpdGUgc2xvdCArIHNldCByeF9mbGFnPC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIyMy42ODc1LCA0ODMpIj48ZyBjbGFzcz0ibGFiZWwiIGRhdGEtaWQ9IkxfUlhfQlVGX0RJU1BBVENIXzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00OC40Njg3NSwgLTEyKSI+PGZvcmVpZ25PYmplY3Qgd2lkdGg9Ijk2LjkzNzUiIGhlaWdodD0iMjQiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIGNsYXNzPSJsYWJlbEJrZyIgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwgIj40LiBQb2xsIHJ4X2ZsYWc8L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgY2xhc3M9ImxhYmVsIiBkYXRhLWlkPSJESVNQQVRDSC1jeWNsaWMtc3BlY2lhbC0xIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSI+PGZvcmVpZ25PYmplY3Qgd2lkdGg9IjAiIGhlaWdodD0iMCI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgY2xhc3M9ImxhYmVsQmtnIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCAiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMDUuODQzNzUsIDc4NykiPjxnIGNsYXNzPSJsYWJlbCIgZGF0YS1pZD0iRElTUEFUQ0gtY3ljbGljLXNwZWNpYWwtbWlkIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOTcuODQzNzUsIC0xMikiPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIxOTUuNjg3NSIgaGVpZ2h0PSIyNCI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgY2xhc3M9ImxhYmVsQmtnIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCAiPjUuIEV4ZWN1dGUgZGVjb2RlciBoYW5kbGVyPC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIGNsYXNzPSJsYWJlbCIgZGF0YS1pZD0iRElTUEFUQ0gtY3ljbGljLXNwZWNpYWwtMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIwIiBoZWlnaHQ9IjAiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIGNsYXNzPSJsYWJlbEJrZyIgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwgIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzU5LjAyMzQzNzUsIDY0NykiPjxnIGNsYXNzPSJsYWJlbCIgZGF0YS1pZD0iTF9ESVNQQVRDSF9UWF9CVUZfMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwMCwgLTI0KSI+PGZvcmVpZ25PYmplY3Qgd2lkdGg9IjIwMCIgaGVpZ2h0PSI0OCI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgY2xhc3M9ImxhYmVsQmtnIiBzdHlsZT0iZGlzcGxheTogdGFibGU7IHdoaXRlLXNwYWNlOiBicmVhay1zcGFjZXM7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsgd2lkdGg6IDIwMHB4OyI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCAiPjYuIFdyaXRlIHJlc3BvbnNlICsgc2V0IHR4X2ZsYWc8L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzU5LjAyMzQzNzUsIDc4NykiPjxnIGNsYXNzPSJsYWJlbCIgZGF0YS1pZD0iTF9UWF9CVUZfVFhfMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQ4LjAzMTI1LCAtMTIpIj48Zm9yZWlnbk9iamVjdCB3aWR0aD0iOTYuMDYyNSIgaGVpZ2h0PSIyNCI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgY2xhc3M9ImxhYmVsQmtnIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCAiPjcuIFBvbGwgdHhfZmxhZzwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0OTQuMzU5Mzc1LCA0ODMpIj48ZyBjbGFzcz0ibGFiZWwiIGRhdGEtaWQ9IkxfVFhfUkRNQV8wIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTAuMjQyMTg3NSwgLTEyKSI+PGZvcmVpZ25PYmplY3Qgd2lkdGg9IjEwMC40ODQzNzUiIGhlaWdodD0iMjQiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIGNsYXNzPSJsYWJlbEJrZyIgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwgIj44LiBSRE1BIHJlYWQ8L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDQ0LjM5NDUzMTI1LCA5OSkiPjxnIGNsYXNzPSJsYWJlbCIgZGF0YS1pZD0iTF9SRE1BX0ZQR0FfMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTc1LjU5Mzc1LCAtMTIpIj48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMTUxLjE4NzUiIGhlaWdodD0iMjQiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIGNsYXNzPSJsYWJlbEJrZyIgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwgIj45LiBDb3JyZWN0aW9uIHBhY2tldHM8L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PC9nPjxnIGNsYXNzPSJub2RlcyI+PGcgY2xhc3M9Im5vZGUgZGVmYXVsdCAgIiBpZD0iZmxvd2NoYXJ0LUZQR0EtMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzU5LjAyMzQzNzUsIDM1KSI+PHJlY3QgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIgc3R5bGU9IiIgeD0iLTExOC45Mjk2ODc1IiB5PSItMjciIHdpZHRoPSIyMzcuODU5Mzc1IiBoZWlnaHQ9IjU0Ii8+PGcgY2xhc3M9ImxhYmVsIiBzdHlsZT0iIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtODguOTI5Njg3NSwgLTEyKSI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIxNzcuODU5Mzc1IiBoZWlnaHQ9IjI0Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCAiPjxwPkZQR0EgLyBRdWFudHVtIENvbnRyb2w8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJub2RlIGRlZmF1bHQgICIgaWQ9ImZsb3djaGFydC1SRE1BLTEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM1OS4wMjM0Mzc1LCAxNjMpIj48cmVjdCBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIiBzdHlsZT0iIiB4PSItOTguMDIzNDM3NSIgeT0iLTI3IiB3aWR0aD0iMTk2LjA0Njg3NSIgaGVpZ2h0PSI1NCIvPjxnIGNsYXNzPSJsYWJlbCIgc3R5bGU9IiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTY4LjAyMzQzNzUsIC0xMikiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMTM2LjA0Njg3NSIgaGVpZ2h0PSIyNCI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwgIj48cD5Db25uZWN0WC03IFJETUE8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJub2RlIGRlZmF1bHQgICIgaWQ9ImZsb3djaGFydC1SWC0zIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMjMuNjg3NSwgMjkxKSI+PHJlY3QgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIgc3R5bGU9IiIgeD0iLTEwMi40Njg3NSIgeT0iLTI3IiB3aWR0aD0iMjA0LjkzNzUiIGhlaWdodD0iNTQiLz48ZyBjbGFzcz0ibGFiZWwiIHN0eWxlPSIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03Mi40Njg3NSwgLTEyKSI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIxNDQuOTM3NSIgaGVpZ2h0PSIyNCI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwgIj48cD5SWCBLZXJuZWwgKEhvbG9saW5rKTwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9Im5vZGUgZGVmYXVsdCAgIiBpZD0iZmxvd2NoYXJ0LVJYX0JVRi01IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMjMuNjg3NSwgNDE5KSI+PHJlY3QgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIgc3R5bGU9IiIgeD0iLTEwMS42NjQwNjI1IiB5PSItMjciIHdpZHRoPSIyMDMuMzI4MTI1IiBoZWlnaHQ9IjU0Ii8+PGcgY2xhc3M9ImxhYmVsIiBzdHlsZT0iIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNzEuNjY0MDYyNSwgLTEyKSI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIxNDMuMzI4MTI1IiBoZWlnaHQ9IjI0Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCAiPjxwPlJYIEJ1ZmZlciArIHJ4X2ZsYWdzPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0ibm9kZSBkZWZhdWx0ICAiIGlkPSJmbG93Y2hhcnQtRElTUEFUQ0gtNyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjIzLjY4NzUsIDU1OSkiPjxyZWN0IGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiIHN0eWxlPSIiIHg9Ii0xMzAiIHk9Ii0zOSIgd2lkdGg9IjI2MCIgaGVpZ2h0PSI3OCIvPjxnIGNsYXNzPSJsYWJlbCIgc3R5bGU9IiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwMCwgLTI0KSI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIyMDAiIGhlaWdodD0iNDgiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiB0YWJsZTsgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlczsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyB3aWR0aDogMjAwcHg7Ij48c3BhbiBjbGFzcz0ibm9kZUxhYmVsICI+PHA+RGlzcGF0Y2ggS2VybmVsIChDVURBLVEgUmVhbHRpbWUpPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0ibm9kZSBkZWZhdWx0ICAiIGlkPSJmbG93Y2hhcnQtVFhfQlVGLTExIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzNTkuMDIzNDM3NSwgNzIzKSI+PHJlY3QgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIgc3R5bGU9IiIgeD0iLTEwMC4zMzU5Mzc1IiB5PSItMjciIHdpZHRoPSIyMDAuNjcxODc1IiBoZWlnaHQ9IjU0Ii8+PGcgY2xhc3M9ImxhYmVsIiBzdHlsZT0iIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNzAuMzM1OTM3NSwgLTEyKSI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIxNDAuNjcxODc1IiBoZWlnaHQ9IjI0Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCAiPjxwPlRYIEJ1ZmZlciArIHR4X2ZsYWdzPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0ibm9kZSBkZWZhdWx0ICAiIGlkPSJmbG93Y2hhcnQtVFgtMTMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQyNi42OTE0MDYyNSwgODUxKSI+PHJlY3QgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIgc3R5bGU9IiIgeD0iLTEwMS41NzgxMjUiIHk9Ii0yNyIgd2lkdGg9IjIwMy4xNTYyNSIgaGVpZ2h0PSI1NCIvPjxnIGNsYXNzPSJsYWJlbCIgc3R5bGU9IiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTcxLjU3ODEyNSwgLTEyKSI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIxNDMuMTU2MjUiIGhlaWdodD0iMjQiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48c3BhbiBjbGFzcz0ibm9kZUxhYmVsICI+PHA+VFggS2VybmVsIChIb2xvbGluayk8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJsYWJlbCBlZGdlTGFiZWwiIGlkPSJESVNQQVRDSC0tLURJU1BBVENILS0tMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA1Ljg0Mzc1LCA3MjMpIj48cmVjdCB3aWR0aD0iMC4xIiBoZWlnaHQ9IjAuMSIvPjxnIGNsYXNzPSJsYWJlbCIgc3R5bGU9IiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMCIgaGVpZ2h0PSIwIj48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAxMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48c3BhbiBjbGFzcz0ibm9kZUxhYmVsICI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJsYWJlbCBlZGdlTGFiZWwiIGlkPSJESVNQQVRDSC0tLURJU1BBVENILS0tMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTQ5LjkzMzU5Mzc1LCA4NTEpIj48cmVjdCB3aWR0aD0iMC4xIiBoZWlnaHQ9IjAuMSIvPjxnIGNsYXNzPSJsYWJlbCIgc3R5bGU9IiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMCIgaGVpZ2h0PSIwIj48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAxMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48c3BhbiBjbGFzcz0ibm9kZUxhYmVsICI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjwvZz48L2c+PC9nPjwvc3ZnPg==" alt="3-kernel architecture" width="553" height="886">

### Data Flow Summary

<!-- markdownlint-disable -->

<table class="data">
  <thead>
    <tr>
      <th>Step</th>
      <th>Component</th>
      <th>Action</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1-2</td>
      <td>FPGA → ConnectX</td>
      <td>Detection event data sent over Ethernet, RDMA writes to GPU memory</td>
    </tr>
    <tr>
      <td>3</td>
      <td>RX Kernel</td>
      <td>Frames detection events into RPC message, sets <code>rx_flags[slot]</code> (see Message completion note)</td>
    </tr>
    <tr>
      <td>4-5</td>
      <td>Dispatch Kernel</td>
      <td>Polls for ready slots, looks up handler by <code>function_id</code>, executes decoder</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Dispatch Kernel</td>
      <td>Writes <code>RPCResponse</code> + correction, sets <code>tx_flags[slot]</code></td>
    </tr>
    <tr>
      <td>7-8</td>
      <td>TX Kernel</td>
      <td>Polls for responses, triggers RDMA send back to FPGA</td>
    </tr>
    <tr>
      <td>9</td>
      <td>ConnectX → FPGA</td>
      <td>Correction delivered to quantum controller</td>
    </tr>
  </tbody>
</table>

<!-- markdownlint-enable -->

### Why 3 Kernels?

1. **Separation of concerns**:
Transport (RX/TX kernels) vs. compute (dispatch) are decoupled
2. **Reusability**:
Same dispatch kernel works with any decoder handler
3. **Testability**:
Dispatch kernel can be tested without Hololink hardware
4. **Flexibility**:
RX/TX kernels can be replaced with different transport mechanisms
5. **Transport independence**:
The protocol works with Hololink, `libibverbs`, or proprietary transports

## What This API Does (In One Paragraph)

The host API wires a dispatcher (GPU kernel or CPU thread) to shared ring buffers.
The transport mechanism (e.g., Hololink RX/TX kernels, `libibverbs` threads, or
proprietary transport) places incoming RPC messages into RX slots and retrieves
responses from TX slots.
The dispatcher polls RX flags (see Message completion note), looks up a
handler by `function_id`, executes it on the GPU, and writes a response into the
same slot. Hololink’s RX/TX kernels handle device I/O; the dispatch kernel sits
in the middle and runs the decoder handler.

## Scope

- C host API in `cudaq_realtime.h`
- RPC messaging protocol (header + payload + response)

## Terms and Components

- **Ring buffer**:
Fixed-size slots holding RPC messages (see Message completion note).
Each slot has an RX flag and a TX flag.
- **RX flag**:
Nonzero means a slot is ready to be processed.
- **TX flag**:
Nonzero means a response is ready to send.
- **Dispatcher**:
Component that processes RPC messages (GPU kernel or CPU thread).
- **Handler**:
Function registered in the function table that processes specific message types.
- **Function table**:
Array of handler function pointers + IDs + schemas.

## Schema Data Structures

Each handler registered in the function table includes a schema that describes
its argument and result types.

### Type Descriptors

```cpp
// Standardized payload type identifiers
typedef enum {
  CUDAQ_TYPE_UINT8           = 0x10,
  CUDAQ_TYPE_INT32           = 0x11,
  CUDAQ_TYPE_INT64           = 0x12,
  CUDAQ_TYPE_FLOAT32         = 0x13,
  CUDAQ_TYPE_FLOAT64         = 0x14,
  CUDAQ_TYPE_ARRAY_UINT8     = 0x20,
  CUDAQ_TYPE_ARRAY_INT32     = 0x21,
  CUDAQ_TYPE_ARRAY_FLOAT32   = 0x22,
  CUDAQ_TYPE_ARRAY_FLOAT64   = 0x23,
  CUDAQ_TYPE_BIT_PACKED      = 0x30   // Bit-packed data (LSB-first)
} cudaq_payload_type_t;

struct cudaq_type_desc_t {
  uint8_t  type_id;       // cudaq_payload_type_t value
  uint8_t  reserved[3];
  uint32_t size_bytes;    // Total size in bytes
  uint32_t num_elements;  // Interpretation depends on type_id
};
```

The `num_elements` field interpretation:

- **Scalar types** (`CUDAQ_TYPE_UINT8`, `CUDAQ_TYPE_INT32`, etc.):
unused, set to 1
- **Array types** (`CUDAQ_TYPE_ARRAY_*`): number of array elements
- **CUDAQ_TYPE_BIT_PACKED**: number of bits (not bytes)

### Handler Schema

```cpp
struct cudaq_handler_schema_t {
  uint8_t  num_args;              // Number of input arguments
  uint8_t  num_results;           // Number of return values
  uint16_t reserved;
  
  cudaq_type_desc_t args[8];      // Argument type descriptors
  cudaq_type_desc_t results[4];   // Result type descriptors
};
```

Limits:

- Maximum 8 arguments per handler
- Maximum 4 results per handler
- Total payload size must fit in slot: `slot_size - sizeof(RPCHeader)`

## RPC Messaging Protocol

Each RX ring buffer slot contains an RPC request. The dispatcher writes the
response to the corresponding TX ring buffer slot.

```text
RX Slot: | RPCHeader | request payload bytes |
TX Slot: | RPCResponse | response payload bytes |
```

Payload encoding details (type system, multi-argument encoding, bit-packing,
and QEC-specific examples) are defined in [cudaq_realtime_message_protocol.md](cudaq_realtime_message_protocol.md).

Magic values (little-endian 32-bit):

- `RPC_MAGIC_REQUEST = 0x43555152` (`'CUQR'`)
- `RPC_MAGIC_RESPONSE = 0x43555153` (`'CUQS'`)

```cpp
// Wire format (byte layout must match dispatch_kernel_launch.h)
struct RPCHeader {
  uint32_t magic;        // RPC_MAGIC_REQUEST
  uint32_t function_id;  // fnv1a_hash("handler_name")
  uint32_t arg_len;      // payload bytes following this header
  uint32_t request_id;   // caller-assigned ID, echoed in the response
};

struct RPCResponse {
  uint32_t magic;        // RPC_MAGIC_RESPONSE
  int32_t  status;       // 0 = success
  uint32_t result_len;   // bytes of response payload
  uint32_t request_id;   // echoed from RPCHeader::request_id
};
```

Both structs are 16 bytes, packed with no padding. See `cudaq_realtime_message_protocol.bs`
for `request_id` semantics.

Payload conventions:

- **Request payload**:
argument data as specified by handler schema.
- **Response payload**:
result data as specified by handler schema.
- **Size limit**:
payload must fit in one slot. `max_payload_bytes = slot_size - sizeof(RPCHeader)`.
- **Multi-argument encoding**:
arguments concatenated in schema order (see message protocol doc).

## Host API Overview

Header: `realtime/include/cudaq/realtime/daemon/dispatcher/cudaq_realtime.h`

## Manager and Dispatcher Topology

The manager is a lightweight owner for one or more dispatchers. Each dispatcher
is configured independently (e.g., `vp_id`, `kernel_type`, `dispatch_mode`) and
can target different workloads.

<!-- markdownlint-disable-next-line -->
<img src="data:image/svg+xml;base64,PHN2ZyBpZD0ibWVybWFpZC1zdmciIHdpZHRoPSIxMDAlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGNsYXNzPSJmbG93Y2hhcnQiIHN0eWxlPSJtYXgtd2lkdGg6IDExMjFweDsiIHZpZXdCb3g9IjAgMCAxMTIxIDU0OCIgcm9sZT0iZ3JhcGhpY3MtZG9jdW1lbnQgZG9jdW1lbnQiIGFyaWEtcm9sZWRlc2NyaXB0aW9uPSJmbG93Y2hhcnQtdjIiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48c3R5bGUgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPkBpbXBvcnQgdXJsKCJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9mb250LWF3ZXNvbWUvNi43LjIvY3NzL2FsbC5taW4uY3NzIik7PC9zdHlsZT48c3R5bGU+I21lcm1haWQtc3Zne2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6MTZweDtmaWxsOiMzMzM7fUBrZXlmcmFtZXMgZWRnZS1hbmltYXRpb24tZnJhbWV7ZnJvbXtzdHJva2UtZGFzaG9mZnNldDowO319QGtleWZyYW1lcyBkYXNoe3Rve3N0cm9rZS1kYXNob2Zmc2V0OjA7fX0jbWVybWFpZC1zdmcgLmVkZ2UtYW5pbWF0aW9uLXNsb3d7c3Ryb2tlLWRhc2hhcnJheTo5LDUhaW1wb3J0YW50O3N0cm9rZS1kYXNob2Zmc2V0OjkwMDthbmltYXRpb246ZGFzaCA1MHMgbGluZWFyIGluZmluaXRlO3N0cm9rZS1saW5lY2FwOnJvdW5kO30jbWVybWFpZC1zdmcgLmVkZ2UtYW5pbWF0aW9uLWZhc3R7c3Ryb2tlLWRhc2hhcnJheTo5LDUhaW1wb3J0YW50O3N0cm9rZS1kYXNob2Zmc2V0OjkwMDthbmltYXRpb246ZGFzaCAyMHMgbGluZWFyIGluZmluaXRlO3N0cm9rZS1saW5lY2FwOnJvdW5kO30jbWVybWFpZC1zdmcgLmVycm9yLWljb257ZmlsbDojNTUyMjIyO30jbWVybWFpZC1zdmcgLmVycm9yLXRleHR7ZmlsbDojNTUyMjIyO3N0cm9rZTojNTUyMjIyO30jbWVybWFpZC1zdmcgLmVkZ2UtdGhpY2tuZXNzLW5vcm1hbHtzdHJva2Utd2lkdGg6MXB4O30jbWVybWFpZC1zdmcgLmVkZ2UtdGhpY2tuZXNzLXRoaWNre3N0cm9rZS13aWR0aDozLjVweDt9I21lcm1haWQtc3ZnIC5lZGdlLXBhdHRlcm4tc29saWR7c3Ryb2tlLWRhc2hhcnJheTowO30jbWVybWFpZC1zdmcgLmVkZ2UtdGhpY2tuZXNzLWludmlzaWJsZXtzdHJva2Utd2lkdGg6MDtmaWxsOm5vbmU7fSNtZXJtYWlkLXN2ZyAuZWRnZS1wYXR0ZXJuLWRhc2hlZHtzdHJva2UtZGFzaGFycmF5OjM7fSNtZXJtYWlkLXN2ZyAuZWRnZS1wYXR0ZXJuLWRvdHRlZHtzdHJva2UtZGFzaGFycmF5OjI7fSNtZXJtYWlkLXN2ZyAubWFya2Vye2ZpbGw6IzMzMzMzMztzdHJva2U6IzMzMzMzMzt9I21lcm1haWQtc3ZnIC5tYXJrZXIuY3Jvc3N7c3Ryb2tlOiMzMzMzMzM7fSNtZXJtYWlkLXN2ZyBzdmd7Zm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxNnB4O30jbWVybWFpZC1zdmcgcHttYXJnaW46MDt9I21lcm1haWQtc3ZnIC5sYWJlbHtmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Y29sb3I6IzMzMzt9I21lcm1haWQtc3ZnIC5jbHVzdGVyLWxhYmVsIHRleHR7ZmlsbDojMzMzO30jbWVybWFpZC1zdmcgLmNsdXN0ZXItbGFiZWwgc3Bhbntjb2xvcjojMzMzO30jbWVybWFpZC1zdmcgLmNsdXN0ZXItbGFiZWwgc3BhbiBwe2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7fSNtZXJtYWlkLXN2ZyAubGFiZWwgdGV4dCwjbWVybWFpZC1zdmcgc3BhbntmaWxsOiMzMzM7Y29sb3I6IzMzMzt9I21lcm1haWQtc3ZnIC5ub2RlIHJlY3QsI21lcm1haWQtc3ZnIC5ub2RlIGNpcmNsZSwjbWVybWFpZC1zdmcgLm5vZGUgZWxsaXBzZSwjbWVybWFpZC1zdmcgLm5vZGUgcG9seWdvbiwjbWVybWFpZC1zdmcgLm5vZGUgcGF0aHtmaWxsOiNFQ0VDRkY7c3Ryb2tlOiM5MzcwREI7c3Ryb2tlLXdpZHRoOjFweDt9I21lcm1haWQtc3ZnIC5yb3VnaC1ub2RlIC5sYWJlbCB0ZXh0LCNtZXJtYWlkLXN2ZyAubm9kZSAubGFiZWwgdGV4dCwjbWVybWFpZC1zdmcgLmltYWdlLXNoYXBlIC5sYWJlbCwjbWVybWFpZC1zdmcgLmljb24tc2hhcGUgLmxhYmVse3RleHQtYW5jaG9yOm1pZGRsZTt9I21lcm1haWQtc3ZnIC5ub2RlIC5rYXRleCBwYXRoe2ZpbGw6IzAwMDtzdHJva2U6IzAwMDtzdHJva2Utd2lkdGg6MXB4O30jbWVybWFpZC1zdmcgLnJvdWdoLW5vZGUgLmxhYmVsLCNtZXJtYWlkLXN2ZyAubm9kZSAubGFiZWwsI21lcm1haWQtc3ZnIC5pbWFnZS1zaGFwZSAubGFiZWwsI21lcm1haWQtc3ZnIC5pY29uLXNoYXBlIC5sYWJlbHt0ZXh0LWFsaWduOmNlbnRlcjt9I21lcm1haWQtc3ZnIC5ub2RlLmNsaWNrYWJsZXtjdXJzb3I6cG9pbnRlcjt9I21lcm1haWQtc3ZnIC5yb290IC5hbmNob3IgcGF0aHtmaWxsOiMzMzMzMzMhaW1wb3J0YW50O3N0cm9rZS13aWR0aDowO3N0cm9rZTojMzMzMzMzO30jbWVybWFpZC1zdmcgLmFycm93aGVhZFBhdGh7ZmlsbDojMzMzMzMzO30jbWVybWFpZC1zdmcgLmVkZ2VQYXRoIC5wYXRoe3N0cm9rZTojMzMzMzMzO3N0cm9rZS13aWR0aDoyLjBweDt9I21lcm1haWQtc3ZnIC5mbG93Y2hhcnQtbGlua3tzdHJva2U6IzMzMzMzMztmaWxsOm5vbmU7fSNtZXJtYWlkLXN2ZyAuZWRnZUxhYmVse2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt0ZXh0LWFsaWduOmNlbnRlcjt9I21lcm1haWQtc3ZnIC5lZGdlTGFiZWwgcHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7fSNtZXJtYWlkLXN2ZyAuZWRnZUxhYmVsIHJlY3R7b3BhY2l0eTowLjU7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO2ZpbGw6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt9I21lcm1haWQtc3ZnIC5sYWJlbEJrZ3tiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLCAyMzIsIDIzMiwgMC41KTt9I21lcm1haWQtc3ZnIC5jbHVzdGVyIHJlY3R7ZmlsbDojZmZmZmRlO3N0cm9rZTojYWFhYTMzO3N0cm9rZS13aWR0aDoxcHg7fSNtZXJtYWlkLXN2ZyAuY2x1c3RlciB0ZXh0e2ZpbGw6IzMzMzt9I21lcm1haWQtc3ZnIC5jbHVzdGVyIHNwYW57Y29sb3I6IzMzMzt9I21lcm1haWQtc3ZnIGRpdi5tZXJtYWlkVG9vbHRpcHtwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmNlbnRlcjttYXgtd2lkdGg6MjAwcHg7cGFkZGluZzoycHg7Zm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxMnB4O2JhY2tncm91bmQ6aHNsKDgwLCAxMDAlLCA5Ni4yNzQ1MDk4MDM5JSk7Ym9yZGVyOjFweCBzb2xpZCAjYWFhYTMzO2JvcmRlci1yYWRpdXM6MnB4O3BvaW50ZXItZXZlbnRzOm5vbmU7ei1pbmRleDoxMDA7fSNtZXJtYWlkLXN2ZyAuZmxvd2NoYXJ0VGl0bGVUZXh0e3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6MThweDtmaWxsOiMzMzM7fSNtZXJtYWlkLXN2ZyByZWN0LnRleHR7ZmlsbDpub25lO3N0cm9rZS13aWR0aDowO30jbWVybWFpZC1zdmcgLmljb24tc2hhcGUsI21lcm1haWQtc3ZnIC5pbWFnZS1zaGFwZXtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7dGV4dC1hbGlnbjpjZW50ZXI7fSNtZXJtYWlkLXN2ZyAuaWNvbi1zaGFwZSBwLCNtZXJtYWlkLXN2ZyAuaW1hZ2Utc2hhcGUgcHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7cGFkZGluZzoycHg7fSNtZXJtYWlkLXN2ZyAuaWNvbi1zaGFwZSByZWN0LCNtZXJtYWlkLXN2ZyAuaW1hZ2Utc2hhcGUgcmVjdHtvcGFjaXR5OjAuNTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7ZmlsbDpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO30jbWVybWFpZC1zdmcgLmxhYmVsLWljb257ZGlzcGxheTppbmxpbmUtYmxvY2s7aGVpZ2h0OjFlbTtvdmVyZmxvdzp2aXNpYmxlO3ZlcnRpY2FsLWFsaWduOi0wLjEyNWVtO30jbWVybWFpZC1zdmcgLm5vZGUgLmxhYmVsLWljb24gcGF0aHtmaWxsOmN1cnJlbnRDb2xvcjtzdHJva2U6cmV2ZXJ0O3N0cm9rZS13aWR0aDpyZXZlcnQ7fSNtZXJtYWlkLXN2ZyA6cm9vdHstLW1lcm1haWQtZm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO308L3N0eWxlPjxnPjxtYXJrZXIgaWQ9Im1lcm1haWQtc3ZnX2Zsb3djaGFydC12Mi1wb2ludEVuZCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQtdjIiIHZpZXdCb3g9IjAgMCAxMCAxMCIgcmVmWD0iNSIgcmVmWT0iNSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXJrZXJXaWR0aD0iOCIgbWFya2VySGVpZ2h0PSI4IiBvcmllbnQ9ImF1dG8iPjxwYXRoIGQ9Ik0gMCAwIEwgMTAgNSBMIDAgMTAgeiIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiLz48L21hcmtlcj48bWFya2VyIGlkPSJtZXJtYWlkLXN2Z19mbG93Y2hhcnQtdjItcG9pbnRTdGFydCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQtdjIiIHZpZXdCb3g9IjAgMCAxMCAxMCIgcmVmWD0iNC41IiByZWZZPSI1IiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hcmtlcldpZHRoPSI4IiBtYXJrZXJIZWlnaHQ9IjgiIG9yaWVudD0iYXV0byI+PHBhdGggZD0iTSAwIDUgTCAxMCAxMCBMIDEwIDAgeiIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiLz48L21hcmtlcj48bWFya2VyIGlkPSJtZXJtYWlkLXN2Z19mbG93Y2hhcnQtdjItY2lyY2xlRW5kIiBjbGFzcz0ibWFya2VyIGZsb3djaGFydC12MiIgdmlld0JveD0iMCAwIDEwIDEwIiByZWZYPSIxMSIgcmVmWT0iNSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXJrZXJXaWR0aD0iMTEiIG1hcmtlckhlaWdodD0iMTEiIG9yaWVudD0iYXV0byI+PGNpcmNsZSBjeD0iNSIgY3k9IjUiIHI9IjUiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7Ii8+PC9tYXJrZXI+PG1hcmtlciBpZD0ibWVybWFpZC1zdmdfZmxvd2NoYXJ0LXYyLWNpcmNsZVN0YXJ0IiBjbGFzcz0ibWFya2VyIGZsb3djaGFydC12MiIgdmlld0JveD0iMCAwIDEwIDEwIiByZWZYPSItMSIgcmVmWT0iNSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiBtYXJrZXJXaWR0aD0iMTEiIG1hcmtlckhlaWdodD0iMTEiIG9yaWVudD0iYXV0byI+PGNpcmNsZSBjeD0iNSIgY3k9IjUiIHI9IjUiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7Ii8+PC9tYXJrZXI+PG1hcmtlciBpZD0ibWVybWFpZC1zdmdfZmxvd2NoYXJ0LXYyLWNyb3NzRW5kIiBjbGFzcz0ibWFya2VyIGNyb3NzIGZsb3djaGFydC12MiIgdmlld0JveD0iMCAwIDExIDExIiByZWZYPSIxMiIgcmVmWT0iNS4yIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VySGVpZ2h0PSIxMSIgb3JpZW50PSJhdXRvIj48cGF0aCBkPSJNIDEsMSBsIDksOSBNIDEwLDEgbCAtOSw5IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAyOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIvPjwvbWFya2VyPjxtYXJrZXIgaWQ9Im1lcm1haWQtc3ZnX2Zsb3djaGFydC12Mi1jcm9zc1N0YXJ0IiBjbGFzcz0ibWFya2VyIGNyb3NzIGZsb3djaGFydC12MiIgdmlld0JveD0iMCAwIDExIDExIiByZWZYPSItMSIgcmVmWT0iNS4yIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VySGVpZ2h0PSIxMSIgb3JpZW50PSJhdXRvIj48cGF0aCBkPSJNIDEsMSBsIDksOSBNIDEwLDEgbCAtOSw5IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAyOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIvPjwvbWFya2VyPjxnIGNsYXNzPSJyb290Ij48ZyBjbGFzcz0iY2x1c3RlcnMiLz48ZyBjbGFzcz0iZWRnZVBhdGhzIj48cGF0aCBkPSJNNDMwLjUsODQuNjYyTDM4OCw5My4wNTJDMzQ1LjUsMTAxLjQ0MiwyNjAuNSwxMTguMjIxLDIxOCwxMzAuMTFDMTc1LjUsMTQyLDE3NS41LDE0OSwxNzUuNSwxNTIuNUwxNzUuNSwxNTYiIGlkPSJMX01HUl9EMF8wIiBjbGFzcz0iIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgc3R5bGU9IjsiIGRhdGEtZWRnZT0idHJ1ZSIgZGF0YS1ldD0iZWRnZSIgZGF0YS1pZD0iTF9NR1JfRDBfMCIgZGF0YS1wb2ludHM9Ilczc2llQ0k2TkRNd0xqVXNJbmtpT2pnMExqWTJNak16TnpZMk1qTXpOelkyZlN4N0luZ2lPakUzTlM0MUxDSjVJam94TXpWOUxIc2llQ0k2TVRjMUxqVXNJbmtpT2pFMk1IMWQiIG1hcmtlci1lbmQ9InVybCgjbWVybWFpZC1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIvPjxwYXRoIGQ9Ik01NjAuNSwxMTBMNTYwLjUsMTE0LjE2N0M1NjAuNSwxMTguMzMzLDU2MC41LDEyNi42NjcsNTYwLjUsMTM0LjMzM0M1NjAuNSwxNDIsNTYwLjUsMTQ5LDU2MC41LDE1Mi41TDU2MC41LDE1NiIgaWQ9IkxfTUdSX0QxXzAiIGNsYXNzPSIgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBzdHlsZT0iOyIgZGF0YS1lZGdlPSJ0cnVlIiBkYXRhLWV0PSJlZGdlIiBkYXRhLWlkPSJMX01HUl9EMV8wIiBkYXRhLXBvaW50cz0iVzNzaWVDSTZOVFl3TGpVc0lua2lPakV4TUgwc2V5SjRJam8xTmpBdU5Td2llU0k2TVRNMWZTeDdJbmdpT2pVMk1DNDFMQ0o1SWpveE5qQjlYUT09IiBtYXJrZXItZW5kPSJ1cmwoI21lcm1haWQtc3ZnX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiLz48cGF0aCBkPSJNNjkwLjUsODQuNjYyTDczMyw5My4wNTJDNzc1LjUsMTAxLjQ0Miw4NjAuNSwxMTguMjIxLDkwMywxMzAuMTFDOTQ1LjUsMTQyLDk0NS41LDE0OSw5NDUuNSwxNTIuNUw5NDUuNSwxNTYiIGlkPSJMX01HUl9ETl8wIiBjbGFzcz0iIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgc3R5bGU9IjsiIGRhdGEtZWRnZT0idHJ1ZSIgZGF0YS1ldD0iZWRnZSIgZGF0YS1pZD0iTF9NR1JfRE5fMCIgZGF0YS1wb2ludHM9Ilczc2llQ0k2Tmprd0xqVXNJbmtpT2pnMExqWTJNak16TnpZMk1qTXpOelkyZlN4N0luZ2lPamswTlM0MUxDSjVJam94TXpWOUxIc2llQ0k2T1RRMUxqVXNJbmtpT2pFMk1IMWQiIG1hcmtlci1lbmQ9InVybCgjbWVybWFpZC1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIvPjxwYXRoIGQ9Ik0xNzUuNSwyMTRMMTc1LjUsMjE4LjE2N0MxNzUuNSwyMjIuMzMzLDE3NS41LDIzMC42NjcsMTc1LjUsMjM4LjMzM0MxNzUuNSwyNDYsMTc1LjUsMjUzLDE3NS41LDI1Ni41TDE3NS41LDI2MCIgaWQ9IkxfRDBfRDBfQ0ZHXzAiIGNsYXNzPSIgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBzdHlsZT0iOyIgZGF0YS1lZGdlPSJ0cnVlIiBkYXRhLWV0PSJlZGdlIiBkYXRhLWlkPSJMX0QwX0QwX0NGR18wIiBkYXRhLXBvaW50cz0iVzNzaWVDSTZNVGMxTGpVc0lua2lPakl4Tkgwc2V5SjRJam94TnpVdU5Td2llU0k2TWpNNWZTeDdJbmdpT2pFM05TNDFMQ0o1SWpveU5qUjlYUT09IiBtYXJrZXItZW5kPSJ1cmwoI21lcm1haWQtc3ZnX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiLz48cGF0aCBkPSJNNTYwLjUsMjE0TDU2MC41LDIxOC4xNjdDNTYwLjUsMjIyLjMzMyw1NjAuNSwyMzAuNjY3LDU2MC41LDIzOC4zMzNDNTYwLjUsMjQ2LDU2MC41LDI1Myw1NjAuNSwyNTYuNUw1NjAuNSwyNjAiIGlkPSJMX0QxX0QxX0NGR18wIiBjbGFzcz0iIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgc3R5bGU9IjsiIGRhdGEtZWRnZT0idHJ1ZSIgZGF0YS1ldD0iZWRnZSIgZGF0YS1pZD0iTF9EMV9EMV9DRkdfMCIgZGF0YS1wb2ludHM9Ilczc2llQ0k2TlRZd0xqVXNJbmtpT2pJeE5IMHNleUo0SWpvMU5qQXVOU3dpZVNJNk1qTTVmU3g3SW5naU9qVTJNQzQxTENKNUlqb3lOalI5WFE9PSIgbWFya2VyLWVuZD0idXJsKCNtZXJtYWlkLXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIi8+PHBhdGggZD0iTTk0NS41LDIxNEw5NDUuNSwyMTguMTY3Qzk0NS41LDIyMi4zMzMsOTQ1LjUsMjMwLjY2Nyw5NDUuNSwyMzguMzMzQzk0NS41LDI0Niw5NDUuNSwyNTMsOTQ1LjUsMjU2LjVMOTQ1LjUsMjYwIiBpZD0iTF9ETl9ETl9DRkdfMCIgY2xhc3M9IiBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIHN0eWxlPSI7IiBkYXRhLWVkZ2U9InRydWUiIGRhdGEtZXQ9ImVkZ2UiIGRhdGEtaWQ9IkxfRE5fRE5fQ0ZHXzAiIGRhdGEtcG9pbnRzPSJXM3NpZUNJNk9UUTFMalVzSW5raU9qSXhOSDBzZXlKNElqbzVORFV1TlN3aWVTSTZNak01ZlN4N0luZ2lPamswTlM0MUxDSjVJam95TmpSOVhRPT0iIG1hcmtlci1lbmQ9InVybCgjbWVybWFpZC1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIvPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVscyI+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgY2xhc3M9ImxhYmVsIiBkYXRhLWlkPSJMX01HUl9EMF8wIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSI+PGZvcmVpZ25PYmplY3Qgd2lkdGg9IjAiIGhlaWdodD0iMCI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgY2xhc3M9ImxhYmVsQmtnIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCAiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyBjbGFzcz0ibGFiZWwiIGRhdGEtaWQ9IkxfTUdSX0QxXzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIj48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMCIgaGVpZ2h0PSIwIj48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBjbGFzcz0ibGFiZWxCa2ciIHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48c3BhbiBjbGFzcz0iZWRnZUxhYmVsICI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIGNsYXNzPSJsYWJlbCIgZGF0YS1pZD0iTF9NR1JfRE5fMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIwIiBoZWlnaHQ9IjAiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIGNsYXNzPSJsYWJlbEJrZyIgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwgIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgY2xhc3M9ImxhYmVsIiBkYXRhLWlkPSJMX0QwX0QwX0NGR18wIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSI+PGZvcmVpZ25PYmplY3Qgd2lkdGg9IjAiIGhlaWdodD0iMCI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgY2xhc3M9ImxhYmVsQmtnIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCAiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyBjbGFzcz0ibGFiZWwiIGRhdGEtaWQ9IkxfRDFfRDFfQ0ZHXzAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIj48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMCIgaGVpZ2h0PSIwIj48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBjbGFzcz0ibGFiZWxCa2ciIHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48c3BhbiBjbGFzcz0iZWRnZUxhYmVsICI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIGNsYXNzPSJsYWJlbCIgZGF0YS1pZD0iTF9ETl9ETl9DRkdfMCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIwIiBoZWlnaHQ9IjAiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIGNsYXNzPSJsYWJlbEJrZyIgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwgIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PC9nPjxnIGNsYXNzPSJub2RlcyI+PGcgY2xhc3M9InJvb3QiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDc3MCwgMjU2KSI+PGcgY2xhc3M9ImNsdXN0ZXJzIj48ZyBjbGFzcz0iY2x1c3RlciAiIGlkPSJETl9DRkciIGRhdGEtbG9vaz0iY2xhc3NpYyI+PHJlY3Qgc3R5bGU9IiIgeD0iOCIgeT0iOCIgd2lkdGg9IjMzNSIgaGVpZ2h0PSIyNzYiLz48ZyBjbGFzcz0iY2x1c3Rlci1sYWJlbCAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDk4LjU3ODEyNSwgOCkiPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIxNTMuODQzNzUiIGhlaWdodD0iMjQiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48c3BhbiBjbGFzcz0ibm9kZUxhYmVsICI+PHA+RGlzcGF0Y2hlciBOLTEgY29uZmlnPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VQYXRocyIvPjxnIGNsYXNzPSJlZGdlTGFiZWxzIi8+PGcgY2xhc3M9Im5vZGVzIj48ZyBjbGFzcz0ibm9kZSBkZWZhdWx0ICAiIGlkPSJmbG93Y2hhcnQtRE5BLTExIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNzUuNSwgODIpIj48cmVjdCBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIiBzdHlsZT0iIiB4PSItMTMwIiB5PSItMzkiIHdpZHRoPSIyNjAiIGhlaWdodD0iNzgiLz48ZyBjbGFzcz0ibGFiZWwiIHN0eWxlPSIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDAsIC0yNCkiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjQ4Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGU7IHdoaXRlLXNwYWNlOiBicmVhay1zcGFjZXM7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsgd2lkdGg6IDIwMHB4OyI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCAiPjxwPktlcm5lbDogQ29vcGVyYXRpdmUgb3IgUmVndWxhcjwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9Im5vZGUgZGVmYXVsdCAgIiBpZD0iZmxvd2NoYXJ0LUROQi0xMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTc1LjUsIDIxMCkiPjxyZWN0IGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiIHN0eWxlPSIiIHg9Ii0xMzAiIHk9Ii0zOSIgd2lkdGg9IjI2MCIgaGVpZ2h0PSI3OCIvPjxnIGNsYXNzPSJsYWJlbCIgc3R5bGU9IiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEwMCwgLTI0KSI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIyMDAiIGhlaWdodD0iNDgiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiB0YWJsZTsgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlczsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyB3aWR0aDogMjAwcHg7Ij48c3BhbiBjbGFzcz0ibm9kZUxhYmVsICI+PHA+RGlzcGF0Y2g6IERldmljZUNhbGwgb3IgR3JhcGhMYXVuY2g8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjwvZz48L2c+PGcgY2xhc3M9InJvb3QiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM4NSwgMjU2KSI+PGcgY2xhc3M9ImNsdXN0ZXJzIj48ZyBjbGFzcz0iY2x1c3RlciAiIGlkPSJEMV9DRkciIGRhdGEtbG9vaz0iY2xhc3NpYyI+PHJlY3Qgc3R5bGU9IiIgeD0iOCIgeT0iOCIgd2lkdGg9IjMzNSIgaGVpZ2h0PSIyNzYiLz48ZyBjbGFzcz0iY2x1c3Rlci1sYWJlbCAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwNy4wMTU2MjUsIDgpIj48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMTM2Ljk2ODc1IiBoZWlnaHQ9IjI0Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCAiPjxwPkRpc3BhdGNoZXIgMSBjb25maWc8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZVBhdGhzIi8+PGcgY2xhc3M9ImVkZ2VMYWJlbHMiLz48ZyBjbGFzcz0ibm9kZXMiPjxnIGNsYXNzPSJub2RlIGRlZmF1bHQgICIgaWQ9ImZsb3djaGFydC1EMUEtOSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTc1LjUsIDgyKSI+PHJlY3QgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIgc3R5bGU9IiIgeD0iLTEzMCIgeT0iLTM5IiB3aWR0aD0iMjYwIiBoZWlnaHQ9Ijc4Ii8+PGcgY2xhc3M9ImxhYmVsIiBzdHlsZT0iIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTAwLCAtMjQpIj48cmVjdC8+PGZvcmVpZ25PYmplY3Qgd2lkdGg9IjIwMCIgaGVpZ2h0PSI0OCI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IHRhYmxlOyB3aGl0ZS1zcGFjZTogYnJlYWstc3BhY2VzOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IHdpZHRoOiAyMDBweDsiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwgIj48cD5LZXJuZWw6IENvb3BlcmF0aXZlIG9yIFJlZ3VsYXI8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJub2RlIGRlZmF1bHQgICIgaWQ9ImZsb3djaGFydC1EMUItMTAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE3NS41LCAyMTApIj48cmVjdCBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIiBzdHlsZT0iIiB4PSItMTMwIiB5PSItMzkiIHdpZHRoPSIyNjAiIGhlaWdodD0iNzgiLz48ZyBjbGFzcz0ibGFiZWwiIHN0eWxlPSIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDAsIC0yNCkiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjQ4Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGU7IHdoaXRlLXNwYWNlOiBicmVhay1zcGFjZXM7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsgd2lkdGg6IDIwMHB4OyI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCAiPjxwPkRpc3BhdGNoOiBEZXZpY2VDYWxsIG9yIEdyYXBoTGF1bmNoPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48L2c+PC9nPjxnIGNsYXNzPSJyb290IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAyNTYpIj48ZyBjbGFzcz0iY2x1c3RlcnMiPjxnIGNsYXNzPSJjbHVzdGVyICIgaWQ9IkQwX0NGRyIgZGF0YS1sb29rPSJjbGFzc2ljIj48cmVjdCBzdHlsZT0iIiB4PSI4IiB5PSI4IiB3aWR0aD0iMzM1IiBoZWlnaHQ9IjI3NiIvPjxnIGNsYXNzPSJjbHVzdGVyLWxhYmVsICIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA3LjAxNTYyNSwgOCkiPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIxMzYuOTY4NzUiIGhlaWdodD0iMjQiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48c3BhbiBjbGFzcz0ibm9kZUxhYmVsICI+PHA+RGlzcGF0Y2hlciAwIGNvbmZpZzwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PC9nPjxnIGNsYXNzPSJlZGdlUGF0aHMiLz48ZyBjbGFzcz0iZWRnZUxhYmVscyIvPjxnIGNsYXNzPSJub2RlcyI+PGcgY2xhc3M9Im5vZGUgZGVmYXVsdCAgIiBpZD0iZmxvd2NoYXJ0LUQwQS03IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNzUuNSwgODIpIj48cmVjdCBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIiBzdHlsZT0iIiB4PSItMTMwIiB5PSItMzkiIHdpZHRoPSIyNjAiIGhlaWdodD0iNzgiLz48ZyBjbGFzcz0ibGFiZWwiIHN0eWxlPSIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDAsIC0yNCkiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjQ4Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGU7IHdoaXRlLXNwYWNlOiBicmVhay1zcGFjZXM7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsgd2lkdGg6IDIwMHB4OyI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCAiPjxwPktlcm5lbDogQ29vcGVyYXRpdmUgb3IgUmVndWxhcjwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9Im5vZGUgZGVmYXVsdCAgIiBpZD0iZmxvd2NoYXJ0LUQwQi04IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNzUuNSwgMjEwKSI+PHJlY3QgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIgc3R5bGU9IiIgeD0iLTEzMCIgeT0iLTM5IiB3aWR0aD0iMjYwIiBoZWlnaHQ9Ijc4Ii8+PGcgY2xhc3M9ImxhYmVsIiBzdHlsZT0iIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTAwLCAtMjQpIj48cmVjdC8+PGZvcmVpZ25PYmplY3Qgd2lkdGg9IjIwMCIgaGVpZ2h0PSI0OCI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IHRhYmxlOyB3aGl0ZS1zcGFjZTogYnJlYWstc3BhY2VzOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IHdpZHRoOiAyMDBweDsiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwgIj48cD5EaXNwYXRjaDogRGV2aWNlQ2FsbCBvciBHcmFwaExhdW5jaDwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PC9nPjwvZz48ZyBjbGFzcz0ibm9kZSBkZWZhdWx0ICAiIGlkPSJmbG93Y2hhcnQtTUdSLTAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU2MC41LCA1OSkiPjxyZWN0IGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiIHN0eWxlPSIiIHg9Ii0xMzAiIHk9Ii01MSIgd2lkdGg9IjI2MCIgaGVpZ2h0PSIxMDIiLz48ZyBjbGFzcz0ibGFiZWwiIHN0eWxlPSIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDAsIC0zNikiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjcyIj48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGU7IHdoaXRlLXNwYWNlOiBicmVhay1zcGFjZXM7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsgd2lkdGg6IDIwMHB4OyI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCAiPjxwPkRpc3BhdGNoZXIgTWFuYWdlcjxiciAvPkNyZWF0ZXMgYW5kIG93bnMgZGlzcGF0Y2hlcnM8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJub2RlIGRlZmF1bHQgICIgaWQ9ImZsb3djaGFydC1EMC0yIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNzUuNSwgMTg3KSI+PHJlY3QgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIgc3R5bGU9IiIgeD0iLTk3LjU4NTkzNzUiIHk9Ii0yNyIgd2lkdGg9IjE5NS4xNzE4NzUiIGhlaWdodD0iNTQiLz48ZyBjbGFzcz0ibGFiZWwiIHN0eWxlPSIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02Ny41ODU5Mzc1LCAtMTIpIj48cmVjdC8+PGZvcmVpZ25PYmplY3Qgd2lkdGg9IjEzNS4xNzE4NzUiIGhlaWdodD0iMjQiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48c3BhbiBjbGFzcz0ibm9kZUxhYmVsICI+PHA+RGlzcGF0Y2hlciAwIChWUDApPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0ibm9kZSBkZWZhdWx0ICAiIGlkPSJmbG93Y2hhcnQtRDEtNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTYwLjUsIDE4NykiPjxyZWN0IGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiIHN0eWxlPSIiIHg9Ii05Ny41ODU5Mzc1IiB5PSItMjciIHdpZHRoPSIxOTUuMTcxODc1IiBoZWlnaHQ9IjU0Ii8+PGcgY2xhc3M9ImxhYmVsIiBzdHlsZT0iIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNjcuNTg1OTM3NSwgLTEyKSI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IHdpZHRoPSIxMzUuMTcxODc1IiBoZWlnaHQ9IjI0Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCAiPjxwPkRpc3BhdGNoZXIgMSAoVlAxKTwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9Im5vZGUgZGVmYXVsdCAgIiBpZD0iZmxvd2NoYXJ0LUROLTYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDk0NS41LCAxODcpIj48cmVjdCBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIiBzdHlsZT0iIiB4PSItMTE0LjQ2ODc1IiB5PSItMjciIHdpZHRoPSIyMjguOTM3NSIgaGVpZ2h0PSI1NCIvPjxnIGNsYXNzPSJsYWJlbCIgc3R5bGU9IiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg0LjQ2ODc1LCAtMTIpIj48cmVjdC8+PGZvcmVpZ25PYmplY3Qgd2lkdGg9IjE2OC45Mzc1IiBoZWlnaHQ9IjI0Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCAiPjxwPkRpc3BhdGNoZXIgTi0xIChWUE4tMSk8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjwvZz48L2c+PC9nPjwvc3ZnPg==" alt="Manager and dispatcher topology" width="1121" height="548">

## Host API Functions
<!-- markdownlint-disable MD033 -->

Function usage:

<strong><code>cudaq_dispatch_manager_create</code></strong> creates
the top-level manager that owns dispatchers.

Parameters:

- `out_mgr`: receives the created manager handle.

Call this once near program startup and keep the manager alive for the
lifetime of the dispatch subsystem.

<strong><code>cudaq_dispatch_manager_destroy</code></strong>
releases the manager and any internal resources.

Parameters:

- `mgr`: manager handle to destroy.

Call this after all dispatchers have been destroyed and the program is
shutting down.

<strong><code>cudaq_dispatcher_create</code></strong> allocates a
dispatcher instance and validates the configuration.

Parameters:

- `mgr`: owning manager.
- `config`: filled `cudaq_dispatcher_config_t` with:
  - `device_id` (default 0): selects the CUDA device for the dispatcher
  - `num_blocks` (default 1)
  - `threads_per_block` (default 32)
  - `num_slots` (required)
  - `slot_size` (required)
  - `vp_id` (default 0): tags a dispatcher to a transport channel.
  Queue pair selection and NIC port/IP binding are configured
  in Hololink, not in this API.
  - `kernel_type` (default `CUDAQ_KERNEL_REGULAR`)
    - `CUDAQ_KERNEL_REGULAR`: standard kernel launch
    - `CUDAQ_KERNEL_COOPERATIVE`: cooperative launch (`grid.sync()` capable)
  - `dispatch_mode` (default `CUDAQ_DISPATCH_DEVICE_CALL`)
    - `CUDAQ_DISPATCH_DEVICE_CALL`: direct `__device__` handler call (lowest latency)
    - `CUDAQ_DISPATCH_GRAPH_LAUNCH`: CUDA graph launch from device code
    (requires `sm_90+`, Hopper or later GPUs)
- `out_dispatcher`: receives the created dispatcher handle.

Call this before wiring ring buffers, function tables, or control state.

<strong><code>cudaq_dispatcher_destroy</code></strong> releases a dispatcher
after it has been stopped.

Parameters:

- `dispatcher`: dispatcher handle to destroy.

Call this when the dispatcher is no longer needed.

<strong><code>cudaq_dispatcher_set_ringbuffer</code></strong> provides
the RX/TX flag and data pointers the dispatch kernel will poll
and use for request/response slots.

Parameters:

- `dispatcher`: dispatcher handle.
- `ringbuffer`: `cudaq_ringbuffer_t` with:
  - `rx_flags`: device-visible pointer to RX flags.
  - `tx_flags`: device-visible pointer to TX flags.
  - `rx_data`: device-visible pointer to RX slot data (request payloads).
  - `tx_data`: device-visible pointer to TX slot data (response payloads).
  - `rx_stride_sz`: size in bytes of each RX slot.
  - `tx_stride_sz`: size in bytes of each TX slot.

Call this before `cudaq_dispatcher_start`, after allocating mapped host memory
or device memory for the ring buffers.

<strong><code>cudaq_dispatcher_set_function_table</code></strong> supplies
the function table containing handler pointers, IDs, and schemas.

Parameters:

- `dispatcher`: dispatcher handle.
- `table`: `cudaq_function_table_t` with:
  - `entries`: device pointer to array of `cudaq_function_entry_t`.
  - `count`: number of entries in the table.

```cpp
// Unified function table entry with schema
struct cudaq_function_entry_t {
  union {
    void*           device_fn_ptr;   // for CUDAQ_DISPATCH_DEVICE_CALL
    cudaGraphExec_t graph_exec;      // for CUDAQ_DISPATCH_GRAPH_LAUNCH
  } handler;
  
  uint32_t                function_id;
  uint8_t                 dispatch_mode;   // Per-handler dispatch mode
  uint8_t                 reserved[3];
  
  cudaq_handler_schema_t  schema;          // Handler interface schema
};

struct cudaq_function_table_t {
  cudaq_function_entry_t* entries;   // Device pointer to entry array
  uint32_t                count;     // Number of entries
};
```

Call this after initializing the device-side function table entries.
Each entry contains a handler pointer (or graph), function_id, dispatch mode,
and schema describing the handler's interface.

Function ID semantics:

- `function_id` is the 32-bit **`FNV-1a` hash** of the handler name string.
- The handler name is the string you hash when populating entries;
there is no separate runtime registration call.
- If no entry matches, the dispatcher clears the slot without a response.
- Suggested: use stable, human-readable handler names (e.g., `"mock_decode"`).

<strong><code>cudaq_dispatcher_set_control</code></strong> supplies
the shutdown flag and stats buffer the dispatch kernel uses
for termination and bookkeeping.

Parameters:

- `dispatcher`: dispatcher handle.
- `shutdown_flag`: device-visible flag used to signal shutdown.
- `stats`: device-visible stats buffer.

Call this before starting the dispatcher; both buffers must remain valid for
the dispatcher’s lifetime.

<strong><code>cudaq_dispatcher_set_launch_fn</code></strong> provides
the host-side launch wrapper that invokes the dispatch kernel
with the correct grid/block dimensions.

Parameters:

- `dispatcher`: dispatcher handle.
- `launch_fn`: host launch function pointer.

Call this once during setup. Typically you pass one of the provided launch functions:

- `cudaq_launch_dispatch_kernel_regular` - for `CUDAQ_KERNEL_REGULAR` mode
- `cudaq_launch_dispatch_kernel_cooperative` - for `CUDAQ_KERNEL_COOPERATIVE` mode

<strong><code>cudaq_dispatcher_start</code></strong> launches
the persistent dispatch kernel and begins processing slots.

Parameters:

- `dispatcher`: dispatcher handle.

Call this only after ring buffers, function table, control buffers, and launch
function are set.

<strong><code>cudaq_dispatcher_stop</code></strong> signals
the dispatch kernel to exit and waits for it to shut down.

Parameters:

- `dispatcher`: dispatcher handle.

Call this during tear-down before destroying the dispatcher.

<strong><code>cudaq_dispatcher_get_processed</code></strong> reads
the processed‑packet counter from the stats buffer
to support debugging or throughput tracking.

Parameters:

- `dispatcher`: dispatcher handle.
- `out_packets`: receives the processed packet count.

### Occupancy Query and Eager Module Loading

Before calling `cudaq_dispatcher_start`, call the appropriate occupancy query
to force eager loading of the dispatch kernel module. This avoids lazy-load
deadlocks when the dispatch kernel and transport kernels (e.g., Hololink RX/TX)
run as persistent kernels.

<strong><code>cudaq_dispatch_kernel_query_occupancy</code></strong> returns the
maximum number of active blocks per multiprocessor for the **regular** dispatch
kernel.

Parameters:

- `out_blocks`: receives the max blocks per SM (or 0 on error).
- `threads_per_block`: block size used for the occupancy calculation.

Returns `cudaSuccess` on success. Call this when `kernel_type` is
`CUDAQ_KERNEL_REGULAR`.

<strong><code>cudaq_dispatch_kernel_cooperative_query_occupancy</code></strong>
returns the maximum number of active blocks per multiprocessor for the
**cooperative** dispatch kernel.

Parameters:

- `out_blocks`: receives the max blocks per SM (or 0 on error).
- `threads_per_block`: block size used for the occupancy calculation
(e.g., 128 for cooperative decoders).

Returns `cudaSuccess` on success. Call this when `kernel_type` is
`CUDAQ_KERNEL_COOPERATIVE`. Use the same `threads_per_block` value that will
be passed to the dispatcher configuration and launch function.

Call the occupancy function that matches the dispatcher's `kernel_type` once
before `cudaq_dispatcher_start`; the result can be used to size the dispatch
grid (e.g., to reserve `SM`'s for transport kernels).

Lifetime/ownership:

- All resources are assumed to live for the program lifetime.
- The API does not take ownership of host-allocated memory.

Threading:

- Single-threaded host usage; create/wire/start/stop from one thread.

Error handling:

- All calls return `cudaq_status_t`.
- `CUDAQ_ERR_INVALID_ARG` for missing pointers or invalid configuration.
- `CUDAQ_ERR_CUDA` for CUDA API failures during start/stop.

### Graph-Based Dispatch Functions

The following functions are only available when using
`CUDAQ_DISPATCH_GRAPH_LAUNCH` mode with `sm_90+` GPUs:

<strong><code>cudaq_create_dispatch_graph_regular</code></strong> creates
a graph-based dispatch context that enables device-side graph launching.

Parameters:

- `rx_flags`: device-visible pointer to RX ring buffer flags
- `tx_flags`: device-visible pointer to TX ring buffer flags
- `rx_data`: device-visible pointer to RX slot data (request payloads)
- `tx_data`: device-visible pointer to TX slot data (response payloads)
- `rx_stride_sz`: size in bytes of each RX slot
- `tx_stride_sz`: size in bytes of each TX slot
- `function_table`: device pointer to function table entries
- `func_count`: number of function table entries
- `graph_io_ctx`: device pointer to a `GraphIOContext` struct for graph buffer communication
- `shutdown_flag`: device-visible shutdown flag
- `stats`: device-visible stats buffer
- `num_slots`: number of ring buffer slots
- `num_blocks`: grid size for dispatch kernel
- `threads_per_block`: block size for dispatch kernel
- `stream`: CUDA stream for graph operations
- `out_context`: receives the created graph context handle

Returns `cudaSuccess` on success, or CUDA error code on failure.

This function creates a graph containing the dispatch kernel, instantiates it
with `cudaGraphInstantiateFlagDeviceLaunch`, and uploads it to the device.
The resulting graph context enables device-side `cudaGraphLaunch()` calls
from within handlers.

<strong><code>cudaq_launch_dispatch_graph</code></strong> launches
the dispatch graph to begin processing RPC messages.

Parameters:

- `context`: graph context handle from `cudaq_create_dispatch_graph_regular`
- `stream`: CUDA stream for graph launch

Returns `cudaSuccess` on success, or CUDA error code on failure.

Call this to start the persistent dispatch kernel. The kernel will continue
running until the shutdown flag is set.

<strong><code>cudaq_destroy_dispatch_graph</code></strong> destroys
the graph context and releases all associated resources.

Parameters:

- `context`: graph context handle to destroy

Returns `cudaSuccess` on success, or CUDA error code on failure.

Call this after the dispatch kernel has exited (shutdown flag was set)
to clean up graph resources.

### Kernel Launch Helper Functions

The following helper functions are provided for use with `cudaq_dispatcher_set_launch_fn()`:

<strong><code>cudaq_launch_dispatch_kernel_regular</code></strong> launches
the dispatch kernel in regular (non-cooperative) mode.

Parameters:

- `rx_flags`: device-visible pointer to RX ring buffer flags
- `tx_flags`: device-visible pointer to TX ring buffer flags
- `rx_data`: device-visible pointer to RX slot data (request payloads)
- `tx_data`: device-visible pointer to TX slot data (response payloads)
- `rx_stride_sz`: size in bytes of each RX slot
- `tx_stride_sz`: size in bytes of each TX slot
- `function_table`: device pointer to function table entries
- `func_count`: number of function table entries
- `shutdown_flag`: device-visible shutdown flag
- `stats`: device-visible stats buffer
- `num_slots`: number of ring buffer slots
- `num_blocks`: grid size for dispatch kernel
- `threads_per_block`: block size for dispatch kernel
- `stream`: CUDA stream for kernel launch

Use this when `kernel_type` is set to `CUDAQ_KERNEL_REGULAR` in the dispatcher configuration.

<strong><code>cudaq_launch_dispatch_kernel_cooperative</code></strong>
launches the dispatch kernel in cooperative mode.

Parameters: Same as `cudaq_launch_dispatch_kernel_regular`.

Use this when `kernel_type` is set to `CUDAQ_KERNEL_COOPERATIVE`
in the dispatcher configuration.
This enables the dispatch kernel and handlers to use grid-wide synchronization
via `cooperative_groups::this_grid().sync()`.

## Memory Layout and Ring Buffer Wiring

Each slot is a fixed-size byte region:

```text
| RPCHeader | payload bytes (arg_len) | unused padding (slot_size - header - payload) |
```

Unused padding is the remaining bytes in the fixed-size slot after the header
and payload.

Flags (both are `uint64_t` arrays of slot flags):

- `rx_flags[slot]` is set by the producer to a non-zero value when a slot is ready.
- `tx_flags[slot]` is set by the dispatch kernel to a non-zero value
when the response is ready.

Message completion note:
An RPC message may be delivered as multiple RDMA writes into a single slot.
Completion is signaled only after the final write (often an RDMA write with
immediate) sets `rx_flags[slot]` to a non-zero value. The dispatch kernel treats
the slot as complete only after the flag is set.

In the NIC-free path, flags and data are allocated with
`cudaHostAllocMapped` so the device and host see the same memory.

## Step-by-Step: Wiring the Host API (Minimal)

```cpp
// Host API wiring
ASSERT_EQ(cudaq_dispatch_manager_create(&manager_), CUDAQ_OK);
cudaq_dispatcher_config_t config{};
config.device_id = 0;
config.num_blocks = 1;
config.threads_per_block = 32;
config.num_slots = static_cast<uint32_t>(num_slots_);
config.slot_size = static_cast<uint32_t>(slot_size_);
config.vp_id = 0;
config.kernel_type = CUDAQ_KERNEL_REGULAR;
config.dispatch_mode = CUDAQ_DISPATCH_DEVICE_CALL;

ASSERT_EQ(cudaq_dispatcher_create(manager_, &config, &dispatcher_), CUDAQ_OK);

cudaq_ringbuffer_t ringbuffer{};
ringbuffer.rx_flags = rx_flags_;
ringbuffer.tx_flags = tx_flags_;
ringbuffer.rx_data = rx_data_;
ringbuffer.tx_data = tx_data_;
ringbuffer.rx_stride_sz = slot_size_;
ringbuffer.tx_stride_sz = slot_size_;
ASSERT_EQ(cudaq_dispatcher_set_ringbuffer(dispatcher_, &ringbuffer), CUDAQ_OK);

// Allocate and initialize function table entries
cudaq_function_entry_t* d_entries;
cudaMalloc(&d_entries, func_count_ * sizeof(cudaq_function_entry_t));

// Initialize entries on device (including schemas)
init_function_table<<<1, 1>>>(d_entries);
cudaDeviceSynchronize();

cudaq_function_table_t table{};
table.entries = d_entries;
table.count = func_count_;
ASSERT_EQ(cudaq_dispatcher_set_function_table(dispatcher_, &table), CUDAQ_OK);

ASSERT_EQ(cudaq_dispatcher_set_control(dispatcher_, d_shutdown_flag_, d_stats_),
          CUDAQ_OK);

ASSERT_EQ(cudaq_dispatcher_set_launch_fn(
              dispatcher_,
              &cudaq::qec::realtime::mock_decode_launch_dispatch_kernel),
          CUDAQ_OK);

ASSERT_EQ(cudaq_dispatcher_start(dispatcher_), CUDAQ_OK);
```

## Device Handler and Function ID

```cpp
// The dispatcher uses function_id to find the handler
constexpr std::uint32_t MOCK_DECODE_FUNCTION_ID =
    cudaq::realtime::fnv1a_hash("mock_decode");

/// @brief Initialize the device function table with schema
__global__ void init_function_table(cudaq_function_entry_t* entries) {
  if (threadIdx.x == 0 && blockIdx.x == 0) {
    // Entry 0: Mock decoder
    entries[0].handler.device_fn_ptr = 
        reinterpret_cast<void*>(&cudaq::qec::realtime::mock_decode_rpc);
    entries[0].function_id = MOCK_DECODE_FUNCTION_ID;
    entries[0].dispatch_mode = CUDAQ_DISPATCH_DEVICE_CALL;
    
    // Schema: 1 arg (bit-packed detection events), 1 result (correction byte)
    entries[0].schema.num_args = 1;
    entries[0].schema.args[0] = {CUDAQ_TYPE_BIT_PACKED, {0}, 16, 128};  // 128 bits
    entries[0].schema.num_results = 1;
    entries[0].schema.results[0] = {CUDAQ_TYPE_UINT8, {0}, 1, 1};
  }
}
```

### Multi-Argument Handler Example

```cpp
constexpr std::uint32_t ADVANCED_DECODE_FUNCTION_ID =
    cudaq::realtime::fnv1a_hash("advanced_decode");

__global__ void init_advanced_handler(cudaq_function_entry_t* entries, 
                                       uint32_t index) {
  if (threadIdx.x == 0 && blockIdx.x == 0) {
    entries[index].handler.device_fn_ptr = 
        reinterpret_cast<void*>(&advanced_decode_rpc);
    entries[index].function_id = ADVANCED_DECODE_FUNCTION_ID;
    entries[index].dispatch_mode = CUDAQ_DISPATCH_DEVICE_CALL;
    
    // Schema: 2 args (detection events + calibration), 1 result
    entries[index].schema.num_args = 2;
    entries[index].schema.args[0] = {CUDAQ_TYPE_BIT_PACKED, {0}, 16, 128};
    entries[index].schema.args[1] = {CUDAQ_TYPE_ARRAY_FLOAT32, {0}, 64, 16};  // 16 floats
    entries[index].schema.num_results = 1;
    entries[index].schema.results[0] = {CUDAQ_TYPE_UINT8, {0}, 1, 1};
  }
}
```

## CUDA Graph Dispatch Mode

The `CUDAQ_DISPATCH_GRAPH_LAUNCH` mode enables handlers to be executed as
pre-captured CUDA graphs launched from device code.
This is useful for complex multi-kernel workflows that benefit
from graph optimization and can reduce kernel launch overhead for sophisticated decoders.

### Requirements

- **GPU Architecture**: Compute capability 9.0 or higher (Hopper H100 or later)
- **CUDA Version**: CUDA 12.0+ with device-side graph launch support
- **Graph Setup**: Handler graphs must be captured and instantiated with `cudaGraphInstantiateFlagDeviceLaunch`

### Graph-Based Dispatch API

The API provides functions to properly wrap the dispatch kernel
in a graph context that enables device-side `cudaGraphLaunch()`:

```cpp
// Opaque handle for graph-based dispatch context
typedef struct cudaq_dispatch_graph_context cudaq_dispatch_graph_context;

// Create a graph-based dispatch context
cudaError_t cudaq_create_dispatch_graph_regular(
    volatile uint64_t *rx_flags, volatile uint64_t *tx_flags,
    uint8_t *rx_data, uint8_t *tx_data,
    size_t rx_stride_sz, size_t tx_stride_sz,
    cudaq_function_entry_t *function_table, size_t func_count,
    void *graph_io_ctx, volatile int *shutdown_flag, uint64_t *stats,
    size_t num_slots, uint32_t num_blocks, uint32_t threads_per_block,
    cudaStream_t stream, cudaq_dispatch_graph_context **out_context);

// Launch the dispatch graph
cudaError_t cudaq_launch_dispatch_graph(cudaq_dispatch_graph_context *context,
                                        cudaStream_t stream);

// Destroy the dispatch graph context
cudaError_t cudaq_destroy_dispatch_graph(cudaq_dispatch_graph_context *context);
```

### Graph Handler Setup Example

```cpp
/// @brief Initialize function table with CUDA graph handler
__global__ void init_function_table_graph(cudaq_function_entry_t* entries) {
  if (threadIdx.x == 0 && blockIdx.x == 0) {
    entries[0].handler.graph_exec = /* pre-captured cudaGraphExec_t */;
    entries[0].function_id = DECODE_FUNCTION_ID;
    entries[0].dispatch_mode = CUDAQ_DISPATCH_GRAPH_LAUNCH;
    
    // Schema: same as device call mode
    entries[0].schema.num_args = 1;
    entries[0].schema.args[0] = {TYPE_BIT_PACKED, {0}, 16, 128};
    entries[0].schema.num_results = 1;
    entries[0].schema.results[0] = {TYPE_UINT8, {0}, 1, 1};
  }
}
```

### Graph Capture and Instantiation

Handler graphs must be captured and instantiated with the device launch flag:

```cpp
cudaStream_t capture_stream;
cudaStreamCreate(&capture_stream);

// Capture the decoder kernel(s) into a graph
cudaStreamBeginCapture(capture_stream, cudaStreamCaptureModeGlobal);
decode_kernel<<<blocks, threads, 0, capture_stream>>>(args...);
cudaStreamEndCapture(capture_stream, &graph);

// Instantiate with device launch flag (required for device-side cudaGraphLaunch)
cudaGraphExec_t graph_exec;
cudaGraphInstantiateWithFlags(&graph_exec, graph, 
                              cudaGraphInstantiateFlagDeviceLaunch);

// Upload graph to device
cudaGraphUpload(graph_exec, capture_stream);
cudaStreamSynchronize(capture_stream);
cudaStreamDestroy(capture_stream);
```

### When to Use Graph Dispatch

Use `CUDAQ_DISPATCH_GRAPH_LAUNCH` mode with the graph-based dispatch API
when handlers need to launch CUDA graphs from device code.
The graph-based dispatch API (`cudaq_create_dispatch_graph_regular()` + `cudaq_launch_dispatch_graph()`)
wraps the dispatch kernel in a graph execution context, enabling device-side `cudaGraphLaunch()`
calls from within handlers.

### Graph vs Device Call Dispatch

**Device Call Mode** (`CUDAQ_DISPATCH_DEVICE_CALL`):

- Lowest latency for simple handlers
- Direct `__device__` function call from dispatcher
- Suitable for lightweight decoders and data transformations
- No special hardware requirements

**Graph Launch Mode** (`CUDAQ_DISPATCH_GRAPH_LAUNCH`):

- Enables complex multi-kernel workflows
- Benefits from CUDA graph optimizations
- Requires `sm_90+` hardware (Hopper or later)
- Higher setup overhead but can reduce per-invocation latency for complex pipelines

## Building and Sending an RPC Message

Adapted from `test_realtime_decoding.cu` (the actual test uses a library helper,
`setup_mock_decode_function_table`, that performs equivalent setup via
`cudaMemcpy`):

Note: this host-side snippet emulates what the external device/FPGA would do
when populating RX slots in a Hololink deployment.

```cpp
/// @brief Write detection events to RX buffer in RPC format.
void write_rpc_request(std::size_t slot, const std::vector<uint8_t>& measurements) {
  uint8_t* slot_data = const_cast<uint8_t*>(rx_data_host_) + slot * slot_size_;
  
  // Write RPCHeader
  cudaq::realtime::RPCHeader* header =
      reinterpret_cast<cudaq::realtime::RPCHeader*>(slot_data);
  header->magic = cudaq::realtime::RPC_MAGIC_REQUEST;
  header->function_id = MOCK_DECODE_FUNCTION_ID;
  header->arg_len = static_cast<std::uint32_t>(measurements.size());
  header->request_id = static_cast<std::uint32_t>(slot);
  
  // Write measurement data after header
  memcpy(slot_data + sizeof(cudaq::realtime::RPCHeader),
         measurements.data(), measurements.size());
}
```

## Reading the Response

Note: this host-side snippet emulates what the external device/FPGA would do
when consuming TX slots in a Hololink deployment.

```cpp
/// @brief Read response from TX buffer.
/// Responses are written by the dispatch kernel to the TX ring buffer; read from tx_data, not rx_data.
bool read_rpc_response(std::size_t slot, uint8_t& correction,
                       std::int32_t* status_out = nullptr,
                       std::uint32_t* result_len_out = nullptr,
                       std::uint32_t* request_id_out = nullptr) {
  __sync_synchronize();
  const uint8_t* slot_data = const_cast<uint8_t*>(tx_data_host_) + slot * slot_size_;
  
  // Read RPCResponse
  const cudaq::realtime::RPCResponse* response =
      reinterpret_cast<const cudaq::realtime::RPCResponse*>(slot_data);

  if (response->magic != cudaq::realtime::RPC_MAGIC_RESPONSE) {
    return false;
  }

  if (status_out)
    *status_out = response->status;
  if (result_len_out)
    *result_len_out = response->result_len;
  if (request_id_out)
    *request_id_out = response->request_id;
  
  if (response->status != 0) {
    return false;
  }
  
  // Read correction data after response header
  correction = *(slot_data + sizeof(cudaq::realtime::RPCResponse));
  return true;
}
```

## Schema-Driven Argument Parsing

The dispatcher uses the handler schema to interpret the typeless payload bytes.
This example shows conceptual parsing logic:

```cpp
__device__ void parse_args_from_payload(
    const uint8_t* payload,
    const cudaq_handler_schema_t& schema,
    void** arg_ptrs) {
  
  uint32_t offset = 0;
  
  for (uint8_t i = 0; i < schema.num_args; i++) {
    arg_ptrs[i] = const_cast<uint8_t*>(payload + offset);
    offset += schema.args[i].size_bytes;
  }
}

__device__ void dispatch_with_schema(
    uint8_t* slot_data,
    const cudaq_function_entry_t& entry) {
  
  RPCHeader* hdr = reinterpret_cast<RPCHeader*>(slot_data);
  uint8_t* payload = slot_data + sizeof(RPCHeader);
  
  // Parse arguments using schema
  void* arg_ptrs[8];
  parse_args_from_payload(payload, entry.schema, arg_ptrs);
  
  // Call handler with parsed arguments
  if (entry.dispatch_mode == CUDAQ_DISPATCH_DEVICE_CALL) {
    auto handler = reinterpret_cast<HandlerFn>(entry.handler.device_fn_ptr);
    handler(arg_ptrs, entry.schema.num_args, /* result buffer */);
  }
  // ... graph launch path uses same parsed args
}
```

For multi-argument payloads, arguments are **concatenated in schema order**:

```text
| RPCHeader | arg0_bytes | arg1_bytes | arg2_bytes | ... |
             ^            ^            ^
             offset=0     offset=16    offset=80
```

The schema specifies the size of each argument, allowing the dispatcher to
compute offsets.

## Hololink 3-Kernel Workflow (Primary)

See the [3-Kernel Architecture](#three-kernel-architecture) diagram above for
the complete data flow. The key integration points are:

**Ring buffer handoff (RX → Dispatch)**:

```cpp
// Hololink RX kernel sets this after writing detection event data
rx_flags[slot] = device_ptr_to_slot_data;
```

**Ring buffer handoff (Dispatch → TX)**:

```cpp
// Dispatch kernel sets this after writing RPCResponse
tx_flags[slot] = device_ptr_to_slot_data;
```

**Latency path**: The critical path is:

1. RDMA write completes → RX kernel signals → Dispatch polls and processes →
TX kernel polls and sends → RDMA read completes

All three kernels are **persistent** (launched once, run indefinitely), so
there is no kernel launch overhead in the hot path.

## NIC-Free Testing (No Hololink / No ConnectX-7)

Emulate RX/TX with mapped host memory:

- `cuda-quantum` host API test:
  - `realtime/unittests/test_dispatch_kernel.cu`

## Troubleshooting

- **Timeout waiting for TX**: ensure the RX flag points to device-mapped memory.
- **Invalid `arg`**: check `slot_size`, `num_slots`, function table pointers.
- **CUDA errors**: verify `device_id`, and that CUDA is initialized.
