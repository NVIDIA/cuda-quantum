::: wy-grid-for-nav
::: wy-side-scroll
::: {.wy-side-nav-search style="background: #76b900"}
[NVIDIA CUDA-Q](../../index.html){.icon .icon-home}

::: version
pr-4000
:::

::: {role="search"}
:::
:::

::: {.wy-menu .wy-menu-vertical spy="affix" role="navigation" aria-label="Navigation menu"}
[Contents]{.caption-text}

-   [Quick Start](../../using/quick_start.html){.reference .internal}
    -   [Install
        CUDA-Q](../../using/quick_start.html#install-cuda-q){.reference
        .internal}
    -   [Validate your
        Installation](../../using/quick_start.html#validate-your-installation){.reference
        .internal}
    -   [CUDA-Q
        Academic](../../using/quick_start.html#cuda-q-academic){.reference
        .internal}
-   [Basics](../../using/basics/basics.html){.reference .internal}
    -   [What is a CUDA-Q
        Kernel?](../../using/basics/kernel_intro.html){.reference
        .internal}
    -   [Building your first CUDA-Q
        Program](../../using/basics/build_kernel.html){.reference
        .internal}
    -   [Running your first CUDA-Q
        Program](../../using/basics/run_kernel.html){.reference
        .internal}
        -   [Sample](../../using/basics/run_kernel.html#sample){.reference
            .internal}
        -   [Run](../../using/basics/run_kernel.html#run){.reference
            .internal}
        -   [Observe](../../using/basics/run_kernel.html#observe){.reference
            .internal}
        -   [Running on a
            GPU](../../using/basics/run_kernel.html#running-on-a-gpu){.reference
            .internal}
    -   [Troubleshooting](../../using/basics/troubleshooting.html){.reference
        .internal}
        -   [Debugging and Verbose Simulation
            Output](../../using/basics/troubleshooting.html#debugging-and-verbose-simulation-output){.reference
            .internal}
-   [Examples](../../using/examples/examples.html){.reference .internal}
    -   [Introduction](../../using/examples/introduction.html){.reference
        .internal}
    -   [Building
        Kernels](../../using/examples/building_kernels.html){.reference
        .internal}
        -   [Defining
            Kernels](../../using/examples/building_kernels.html#defining-kernels){.reference
            .internal}
        -   [Initializing
            states](../../using/examples/building_kernels.html#initializing-states){.reference
            .internal}
        -   [Applying
            Gates](../../using/examples/building_kernels.html#applying-gates){.reference
            .internal}
        -   [Controlled
            Operations](../../using/examples/building_kernels.html#controlled-operations){.reference
            .internal}
        -   [Multi-Controlled
            Operations](../../using/examples/building_kernels.html#multi-controlled-operations){.reference
            .internal}
        -   [Adjoint
            Operations](../../using/examples/building_kernels.html#adjoint-operations){.reference
            .internal}
        -   [Custom
            Operations](../../using/examples/building_kernels.html#custom-operations){.reference
            .internal}
        -   [Building Kernels with
            Kernels](../../using/examples/building_kernels.html#building-kernels-with-kernels){.reference
            .internal}
        -   [Parameterized
            Kernels](../../using/examples/building_kernels.html#parameterized-kernels){.reference
            .internal}
    -   [Quantum
        Operations](../../using/examples/quantum_operations.html){.reference
        .internal}
        -   [Quantum
            States](../../using/examples/quantum_operations.html#quantum-states){.reference
            .internal}
        -   [Quantum
            Gates](../../using/examples/quantum_operations.html#quantum-gates){.reference
            .internal}
        -   [Measurements](../../using/examples/quantum_operations.html#measurements){.reference
            .internal}
    -   [Measuring
        Kernels](../../using/examples/measuring_kernels.html){.reference
        .internal}
        -   [Mid-circuit Measurement and Conditional
            Logic](../../using/examples/measuring_kernels.html#mid-circuit-measurement-and-conditional-logic){.reference
            .internal}
    -   [Visualizing
        Kernels](../../examples/python/visualization.html){.reference
        .internal}
        -   [Qubit
            Visualization](../../examples/python/visualization.html#Qubit-Visualization){.reference
            .internal}
        -   [Kernel
            Visualization](../../examples/python/visualization.html#Kernel-Visualization){.reference
            .internal}
    -   [Executing
        Kernels](../../using/examples/executing_kernels.html){.reference
        .internal}
        -   [Sample](../../using/examples/executing_kernels.html#sample){.reference
            .internal}
            -   [Sample
                Asynchronous](../../using/examples/executing_kernels.html#sample-asynchronous){.reference
                .internal}
        -   [Run](../../using/examples/executing_kernels.html#run){.reference
            .internal}
            -   [Return Custom Data
                Types](../../using/examples/executing_kernels.html#return-custom-data-types){.reference
                .internal}
            -   [Run
                Asynchronous](../../using/examples/executing_kernels.html#run-asynchronous){.reference
                .internal}
        -   [Observe](../../using/examples/executing_kernels.html#observe){.reference
            .internal}
            -   [Observe
                Asynchronous](../../using/examples/executing_kernels.html#observe-asynchronous){.reference
                .internal}
        -   [Get
            State](../../using/examples/executing_kernels.html#get-state){.reference
            .internal}
            -   [Get State
                Asynchronous](../../using/examples/executing_kernels.html#get-state-asynchronous){.reference
                .internal}
    -   [Computing Expectation
        Values](../../using/examples/expectation_values.html){.reference
        .internal}
        -   [Parallelizing across Multiple
            Processors](../../using/examples/expectation_values.html#parallelizing-across-multiple-processors){.reference
            .internal}
    -   [Multi-GPU
        Workflows](../../using/examples/multi_gpu_workflows.html){.reference
        .internal}
        -   [From CPU to
            GPU](../../using/examples/multi_gpu_workflows.html#from-cpu-to-gpu){.reference
            .internal}
        -   [Pooling the memory of multiple GPUs ([`mgpu`{.code
            .docutils .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#pooling-the-memory-of-multiple-gpus-mgpu){.reference
            .internal}
        -   [Parallel execution over multiple QPUs ([`mqpu`{.code
            .docutils .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#parallel-execution-over-multiple-qpus-mqpu){.reference
            .internal}
            -   [Batching Hamiltonian
                Terms](../../using/examples/multi_gpu_workflows.html#batching-hamiltonian-terms){.reference
                .internal}
            -   [Circuit
                Batching](../../using/examples/multi_gpu_workflows.html#circuit-batching){.reference
                .internal}
        -   [Multi-QPU + Other Backends ([`remote-mqpu`{.code .docutils
            .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#multi-qpu-other-backends-remote-mqpu){.reference
            .internal}
    -   [Optimizers &
        Gradients](../../examples/python/optimizers_gradients.html){.reference
        .internal}
        -   [CUDA-Q Optimizer
            Overview](../../examples/python/optimizers_gradients.html#CUDA-Q-Optimizer-Overview){.reference
            .internal}
            -   [Gradient-Free Optimizers (no gradients
                required):](../../examples/python/optimizers_gradients.html#Gradient-Free-Optimizers-(no-gradients-required):){.reference
                .internal}
            -   [Gradient-Based Optimizers (require
                gradients):](../../examples/python/optimizers_gradients.html#Gradient-Based-Optimizers-(require-gradients):){.reference
                .internal}
        -   [1. Built-in CUDA-Q Optimizers and
            Gradients](../../examples/python/optimizers_gradients.html#1.-Built-in-CUDA-Q-Optimizers-and-Gradients){.reference
            .internal}
            -   [1.1 Adam Optimizer with Parameter
                Configuration](../../examples/python/optimizers_gradients.html#1.1-Adam-Optimizer-with-Parameter-Configuration){.reference
                .internal}
            -   [1.2 SGD (Stochastic Gradient Descent)
                Optimizer](../../examples/python/optimizers_gradients.html#1.2-SGD-(Stochastic-Gradient-Descent)-Optimizer){.reference
                .internal}
            -   [1.3 SPSA (Simultaneous Perturbation Stochastic
                Approximation)](../../examples/python/optimizers_gradients.html#1.3-SPSA-(Simultaneous-Perturbation-Stochastic-Approximation)){.reference
                .internal}
        -   [2. Third-Party
            Optimizers](../../examples/python/optimizers_gradients.html#2.-Third-Party-Optimizers){.reference
            .internal}
        -   [3. Parallel Parameter Shift
            Gradients](../../examples/python/optimizers_gradients.html#3.-Parallel-Parameter-Shift-Gradients){.reference
            .internal}
    -   [Noisy
        Simulations](../../examples/python/noisy_simulations.html){.reference
        .internal}
    -   [Constructing
        Operators](../../using/examples/operators.html){.reference
        .internal}
        -   [Constructing Spin
            Operators](../../using/examples/operators.html#constructing-spin-operators){.reference
            .internal}
        -   [Pauli Words and Exponentiating Pauli
            Words](../../using/examples/operators.html#pauli-words-and-exponentiating-pauli-words){.reference
            .internal}
    -   [Performance
        Optimizations](../../examples/python/performance_optimizations.html){.reference
        .internal}
        -   [Gate
            Fusion](../../examples/python/performance_optimizations.html#Gate-Fusion){.reference
            .internal}
    -   [Using Quantum Hardware
        Providers](../../using/examples/hardware_providers.html){.reference
        .internal}
        -   [Amazon
            Braket](../../using/examples/hardware_providers.html#amazon-braket){.reference
            .internal}
        -   [Anyon
            Technologies](../../using/examples/hardware_providers.html#anyon-technologies){.reference
            .internal}
        -   [Infleqtion](../../using/examples/hardware_providers.html#infleqtion){.reference
            .internal}
        -   [IonQ](../../using/examples/hardware_providers.html#ionq){.reference
            .internal}
        -   [IQM](../../using/examples/hardware_providers.html#iqm){.reference
            .internal}
        -   [OQC](../../using/examples/hardware_providers.html#oqc){.reference
            .internal}
        -   [ORCA
            Computing](../../using/examples/hardware_providers.html#orca-computing){.reference
            .internal}
        -   [Pasqal](../../using/examples/hardware_providers.html#pasqal){.reference
            .internal}
        -   [Quantinuum](../../using/examples/hardware_providers.html#quantinuum){.reference
            .internal}
        -   [Quantum Circuits,
            Inc.](../../using/examples/hardware_providers.html#quantum-circuits-inc){.reference
            .internal}
        -   [Quantum
            Machines](../../using/examples/hardware_providers.html#quantum-machines){.reference
            .internal}
        -   [QuEra
            Computing](../../using/examples/hardware_providers.html#quera-computing){.reference
            .internal}
    -   [Dynamics
        Examples](../../using/examples/dynamics_examples.html){.reference
        .internal}
        -   [Introduction to CUDA-Q Dynamics (Jaynes-Cummings
            Model)](../../examples/python/dynamics/dynamics_intro_1.html){.reference
            .internal}
            -   [Why dynamics simulations vs. circuit
                simulations?](../../examples/python/dynamics/dynamics_intro_1.html#Why-dynamics-simulations-vs.-circuit-simulations?){.reference
                .internal}
            -   [Functionality](../../examples/python/dynamics/dynamics_intro_1.html#Functionality){.reference
                .internal}
            -   [Performance](../../examples/python/dynamics/dynamics_intro_1.html#Performance){.reference
                .internal}
            -   [Section 1 - Simulating the Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Section-1---Simulating-the-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Exercise 1 - Simulating a many-photon Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-1---Simulating-a-many-photon-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Section 2 - Simulating open quantum systems with the
                [`collapse_operators`{.docutils .literal
                .notranslate}]{.pre}](../../examples/python/dynamics/dynamics_intro_1.html#Section-2---Simulating-open-quantum-systems-with-the-collapse_operators){.reference
                .internal}
            -   [Exercise 2 - Adding additional jump operators
                [\\(L_i\\)]{.math .notranslate
                .nohighlight}](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-2---Adding-additional-jump-operators-L_i){.reference
                .internal}
            -   [Section 3 - Many qubits coupled to the
                resonator](../../examples/python/dynamics/dynamics_intro_1.html#Section-3---Many-qubits-coupled-to-the-resonator){.reference
                .internal}
        -   [Introduction to CUDA-Q Dynamics (Time Dependent
            Hamiltonians)](../../examples/python/dynamics/dynamics_intro_2.html){.reference
            .internal}
            -   [The Landau-Zener
                model](../../examples/python/dynamics/dynamics_intro_2.html#The-Landau-Zener-model){.reference
                .internal}
            -   [Section 1 - Implementing time dependent
                terms](../../examples/python/dynamics/dynamics_intro_2.html#Section-1---Implementing-time-dependent-terms){.reference
                .internal}
            -   [Section 2 - Implementing custom
                operators](../../examples/python/dynamics/dynamics_intro_2.html#Section-2---Implementing-custom-operators){.reference
                .internal}
            -   [Section 3 - Heisenberg Model with a time-varying
                magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Section-3---Heisenberg-Model-with-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 1 - Define a time-varying magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-1---Define-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 2
                (Optional)](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-2-(Optional)){.reference
                .internal}
        -   [Superconducting
            Qubits](../../examples/python/dynamics/superconducting.html){.reference
            .internal}
            -   [Cavity
                QED](../../examples/python/dynamics/superconducting.html#Cavity-QED){.reference
                .internal}
            -   [Cross
                Resonance](../../examples/python/dynamics/superconducting.html#Cross-Resonance){.reference
                .internal}
            -   [Transmon
                Resonator](../../examples/python/dynamics/superconducting.html#Transmon-Resonator){.reference
                .internal}
        -   [Spin
            Qubits](../../examples/python/dynamics/spinqubits.html){.reference
            .internal}
            -   [Silicon Spin
                Qubit](../../examples/python/dynamics/spinqubits.html#Silicon-Spin-Qubit){.reference
                .internal}
            -   [Heisenberg
                Model](../../examples/python/dynamics/spinqubits.html#Heisenberg-Model){.reference
                .internal}
        -   [Trapped Ion
            Qubits](../../examples/python/dynamics/iontrap.html){.reference
            .internal}
            -   [GHZ
                state](../../examples/python/dynamics/iontrap.html#GHZ-state){.reference
                .internal}
        -   [Control](../../examples/python/dynamics/control.html){.reference
            .internal}
            -   [Gate
                Calibration](../../examples/python/dynamics/control.html#Gate-Calibration){.reference
                .internal}
            -   [Pulse](../../examples/python/dynamics/control.html#Pulse){.reference
                .internal}
            -   [Qubit
                Control](../../examples/python/dynamics/control.html#Qubit-Control){.reference
                .internal}
            -   [Qubit
                Dynamics](../../examples/python/dynamics/control.html#Qubit-Dynamics){.reference
                .internal}
            -   [Landau-Zenner](../../examples/python/dynamics/control.html#Landau-Zenner){.reference
                .internal}
-   [Applications](../../using/applications.html){.reference .internal}
    -   [Max-Cut with
        QAOA](../../applications/python/qaoa.html){.reference .internal}
    -   [Molecular docking via
        DC-QAOA](../../applications/python/digitized_counterdiabatic_qaoa.html){.reference
        .internal}
        -   [Setting up the Molecular Docking
            Problem](../../applications/python/digitized_counterdiabatic_qaoa.html#Setting-up-the-Molecular-Docking-Problem){.reference
            .internal}
        -   [CUDA-Q
            Implementation](../../applications/python/digitized_counterdiabatic_qaoa.html#CUDA-Q-Implementation){.reference
            .internal}
    -   [Multi-reference Quantum Krylov Algorithm - [\\(H_2\\)]{.math
        .notranslate .nohighlight}
        Molecule](../../applications/python/krylov.html){.reference
        .internal}
        -   [Setup](../../applications/python/krylov.html#Setup){.reference
            .internal}
        -   [Computing the matrix
            elements](../../applications/python/krylov.html#Computing-the-matrix-elements){.reference
            .internal}
        -   [Determining the ground state energy of the
            subspace](../../applications/python/krylov.html#Determining-the-ground-state-energy-of-the-subspace){.reference
            .internal}
    -   [Quantum-Selected Configuration Interaction
        (QSCI)](../../applications/python/qsci.html){.reference
        .internal}
        -   [0. Problem
            definition](../../applications/python/qsci.html#0.-Problem-definition){.reference
            .internal}
        -   [1. Prepare an Approximate Quantum
            State](../../applications/python/qsci.html#1.-Prepare-an-Approximate-Quantum-State){.reference
            .internal}
        -   [2 Quantum Sampling to Select
            Configuration](../../applications/python/qsci.html#2-Quantum-Sampling-to-Select-Configuration){.reference
            .internal}
        -   [3. Classical Diagonalization on the Selected
            Subspace](../../applications/python/qsci.html#3.-Classical-Diagonalization-on-the-Selected-Subspace){.reference
            .internal}
        -   [5. Compuare
            results](../../applications/python/qsci.html#5.-Compuare-results){.reference
            .internal}
        -   [Reference](../../applications/python/qsci.html#Reference){.reference
            .internal}
    -   [Bernstein-Vazirani
        Algorithm](../../applications/python/bernstein_vazirani.html){.reference
        .internal}
        -   [Classical
            case](../../applications/python/bernstein_vazirani.html#Classical-case){.reference
            .internal}
        -   [Quantum
            case](../../applications/python/bernstein_vazirani.html#Quantum-case){.reference
            .internal}
        -   [Implementing in
            CUDA-Q](../../applications/python/bernstein_vazirani.html#Implementing-in-CUDA-Q){.reference
            .internal}
    -   [Cost
        Minimization](../../applications/python/cost_minimization.html){.reference
        .internal}
    -   [Deutsch's
        Algorithm](../../applications/python/deutsch_algorithm.html){.reference
        .internal}
        -   [XOR [\\(\\oplus\\)]{.math .notranslate
            .nohighlight}](../../applications/python/deutsch_algorithm.html#XOR-\oplus){.reference
            .internal}
        -   [Quantum
            oracles](../../applications/python/deutsch_algorithm.html#Quantum-oracles){.reference
            .internal}
        -   [Phase
            oracle](../../applications/python/deutsch_algorithm.html#Phase-oracle){.reference
            .internal}
        -   [Quantum
            parallelism](../../applications/python/deutsch_algorithm.html#Quantum-parallelism){.reference
            .internal}
        -   [Deutsch's
            Algorithm:](../../applications/python/deutsch_algorithm.html#Deutsch's-Algorithm:){.reference
            .internal}
    -   [Divisive Clustering With Coresets Using
        CUDA-Q](../../applications/python/divisive_clustering_coresets.html){.reference
        .internal}
        -   [Data
            preprocessing](../../applications/python/divisive_clustering_coresets.html#Data-preprocessing){.reference
            .internal}
        -   [Quantum
            functions](../../applications/python/divisive_clustering_coresets.html#Quantum-functions){.reference
            .internal}
        -   [Divisive Clustering
            Function](../../applications/python/divisive_clustering_coresets.html#Divisive-Clustering-Function){.reference
            .internal}
        -   [QAOA
            Implementation](../../applications/python/divisive_clustering_coresets.html#QAOA-Implementation){.reference
            .internal}
        -   [Scaling simulations with
            CUDA-Q](../../applications/python/divisive_clustering_coresets.html#Scaling-simulations-with-CUDA-Q){.reference
            .internal}
    -   [Hybrid Quantum Neural
        Networks](../../applications/python/hybrid_quantum_neural_networks.html){.reference
        .internal}
    -   [Using the Hadamard Test to Determine Quantum Krylov Subspace
        Decomposition Matrix
        Elements](../../applications/python/hadamard_test.html){.reference
        .internal}
        -   [Numerical result as a
            reference:](../../applications/python/hadamard_test.html#Numerical-result-as-a-reference:){.reference
            .internal}
        -   [Using [`Sample`{.docutils .literal .notranslate}]{.pre} to
            perform the Hadamard
            test](../../applications/python/hadamard_test.html#Using-Sample-to-perform-the-Hadamard-test){.reference
            .internal}
        -   [Multi-GPU evaluation of QKSD matrix elements using the
            Hadamard
            Test](../../applications/python/hadamard_test.html#Multi-GPU-evaluation-of-QKSD-matrix-elements-using-the-Hadamard-Test){.reference
            .internal}
            -   [Classically Diagonalize the Subspace
                Matrix](../../applications/python/hadamard_test.html#Classically-Diagonalize-the-Subspace-Matrix){.reference
                .internal}
    -   [Anderson Impurity Model ground state solver on Infleqtion's
        Sqale](../../applications/python/logical_aim_sqale.html){.reference
        .internal}
        -   [Performing logical Variational Quantum Eigensolver (VQE)
            with
            CUDA-QX](../../applications/python/logical_aim_sqale.html#Performing-logical-Variational-Quantum-Eigensolver-(VQE)-with-CUDA-QX){.reference
            .internal}
        -   [Constructing circuits in the [`[[4,2,2]]`{.docutils
            .literal .notranslate}]{.pre}
            encoding](../../applications/python/logical_aim_sqale.html#Constructing-circuits-in-the-%5B%5B4,2,2%5D%5D-encoding){.reference
            .internal}
        -   [Setting up submission and decoding
            workflow](../../applications/python/logical_aim_sqale.html#Setting-up-submission-and-decoding-workflow){.reference
            .internal}
        -   [Running a CUDA-Q noisy
            simulation](../../applications/python/logical_aim_sqale.html#Running-a-CUDA-Q-noisy-simulation){.reference
            .internal}
        -   [Running logical AIM on Infleqtion's
            hardware](../../applications/python/logical_aim_sqale.html#Running-logical-AIM-on-Infleqtion's-hardware){.reference
            .internal}
    -   [Spin-Hamiltonian Simulation Using
        CUDA-Q](../../applications/python/hamiltonian_simulation.html){.reference
        .internal}
        -   [Introduction](../../applications/python/hamiltonian_simulation.html#Introduction){.reference
            .internal}
            -   [Heisenberg
                Hamiltonian](../../applications/python/hamiltonian_simulation.html#Heisenberg-Hamiltonian){.reference
                .internal}
            -   [Transverse Field Ising Model
                (TFIM)](../../applications/python/hamiltonian_simulation.html#Transverse-Field-Ising-Model-(TFIM)){.reference
                .internal}
            -   [Time Evolution and Trotter
                Decomposition](../../applications/python/hamiltonian_simulation.html#Time-Evolution-and-Trotter-Decomposition){.reference
                .internal}
        -   [Key
            steps](../../applications/python/hamiltonian_simulation.html#Key-steps){.reference
            .internal}
            -   [1. Prepare initial
                state](../../applications/python/hamiltonian_simulation.html#1.-Prepare-initial-state){.reference
                .internal}
            -   [2. Hamiltonian
                Trotterization](../../applications/python/hamiltonian_simulation.html#2.-Hamiltonian-Trotterization){.reference
                .internal}
            -   [3. [`Compute`{.docutils .literal
                .notranslate}]{.pre}` `{.docutils .literal
                .notranslate}[`overlap`{.docutils .literal
                .notranslate}]{.pre}](../../applications/python/hamiltonian_simulation.html#3.-Compute-overlap){.reference
                .internal}
            -   [4. Construct Heisenberg
                Hamiltonian](../../applications/python/hamiltonian_simulation.html#4.-Construct-Heisenberg-Hamiltonian){.reference
                .internal}
            -   [5. Construct TFIM
                Hamiltonian](../../applications/python/hamiltonian_simulation.html#5.-Construct-TFIM-Hamiltonian){.reference
                .internal}
            -   [6. Extract coefficients and Pauli
                words](../../applications/python/hamiltonian_simulation.html#6.-Extract-coefficients-and-Pauli-words){.reference
                .internal}
        -   [Main
            code](../../applications/python/hamiltonian_simulation.html#Main-code){.reference
            .internal}
        -   [Visualization of probablity over
            time](../../applications/python/hamiltonian_simulation.html#Visualization-of-probablity-over-time){.reference
            .internal}
        -   [Expectation value over
            time:](../../applications/python/hamiltonian_simulation.html#Expectation-value-over-time:){.reference
            .internal}
        -   [Visualization of expectation over
            time](../../applications/python/hamiltonian_simulation.html#Visualization-of-expectation-over-time){.reference
            .internal}
        -   [Additional
            information](../../applications/python/hamiltonian_simulation.html#Additional-information){.reference
            .internal}
        -   [Relevant
            references](../../applications/python/hamiltonian_simulation.html#Relevant-references){.reference
            .internal}
    -   [Quantum Fourier
        Transform](../../applications/python/quantum_fourier_transform.html){.reference
        .internal}
        -   [Quantum Fourier Transform
            revisited](../../applications/python/quantum_fourier_transform.html#Quantum-Fourier-Transform-revisited){.reference
            .internal}
    -   [Quantum
        Teleporation](../../applications/python/quantum_teleportation.html){.reference
        .internal}
        -   [Teleportation
            explained](../../applications/python/quantum_teleportation.html#Teleportation-explained){.reference
            .internal}
    -   [Quantum
        Volume](../../applications/python/quantum_volume.html){.reference
        .internal}
    -   [Readout Error
        Mitigation](../../applications/python/readout_error_mitigation.html){.reference
        .internal}
        -   [Inverse confusion matrix from single-qubit noise
            model](../../applications/python/readout_error_mitigation.html#Inverse-confusion-matrix-from-single-qubit-noise-model){.reference
            .internal}
        -   [Inverse confusion matrix from k local confusion
            matrices](../../applications/python/readout_error_mitigation.html#Inverse-confusion-matrix-from-k-local-confusion-matrices){.reference
            .internal}
        -   [Inverse of full confusion
            matrix](../../applications/python/readout_error_mitigation.html#Inverse-of-full-confusion-matrix){.reference
            .internal}
    -   [Compiling Unitaries Using Diffusion
        Models](../../applications/python/unitary_compilation_diffusion_models.html){.reference
        .internal}
        -   [Diffusion model
            pipeline](../../applications/python/unitary_compilation_diffusion_models.html#Diffusion-model-pipeline){.reference
            .internal}
        -   [Setup and load
            models](../../applications/python/unitary_compilation_diffusion_models.html#Setup-and-load-models){.reference
            .internal}
            -   [Load discrete
                model](../../applications/python/unitary_compilation_diffusion_models.html#Load-discrete-model){.reference
                .internal}
            -   [Load continuous
                model](../../applications/python/unitary_compilation_diffusion_models.html#Load-continuous-model){.reference
                .internal}
            -   [Create helper
                functions](../../applications/python/unitary_compilation_diffusion_models.html#Create-helper-functions){.reference
                .internal}
        -   [Unitary
            compilation](../../applications/python/unitary_compilation_diffusion_models.html#Unitary-compilation){.reference
            .internal}
            -   [Random
                unitary](../../applications/python/unitary_compilation_diffusion_models.html#Random-unitary){.reference
                .internal}
            -   [Discrete
                model](../../applications/python/unitary_compilation_diffusion_models.html#Discrete-model){.reference
                .internal}
            -   [Continuous
                model](../../applications/python/unitary_compilation_diffusion_models.html#Continuous-model){.reference
                .internal}
            -   [Quantum Fourier
                transform](../../applications/python/unitary_compilation_diffusion_models.html#Quantum-Fourier-transform){.reference
                .internal}
            -   [XXZ-Hamiltonian
                evolution](../../applications/python/unitary_compilation_diffusion_models.html#XXZ-Hamiltonian-evolution){.reference
                .internal}
        -   [Choosing the circuit you
            need](../../applications/python/unitary_compilation_diffusion_models.html#Choosing-the-circuit-you-need){.reference
            .internal}
    -   [VQE with gradients, active spaces, and gate
        fusion](../../applications/python/vqe_advanced.html){.reference
        .internal}
        -   [The Basics of
            VQE](../../applications/python/vqe_advanced.html#The-Basics-of-VQE){.reference
            .internal}
        -   [Installing/Loading Relevant
            Packages](../../applications/python/vqe_advanced.html#Installing/Loading-Relevant-Packages){.reference
            .internal}
        -   [Implementing VQE in
            CUDA-Q](../../applications/python/vqe_advanced.html#Implementing-VQE-in-CUDA-Q){.reference
            .internal}
        -   [Parallel Parameter Shift
            Gradients](../../applications/python/vqe_advanced.html#Parallel-Parameter-Shift-Gradients){.reference
            .internal}
        -   [Using an Active
            Space](../../applications/python/vqe_advanced.html#Using-an-Active-Space){.reference
            .internal}
        -   [Gate Fusion for Larger
            Circuits](../../applications/python/vqe_advanced.html#Gate-Fusion-for-Larger-Circuits){.reference
            .internal}
    -   [Quantum
        Transformer](../../applications/python/quantum_transformer.html){.reference
        .internal}
        -   [Installation](../../applications/python/quantum_transformer.html#Installation){.reference
            .internal}
        -   [Algorithm and
            Example](../../applications/python/quantum_transformer.html#Algorithm-and-Example){.reference
            .internal}
            -   [Creating the self-attention
                circuits](../../applications/python/quantum_transformer.html#Creating-the-self-attention-circuits){.reference
                .internal}
        -   [Usage](../../applications/python/quantum_transformer.html#Usage){.reference
            .internal}
            -   [Model
                Training](../../applications/python/quantum_transformer.html#Model-Training){.reference
                .internal}
            -   [Generating
                Molecules](../../applications/python/quantum_transformer.html#Generating-Molecules){.reference
                .internal}
            -   [Attention
                Maps](../../applications/python/quantum_transformer.html#Attention-Maps){.reference
                .internal}
    -   [Quantum Enhanced Auxiliary Field Quantum Monte
        Carlo](../../applications/python/afqmc.html){.reference
        .internal}
        -   [Hamiltonian preparation for
            VQE](../../applications/python/afqmc.html#Hamiltonian-preparation-for-VQE){.reference
            .internal}
        -   [Run VQE with
            CUDA-Q](../../applications/python/afqmc.html#Run-VQE-with-CUDA-Q){.reference
            .internal}
        -   [Auxiliary Field Quantum Monte Carlo
            (AFQMC)](../../applications/python/afqmc.html#Auxiliary-Field-Quantum-Monte-Carlo-(AFQMC)){.reference
            .internal}
        -   [Preparation of the molecular
            Hamiltonian](../../applications/python/afqmc.html#Preparation-of-the-molecular-Hamiltonian){.reference
            .internal}
        -   [Preparation of the trial wave
            function](../../applications/python/afqmc.html#Preparation-of-the-trial-wave-function){.reference
            .internal}
        -   [Setup of the AFQMC
            parameters](../../applications/python/afqmc.html#Setup-of-the-AFQMC-parameters){.reference
            .internal}
    -   [ADAPT-QAOA
        algorithm](../../applications/python/adapt_qaoa.html){.reference
        .internal}
        -   [Simulation
            input:](../../applications/python/adapt_qaoa.html#Simulation-input:){.reference
            .internal}
        -   [The problem Hamiltonian [\\(H_C\\)]{.math .notranslate
            .nohighlight} of the max-cut
            graph:](../../applications/python/adapt_qaoa.html#The-problem-Hamiltonian-H_C-of-the-max-cut-graph:){.reference
            .internal}
        -   [Th operator pool [\\(A_j\\)]{.math .notranslate
            .nohighlight}:](../../applications/python/adapt_qaoa.html#Th-operator-pool-A_j:){.reference
            .internal}
        -   [The commutator [\\(\[H_C,A_j\]\\)]{.math .notranslate
            .nohighlight}:](../../applications/python/adapt_qaoa.html#The-commutator-%5BH_C,A_j%5D:){.reference
            .internal}
        -   [Beginning of ADAPT-QAOA
            iteration:](../../applications/python/adapt_qaoa.html#Beginning-of-ADAPT-QAOA-iteration:){.reference
            .internal}
    -   [ADAPT-VQE
        algorithm](../../applications/python/adapt_vqe.html){.reference
        .internal}
        -   [Classical
            pre-processing](../../applications/python/adapt_vqe.html#Classical-pre-processing){.reference
            .internal}
        -   [Jordan
            Wigner:](../../applications/python/adapt_vqe.html#Jordan-Wigner:){.reference
            .internal}
        -   [UCCSD operator
            pool](../../applications/python/adapt_vqe.html#UCCSD-operator-pool){.reference
            .internal}
            -   [Single
                excitation](../../applications/python/adapt_vqe.html#Single-excitation){.reference
                .internal}
            -   [Double
                excitation](../../applications/python/adapt_vqe.html#Double-excitation){.reference
                .internal}
        -   [Commutator \[[\\(H\\)]{.math .notranslate .nohighlight},
            [\\(A_i\\)]{.math .notranslate
            .nohighlight}\]](../../applications/python/adapt_vqe.html#Commutator-%5BH,-A_i%5D){.reference
            .internal}
        -   [Reference
            State:](../../applications/python/adapt_vqe.html#Reference-State:){.reference
            .internal}
        -   [Quantum
            kernels:](../../applications/python/adapt_vqe.html#Quantum-kernels:){.reference
            .internal}
        -   [Beginning of
            ADAPT-VQE:](../../applications/python/adapt_vqe.html#Beginning-of-ADAPT-VQE:){.reference
            .internal}
    -   [Quantum edge
        detection](../../applications/python/edge_detection.html){.reference
        .internal}
        -   [Image](../../applications/python/edge_detection.html#Image){.reference
            .internal}
        -   [Quantum Probability Image Encoding
            (QPIE):](../../applications/python/edge_detection.html#Quantum-Probability-Image-Encoding-(QPIE):){.reference
            .internal}
            -   [Below we show how to encode an image using QPIE in
                cudaq.](../../applications/python/edge_detection.html#Below-we-show-how-to-encode-an-image-using-QPIE-in-cudaq.){.reference
                .internal}
        -   [Flexible Representation of Quantum Images
            (FRQI):](../../applications/python/edge_detection.html#Flexible-Representation-of-Quantum-Images-(FRQI):){.reference
            .internal}
            -   [Building the FRQI
                State:](../../applications/python/edge_detection.html#Building-the-FRQI-State:){.reference
                .internal}
        -   [Quantum Hadamard Edge Detection
            (QHED)](../../applications/python/edge_detection.html#Quantum-Hadamard-Edge-Detection-(QHED)){.reference
            .internal}
            -   [Post-processing](../../applications/python/edge_detection.html#Post-processing){.reference
                .internal}
    -   [Factoring Integers With Shor's
        Algorithm](../../applications/python/shors.html){.reference
        .internal}
        -   [Shor's
            algorithm](../../applications/python/shors.html#Shor's-algorithm){.reference
            .internal}
            -   [Solving the order-finding problem
                classically](../../applications/python/shors.html#Solving-the-order-finding-problem-classically){.reference
                .internal}
            -   [Solving the order-finding problem with a quantum
                algorithm](../../applications/python/shors.html#Solving-the-order-finding-problem-with-a-quantum-algorithm){.reference
                .internal}
            -   [Determining the order from the measurement results of
                the phase
                kernel](../../applications/python/shors.html#Determining-the-order-from-the-measurement-results-of-the-phase-kernel){.reference
                .internal}
            -   [Postscript](../../applications/python/shors.html#Postscript){.reference
                .internal}
    -   [Generating the electronic
        Hamiltonian](../../applications/python/generate_fermionic_ham.html){.reference
        .internal}
        -   [Second Quantized
            formulation.](../../applications/python/generate_fermionic_ham.html#Second-Quantized-formulation.){.reference
            .internal}
            -   [Computational
                Implementation](../../applications/python/generate_fermionic_ham.html#Computational-Implementation){.reference
                .internal}
            -   [(a) Generate the molecular Hamiltonian using Restricted
                Hartree Fock molecular
                orbitals](../../applications/python/generate_fermionic_ham.html#(a)-Generate-the-molecular-Hamiltonian-using-Restricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(b) Generate the molecular Hamiltonian using
                Unrestricted Hartree Fock molecular
                orbitals](../../applications/python/generate_fermionic_ham.html#(b)-Generate-the-molecular-Hamiltonian-using-Unrestricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(a) Generate the active space hamiltonian using RHF
                molecular
                orbitals.](../../applications/python/generate_fermionic_ham.html#(a)-Generate-the-active-space-hamiltonian-using-RHF-molecular-orbitals.){.reference
                .internal}
            -   [(b) Generate the active space Hamiltonian using the
                natural orbitals computed from MP2
                simulation](../../applications/python/generate_fermionic_ham.html#(b)-Generate-the-active-space-Hamiltonian-using-the-natural-orbitals-computed-from-MP2-simulation){.reference
                .internal}
            -   [(c) Generate the active space Hamiltonian computed from
                the CASSCF molecular
                orbitals](../../applications/python/generate_fermionic_ham.html#(c)-Generate-the-active-space-Hamiltonian-computed-from-the-CASSCF-molecular-orbitals){.reference
                .internal}
            -   [(d) Generate the electronic Hamiltonian using
                ROHF](../../applications/python/generate_fermionic_ham.html#(d)-Generate-the-electronic-Hamiltonian-using-ROHF){.reference
                .internal}
            -   [(e) Generate electronic Hamiltonian using
                UHF](../../applications/python/generate_fermionic_ham.html#(e)-Generate-electronic-Hamiltonian-using-UHF){.reference
                .internal}
    -   [Grover's
        Algorithm](../../applications/python/grovers.html){.reference
        .internal}
        -   [Overview](../../applications/python/grovers.html#Overview){.reference
            .internal}
        -   [Problem](../../applications/python/grovers.html#Problem){.reference
            .internal}
        -   [Structure of Grover's
            Algorithm](../../applications/python/grovers.html#Structure-of-Grover's-Algorithm){.reference
            .internal}
            -   [Step 1:
                Preparation](../../applications/python/grovers.html#Step-1:-Preparation){.reference
                .internal}
            -   [Good and Bad
                States](../../applications/python/grovers.html#Good-and-Bad-States){.reference
                .internal}
            -   [Step 2: Oracle
                application](../../applications/python/grovers.html#Step-2:-Oracle-application){.reference
                .internal}
            -   [Step 3: Amplitude
                amplification](../../applications/python/grovers.html#Step-3:-Amplitude-amplification){.reference
                .internal}
            -   [Steps 4 and 5: Iteration and
                measurement](../../applications/python/grovers.html#Steps-4-and-5:-Iteration-and-measurement){.reference
                .internal}
    -   [Quantum
        PageRank](../../applications/python/quantum_pagerank.html){.reference
        .internal}
        -   [Problem
            Definition](../../applications/python/quantum_pagerank.html#Problem-Definition){.reference
            .internal}
        -   [Simulating Quantum PageRank by CUDA-Q
            dynamics](../../applications/python/quantum_pagerank.html#Simulating-Quantum-PageRank-by-CUDA-Q-dynamics){.reference
            .internal}
        -   [Breakdown of
            Terms](../../applications/python/quantum_pagerank.html#Breakdown-of-Terms){.reference
            .internal}
    -   [The UCCSD Wavefunction
        ansatz](../../applications/python/uccsd_wf_ansatz.html){.reference
        .internal}
        -   [What is
            UCCSD?](../../applications/python/uccsd_wf_ansatz.html#What-is-UCCSD?){.reference
            .internal}
        -   [Implementation in Quantum
            Computing](../../applications/python/uccsd_wf_ansatz.html#Implementation-in-Quantum-Computing){.reference
            .internal}
        -   [Run
            VQE](../../applications/python/uccsd_wf_ansatz.html#Run-VQE){.reference
            .internal}
        -   [Challenges and
            consideration](../../applications/python/uccsd_wf_ansatz.html#Challenges-and-consideration){.reference
            .internal}
    -   [Approximate State Preparation using MPS Sequential
        Encoding](../../applications/python/mps_encoding.html){.reference
        .internal}
        -   [Ran's
            approach](../../applications/python/mps_encoding.html#Ran's-approach){.reference
            .internal}
    -   [QM/MM simulation: VQE within a Polarizable Embedded
        Framework.](../../applications/python/qm_mm_pe.html){.reference
        .internal}
        -   [Key
            concepts:](../../applications/python/qm_mm_pe.html#Key-concepts:){.reference
            .internal}
        -   [PE-VQE-SCF Algorithm
            Steps](../../applications/python/qm_mm_pe.html#PE-VQE-SCF-Algorithm-Steps){.reference
            .internal}
            -   [Step 1: Initialize (Classical
                pre-processing)](../../applications/python/qm_mm_pe.html#Step-1:-Initialize-(Classical-pre-processing)){.reference
                .internal}
            -   [Step 2: Build the
                Hamiltonian](../../applications/python/qm_mm_pe.html#Step-2:-Build-the-Hamiltonian){.reference
                .internal}
            -   [Step 3: Run
                VQE](../../applications/python/qm_mm_pe.html#Step-3:-Run-VQE){.reference
                .internal}
            -   [Step 4: Update
                Environment](../../applications/python/qm_mm_pe.html#Step-4:-Update-Environment){.reference
                .internal}
            -   [Step 5: Self-Consistency
                Loop](../../applications/python/qm_mm_pe.html#Step-5:-Self-Consistency-Loop){.reference
                .internal}
            -   [Requirments:](../../applications/python/qm_mm_pe.html#Requirments:){.reference
                .internal}
            -   [Example 1: LiH with 2 water
                molecules.](../../applications/python/qm_mm_pe.html#Example-1:-LiH-with-2-water-molecules.){.reference
                .internal}
            -   [VQE, update environment, and scf
                loop.](../../applications/python/qm_mm_pe.html#VQE,-update-environment,-and-scf-loop.){.reference
                .internal}
            -   [Example 2: NH3 with 46 water molecule using active
                space.](../../applications/python/qm_mm_pe.html#Example-2:-NH3-with-46-water-molecule-using-active-space.){.reference
                .internal}
    -   [Sample-Based Krylov Quantum Diagonalization
        (SKQD)](../../applications/python/skqd.html){.reference
        .internal}
        -   [Why
            SKQD?](../../applications/python/skqd.html#Why-SKQD?){.reference
            .internal}
        -   [Understanding Krylov
            Subspaces](../../applications/python/skqd.html#Understanding-Krylov-Subspaces){.reference
            .internal}
            -   [What is a Krylov
                Subspace?](../../applications/python/skqd.html#What-is-a-Krylov-Subspace?){.reference
                .internal}
            -   [The SKQD
                Algorithm](../../applications/python/skqd.html#The-SKQD-Algorithm){.reference
                .internal}
        -   [Problem Setup: 22-Qubit Heisenberg
            Model](../../applications/python/skqd.html#Problem-Setup:-22-Qubit-Heisenberg-Model){.reference
            .internal}
        -   [Krylov State Generation via Repeated
            Evolution](../../applications/python/skqd.html#Krylov-State-Generation-via-Repeated-Evolution){.reference
            .internal}
        -   [Quantum Measurements and
            Sampling](../../applications/python/skqd.html#Quantum-Measurements-and-Sampling){.reference
            .internal}
            -   [The Sampling
                Process](../../applications/python/skqd.html#The-Sampling-Process){.reference
                .internal}
        -   [Classical Post-Processing and
            Diagonalization](../../applications/python/skqd.html#Classical-Post-Processing-and-Diagonalization){.reference
            .internal}
            -   [The SKQD Algorithm: Matrix Construction
                Details](../../applications/python/skqd.html#The-SKQD-Algorithm:-Matrix-Construction-Details){.reference
                .internal}
        -   [Results Analysis and
            Convergence](../../applications/python/skqd.html#Results-Analysis-and-Convergence){.reference
            .internal}
            -   [What to
                Expect:](../../applications/python/skqd.html#What-to-Expect:){.reference
                .internal}
        -   [GPU Acceleration for
            Postprocessing](../../applications/python/skqd.html#GPU-Acceleration-for-Postprocessing){.reference
            .internal}
    -   [Entanglement Accelerates Quantum
        Simulation](../../applications/python/entanglement_acc_hamiltonian_simulation.html){.reference
        .internal}
        -   [2. Model
            Definition](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.-Model-Definition){.reference
            .internal}
            -   [2.1 Initial product
                state](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.1-Initial-product-state){.reference
                .internal}
            -   [2.2 QIMF
                Hamiltonian](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.2-QIMF-Hamiltonian){.reference
                .internal}
            -   [2.3 First-Order Trotter Formula
                (PF1)](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.3-First-Order-Trotter-Formula-(PF1)){.reference
                .internal}
            -   [2.4 PF1 step for the QIMF
                partition](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.4-PF1-step-for-the-QIMF-partition){.reference
                .internal}
            -   [2.5 Hamiltonian
                helpers](../../applications/python/entanglement_acc_hamiltonian_simulation.html#2.5-Hamiltonian-helpers){.reference
                .internal}
        -   [3. Entanglement
            metrics](../../applications/python/entanglement_acc_hamiltonian_simulation.html#3.-Entanglement-metrics){.reference
            .internal}
        -   [4. Simulation
            workflow](../../applications/python/entanglement_acc_hamiltonian_simulation.html#4.-Simulation-workflow){.reference
            .internal}
            -   [4.1 Single-step Trotter
                error](../../applications/python/entanglement_acc_hamiltonian_simulation.html#4.1-Single-step-Trotter-error){.reference
                .internal}
            -   [4.2 Dual trajectory
                update](../../applications/python/entanglement_acc_hamiltonian_simulation.html#4.2-Dual-trajectory-update){.reference
                .internal}
        -   [5. Reproducing the paper's Figure
            1a](../../applications/python/entanglement_acc_hamiltonian_simulation.html#5.-Reproducing-the-papers-Figure-1a){.reference
            .internal}
            -   [5.1 Visualising the joint
                behaviour](../../applications/python/entanglement_acc_hamiltonian_simulation.html#5.1-Visualising-the-joint-behaviour){.reference
                .internal}
            -   [5.2 Interpreting the
                result](../../applications/python/entanglement_acc_hamiltonian_simulation.html#5.2-Interpreting-the-result){.reference
                .internal}
        -   [6. References and further
            reading](../../applications/python/entanglement_acc_hamiltonian_simulation.html#6.-References-and-further-reading){.reference
            .internal}
-   [Backends](../../using/backends/backends.html){.reference .internal}
    -   [Circuit
        Simulation](../../using/backends/simulators.html){.reference
        .internal}
        -   [State Vector
            Simulators](../../using/backends/sims/svsims.html){.reference
            .internal}
            -   [CPU](../../using/backends/sims/svsims.html#cpu){.reference
                .internal}
            -   [Single-GPU](../../using/backends/sims/svsims.html#single-gpu){.reference
                .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/svsims.html#multi-gpu-multi-node){.reference
                .internal}
        -   [Tensor Network
            Simulators](../../using/backends/sims/tnsims.html){.reference
            .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/tnsims.html#multi-gpu-multi-node){.reference
                .internal}
            -   [Matrix product
                state](../../using/backends/sims/tnsims.html#matrix-product-state){.reference
                .internal}
            -   [Fermioniq](../../using/backends/sims/tnsims.html#fermioniq){.reference
                .internal}
        -   [Multi-QPU
            Simulators](../../using/backends/sims/mqpusims.html){.reference
            .internal}
            -   [Simulate Multiple QPUs in
                Parallel](../../using/backends/sims/mqpusims.html#simulate-multiple-qpus-in-parallel){.reference
                .internal}
            -   [Multi-QPU + Other
                Backends](../../using/backends/sims/mqpusims.html#multi-qpu-other-backends){.reference
                .internal}
        -   [Noisy
            Simulators](../../using/backends/sims/noisy.html){.reference
            .internal}
            -   [Trajectory Noisy
                Simulation](../../using/backends/sims/noisy.html#trajectory-noisy-simulation){.reference
                .internal}
            -   [Density
                Matrix](../../using/backends/sims/noisy.html#density-matrix){.reference
                .internal}
            -   [Stim](../../using/backends/sims/noisy.html#stim){.reference
                .internal}
        -   [Photonics
            Simulators](../../using/backends/sims/photonics.html){.reference
            .internal}
            -   [orca-photonics](../../using/backends/sims/photonics.html#orca-photonics){.reference
                .internal}
    -   [Quantum Hardware
        (QPUs)](../../using/backends/hardware.html){.reference
        .internal}
        -   [Ion Trap
            QPUs](../../using/backends/hardware/iontrap.html){.reference
            .internal}
            -   [IonQ](../../using/backends/hardware/iontrap.html#ionq){.reference
                .internal}
            -   [Quantinuum](../../using/backends/hardware/iontrap.html#quantinuum){.reference
                .internal}
        -   [Superconducting
            QPUs](../../using/backends/hardware/superconducting.html){.reference
            .internal}
            -   [Anyon Technologies/Anyon
                Computing](../../using/backends/hardware/superconducting.html#anyon-technologies-anyon-computing){.reference
                .internal}
            -   [IQM](../../using/backends/hardware/superconducting.html#iqm){.reference
                .internal}
            -   [OQC](../../using/backends/hardware/superconducting.html#oqc){.reference
                .internal}
            -   [Quantum Circuits,
                Inc.](../../using/backends/hardware/superconducting.html#quantum-circuits-inc){.reference
                .internal}
        -   [Neutral Atom
            QPUs](../../using/backends/hardware/neutralatom.html){.reference
            .internal}
            -   [Infleqtion](../../using/backends/hardware/neutralatom.html#infleqtion){.reference
                .internal}
            -   [Pasqal](../../using/backends/hardware/neutralatom.html#pasqal){.reference
                .internal}
            -   [QuEra
                Computing](../../using/backends/hardware/neutralatom.html#quera-computing){.reference
                .internal}
        -   [Photonic
            QPUs](../../using/backends/hardware/photonic.html){.reference
            .internal}
            -   [ORCA
                Computing](../../using/backends/hardware/photonic.html#orca-computing){.reference
                .internal}
        -   [Quantum Control
            Systems](../../using/backends/hardware/qcontrol.html){.reference
            .internal}
            -   [Quantum
                Machines](../../using/backends/hardware/qcontrol.html#quantum-machines){.reference
                .internal}
    -   [Dynamics
        Simulation](../../using/backends/dynamics_backends.html){.reference
        .internal}
    -   [Cloud](../../using/backends/cloud.html){.reference .internal}
        -   [Amazon Braket
            (braket)](../../using/backends/cloud/braket.html){.reference
            .internal}
            -   [Setting
                Credentials](../../using/backends/cloud/braket.html#setting-credentials){.reference
                .internal}
            -   [Submission from
                C++](../../using/backends/cloud/braket.html#submission-from-c){.reference
                .internal}
            -   [Submission from
                Python](../../using/backends/cloud/braket.html#submission-from-python){.reference
                .internal}
-   [Dynamics](../../using/dynamics.html){.reference .internal}
    -   [Quick Start](../../using/dynamics.html#quick-start){.reference
        .internal}
    -   [Operator](../../using/dynamics.html#operator){.reference
        .internal}
    -   [Time-Dependent
        Dynamics](../../using/dynamics.html#time-dependent-dynamics){.reference
        .internal}
    -   [Super-operator
        Representation](../../using/dynamics.html#super-operator-representation){.reference
        .internal}
    -   [Numerical
        Integrators](../../using/dynamics.html#numerical-integrators){.reference
        .internal}
    -   [Batch
        simulation](../../using/dynamics.html#batch-simulation){.reference
        .internal}
    -   [Multi-GPU Multi-Node
        Execution](../../using/dynamics.html#multi-gpu-multi-node-execution){.reference
        .internal}
    -   [Examples](../../using/dynamics.html#examples){.reference
        .internal}
-   [CUDA-QX](../../using/cudaqx/cudaqx.html){.reference .internal}
    -   [CUDA-Q
        Solvers](../../using/cudaqx/cudaqx.html#cuda-q-solvers){.reference
        .internal}
    -   [CUDA-Q
        QEC](../../using/cudaqx/cudaqx.html#cuda-q-qec){.reference
        .internal}
-   [Installation](../../using/install/install.html){.reference
    .internal}
    -   [Local
        Installation](../../using/install/local_installation.html){.reference
        .internal}
        -   [Introduction](../../using/install/local_installation.html#introduction){.reference
            .internal}
            -   [Docker](../../using/install/local_installation.html#docker){.reference
                .internal}
            -   [Known Blackwell
                Issues](../../using/install/local_installation.html#known-blackwell-issues){.reference
                .internal}
            -   [Singularity](../../using/install/local_installation.html#singularity){.reference
                .internal}
            -   [Python
                wheels](../../using/install/local_installation.html#python-wheels){.reference
                .internal}
            -   [Pre-built
                binaries](../../using/install/local_installation.html#pre-built-binaries){.reference
                .internal}
        -   [Development with VS
            Code](../../using/install/local_installation.html#development-with-vs-code){.reference
            .internal}
            -   [Using a Docker
                container](../../using/install/local_installation.html#using-a-docker-container){.reference
                .internal}
            -   [Using a Singularity
                container](../../using/install/local_installation.html#using-a-singularity-container){.reference
                .internal}
        -   [Connecting to a Remote
            Host](../../using/install/local_installation.html#connecting-to-a-remote-host){.reference
            .internal}
            -   [Developing with Remote
                Tunnels](../../using/install/local_installation.html#developing-with-remote-tunnels){.reference
                .internal}
            -   [Remote Access via
                SSH](../../using/install/local_installation.html#remote-access-via-ssh){.reference
                .internal}
        -   [DGX
            Cloud](../../using/install/local_installation.html#dgx-cloud){.reference
            .internal}
            -   [Get
                Started](../../using/install/local_installation.html#get-started){.reference
                .internal}
            -   [Use
                JupyterLab](../../using/install/local_installation.html#use-jupyterlab){.reference
                .internal}
            -   [Use VS
                Code](../../using/install/local_installation.html#use-vs-code){.reference
                .internal}
        -   [Additional CUDA
            Tools](../../using/install/local_installation.html#additional-cuda-tools){.reference
            .internal}
            -   [Installation via
                PyPI](../../using/install/local_installation.html#installation-via-pypi){.reference
                .internal}
            -   [Installation In Container
                Images](../../using/install/local_installation.html#installation-in-container-images){.reference
                .internal}
            -   [Installing Pre-built
                Binaries](../../using/install/local_installation.html#installing-pre-built-binaries){.reference
                .internal}
        -   [Distributed Computing with
            MPI](../../using/install/local_installation.html#distributed-computing-with-mpi){.reference
            .internal}
        -   [Updating
            CUDA-Q](../../using/install/local_installation.html#updating-cuda-q){.reference
            .internal}
        -   [Dependencies and
            Compatibility](../../using/install/local_installation.html#dependencies-and-compatibility){.reference
            .internal}
        -   [Next
            Steps](../../using/install/local_installation.html#next-steps){.reference
            .internal}
    -   [Data Center
        Installation](../../using/install/data_center_install.html){.reference
        .internal}
        -   [Prerequisites](../../using/install/data_center_install.html#prerequisites){.reference
            .internal}
        -   [Build
            Dependencies](../../using/install/data_center_install.html#build-dependencies){.reference
            .internal}
            -   [CUDA](../../using/install/data_center_install.html#cuda){.reference
                .internal}
            -   [Toolchain](../../using/install/data_center_install.html#toolchain){.reference
                .internal}
        -   [Building
            CUDA-Q](../../using/install/data_center_install.html#building-cuda-q){.reference
            .internal}
        -   [Python
            Support](../../using/install/data_center_install.html#python-support){.reference
            .internal}
        -   [C++
            Support](../../using/install/data_center_install.html#c-support){.reference
            .internal}
        -   [Installation on the
            Host](../../using/install/data_center_install.html#installation-on-the-host){.reference
            .internal}
            -   [CUDA Runtime
                Libraries](../../using/install/data_center_install.html#cuda-runtime-libraries){.reference
                .internal}
            -   [MPI](../../using/install/data_center_install.html#mpi){.reference
                .internal}
-   [Integration](../../using/integration/integration.html){.reference
    .internal}
    -   [Downstream CMake
        Integration](../../using/integration/cmake_app.html){.reference
        .internal}
    -   [Combining CUDA with
        CUDA-Q](../../using/integration/cuda_gpu.html){.reference
        .internal}
    -   [Integrating with Third-Party
        Libraries](../../using/integration/libraries.html){.reference
        .internal}
        -   [Calling a CUDA-Q library from
            C++](../../using/integration/libraries.html#calling-a-cuda-q-library-from-c){.reference
            .internal}
        -   [Calling an C++ library from
            CUDA-Q](../../using/integration/libraries.html#calling-an-c-library-from-cuda-q){.reference
            .internal}
        -   [Interfacing between binaries compiled with a different
            toolchains](../../using/integration/libraries.html#interfacing-between-binaries-compiled-with-a-different-toolchains){.reference
            .internal}
-   [Extending](../../using/extending/extending.html){.reference
    .internal}
    -   [Add a new Hardware
        Backend](../../using/extending/backend.html){.reference
        .internal}
        -   [Overview](../../using/extending/backend.html#overview){.reference
            .internal}
        -   [Server Helper
            Implementation](../../using/extending/backend.html#server-helper-implementation){.reference
            .internal}
            -   [Directory
                Structure](../../using/extending/backend.html#directory-structure){.reference
                .internal}
            -   [Server Helper
                Class](../../using/extending/backend.html#server-helper-class){.reference
                .internal}
            -   [[`CMakeLists.txt`{.docutils .literal
                .notranslate}]{.pre}](../../using/extending/backend.html#cmakelists-txt){.reference
                .internal}
        -   [Target
            Configuration](../../using/extending/backend.html#target-configuration){.reference
            .internal}
            -   [Update Parent [`CMakeLists.txt`{.docutils .literal
                .notranslate}]{.pre}](../../using/extending/backend.html#update-parent-cmakelists-txt){.reference
                .internal}
        -   [Testing](../../using/extending/backend.html#testing){.reference
            .internal}
            -   [Unit
                Tests](../../using/extending/backend.html#unit-tests){.reference
                .internal}
            -   [Mock
                Server](../../using/extending/backend.html#mock-server){.reference
                .internal}
            -   [Python
                Tests](../../using/extending/backend.html#python-tests){.reference
                .internal}
            -   [Integration
                Tests](../../using/extending/backend.html#integration-tests){.reference
                .internal}
        -   [Documentation](../../using/extending/backend.html#documentation){.reference
            .internal}
        -   [Example
            Usage](../../using/extending/backend.html#example-usage){.reference
            .internal}
        -   [Code
            Review](../../using/extending/backend.html#code-review){.reference
            .internal}
        -   [Maintaining a
            Backend](../../using/extending/backend.html#maintaining-a-backend){.reference
            .internal}
        -   [Conclusion](../../using/extending/backend.html#conclusion){.reference
            .internal}
    -   [Create a new NVQIR
        Simulator](../../using/extending/nvqir_simulator.html){.reference
        .internal}
        -   [[`CircuitSimulator`{.code .docutils .literal
            .notranslate}]{.pre}](../../using/extending/nvqir_simulator.html#circuitsimulator){.reference
            .internal}
        -   [Let's see this in
            action](../../using/extending/nvqir_simulator.html#let-s-see-this-in-action){.reference
            .internal}
    -   [Working with CUDA-Q
        IR](../../using/extending/cudaq_ir.html){.reference .internal}
    -   [Create an MLIR Pass for
        CUDA-Q](../../using/extending/mlir_pass.html){.reference
        .internal}
-   [Specifications](../../specification/index.html){.reference
    .internal}
    -   [Language
        Specification](../../specification/cudaq.html){.reference
        .internal}
        -   [1. Machine
            Model](../../specification/cudaq/machine_model.html){.reference
            .internal}
        -   [2. Namespace and
            Standard](../../specification/cudaq/namespace.html){.reference
            .internal}
        -   [3. Quantum
            Types](../../specification/cudaq/types.html){.reference
            .internal}
            -   [3.1. [`cudaq::qudit<Levels>`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/types.html#cudaq-qudit-levels){.reference
                .internal}
            -   [3.2. [`cudaq::qubit`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/types.html#cudaq-qubit){.reference
                .internal}
            -   [3.3. Quantum
                Containers](../../specification/cudaq/types.html#quantum-containers){.reference
                .internal}
        -   [4. Quantum
            Operators](../../specification/cudaq/operators.html){.reference
            .internal}
            -   [4.1. [`cudaq::spin_op`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/operators.html#cudaq-spin-op){.reference
                .internal}
        -   [5. Quantum
            Operations](../../specification/cudaq/operations.html){.reference
            .internal}
            -   [5.1. Operations on [`cudaq::qubit`{.code .docutils
                .literal
                .notranslate}]{.pre}](../../specification/cudaq/operations.html#operations-on-cudaq-qubit){.reference
                .internal}
        -   [6. Quantum
            Kernels](../../specification/cudaq/kernels.html){.reference
            .internal}
        -   [7. Sub-circuit
            Synthesis](../../specification/cudaq/synthesis.html){.reference
            .internal}
        -   [8. Control
            Flow](../../specification/cudaq/control_flow.html){.reference
            .internal}
        -   [9. Just-in-Time Kernel
            Creation](../../specification/cudaq/dynamic_kernels.html){.reference
            .internal}
        -   [10. Quantum
            Patterns](../../specification/cudaq/patterns.html){.reference
            .internal}
            -   [10.1.
                Compute-Action-Uncompute](../../specification/cudaq/patterns.html#compute-action-uncompute){.reference
                .internal}
        -   [11.
            Platform](../../specification/cudaq/platform.html){.reference
            .internal}
        -   [12. Algorithmic
            Primitives](../../specification/cudaq/algorithmic_primitives.html){.reference
            .internal}
            -   [12.1. [`cudaq::sample`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/algorithmic_primitives.html#cudaq-sample){.reference
                .internal}
            -   [12.2. [`cudaq::run`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/algorithmic_primitives.html#cudaq-run){.reference
                .internal}
            -   [12.3. [`cudaq::observe`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/algorithmic_primitives.html#cudaq-observe){.reference
                .internal}
            -   [12.4. [`cudaq::optimizer`{.code .docutils .literal
                .notranslate}]{.pre} (deprecated, functionality moved to
                CUDA-Q
                libraries)](../../specification/cudaq/algorithmic_primitives.html#cudaq-optimizer-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
            -   [12.5. [`cudaq::gradient`{.code .docutils .literal
                .notranslate}]{.pre} (deprecated, functionality moved to
                CUDA-Q
                libraries)](../../specification/cudaq/algorithmic_primitives.html#cudaq-gradient-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
        -   [13. Example
            Programs](../../specification/cudaq/examples.html){.reference
            .internal}
            -   [13.1. Hello World - Simple Bell
                State](../../specification/cudaq/examples.html#hello-world-simple-bell-state){.reference
                .internal}
            -   [13.2. GHZ State Preparation and
                Sampling](../../specification/cudaq/examples.html#ghz-state-preparation-and-sampling){.reference
                .internal}
            -   [13.3. Quantum Phase
                Estimation](../../specification/cudaq/examples.html#quantum-phase-estimation){.reference
                .internal}
            -   [13.4. Deuteron Binding Energy Parameter
                Sweep](../../specification/cudaq/examples.html#deuteron-binding-energy-parameter-sweep){.reference
                .internal}
            -   [13.5. Grover's
                Algorithm](../../specification/cudaq/examples.html#grover-s-algorithm){.reference
                .internal}
            -   [13.6. Iterative Phase
                Estimation](../../specification/cudaq/examples.html#iterative-phase-estimation){.reference
                .internal}
    -   [Quake
        Specification](../../specification/quake-dialect.html){.reference
        .internal}
        -   [General
            Introduction](../../specification/quake-dialect.html#general-introduction){.reference
            .internal}
        -   [Motivation](../../specification/quake-dialect.html#motivation){.reference
            .internal}
-   [API Reference](../api.html){.reference .internal}
    -   [C++ API](cpp_api.html){.reference .internal}
        -   [Operators](cpp_api.html#operators){.reference .internal}
        -   [Quantum](cpp_api.html#quantum){.reference .internal}
        -   [Common](cpp_api.html#common){.reference .internal}
        -   [Noise Modeling](cpp_api.html#noise-modeling){.reference
            .internal}
        -   [Kernel Builder](cpp_api.html#kernel-builder){.reference
            .internal}
        -   [Algorithms](cpp_api.html#algorithms){.reference .internal}
        -   [Platform](cpp_api.html#platform){.reference .internal}
        -   [Utilities](cpp_api.html#utilities){.reference .internal}
        -   [Namespaces](cpp_api.html#namespaces){.reference .internal}
    -   [Python API](#){.current .reference .internal}
        -   [Program Construction](#program-construction){.reference
            .internal}
            -   [[`make_kernel()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.make_kernel){.reference
                .internal}
            -   [[`PyKernel`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.PyKernel){.reference
                .internal}
            -   [[`Kernel`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.Kernel){.reference
                .internal}
            -   [[`PyKernelDecorator`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.PyKernelDecorator){.reference
                .internal}
            -   [[`kernel()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.kernel){.reference
                .internal}
        -   [Kernel Execution](#kernel-execution){.reference .internal}
            -   [[`sample()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.sample){.reference
                .internal}
            -   [[`sample_async()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.sample_async){.reference
                .internal}
            -   [[`run()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.run){.reference .internal}
            -   [[`run_async()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.run_async){.reference
                .internal}
            -   [[`observe()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.observe){.reference
                .internal}
            -   [[`observe_async()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.observe_async){.reference
                .internal}
            -   [[`get_state()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.get_state){.reference
                .internal}
            -   [[`get_state_async()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.get_state_async){.reference
                .internal}
            -   [[`vqe()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.vqe){.reference .internal}
            -   [[`draw()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.draw){.reference .internal}
            -   [[`translate()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.translate){.reference
                .internal}
            -   [[`estimate_resources()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.estimate_resources){.reference
                .internal}
        -   [Backend Configuration](#backend-configuration){.reference
            .internal}
            -   [[`has_target()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.has_target){.reference
                .internal}
            -   [[`get_target()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.get_target){.reference
                .internal}
            -   [[`get_targets()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.get_targets){.reference
                .internal}
            -   [[`set_target()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.set_target){.reference
                .internal}
            -   [[`reset_target()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.reset_target){.reference
                .internal}
            -   [[`set_noise()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.set_noise){.reference
                .internal}
            -   [[`unset_noise()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.unset_noise){.reference
                .internal}
            -   [[`register_set_target_callback()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.register_set_target_callback){.reference
                .internal}
            -   [[`unregister_set_target_callback()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.unregister_set_target_callback){.reference
                .internal}
            -   [[`cudaq.apply_noise()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.cudaq.apply_noise){.reference
                .internal}
            -   [[`initialize_cudaq()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.initialize_cudaq){.reference
                .internal}
            -   [[`num_available_gpus()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.num_available_gpus){.reference
                .internal}
            -   [[`set_random_seed()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.set_random_seed){.reference
                .internal}
        -   [Dynamics](#dynamics){.reference .internal}
            -   [[`evolve()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.evolve){.reference
                .internal}
            -   [[`evolve_async()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.evolve_async){.reference
                .internal}
            -   [[`Schedule`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.Schedule){.reference
                .internal}
            -   [[`BaseIntegrator`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.dynamics.integrator.BaseIntegrator){.reference
                .internal}
            -   [[`InitialState`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.dynamics.helpers.InitialState){.reference
                .internal}
            -   [[`InitialStateType`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.InitialStateType){.reference
                .internal}
            -   [[`IntermediateResultSave`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.IntermediateResultSave){.reference
                .internal}
        -   [Operators](#operators){.reference .internal}
            -   [[`OperatorSum`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.operators.OperatorSum){.reference
                .internal}
            -   [[`ProductOperator`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.operators.ProductOperator){.reference
                .internal}
            -   [[`ElementaryOperator`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.operators.ElementaryOperator){.reference
                .internal}
            -   [[`ScalarOperator`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.operators.ScalarOperator){.reference
                .internal}
            -   [[`RydbergHamiltonian`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.operators.RydbergHamiltonian){.reference
                .internal}
            -   [[`SuperOperator`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.SuperOperator){.reference
                .internal}
            -   [[`operators.define()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.operators.define){.reference
                .internal}
            -   [[`operators.instantiate()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.operators.instantiate){.reference
                .internal}
            -   [Spin Operators](#spin-operators){.reference .internal}
            -   [Fermion Operators](#fermion-operators){.reference
                .internal}
            -   [Boson Operators](#boson-operators){.reference
                .internal}
            -   [General Operators](#general-operators){.reference
                .internal}
        -   [Data Types](#data-types){.reference .internal}
            -   [[`SimulationPrecision`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.SimulationPrecision){.reference
                .internal}
            -   [[`Target`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.Target){.reference
                .internal}
            -   [[`State`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.State){.reference
                .internal}
            -   [[`Tensor`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.Tensor){.reference
                .internal}
            -   [[`QuakeValue`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.QuakeValue){.reference
                .internal}
            -   [[`qubit`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.qubit){.reference
                .internal}
            -   [[`qreg`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.qreg){.reference .internal}
            -   [[`qvector`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.qvector){.reference
                .internal}
            -   [[`ComplexMatrix`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.ComplexMatrix){.reference
                .internal}
            -   [[`SampleResult`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.SampleResult){.reference
                .internal}
            -   [[`AsyncSampleResult`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.AsyncSampleResult){.reference
                .internal}
            -   [[`ObserveResult`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.ObserveResult){.reference
                .internal}
            -   [[`AsyncObserveResult`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.AsyncObserveResult){.reference
                .internal}
            -   [[`AsyncStateResult`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.AsyncStateResult){.reference
                .internal}
            -   [[`OptimizationResult`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.OptimizationResult){.reference
                .internal}
            -   [[`EvolveResult`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.EvolveResult){.reference
                .internal}
            -   [[`AsyncEvolveResult`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.AsyncEvolveResult){.reference
                .internal}
            -   [[`Resources`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.Resources){.reference
                .internal}
            -   [Optimizers](#optimizers){.reference .internal}
            -   [Gradients](#gradients){.reference .internal}
            -   [Noisy Simulation](#noisy-simulation){.reference
                .internal}
        -   [MPI Submodule](#mpi-submodule){.reference .internal}
            -   [[`initialize()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.mpi.initialize){.reference
                .internal}
            -   [[`rank()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.mpi.rank){.reference
                .internal}
            -   [[`num_ranks()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.mpi.num_ranks){.reference
                .internal}
            -   [[`all_gather()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.mpi.all_gather){.reference
                .internal}
            -   [[`broadcast()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.mpi.broadcast){.reference
                .internal}
            -   [[`is_initialized()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.mpi.is_initialized){.reference
                .internal}
            -   [[`finalize()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.mpi.finalize){.reference
                .internal}
        -   [ORCA Submodule](#orca-submodule){.reference .internal}
            -   [[`sample()`{.docutils .literal
                .notranslate}]{.pre}](#cudaq.orca.sample){.reference
                .internal}
    -   [Quantum Operations](../default_ops.html){.reference .internal}
        -   [Unitary Operations on
            Qubits](../default_ops.html#unitary-operations-on-qubits){.reference
            .internal}
            -   [[`x`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#x){.reference
                .internal}
            -   [[`y`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#y){.reference
                .internal}
            -   [[`z`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#z){.reference
                .internal}
            -   [[`h`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#h){.reference
                .internal}
            -   [[`r1`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#r1){.reference
                .internal}
            -   [[`rx`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#rx){.reference
                .internal}
            -   [[`ry`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#ry){.reference
                .internal}
            -   [[`rz`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#rz){.reference
                .internal}
            -   [[`s`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#s){.reference
                .internal}
            -   [[`t`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#t){.reference
                .internal}
            -   [[`swap`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#swap){.reference
                .internal}
            -   [[`u3`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#u3){.reference
                .internal}
        -   [Adjoint and Controlled
            Operations](../default_ops.html#adjoint-and-controlled-operations){.reference
            .internal}
        -   [Measurements on
            Qubits](../default_ops.html#measurements-on-qubits){.reference
            .internal}
            -   [[`mz`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#mz){.reference
                .internal}
            -   [[`mx`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#mx){.reference
                .internal}
            -   [[`my`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#my){.reference
                .internal}
        -   [User-Defined Custom
            Operations](../default_ops.html#user-defined-custom-operations){.reference
            .internal}
        -   [Photonic Operations on
            Qudits](../default_ops.html#photonic-operations-on-qudits){.reference
            .internal}
            -   [[`create`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#create){.reference
                .internal}
            -   [[`annihilate`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#annihilate){.reference
                .internal}
            -   [[`phase_shift`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#phase-shift){.reference
                .internal}
            -   [[`beam_splitter`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#beam-splitter){.reference
                .internal}
            -   [[`mz`{.code .docutils .literal
                .notranslate}]{.pre}](../default_ops.html#id1){.reference
                .internal}
-   [Other Versions](../../versions.html){.reference .internal}
:::
:::

::: {.section .wy-nav-content-wrap toggle="wy-nav-shift"}
[NVIDIA CUDA-Q](../../index.html)

::: wy-nav-content
::: rst-content
::: {role="navigation" aria-label="Page navigation"}
-   [](../../index.html){.icon .icon-home aria-label="Home"}
-   [Code documentation](../api.html)
-   CUDA-Q Python API
-   

::: {.rst-breadcrumbs-buttons role="navigation" aria-label="Sequential page navigation"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](cpp_api.html "CUDA-Q C++ API"){.btn .btn-neutral .float-left
accesskey="p"} [Next []{.fa .fa-arrow-circle-right
aria-hidden="true"}](../default_ops.html "Quantum Operations"){.btn
.btn-neutral .float-right accesskey="n"}
:::

------------------------------------------------------------------------
:::

::: {.document role="main" itemscope="itemscope" itemtype="http://schema.org/Article"}
::: {itemprop="articleBody"}
::: {#module-cudaq .section}
[]{#cuda-q-python-api}

# CUDA-Q Python API[](#module-cudaq "Permalink to this heading"){.headerlink}

::: {#program-construction .section}
## Program Construction[](#program-construction "Permalink to this heading"){.headerlink}

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[make_kernel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.make_kernel "Permalink to this definition"){.headerlink}

:   <div>
    >
    > Create a [[`Kernel`{.xref .py .py-class .docutils .literal
    > .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
    > .internal}: An empty kernel function to be used for quantum
    > program construction. This kernel is non-parameterized if it
    > accepts no arguments, else takes the provided types as arguments.
    >
    > Returns a kernel if it is non-parameterized, else a tuple
    > containing the kernel and a [[`QuakeValue`{.xref .py .py-class
    > .docutils .literal
    > .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
    > .internal} for each kernel argument.
    >
    > </div>

    ::: {.highlight-python .notranslate}
    ::: highlight
        # Example:
        # Non-parameterized kernel.
        kernel = cudaq.make_kernel()

        # Example:
        # Parameterized kernel that accepts an `int` and `float` as arguments.
        kernel, int_value, float_value = cudaq.make_kernel(int, float)
    :::
    :::

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[PyKernel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[argTypeList]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.PyKernel "Permalink to this definition"){.headerlink}

:   The [[`Kernel`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
    .internal} provides an API for dynamically constructing quantum
    circuits. The [[`Kernel`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
    .internal} programmatically represents the circuit as an MLIR
    function using the Quake dialect.

    [[name]{.pre}]{.sig-name .descname}[](#cudaq.PyKernel.name "Permalink to this definition"){.headerlink}

    :   The name of the [[`Kernel`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal} function. Read-only.

        Type[:]{.colon}

        :   [[`str`{.xref .py .py-obj .docutils .literal
            .notranslate}]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
            .external}

    [[arguments]{.pre}]{.sig-name .descname}[](#cudaq.PyKernel.arguments "Permalink to this definition"){.headerlink}

    :   The arguments accepted by the [[`Kernel`{.xref .py .py-class
        .docutils .literal
        .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal} function. Read-only.

        Type[:]{.colon}

        :   List\[[[`QuakeValue`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal}\]

    [[argument_count]{.pre}]{.sig-name .descname}[](#cudaq.PyKernel.argument_count "Permalink to this definition"){.headerlink}

    :   The number of arguments accepted by the [[`Kernel`{.xref .py
        .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal} function. Read-only.

        Type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Kernel]{.pre}]{.sig-name .descname}[](#cudaq.Kernel "Permalink to this definition"){.headerlink}

:   alias of [[`PyKernel`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.PyKernel "cudaq.kernel.kernel_builder.PyKernel"){.reference
    .internal}

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[PyKernelDecorator]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[function]{.pre}]{.n}*, *[[verbose]{.pre}]{.n}[[=]{.pre}]{.o}[[False]{.pre}]{.default_value}*, *[[module]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[kernelName]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[signature]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[location]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[overrideGlobalScopedVars]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[decorator]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.PyKernelDecorator "Permalink to this definition"){.headerlink}

:   The [`PyKernelDecorator`{.code .docutils .literal
    .notranslate}]{.pre} serves as a standard Python decorator that
    takes the decorated function as input and optionally lowers its AST
    representation to executable code via MLIR. This decorator enables
    full JIT compilation mode, where the function is lowered to an MLIR
    representation.

    This decorator exposes a call overload that executes the code via
    the MLIR [`ExecutionEngine`{.code .docutils .literal
    .notranslate}]{.pre} for the MLIR mode.

    [[\_\_call\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.PyKernelDecorator.__call__ "Permalink to this definition"){.headerlink}

    :   Invoke the CUDA-Q kernel. JIT compilation of the kernel AOT
        Quake module to machine code will occur here.

    [[\_\_str\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.PyKernelDecorator.__str__ "Permalink to this definition"){.headerlink}

    :   Return the MLIR Module string representation for this kernel.

    [[beta_reduction]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.PyKernelDecorator.beta_reduction "Permalink to this definition"){.headerlink}

    :   Perform beta reduction on this kernel decorator in the current
        calling context. We are primary concerned with resolving the
        lambda lifted arguments, but the formal arguments may be
        supplied as well.

        This beta reduction may happen in a context that is earlier than
        the actual call to the decorator. While this loses some of
        Python's intrinsic dynamism, it allows Python kernels to be
        specialized and passed to algorithms written in C++ that call
        back to these Python kernels in a functional composition.

    [[captured_variables]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.PyKernelDecorator.captured_variables "Permalink to this definition"){.headerlink}

    :   The list of variables captured by the kernel.

    [[delete_cache_execution_engine]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[key]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.PyKernelDecorator.delete_cache_execution_engine "Permalink to this definition"){.headerlink}

    :   Delete the [`ExecutionEngine`{.code .docutils .literal
        .notranslate}]{.pre} cache given by a cache key.

    [[enable_return_to_log]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.PyKernelDecorator.enable_return_to_log "Permalink to this definition"){.headerlink}

    :   Enable translation from [`return`{.code .docutils .literal
        .notranslate}]{.pre} statements to QIR output log

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[jStr]{.pre}]{.n}*, *[[overrideDict]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.PyKernelDecorator.from_json "Permalink to this definition"){.headerlink}

    :   Convert a JSON string into a new PyKernelDecorator object.

    [[handle_call_arguments]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.PyKernelDecorator.handle_call_arguments "Permalink to this definition"){.headerlink}

    :   Resolve all the arguments at the call site for this decorator.

    [[launch_args_required]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.PyKernelDecorator.launch_args_required "Permalink to this definition"){.headerlink}

    :   This is a deeper query on the quake module. The quake module may
        have been specialized such that none of the arguments are, in
        fact, required to be provided in order to run the kernel.
        (Argument synthesis.)

        This will analyze the designated entry-point kernel for the
        quake module and determine if any arguments are used and return
        the number used.

    [[lower_quake_to_codegen]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[argValues]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.PyKernelDecorator.lower_quake_to_codegen "Permalink to this definition"){.headerlink}

    :   Take the quake code as input and lower it to be ready for final
        code generation. If argument values are provided, we run
        argument synthesis and specialize this instance of the kernel.

    [[merge_kernel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[otherMod]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.PyKernelDecorator.merge_kernel "Permalink to this definition"){.headerlink}

    :   Merge the kernel in this PyKernelDecorator (the ModuleOp) with
        the provided ModuleOp.

    [[merge_quake_source]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[quakeText]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.PyKernelDecorator.merge_quake_source "Permalink to this definition"){.headerlink}

    :   Merge a module of quake code from source text form into this
        decorator's [`qkeModule`{.code .docutils .literal
        .notranslate}]{.pre} attribute.

    [[pre_compile]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.PyKernelDecorator.pre_compile "Permalink to this definition"){.headerlink}

    :   Compile the Python AST to portable Quake.

    [[signatureWithCallables]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.PyKernelDecorator.signatureWithCallables "Permalink to this definition"){.headerlink}

    :   returns True if and only if the entry-point contains callable
        arguments and/or return values.

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.PyKernelDecorator.to_json "Permalink to this definition"){.headerlink}

    :   Convert [`self`{.code .docutils .literal .notranslate}]{.pre} to
        a JSON-serialized version of the kernel such that
        [`from_json`{.code .docutils .literal .notranslate}]{.pre} can
        reconstruct it elsewhere.

    *[static]{.pre}[ ]{.w}*[[type_to_str]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[t]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.PyKernelDecorator.type_to_str "Permalink to this definition"){.headerlink}

    :   This converts types to strings in a clean JSON-compatible way.
        int -\> 'int' list\[float\] -\> 'list\[float\]' List\[float\]
        -\> 'list\[float\]'

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[kernel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[function]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.kernel "Permalink to this definition"){.headerlink}

:   The [`cudaq.kernel`{.code .docutils .literal .notranslate}]{.pre}
    represents the CUDA-Q language function attribute that programmers
    leverage to indicate the following function is a CUDA-Q kernel and
    should be compile and executed on an available quantum coprocessor.

    Verbose logging can be enabled via [`verbose=True`{.code .docutils
    .literal .notranslate}]{.pre}.
:::

::: {#kernel-execution .section}
## Kernel Execution[](#kernel-execution "Permalink to this heading"){.headerlink}

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[sample]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[shots_count]{.pre}]{.n}[[=]{.pre}]{.o}[[1000]{.pre}]{.default_value}*, *[[noise_model]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[explicit_measurements]{.pre}]{.n}[[=]{.pre}]{.o}[[False]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.sample "Permalink to this definition"){.headerlink}

:   Sample the state generated by the provided [`kernel`{.code .docutils
    .literal .notranslate}]{.pre} at the given kernel [`arguments`{.code
    .docutils .literal .notranslate}]{.pre} over the specified number of
    circuit executions ([`shots_count`{.code .docutils .literal
    .notranslate}]{.pre}). Each argument in [`arguments`{.code .docutils
    .literal .notranslate}]{.pre} provided can be a list or
    [`ndarray`{.code .docutils .literal .notranslate}]{.pre} of
    arguments of the specified kernel argument type, and in this case,
    the [`sample`{.code .docutils .literal .notranslate}]{.pre}
    functionality will be broadcasted over all argument sets and a list
    of [`sample_result`{.code .docutils .literal .notranslate}]{.pre}
    instances will be returned.

    Parameters[:]{.colon}

    :   -   **kernel** ([[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to execute [`shots_count`{.code .docutils
            .literal .notranslate}]{.pre} times on the QPU.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments. For example, if the
            kernel takes two [`float`{.code .docutils .literal
            .notranslate}]{.pre} values as input, the [`sample`{.code
            .docutils .literal .notranslate}]{.pre} call should be
            structured as [`cudaq.sample(kernel,`{.code .docutils
            .literal .notranslate}]{.pre}` `{.code .docutils .literal
            .notranslate}[`firstFloat,`{.code .docutils .literal
            .notranslate}]{.pre}` `{.code .docutils .literal
            .notranslate}[`secondFloat)`{.code .docutils .literal
            .notranslate}]{.pre}. For broadcasting of the
            [`sample`{.code .docutils .literal .notranslate}]{.pre}
            function, the arguments should be structured as a
            [`list`{.code .docutils .literal .notranslate}]{.pre} or
            [`ndarray`{.code .docutils .literal .notranslate}]{.pre} of
            argument values of the specified kernel argument type.

        -   **shots_count**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}*\]*) -- The number of kernel executions on the
            QPU. Defaults to 1000. Key-word only.

        -   **noise_model** (Optional\[[`NoiseModel`{.code .docutils
            .literal .notranslate}]{.pre}\]) -- The optional
            [[`NoiseModel`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference
            .internal} to add noise to the kernel execution on the
            simulator. Defaults to an empty noise model.

        -   **explicit_measurements**
            (*Optional\[*[*bool*](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference
            .external}*\]*) -- Whether or not to concatenate
            measurements in execution order for the returned sample
            result.

    Returns[:]{.colon}

    :   

        A dictionary containing

        :   the measurement count results for the [[`Kernel`{.xref .py
            .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}, or a list of such results in the case of
            [`sample`{.code .docutils .literal .notranslate}]{.pre}
            function broadcasting.

    Return type[:]{.colon}

    :   [[`SampleResult`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} or [`list[SampleResult]`{.code .docutils .literal
        .notranslate}]{.pre}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[sample_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[decorator]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[shots_count]{.pre}]{.n}[[=]{.pre}]{.o}[[1000]{.pre}]{.default_value}*, *[[explicit_measurements]{.pre}]{.n}[[=]{.pre}]{.o}[[False]{.pre}]{.default_value}*, *[[noise_model]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[qpu_id]{.pre}]{.n}[[=]{.pre}]{.o}[[0]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.sample_async "Permalink to this definition"){.headerlink}

:   Asynchronously sample the state of the provided kernel
    [`decorator`{.code .docutils .literal .notranslate}]{.pre} at the
    specified number of circuit executions ([`shots_count`{.code
    .docutils .literal .notranslate}]{.pre}). When targeting a quantum
    platform with more than one QPU, the optional [`qpu_id`{.code
    .docutils .literal .notranslate}]{.pre} allows for control over
    which QPU to enable. Will return a future whose results can be
    retrieved via [`future.get()`{.code .docutils .literal
    .notranslate}]{.pre}.

    Parameters[:]{.colon}

    :   -   **kernel** ([[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to execute [`shots_count`{.code .docutils
            .literal .notranslate}]{.pre} times on the QPU.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

        -   **shots_count**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}*\]*) -- The number of kernel executions on the
            QPU. Defaults to 1000. Key-word only.

        -   **explicit_measurements**
            (*Optional\[*[*bool*](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference
            .external}*\]*) -- A flag to indicate whether or not to
            concatenate measurements in execution order for the returned
            sample result.

        -   **qpu_id**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}*\]*) -- The optional identification for which QPU
            on the platform to target. Defaults to zero. Key-word only.

    Returns[:]{.colon}

    :   

        A dictionary containing the measurement count

        :   results for the [[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}.

    Return type[:]{.colon}

    :   [[`AsyncSampleResult`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.AsyncSampleResult "cudaq.AsyncSampleResult"){.reference
        .internal}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[run]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[decorator]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[shots_count]{.pre}]{.n}[[=]{.pre}]{.o}[[100]{.pre}]{.default_value}*, *[[noise_model]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[qpu_id]{.pre}]{.n}[[=]{.pre}]{.o}[[0]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.run "Permalink to this definition"){.headerlink}

:   

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[run_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[decorator]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[shots_count]{.pre}]{.n}[[=]{.pre}]{.o}[[100]{.pre}]{.default_value}*, *[[noise_model]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[qpu_id]{.pre}]{.n}[[=]{.pre}]{.o}[[0]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.run_async "Permalink to this definition"){.headerlink}

:   Run the provided [`kernel`{.code .docutils .literal
    .notranslate}]{.pre} with the given kernel [`arguments`{.code
    .docutils .literal .notranslate}]{.pre} over the specified number of
    circuit executions ([`shots_count`{.code .docutils .literal
    .notranslate}]{.pre}) asynchronously on the specified
    [`qpu_id`{.code .docutils .literal .notranslate}]{.pre}.

    Parameters[:]{.colon}

    :   -   **kernel** ([[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to execute [`shots_count`{.code .docutils
            .literal .notranslate}]{.pre} times on the QPU.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments. For example, if the
            kernel takes two [`float`{.code .docutils .literal
            .notranslate}]{.pre} values as input, the [`run`{.code
            .docutils .literal .notranslate}]{.pre} call should be
            structured as [`cudaq.run(kernel,`{.code .docutils .literal
            .notranslate}]{.pre}` `{.code .docutils .literal
            .notranslate}[`firstFloat,`{.code .docutils .literal
            .notranslate}]{.pre}` `{.code .docutils .literal
            .notranslate}[`secondFloat)`{.code .docutils .literal
            .notranslate}]{.pre}.

        -   **shots_count**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}*\]*) -- The number of kernel executions on the
            QPU. Defaults to 100. Key-word only.

        -   **noise_model** (Optional\[[`NoiseModel`{.code .docutils
            .literal .notranslate}]{.pre}\]) -- The optional
            [[`NoiseModel`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference
            .internal} to add noise to the kernel execution on the
            simulator. Defaults to an empty noise model.

        -   **qpu_id**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}*\]*) -- The id of the QPU. Defaults to 0.
            Key-word only.

    Returns[:]{.colon}

    :   A handle, which can be waited on via a [`get()`{.code .docutils
        .literal .notranslate}]{.pre} method, which returns an array of
        [`kernel`{.code .docutils .literal .notranslate}]{.pre} return
        values. The length of the list is equal to [`shots_count`{.code
        .docutils .literal .notranslate}]{.pre}.

    Return type[:]{.colon}

    :   [`AsyncRunResult`{.code .docutils .literal .notranslate}]{.pre}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[observe]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}*, *[[spin_operator]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[shots_count]{.pre}]{.n}[[=]{.pre}]{.o}[[0]{.pre}]{.default_value}*, *[[noise_model]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[num_trajectories]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[execution]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[qpu_id]{.pre}]{.n}[[=]{.pre}]{.o}[[0]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.observe "Permalink to this definition"){.headerlink}

:   Compute the expected value of the [`spin_operator`{.code .docutils
    .literal .notranslate}]{.pre} with respect to the [`kernel`{.code
    .docutils .literal .notranslate}]{.pre}. If the input
    [`spin_operator`{.code .docutils .literal .notranslate}]{.pre} is a
    list of [`SpinOperator`{.code .docutils .literal
    .notranslate}]{.pre} then compute the expected value of every
    operator in the list and return a list of results. If the kernel
    accepts arguments, it will be evaluated with respect to
    [`kernel(*arguments)`{.code .docutils .literal .notranslate}]{.pre}.
    Each argument in [`arguments`{.code .docutils .literal
    .notranslate}]{.pre} provided can be a list or [`ndarray`{.code
    .docutils .literal .notranslate}]{.pre} of arguments of the
    specified kernel argument type, and in this case, the
    [`observe`{.code .docutils .literal .notranslate}]{.pre}
    functionality will be broadcasted over all argument sets and a list
    of [`observe_result`{.code .docutils .literal .notranslate}]{.pre}
    instances will be returned. If both the input [`spin_operator`{.code
    .docutils .literal .notranslate}]{.pre} and [`arguments`{.code
    .docutils .literal .notranslate}]{.pre} are broadcast lists, a
    nested list of results over [`arguments`{.code .docutils .literal
    .notranslate}]{.pre} then [`spin_operator`{.code .docutils .literal
    .notranslate}]{.pre} will be returned.

    Parameters[:]{.colon}

    :   -   **kernel** ([[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to evaluate the expectation value with respect
            to.

        -   **spin_operator** ([`SpinOperator`{.code .docutils .literal
            .notranslate}]{.pre} or [`list[SpinOperator]`{.code
            .docutils .literal .notranslate}]{.pre}) -- The Hermitian
            spin operator to calculate the expectation of, or a list of
            such operators.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

        -   **shots_count**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}*\]*) -- The number of shots to use for QPU
            execution. Defaults to -1 implying no shots-based sampling.
            Key-word only.

        -   **noise_model** (Optional\[[`NoiseModel`{.code .docutils
            .literal .notranslate}]{.pre}\]) -- The optional
            [[`NoiseModel`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference
            .internal} to add noise to the kernel execution on the
            simulator. Defaults to an empty noise model.

        -   **num_trajectories**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}*\]*) -- The optional number of trajectories for
            noisy simulation. Only valid if a noise model is provided.
            [`Keyword`{.code .docutils .literal .notranslate}]{.pre}
            only.

        -   **qpu_id**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}*\]*) -- The id of the QPU. Defaults to 0.
            Key-word only.

    Returns[:]{.colon}

    :   A data-type containing the expectation value of the
        [`spin_operator`{.code .docutils .literal .notranslate}]{.pre}
        with respect to the [`kernel(*arguments)`{.code .docutils
        .literal .notranslate}]{.pre}, or a list of such results in the
        case of [`observe`{.code .docutils .literal .notranslate}]{.pre}
        function broadcasting. If [`shots_count`{.code .docutils
        .literal .notranslate}]{.pre} was provided, the
        [[`ObserveResult`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference
        .internal} will also contain a [[`SampleResult`{.xref .py
        .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} dictionary.

    Return type[:]{.colon}

    :   [[`ObserveResult`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference
        .internal}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[observe_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}*, *[[spin_operator]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[qpu_id]{.pre}]{.n}[[=]{.pre}]{.o}[[0]{.pre}]{.default_value}*, *[[shots_count]{.pre}]{.n}[[=]{.pre}]{.o}[[-1]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.observe_async "Permalink to this definition"){.headerlink}

:   Compute the expected value of the [`spin_operator`{.code .docutils
    .literal .notranslate}]{.pre} with respect to the [`kernel`{.code
    .docutils .literal .notranslate}]{.pre} asynchronously. If the
    kernel accepts arguments, it will be evaluated with respect to
    [`kernel(*arguments)`{.code .docutils .literal .notranslate}]{.pre}.
    When targeting a quantum platform with more than one QPU, the
    optional [`qpu_id`{.code .docutils .literal .notranslate}]{.pre}
    allows for control over which QPU to enable. Will return a future
    whose results can be retrieved via [`future.get()`{.code .docutils
    .literal .notranslate}]{.pre}.

    Parameters[:]{.colon}

    :   -   **kernel** ([[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to evaluate the expectation value with respect
            to.

        -   **spin_operator** ([`SpinOperator`{.code .docutils .literal
            .notranslate}]{.pre}) -- The Hermitian spin operator to
            calculate the expectation of.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

        -   **qpu_id**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}*\]*) -- The optional identification for which QPU
            on the platform to target. Defaults to zero. Key-word only.

        -   **shots_count**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}*\]*) -- The number of shots to use for QPU
            execution. Defaults to -1 implying no shots-based sampling.
            Key-word only.

    Returns[:]{.colon}

    :   

        A future containing the result of the call

        :   to observe.

    Return type[:]{.colon}

    :   [[`AsyncObserveResult`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.AsyncObserveResult "cudaq.AsyncObserveResult"){.reference
        .internal}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[get_state]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.get_state "Permalink to this definition"){.headerlink}

:   Return the [[`State`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.State "cudaq.State"){.reference
    .internal} of the system after execution of the provided
    [`kernel`{.code .docutils .literal .notranslate}]{.pre}.

    Parameters[:]{.colon}

    :   -   **kernel** ([[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to execute on the QPU.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

    \# Example: [`import`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`numpy`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`as`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`np`{.code .docutils .literal .notranslate}]{.pre}

    \# Define a kernel that will produced the all [`|11...1>`{.code
    .docutils .literal .notranslate}]{.pre} state. [`qubits`{.code
    .docutils .literal .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`=`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`kernel.qalloc(3)`{.code .docutils .literal
    .notranslate}]{.pre} \# Prepare qubits in the 1-state.
    kernel.x(qubits)

    Get the state of the system. This will execute the provided kernel
    \# and, depending on the selected target, will return the state as a
    \# vector or matrix. state = cudaq.get_state(kernel) print(state)

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[get_state_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[qpu_id]{.pre}]{.n}[[=]{.pre}]{.o}[[0]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.get_state_async "Permalink to this definition"){.headerlink}

:   Asynchronously retrieve the state generated by the given quantum
    kernel. When targeting a quantum platform with more than one QPU,
    the optional [`qpu_id`{.code .docutils .literal .notranslate}]{.pre}
    allows for control over which QPU to enable. Will return a future
    whose results can be retrieved via [`future.get()`{.code .docutils
    .literal .notranslate}]{.pre}.

    Parameters[:]{.colon}

    :   -   **kernel** ([[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to execute on the QPU.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

        -   **qpu_id**
            (*Optional\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}*\]*) -- The optional identification for which QPU
            on the platform to target. Defaults to zero. Key-word only.

    Returns[:]{.colon}

    :   

        Quantum state data. (state vector or density

        :   matrix)

    Return type[:]{.colon}

    :   [[`AsyncStateResult`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.AsyncStateResult "cudaq.AsyncStateResult"){.reference
        .internal}

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[vqe]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[kernel]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[gradient_strategy]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[spin_operator]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[optimizer]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[parameter_count]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[argument_wrapper]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*, *[[shots]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.vqe "Permalink to this definition"){.headerlink}

:   

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[draw]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[decoratorOrFormat]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.draw "Permalink to this definition"){.headerlink}

:   The CUDA-Q specification overloads draw. To meet that, this function
    uses parameter type checking. The two overloads for
    [`cudaq.draw`{.code .docutils .literal .notranslate}]{.pre} are:
    [`` ` ``{.docutils .literal .notranslate}]{.pre}` `{.docutils
    .literal .notranslate}[`python`{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[`cudaq.draw("<format>",`{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[`kernel,`{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[`opt_args...)`{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[`cudaq.draw(kernel,`{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[`opt_args...)`{.docutils .literal
    .notranslate}]{.pre}` `{.docutils .literal
    .notranslate}[`` ` ``{.docutils .literal .notranslate}]{.pre} The
    second overload is equivalent to using a format string of
    [`"ascii"`{.code .docutils .literal .notranslate}]{.pre}.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[translate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[format]{.pre}]{.n}[[=]{.pre}]{.o}[[\'qir:0.1\']{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.translate "Permalink to this definition"){.headerlink}

:   Return a [`UTF-8`{.code .docutils .literal .notranslate}]{.pre}
    encoded string representing drawing of the execution path, i.e., the
    trace, of the provided [`kernel`{.code .docutils .literal
    .notranslate}]{.pre}.

    Parameters[:]{.colon}

    :   -   **format** ([`str`{.code .docutils .literal
            .notranslate}]{.pre}) -- format to translate to,
            \<name\[:version\]\>. Available format names: [`qir`{.code
            .docutils .literal .notranslate}]{.pre}, [`qir-full`{.code
            .docutils .literal .notranslate}]{.pre}, [`qir-base`{.code
            .docutils .literal .notranslate}]{.pre},
            [`qir-adaptive`{.code .docutils .literal
            .notranslate}]{.pre}, [`openqasm2`{.code .docutils .literal
            .notranslate}]{.pre}. QIR versions: [`0.1`{.code .docutils
            .literal .notranslate}]{.pre} and [`1.0`{.code .docutils
            .literal .notranslate}]{.pre}.

        -   **kernel** ([[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to translate.

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

    Note: Translating functions with arguments to OpenQASM 2.0 is not
    supported.

    Returns[:]{.colon}

    :   The [`UTF-8`{.code .docutils .literal .notranslate}]{.pre}
        encoded string of the circuit, without measurement operations.

    \# Example: import cudaq \@cudaq.kernel def bell_pair(): [`q`{.code
    .docutils .literal .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`=`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`cudaq.qvector(2)`{.code .docutils .literal
    .notranslate}]{.pre} h(q\[0\]) [`cx(q[0],`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`q[1])`{.code .docutils .literal .notranslate}]{.pre}
    [`mz(q)`{.code .docutils .literal .notranslate}]{.pre}
    print(cudaq.translate(bell_pair, [`format="qir"`{.code .docutils
    .literal .notranslate}]{.pre}))

    \# Output [`;`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`ModuleID`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`=`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`'LLVMDialectModule'`{.code .docutils .literal
    .notranslate}]{.pre} [`source_filename`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`=`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`'LLVMDialectModule'`{.code .docutils .literal
    .notranslate}]{.pre}

    %Array = type opaque %Result = type opaque %Qubit = type opaque

    ::: {#id1 .section}
    ### ...[](#id1 "Permalink to this heading"){.headerlink}

    define void
    [`` @__nvqpp__mlirgen__function_variable_qreg._Z13variable_qregv`() ``{.code
    .docutils .literal .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`` `local_unnamed_addr ``{.code .docutils .literal
    .notranslate}]{.pre} { %1 = tail call %Array\*
    \@\_\_quantum\_\_rt\_\_qubit_allocate_array(i64 2) ... %8 = tail
    call %Result\* @\`\_\_quantum\_\_qis\_\_mz\`(%Qubit\* %4) %9 = tail
    call %Result\* @\`\_\_quantum\_\_qis\_\_mz\`(%Qubit\* %7) tail call
    void @\`\_\_quantum\_\_rt\_\_qubit_release_array\`(%Array\* %1)
    [`ret`{.code .docutils .literal .notranslate}]{.pre}` `{.code
    .docutils .literal .notranslate}[`void`{.code .docutils .literal
    .notranslate}]{.pre} }
    :::

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[estimate_resources]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[kernel]{.pre}]{.n}*, *[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.estimate_resources "Permalink to this definition"){.headerlink}

:   Performs resource counting on the given quantum kernel expression
    and returns an accounting of how many times each gate was applied,
    in addition to the total number of gates and qubits used.

    Parameters[:]{.colon}

    :   -   **choice** (*Any*) -- A choice function called to determine
            the outcome of measurements, in case control flow depends on
            measurements. Should only return either [`True`{.code
            .docutils .literal .notranslate}]{.pre} or [`False`{.code
            .docutils .literal .notranslate}]{.pre}. Invoking the kernel
            within the choice function is forbidden. Default: returns
            [`True`{.code .docutils .literal .notranslate}]{.pre} or
            [`False`{.code .docutils .literal .notranslate}]{.pre} with
            50% probability.

        -   **kernel** ([[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}) -- The [[`Kernel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} to count resources on

        -   **\*arguments** (*Optional\[Any\]*) -- The concrete values
            to evaluate the kernel function at. Leave empty if the
            kernel doesn't accept any arguments.

    Returns[:]{.colon}

    :   

        A dictionary containing the resource count results

        :   for the [[`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal}.

    Return type[:]{.colon}

    :   [[`Resources`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference
        .internal}
:::

::: {#backend-configuration .section}
## Backend Configuration[](#backend-configuration "Permalink to this heading"){.headerlink}

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[has_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.has_target "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[has_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Return true if the [`cudaq.Target`{.code .docutils .literal
    .notranslate}]{.pre} with the given name exists.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[get_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.get_target "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[get_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Return the [`cudaq.Target`{.code .docutils .literal
    .notranslate}]{.pre} with the given name. Will raise an exception if
    the name is not valid.

    2.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[get_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Return the [`cudaq.Target`{.code .docutils .literal
    .notranslate}]{.pre} with the given name. Will raise an exception if
    the name is not valid.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[get_targets]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.get_targets "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[get_targets]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

    :   

    Return all available [`cudaq.Target`{.code .docutils .literal
    .notranslate}]{.pre} instances on the current system.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[set_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.set_target "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[set_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0:]{.pre} [Target]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

    Set the [`cudaq.Target`{.code .docutils .literal
    .notranslate}]{.pre} to be used for CUDA-Q kernel execution. Can
    provide optional, target-specific configuration data via Python
    kwargs.

    2.  

        [[cudaq.]{.pre}]{.sig-prename .descclassname}[[set_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0:]{.pre} [str]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

    Set the [`cudaq.Target`{.code .docutils .literal
    .notranslate}]{.pre} with given name to be used for CUDA-Q kernel
    execution. Can provide optional, target-specific configuration data
    via Python kwargs.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[reset_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.reset_target "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[reset_target]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Reset the current [`cudaq.Target`{.code .docutils .literal
    .notranslate}]{.pre} to the default.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[set_noise]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.set_noise "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[set_noise]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Set the underlying noise model.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[unset_noise]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.unset_noise "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[unset_noise]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Clear backend simulation from any existing noise models.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[register_set_target_callback]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.register_set_target_callback "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[register_set_target_callback]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Register a callback function to be executed when the runtime target
    is changed. The string [`id`{.code .docutils .literal
    .notranslate}]{.pre} can be used to identify the callback for
    replacement/removal purposes.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[unregister_set_target_callback]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.unregister_set_target_callback "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[unregister_set_target_callback]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Unregister a callback identified by the input identifier.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[apply_noise]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[error_type]{.pre}]{.n}*, *[[parameters\...]{.pre}]{.n}*, *[[targets\...]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.cudaq.apply_noise "Permalink to this definition"){.headerlink}

:   This function is a type-safe injection of noise into a quantum
    kernel, occurring precisely at the call site of the function
    invocation. The function should be called inside CUDA-Q kernels
    (those annotated with [`@cudaq.kernel`{.code .docutils .literal
    .notranslate}]{.pre}). The functionality is only supported for
    simulation targets, so it is automatically (and silently) stripped
    from any programs submitted to hardware targets.

    Parameters[:]{.colon}

    :   -   **error_type** --

            A subtype of [[`cudaq.KrausChannel`{.xref .py .py-class
            .docutils .literal
            .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
            .internal} that implements/defines the desired noise
            mechanisms as Kraus channels (e.g.
            [[`cudaq.Depolarization2`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.Depolarization2 "cudaq.Depolarization2"){.reference
            .internal}). If you want to use a custom
            [[`cudaq.KrausChannel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
            .internal} (i.e. not built-in to CUDA-Q), it must first be
            registered *outside the kernel* with
            [`register_channel`{.code .docutils .literal
            .notranslate}]{.pre}, like this:

            ::: {.highlight-python .notranslate}
            ::: highlight
                class CustomNoiseChannel(cudaq.KrausChannel):
                    num_parameters = 1
                    num_targets = 1

                def __init__(self, params: list[float]):
                    cudaq.KrausChannel.__init__(self)
                    # Example: Create Kraus ops based on params
                    p = params[0]
                    k0 = np.array([[np.sqrt(1 - p), 0], [0, np.sqrt(1 - p)]],
                                dtype=np.complex128)
                    k1 = np.array([[0, np.sqrt(p)], [np.sqrt(p), 0]],
                                dtype=np.complex128)

                    # Create KrausOperators and add to channel
                    self.append(cudaq.KrausOperator(k0))
                    self.append(cudaq.KrausOperator(k1))

                    self.noise_type = cudaq.NoiseModelType.Unknown

                noise = cudaq.NoiseModel()
                noise.register_channel(CustomNoiseChannel)
            :::
            :::

        -   **parameters** --

            The precise argument pack depend on the concrete
            [[`cudaq.KrausChannel`{.xref .py .py-class .docutils
            .literal
            .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
            .internal} being used. The arguments are a concatenated list
            of parameters and targets. For example, to apply a 2-qubit
            depolarization channel, which has [`num_parameters`{.code
            .docutils .literal .notranslate}]{.pre}` `{.code .docutils
            .literal .notranslate}[`=`{.code .docutils .literal
            .notranslate}]{.pre}` `{.code .docutils .literal
            .notranslate}[`1`{.code .docutils .literal
            .notranslate}]{.pre} and [`num_targets`{.code .docutils
            .literal .notranslate}]{.pre}` `{.code .docutils .literal
            .notranslate}[`=`{.code .docutils .literal
            .notranslate}]{.pre}` `{.code .docutils .literal
            .notranslate}[`2`{.code .docutils .literal
            .notranslate}]{.pre}, one would write the call like this:

            ::: {.highlight-python .notranslate}
            ::: highlight
                q, r = cudaq.qubit(), cudaq.qubit()
                cudaq.apply_noise(cudaq.Depolarization2, 0.1, q, r)
            :::
            :::

        -   **targets** -- The target qubits on which to apply the noise

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[initialize_cudaq]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.initialize_cudaq "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[initialize_cudaq]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[option]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Optional]{.pre}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[emulate]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Optional]{.pre}[[\[]{.pre}]{.p}[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Optional]{.pre}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Initialize the CUDA-Q environment.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[num_available_gpus]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.num_available_gpus "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[num_available_gpus]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    The number of available GPUs detected on the system.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[set_random_seed]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.set_random_seed "Permalink to this definition"){.headerlink}

:   

    [[cudaq.]{.pre}]{.sig-prename .descclassname}[[set_random_seed]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Provide the seed for backend quantum kernel simulation.
:::

::: {#dynamics .section}
## Dynamics[](#dynamics "Permalink to this heading"){.headerlink}

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[evolve]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[hamiltonian]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SuperOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SuperOperator"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Mapping]{.pre}](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[schedule]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Schedule]{.pre}](#cudaq.Schedule "cudaq.dynamics.schedule.Schedule"){.reference .internal}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[initial_state]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[State]{.pre}](#cudaq.State "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.State"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[InitialStateType]{.pre}](#cudaq.InitialStateType "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.InitialStateType"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.State]{.pre}](#cudaq.State "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.State"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.InitialStateType]{.pre}](#cudaq.InitialStateType "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.InitialStateType"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[collapse_operators]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[observables]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[store_intermediate_results]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.dynamics.helpers.IntermediateResultSave]{.pre}](#cudaq.IntermediateResultSave "cudaq.dynamics.helpers.IntermediateResultSave"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[IntermediateResultSave.NONE]{.pre}]{.default_value}*, *[[integrator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[BaseIntegrator]{.pre}](#cudaq.dynamics.integrator.BaseIntegrator "cudaq.dynamics.integrator.BaseIntegrator"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[shots_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[max_batch_size]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.EvolveResult"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.EvolveResult"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}[](#cudaq.evolve "Permalink to this definition"){.headerlink}

:   Computes the time evolution of one or more initial state(s) under
    the defined operator(s).

    Parameters[:]{.colon}

    :   -   **hamiltonian** -- Operator that describes the behavior of a
            quantum system without noise.

        -   **dimensions** -- A mapping that specifies the number of
            levels, that is the dimension, of each degree of freedom
            that any of the operator arguments acts on.

        -   **schedule** -- A sequence that generates a mapping of
            keyword arguments to their respective value. The keyword
            arguments are the parameters needed to evaluate any of the
            operators passed to [`evolve`{.code .docutils .literal
            .notranslate}]{.pre}. All required parameters for evaluating
            an operator and their documentation, if available, can be
            queried by accessing the [`parameter`{.code .docutils
            .literal .notranslate}]{.pre} property of the operator.

        -   **initial_state** -- A single state or a sequence of states
            of a quantum system.

        -   **collapse_operators** -- A sequence of operators that
            describe the influence of noise on the quantum system.

        -   **observables** -- A sequence of operators for which to
            compute their expectation value during evolution. If
            [`store_intermediate_results`{.code .docutils .literal
            .notranslate}]{.pre} is not None, the expectation values are
            computed after each step in the schedule, and otherwise only
            the final expectation values at the end of the evolution are
            computed.

        -   **shots_count** -- Optional integer, if provided, it is the
            number of shots to use for QPU execution.

    Returns[:]{.colon}

    :   A single evolution result if a single initial state is provided,
        or a sequence of evolution results representing the data
        computed during the evolution of each initial state. See
        [`EvolveResult`{.code .docutils .literal .notranslate}]{.pre}
        for more information about the data computed during evolution.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[evolve_async]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[hamiltonian]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Mapping]{.pre}](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[schedule]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Schedule]{.pre}](#cudaq.Schedule "cudaq.dynamics.schedule.Schedule"){.reference .internal}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[initial_state]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[State]{.pre}](#cudaq.State "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.State"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[InitialStateType]{.pre}](#cudaq.InitialStateType "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.InitialStateType"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.State]{.pre}](#cudaq.State "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.State"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.InitialStateType]{.pre}](#cudaq.InitialStateType "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.InitialStateType"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[collapse_operators]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[observables]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[store_intermediate_results]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.dynamics.helpers.IntermediateResultSave]{.pre}](#cudaq.IntermediateResultSave "cudaq.dynamics.helpers.IntermediateResultSave"){.reference .internal}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[IntermediateResultSave.NONE]{.pre}]{.default_value}*, *[[integrator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[BaseIntegrator]{.pre}](#cudaq.dynamics.integrator.BaseIntegrator "cudaq.dynamics.integrator.BaseIntegrator"){.reference .internal}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*, *[[shots_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[AsyncEvolveResult]{.pre}](#cudaq.AsyncEvolveResult "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.AsyncEvolveResult"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[AsyncEvolveResult]{.pre}](#cudaq.AsyncEvolveResult "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.AsyncEvolveResult"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}[](#cudaq.evolve_async "Permalink to this definition"){.headerlink}

:   Asynchronously computes the time evolution of one or more initial
    state(s) under the defined operator(s). See [`cudaq.evolve`{.code
    .docutils .literal .notranslate}]{.pre} for more details about the
    parameters passed here.

    Returns[:]{.colon}

    :   The handle to a single evolution result if a single initial
        state is provided, or a sequence of handles to the evolution
        results representing the data computed during the evolution of
        each initial state. See the [`EvolveResult`{.code .docutils
        .literal .notranslate}]{.pre} for more information about the
        data computed during evolution.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Schedule]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[steps]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[get_value]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[Callable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[numpy.complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.4)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.Schedule "Permalink to this definition"){.headerlink}

:   Represents an iterator that produces all values needed for
    evaluating an operator expression at different time steps.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.dynamics.integrator.]{.pre}]{.sig-prename .descclassname}[[BaseIntegrator]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.dynamics.integrator.BaseIntegrator "Permalink to this definition"){.headerlink}

:   An abstract wrapper around ODE integrator to ensure a common
    interface for master equation solver usage.

```{=html}
<!-- -->
```

[[cudaq.dynamics.helpers.]{.pre}]{.sig-prename .descclassname}[[InitialState]{.pre}]{.sig-name .descname}[](#cudaq.dynamics.helpers.InitialState "Permalink to this definition"){.headerlink}

:   alias of [[`InitialStateType`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.InitialStateType "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.InitialStateType"){.reference
    .internal}

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[InitialStateType]{.pre}]{.sig-name .descname}[](#cudaq.InitialStateType "Permalink to this definition"){.headerlink}

:   Enumeration describing the initial state type to be created in the
    backend

    Members:

    > <div>
    >
    > ZERO
    >
    > UNIFORM
    >
    > </div>

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[IntermediateResultSave]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[value]{.pre}]{.n}*, *[[names=\<not]{.pre} [given\>]{.pre}]{.n}*, *[[\*values]{.pre}]{.n}*, *[[module=None]{.pre}]{.n}*, *[[qualname=None]{.pre}]{.n}*, *[[type=None]{.pre}]{.n}*, *[[start=1]{.pre}]{.n}*, *[[boundary=None]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.IntermediateResultSave "Permalink to this definition"){.headerlink}

:   Enum to specify how intermediate results should be saved during the
    dynamics evolution.
:::

::: {#operators .section}
## Operators[](#operators "Permalink to this heading"){.headerlink}

[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[OperatorSum]{.pre}]{.sig-name .descname}[](#cudaq.operators.OperatorSum "Permalink to this definition"){.headerlink}

:   alias of [[`MatrixOperator`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.operators.MatrixOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperator"){.reference
    .internal} \| [[`SpinOperator`{.xref .py .py-class .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperator"){.reference
    .internal} \| [[`BosonOperator`{.xref .py .py-class .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperator"){.reference
    .internal} \| [[`FermionOperator`{.xref .py .py-class .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperator"){.reference
    .internal}

```{=html}
<!-- -->
```

[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[ProductOperator]{.pre}]{.sig-name .descname}[](#cudaq.operators.ProductOperator "Permalink to this definition"){.headerlink}

:   alias of [[`MatrixOperatorTerm`{.xref .py .py-class .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference
    .internal} \| [[`SpinOperatorTerm`{.xref .py .py-class .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorTerm"){.reference
    .internal} \| [[`BosonOperatorTerm`{.xref .py .py-class .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorTerm"){.reference
    .internal} \| [[`FermionOperatorTerm`{.xref .py .py-class .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorTerm"){.reference
    .internal}

```{=html}
<!-- -->
```

[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[ElementaryOperator]{.pre}]{.sig-name .descname}[](#cudaq.operators.ElementaryOperator "Permalink to this definition"){.headerlink}

:   alias of [[`SpinOperatorElement`{.xref .py .py-class .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.operators.spin.SpinOperatorElement "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.SpinOperatorElement"){.reference
    .internal} \| [[`BosonOperatorElement`{.xref .py .py-class .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.operators.boson.BosonOperatorElement "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.BosonOperatorElement"){.reference
    .internal} \| [[`FermionOperatorElement`{.xref .py .py-class
    .docutils .literal
    .notranslate}]{.pre}](#cudaq.operators.fermion.FermionOperatorElement "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.FermionOperatorElement"){.reference
    .internal} \| [[`MatrixOperatorElement`{.xref .py .py-class
    .docutils .literal
    .notranslate}]{.pre}](#cudaq.operators.MatrixOperatorElement "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorElement"){.reference
    .internal}

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[ScalarOperator]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[generator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.4)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[\...]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[numpy.complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.4)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[parameter_info]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[Mapping]{.pre}](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.operators.ScalarOperator "Permalink to this definition"){.headerlink}

:   

    *[classmethod]{.pre}[ ]{.w}*[[const]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[constant_value]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[numpy.complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.4)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}[](#cudaq.operators.ScalarOperator.const "Permalink to this definition"){.headerlink}

    :   Creates a scalar operator that has a constant value.

    [[evaluate]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.ScalarOperator.evaluate "Permalink to this definition"){.headerlink}

    :   

        [[evaluate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [ScalarOperator]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Evaluated value of the operator.

    [[is_constant]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.ScalarOperator.is_constant "Permalink to this definition"){.headerlink}

    :   

        [[is_constant]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.operators.ScalarOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns true if the scalar is a constant value.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[](#cudaq.operators.ScalarOperator.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Mapping]{.pre}](https://docs.python.org/3/library/typing.html#typing.Mapping "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[numpy.complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.4)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[ ]{.w}[[\|]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.4)"){.reference .external}[[\[]{.pre}]{.p}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[dtype]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.4)"){.reference .external}[[\[]{.pre}]{.p}[[complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.4)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}[](#cudaq.operators.ScalarOperator.to_matrix "Permalink to this definition"){.headerlink}

    :   Class method for consistency with other operator classes.
        Invokes the generator with the given keyword arguments.

        Parameters[:]{.colon}

        :   -   **dimensions** -- (unused, passed for consistency) A
                mapping that specifies the number of levels, that is the
                dimension, of each degree of freedom that the operator
                acts on.

            -   **kwargs** -- Keyword arguments needed to evaluate the
                generator. All required parameters and their
                documentation, if available, can be queried by accessing
                the [`parameter`{.code .docutils .literal
                .notranslate}]{.pre} property.

        Returns[:]{.colon}

        :   An array with a single element corresponding to the value of
            the operator for the given keyword arguments.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[RydbergHamiltonian]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[atom_sites]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[amplitude]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[phase]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[delta_global]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[atom_filling]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[delta_local]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.operators.RydbergHamiltonian "Permalink to this definition"){.headerlink}

:   Representation for the time-dependent Hamiltonian which is simulated
    by analog neutral-atom machines such as QuEra's Aquila and Pasqal's
    Fresnel. Ref:
    [https://docs.aws.amazon.com/braket/latest/developerguide/braket-quera-submitting-analog-program-aquila.html#braket-quera-ahs-program-schema](https://docs.aws.amazon.com/braket/latest/developerguide/braket-quera-submitting-analog-program-aquila.html#braket-quera-ahs-program-schema){.reference
    .external}

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[atom_sites]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[amplitude]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[phase]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[delta_global]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}]{.n}*, *[[atom_filling]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\[\]]{.pre}]{.default_value}*, *[[delta_local]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Optional]{.pre}](https://docs.python.org/3/library/typing.html#typing.Optional "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.mlir.\_mlir_libs.\_quakeDialects.cudaq_runtime.ScalarOperator]{.pre}](#cudaq.operators.ScalarOperator "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.ScalarOperator"){.reference .internal}[[,]{.pre}]{.p}[ ]{.w}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.operators.RydbergHamiltonian.__init__ "Permalink to this definition"){.headerlink}

    :   Instantiate an operator consumable by [`evolve`{.code .docutils
        .literal .notranslate}]{.pre} API using the supplied parameters.

        Parameters[:]{.colon}

        :   -   **atom_sites** -- List of 2-d coordinates where the
                tweezers trap atoms.

            -   **amplitude** -- time and value points of driving
                amplitude, Omega(t).

            -   **phase** -- time and value points of driving phase,
                phi(t).

            -   **delta_global** -- time and value points of driving
                detuning, Delta_global(t).

            -   **atom_filling** -- typing.Optional. Marks atoms that
                occupy the trap sites with 1, and empty sites with 0. If
                not provided, all are set to 1, i.e. filled.

            -   **delta_local** -- typing.Optional. A tuple of time and
                value points of the time-dependent factor of the local
                detuning magnitude, Delta_local(t), and site-dependent
                factor of the local detuning magnitude, h_k, a
                dimensionless number between 0.0 and 1.0

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[SuperOperator]{.pre}]{.sig-name .descname}[](#cudaq.SuperOperator "Permalink to this definition"){.headerlink}

:   

    *[static]{.pre}[ ]{.w}*[[left_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.SuperOperator.left_multiply "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[left_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a left multiplication of
        the operator to the density matrix.

        2.  

            [[left_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a left multiplication of
        the operator to the density matrix. The sum is distributed into
        a linear combination of super-operator actions.

    *[static]{.pre}[ ]{.w}*[[left_right_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.SuperOperator.left_right_multiply "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[left_right_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a simultaneous left
        multiplication of the first operator operand and right
        multiplication of the second operator operand to the density
        matrix.

        2.  

            [[left_right_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a simultaneous left
        multiplication of the first operator operand and right
        multiplication of the second operator operand to the density
        matrix. The sum is distributed into a linear combination of
        super-operator actions.

    *[static]{.pre}[ ]{.w}*[[right_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.SuperOperator.right_multiply "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[right_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a right multiplication of
        the operator to the density matrix.

        2.  

            [[right_multiply]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SuperOperator]{.pre}](#cudaq.SuperOperator "cudaq.SuperOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a super-operator representing a right multiplication of
        the operator to the density matrix. The sum is distributed into
        a linear combination of super-operator actions.

```{=html}
<!-- -->
```

[[operators.]{.pre}]{.sig-prename .descclassname}[[define]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[expected_dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[create]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Callable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[\...]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.4)"){.reference .external}[[\[]{.pre}]{.p}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[dtype]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.4)"){.reference .external}[[\[]{.pre}]{.p}[[complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.4)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[override]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}[](#cudaq.operators.define "Permalink to this definition"){.headerlink}

:   Defines a matrix operator element with the given id. After
    definition, an the defined elementary operator can be instantiated
    by providing the operator id as well as the degree(s) of freedom
    that it acts on. A matrix operator element is a parameterized object
    acting on certain degrees of freedom. To evaluate an operator, for
    example to compute its matrix, the level, that is the dimension, for
    each degree of freedom it acts on must be provided, as well as all
    additional parameters. Additional parameters must be provided in the
    form of keyword arguments.

    Note: The dimensions passed during operator evaluation are
    automatically validated against the expected dimensions specified
    during definition - the [`create`{.code .docutils .literal
    .notranslate}]{.pre} function does not need to do this.

    Parameters[:]{.colon}

    :   -   **op_id** -- A string that uniquely identifies the defined
            operator.

        -   **expected_dimensions** -- defines the number of levels,
            that is the dimension, for each degree of freedom in
            canonical (that is sorted) order. A negative or zero value
            for one (or more) of the expected dimensions indicates that
            the operator is defined for any dimension of the
            corresponding degree of freedom.

        -   **create** -- Takes any number of complex-valued arguments
            and returns the matrix representing the operator in
            canonical order. If the matrix can be defined for any number
            of levels for one or more degree of freedom, the
            [`create`{.code .docutils .literal .notranslate}]{.pre}
            function must take an argument called [`dimension`{.code
            .docutils .literal .notranslate}]{.pre} (or [`dim`{.code
            .docutils .literal .notranslate}]{.pre} for short), if the
            operator acts on a single degree of freedom, and an argument
            called [`dimensions`{.code .docutils .literal
            .notranslate}]{.pre} (or [`dims`{.code .docutils .literal
            .notranslate}]{.pre} for short), if the operator acts on
            multiple degrees of freedom.

        -   **override** -- if True it allows override the definition.
            (default: False)

```{=html}
<!-- -->
```

[[operators.]{.pre}]{.sig-prename .descclassname}[[instantiate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}[](#cudaq.operators.instantiate "Permalink to this definition"){.headerlink}

:   Instantiates a product operator containing a previously defined
    operator element.

    Parameters[:]{.colon}

    :   -   **operator_id** -- The id of the operator element as
            specified when it was defined.

        -   **degrees** -- The degree(s) of freedom that the operator
            acts on.

::: {#spin-operators .section}
### Spin Operators[](#spin-operators "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.operators.spin.]{.pre}]{.sig-prename .descclassname}[[SpinOperator]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperator "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. If an empty set is passed, canonicalizes
        all terms in the sum to act on the same degrees of freedom.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperator.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        [`to_matrix`{.code .docutils .literal .notranslate}]{.pre}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[distribute_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.distribute_terms "Permalink to this definition"){.headerlink}

    :   

        [[distribute_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Partitions the terms of the sums into the given number of
        separate sums.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    *[static]{.pre}[ ]{.w}*[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.empty "Permalink to this definition"){.headerlink}

    :   

        [[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a sum operator with no terms. And empty sum is the
        neutral element for addition; multiplying an empty sum with
        anything will still result in an empty sum.

    *[static]{.pre}[ ]{.w}*[[empty_op]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.empty_op "Permalink to this definition"){.headerlink}

    :   

        [[empty_op]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use [`empty`{.code .docutils .literal
        .notranslate}]{.pre} instead.

    [[for_each_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.for_each_pauli "Permalink to this definition"){.headerlink}

    :   

        [[for_each_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - iterator over sum and then iterator over term
        instead.

    [[for_each_term]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.for_each_term "Permalink to this definition"){.headerlink}

    :   

        [[for_each_term]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use standard iteration instead.

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string ('\[d1, d2, d3, ...\]') to spin_op

    *[static]{.pre}[ ]{.w}*[[from_word]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.from_word "Permalink to this definition"){.headerlink}

    :   

        [[from_word]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates an operator from a Pauli word string.

    [[get_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.get_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[get_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use [`evaluate_coefficient`{.code .docutils
        .literal .notranslate}]{.pre} on each term (product operator)
        instead.

    [[get_qubit_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.get_qubit_count "Permalink to this definition"){.headerlink}

    :   

        [[get_qubit_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use [`qubit_count`{.code .docutils .literal
        .notranslate}]{.pre} instead.

    [[get_raw_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.get_raw_data "Permalink to this definition"){.headerlink}

    :   

        [[get_raw_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated.

    [[get_term_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.get_term_count "Permalink to this definition"){.headerlink}

    :   

        [[get_term_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use [`term_count`{.code .docutils .literal
        .notranslate}]{.pre} instead.

    *[static]{.pre}[ ]{.w}*[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.identity "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator with constant value 1. The identity
        operator is the neutral element for multiplication.

        2.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator that applies the identity to the
        given target index.

    [[is_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.is_identity "Permalink to this definition"){.headerlink}

    :   

        [[is_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - is_identity will only be supported on each term
        (product operator) in future releases.

    *[property]{.pre}[ ]{.w}*[[max_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperator.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperator.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperator.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[qubit_count]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperator.qubit_count "Permalink to this definition"){.headerlink}

    :   Return the number of qubits this operator acts on.

    *[static]{.pre}[ ]{.w}*[[random]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.random "Permalink to this definition"){.headerlink}

    :   

        [[random]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[qubit_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*, *[[term_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*, *[[seed]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[309936440]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Return a random spin operator with the given number of terms
        ([`term_count`{.code .docutils .literal .notranslate}]{.pre})
        where each term acts on all targets in the open range \[0,
        qubit_count). An optional seed value may also be provided.

    [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.serialize "Permalink to this definition"){.headerlink}

    :   

        [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the serialized data representation of the operator.

    *[property]{.pre}[ ]{.w}*[[term_count]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperator.term_count "Permalink to this definition"){.headerlink}

    :   Returns the number of terms in the operator.

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert spin_op to JSON string: '\[d1, d2, d3, ...\]'

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

    [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

    [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[print_coefficient]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[True]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use the standard [`str`{.code .docutils .literal
        .notranslate}]{.pre} conversion or [`get_pauli_word`{.code
        .docutils .literal .notranslate}]{.pre} on each term instead.

    [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperator.trim "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[tol]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0.0]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

        2.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperator]{.pre}]{.n}*, *[[tol:]{.pre} [float]{.pre} [=]{.pre} [0.0]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.spin.]{.pre}]{.sig-prename .descclassname}[[SpinOperatorTerm]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorTerm "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. The canonicalization will throw a runtime
        exception if the operator acts on any degrees of freedom that
        are not included in the given set.

    *[property]{.pre}[ ]{.w}*[[coefficient]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorTerm.coefficient "Permalink to this definition"){.headerlink}

    :   Returns the unevaluated coefficient of the operator. The
        coefficient is a callback function that can be invoked with the
        [`evaluate`{.code .docutils .literal .notranslate}]{.pre}
        method.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorTerm.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        [`to_matrix`{.code .docutils .literal .notranslate}]{.pre}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[distribute_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.distribute_terms "Permalink to this definition"){.headerlink}

    :   

        [[distribute_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[chunk_count]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - instantiate a [`SpinOperator`{.code .docutils
        .literal .notranslate}]{.pre} from this
        [`SpinOperatorTerm`{.code .docutils .literal
        .notranslate}]{.pre} and call distribute_terms on that.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    [[evaluate_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.evaluate_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[evaluate_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the evaluated coefficient of the product operator. The
        parameters is a map of parameter names to their concrete,
        complex values.

    [[for_each_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.for_each_pauli "Permalink to this definition"){.headerlink}

    :   

        [[for_each_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use standard iteration instead.

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string ('\[d1, d2, d3, ...\]') to spin_op

    [[get_binary_symplectic_form]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.get_binary_symplectic_form "Permalink to this definition"){.headerlink}

    :   

        [[get_binary_symplectic_form]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Gets the binary symplectic representation of this operator.

    [[get_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.get_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[get_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use [`evaluate_coefficient`{.code .docutils
        .literal .notranslate}]{.pre} instead.

    [[get_pauli_word]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.get_pauli_word "Permalink to this definition"){.headerlink}

    :   

        [[get_pauli_word]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[pad_identities]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Gets the Pauli word representation of this product operator.

    [[get_qubit_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.get_qubit_count "Permalink to this definition"){.headerlink}

    :   

        [[get_qubit_count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use [`qubit_count`{.code .docutils .literal
        .notranslate}]{.pre} instead.

    [[get_raw_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.get_raw_data "Permalink to this definition"){.headerlink}

    :   

        [[get_raw_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated.

    [[is_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.is_identity "Permalink to this definition"){.headerlink}

    :   

        [[is_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Checks if all operators in the product are the identity. Note:
        this function returns true regardless of the value of the
        coefficient.

    *[property]{.pre}[ ]{.w}*[[max_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorTerm.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorTerm.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[ops_count]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorTerm.ops_count "Permalink to this definition"){.headerlink}

    :   Returns the number of operators in the product.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorTerm.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[qubit_count]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorTerm.qubit_count "Permalink to this definition"){.headerlink}

    :   Return the number of qubits this operator acts on.

    [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.serialize "Permalink to this definition"){.headerlink}

    :   

        [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the serialized data representation of the operator.

    *[property]{.pre}[ ]{.w}*[[term_count]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorTerm.term_count "Permalink to this definition"){.headerlink}

    :   Returns the number of terms in the operator. Always returns 1.

    *[property]{.pre}[ ]{.w}*[[term_id]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorTerm.term_id "Permalink to this definition"){.headerlink}

    :   The term id uniquely identifies the operators and targets
        (degrees) that they act on, but does not include information
        about the coefficient.

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert spin_op to JSON string: '\[d1, d2, d3, ...\]'

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

    [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

    [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorTerm.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[print_coefficient]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[True]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deprecated - use the standard [`str`{.code .docutils .literal
        .notranslate}]{.pre} conversion or use [`get_pauli_word`{.code
        .docutils .literal .notranslate}]{.pre} instead.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.spin.]{.pre}]{.sig-prename .descclassname}[[SpinOperatorElement]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorElement "Permalink to this definition"){.headerlink}

:   

    [[as_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorElement.as_pauli "Permalink to this definition"){.headerlink}

    :   

        [[as_pauli]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorElement]{.pre}](#cudaq.operators.spin.SpinOperatorElement "cudaq.operators.spin.SpinOperatorElement"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[Pauli]{.pre}](#cudaq.spin.Pauli "cudaq.spin.Pauli"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the Pauli representation of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorElement.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[target]{.pre}]{.sig-name .descname}[](#cudaq.operators.spin.SpinOperatorElement.target "Permalink to this definition"){.headerlink}

    :   Returns the degree of freedom that the operator targets.

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorElement.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorElement]{.pre}](#cudaq.operators.spin.SpinOperatorElement "cudaq.operators.spin.SpinOperatorElement"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [SpinOperatorElement]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

    [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.spin.SpinOperatorElement.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorElement]{.pre}](#cudaq.operators.spin.SpinOperatorElement "cudaq.operators.spin.SpinOperatorElement"){.reference .internal}]{.n}*, *[[include_degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the string representation of the operator.

[]{#module-cudaq.spin .target}

*[class]{.pre}[ ]{.w}*[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[Pauli]{.pre}]{.sig-name .descname}[](#cudaq.spin.Pauli "Permalink to this definition"){.headerlink}

:   An enumeration representing the types of Pauli matrices.

    Members:

    > <div>
    >
    > X
    >
    > Y
    >
    > Z
    >
    > I
    >
    > </div>

    *[property]{.pre}[ ]{.w}*[[name]{.pre}]{.sig-name .descname}[](#cudaq.spin.Pauli.name "Permalink to this definition"){.headerlink}

    :   object) -\> str :noindex:

        Type[:]{.colon}

        :   

            [[name(self]{.pre}]{.sig-name .descname}

            :   

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.spin.canonicalized "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    2.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. The canonicalization will throw a runtime
    exception if the operator acts on any degrees of freedom that are
    not included in the given set.

    3.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    4.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. If an empty set is passed, canonicalizes all
    terms in the sum to act on the same degrees of freedom.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.spin.empty "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns sum operator with no terms. Note that a sum with no terms
    multiplied by anything still is a sum with no terms.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[i]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.spin.i "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[i]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a Pauli I spin operator on the given target qubit index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.spin.identities "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[first]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*, *[[last]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Creates a product operator that applies an identity operation to all
    degrees of freedom in the open range \[first, last).

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.spin.identity "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns product operator with constant value 1.

    2.  

        [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns an identity operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[minus]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.spin.minus "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[minus]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Return a sigma minus spin operator on the given target qubit index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[plus]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.spin.plus "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[plus]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperator]{.pre}](#cudaq.operators.spin.SpinOperator "cudaq.operators.spin.SpinOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Return a sigma plus spin operator on the given target qubit index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[x]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.spin.x "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[x]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a Pauli X spin operator on the given target qubit index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[y]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.spin.y "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[y]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a Pauli Y spin operator on the given target qubit index.

```{=html}
<!-- -->
```

[[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[z]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.spin.z "Permalink to this definition"){.headerlink}

:   

    [[cudaq.spin.]{.pre}]{.sig-prename .descclassname}[[z]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SpinOperatorTerm]{.pre}](#cudaq.operators.spin.SpinOperatorTerm "cudaq.operators.spin.SpinOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a Pauli Z spin operator on the given target qubit index.
:::

::: {#fermion-operators .section}
### Fermion Operators[](#fermion-operators "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.operators.fermion.]{.pre}]{.sig-prename .descclassname}[[FermionOperator]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperator "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperator.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. If an empty set is passed, canonicalizes
        all terms in the sum to act on the same degrees of freedom.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperator.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperator.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        [`to_matrix`{.code .docutils .literal .notranslate}]{.pre}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[distribute_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperator.distribute_terms "Permalink to this definition"){.headerlink}

    :   

        [[distribute_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Partitions the terms of the sums into the given number of
        separate sums.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperator.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    *[static]{.pre}[ ]{.w}*[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperator.empty "Permalink to this definition"){.headerlink}

    :   

        [[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a sum operator with no terms. And empty sum is the
        neutral element for addition; multiplying an empty sum with
        anything will still result in an empty sum.

    *[static]{.pre}[ ]{.w}*[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperator.identity "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator with constant value 1. The identity
        operator is the neutral element for multiplication.

        2.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator that applies the identity to the
        given target index.

    *[property]{.pre}[ ]{.w}*[[max_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperator.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperator.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperator.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term_count]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperator.term_count "Permalink to this definition"){.headerlink}

    :   Returns the number of terms in the operator.

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperator.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

    [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperator.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

    [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperator.trim "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[tol]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0.0]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

        2.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperator]{.pre}]{.n}*, *[[tol:]{.pre} [float]{.pre} [=]{.pre} [0.0]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.fermion.]{.pre}]{.sig-prename .descclassname}[[FermionOperatorTerm]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperatorTerm "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperatorTerm.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. The canonicalization will throw a runtime
        exception if the operator acts on any degrees of freedom that
        are not included in the given set.

    *[property]{.pre}[ ]{.w}*[[coefficient]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperatorTerm.coefficient "Permalink to this definition"){.headerlink}

    :   Returns the unevaluated coefficient of the operator. The
        coefficient is a callback function that can be invoked with the
        [`evaluate`{.code .docutils .literal .notranslate}]{.pre}
        method.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperatorTerm.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperatorTerm.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        [`to_matrix`{.code .docutils .literal .notranslate}]{.pre}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperatorTerm.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    [[evaluate_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperatorTerm.evaluate_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[evaluate_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the evaluated coefficient of the product operator. The
        parameters is a map of parameter names to their concrete,
        complex values.

    [[is_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperatorTerm.is_identity "Permalink to this definition"){.headerlink}

    :   

        [[is_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Checks if all operators in the product are the identity. Note:
        this function returns true regardless of the value of the
        coefficient.

    *[property]{.pre}[ ]{.w}*[[max_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperatorTerm.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperatorTerm.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[ops_count]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperatorTerm.ops_count "Permalink to this definition"){.headerlink}

    :   Returns the number of operators in the product.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperatorTerm.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term_id]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperatorTerm.term_id "Permalink to this definition"){.headerlink}

    :   The term id uniquely identifies the operators and targets
        (degrees) that they act on, but does not include information
        about the coefficient.

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperatorTerm.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

    [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperatorTerm.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.fermion.]{.pre}]{.sig-prename .descclassname}[[FermionOperatorElement]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperatorElement "Permalink to this definition"){.headerlink}

:   

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperatorElement.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[target]{.pre}]{.sig-name .descname}[](#cudaq.operators.fermion.FermionOperatorElement.target "Permalink to this definition"){.headerlink}

    :   Returns the degree of freedom that the operator targets.

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperatorElement.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorElement]{.pre}](#cudaq.operators.fermion.FermionOperatorElement "cudaq.operators.fermion.FermionOperatorElement"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [FermionOperatorElement]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

    [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.fermion.FermionOperatorElement.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorElement]{.pre}](#cudaq.operators.fermion.FermionOperatorElement "cudaq.operators.fermion.FermionOperatorElement"){.reference .internal}]{.n}*, *[[include_degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the string representation of the operator.

[]{#module-cudaq.fermion .target}

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[annihilate]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.fermion.annihilate "Permalink to this definition"){.headerlink}

:   

    [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[annihilate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a fermionic annihilation operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.fermion.canonicalized "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    2.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. The canonicalization will throw a runtime
    exception if the operator acts on any degrees of freedom that are
    not included in the given set.

    3.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    4.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. If an empty set is passed, canonicalizes all
    terms in the sum to act on the same degrees of freedom.

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[create]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.fermion.create "Permalink to this definition"){.headerlink}

:   

    [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[create]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a fermionic creation operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.fermion.empty "Permalink to this definition"){.headerlink}

:   

    [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperator]{.pre}](#cudaq.operators.fermion.FermionOperator "cudaq.operators.fermion.FermionOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns sum operator with no terms. Note that a sum with no terms
    multiplied by anything still is a sum with no terms.

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.fermion.identities "Permalink to this definition"){.headerlink}

:   

    [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[first]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*, *[[last]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Creates a product operator that applies an identity operation to all
    degrees of freedom in the open range \[first, last).

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.fermion.identity "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns product operator with constant value 1.

    2.  

        [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns an identity operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.fermion.number "Permalink to this definition"){.headerlink}

:   

    [[cudaq.fermion.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[FermionOperatorTerm]{.pre}](#cudaq.operators.fermion.FermionOperatorTerm "cudaq.operators.fermion.FermionOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a fermionic number operator on the given target index.
:::

::: {#boson-operators .section}
### Boson Operators[](#boson-operators "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.operators.boson.]{.pre}]{.sig-prename .descclassname}[[BosonOperator]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperator "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperator.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. If an empty set is passed, canonicalizes
        all terms in the sum to act on the same degrees of freedom.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperator.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperator.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        [`to_matrix`{.code .docutils .literal .notranslate}]{.pre}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[distribute_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperator.distribute_terms "Permalink to this definition"){.headerlink}

    :   

        [[distribute_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Partitions the terms of the sums into the given number of
        separate sums.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperator.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    *[static]{.pre}[ ]{.w}*[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperator.empty "Permalink to this definition"){.headerlink}

    :   

        [[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a sum operator with no terms. And empty sum is the
        neutral element for addition; multiplying an empty sum with
        anything will still result in an empty sum.

    *[static]{.pre}[ ]{.w}*[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperator.identity "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator with constant value 1. The identity
        operator is the neutral element for multiplication.

        2.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator that applies the identity to the
        given target index.

    *[property]{.pre}[ ]{.w}*[[max_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperator.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperator.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperator.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term_count]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperator.term_count "Permalink to this definition"){.headerlink}

    :   Returns the number of terms in the operator.

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperator.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

    [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperator.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

    [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperator.trim "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[tol]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0.0]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

        2.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperator]{.pre}]{.n}*, *[[tol:]{.pre} [float]{.pre} [=]{.pre} [0.0]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.boson.]{.pre}]{.sig-prename .descclassname}[[BosonOperatorTerm]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperatorTerm "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperatorTerm.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. The canonicalization will throw a runtime
        exception if the operator acts on any degrees of freedom that
        are not included in the given set.

    *[property]{.pre}[ ]{.w}*[[coefficient]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperatorTerm.coefficient "Permalink to this definition"){.headerlink}

    :   Returns the unevaluated coefficient of the operator. The
        coefficient is a callback function that can be invoked with the
        [`evaluate`{.code .docutils .literal .notranslate}]{.pre}
        method.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperatorTerm.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperatorTerm.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        [`to_matrix`{.code .docutils .literal .notranslate}]{.pre}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperatorTerm.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    [[evaluate_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperatorTerm.evaluate_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[evaluate_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the evaluated coefficient of the product operator. The
        parameters is a map of parameter names to their concrete,
        complex values.

    [[is_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperatorTerm.is_identity "Permalink to this definition"){.headerlink}

    :   

        [[is_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Checks if all operators in the product are the identity. Note:
        this function returns true regardless of the value of the
        coefficient.

    *[property]{.pre}[ ]{.w}*[[max_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperatorTerm.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperatorTerm.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[ops_count]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperatorTerm.ops_count "Permalink to this definition"){.headerlink}

    :   Returns the number of operators in the product.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperatorTerm.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term_id]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperatorTerm.term_id "Permalink to this definition"){.headerlink}

    :   The term id uniquely identifies the operators and targets
        (degrees) that they act on, but does not include information
        about the coefficient.

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperatorTerm.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

    [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperatorTerm.to_sparse_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_sparse_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the sparse matrix representation of the operator. This
        representation is a [`Tuple[list[complex],`{.code .docutils
        .literal .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int],`{.code .docutils .literal
        .notranslate}]{.pre}` `{.code .docutils .literal
        .notranslate}[`list[int]]`{.code .docutils .literal
        .notranslate}]{.pre}, encoding the non-zero values, rows, and
        columns of the matrix. This format is supported by
        [`scipy.sparse.csr_array`{.code .docutils .literal
        .notranslate}]{.pre}.The matrix is ordered according to the
        convention (endianness) used in CUDA-Q, and the ordering
        returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.boson.]{.pre}]{.sig-prename .descclassname}[[BosonOperatorElement]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperatorElement "Permalink to this definition"){.headerlink}

:   

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperatorElement.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[target]{.pre}]{.sig-name .descname}[](#cudaq.operators.boson.BosonOperatorElement.target "Permalink to this definition"){.headerlink}

    :   Returns the degree of freedom that the operator targets.

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperatorElement.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorElement]{.pre}](#cudaq.operators.boson.BosonOperatorElement "cudaq.operators.boson.BosonOperatorElement"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [BosonOperatorElement]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

    [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.boson.BosonOperatorElement.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorElement]{.pre}](#cudaq.operators.boson.BosonOperatorElement "cudaq.operators.boson.BosonOperatorElement"){.reference .internal}]{.n}*, *[[include_degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the string representation of the operator.

[]{#module-cudaq.boson .target}

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[annihilate]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.boson.annihilate "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[annihilate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a bosonic annihilation operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.boson.canonicalized "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    2.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. The canonicalization will throw a runtime
    exception if the operator acts on any degrees of freedom that are
    not included in the given set.

    3.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    4.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. If an empty set is passed, canonicalizes all
    terms in the sum to act on the same degrees of freedom.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[create]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.boson.create "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[create]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a bosonic creation operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.boson.empty "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns sum operator with no terms. Note that a sum with no terms
    multiplied by anything still is a sum with no terms.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.boson.identities "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[first]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*, *[[last]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Creates a product operator that applies an identity operation to all
    degrees of freedom in the open range \[first, last).

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.boson.identity "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns product operator with constant value 1.

    2.  

        [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Returns an identity operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[momentum]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.boson.momentum "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[momentum]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a bosonic momentum operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.boson.number "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperatorTerm]{.pre}](#cudaq.operators.boson.BosonOperatorTerm "cudaq.operators.boson.BosonOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a bosonic number operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[position]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.boson.position "Permalink to this definition"){.headerlink}

:   

    [[cudaq.boson.]{.pre}]{.sig-prename .descclassname}[[position]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[BosonOperator]{.pre}](#cudaq.operators.boson.BosonOperator "cudaq.operators.boson.BosonOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a bosonic position operator on the given target index.
:::

::: {#general-operators .section}
### General Operators[](#general-operators "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[MatrixOperator]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperator "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.MatrixOperator.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. If an empty set is passed, canonicalizes
        all terms in the sum to act on the same degrees of freedom.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.MatrixOperator.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperator.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets.

    [[distribute_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.MatrixOperator.distribute_terms "Permalink to this definition"){.headerlink}

    :   

        [[distribute_terms]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Partitions the terms of the sums into the given number of
        separate sums.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.MatrixOperator.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    *[static]{.pre}[ ]{.w}*[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.MatrixOperator.empty "Permalink to this definition"){.headerlink}

    :   

        [[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a sum operator with no terms. And empty sum is the
        neutral element for addition; multiplying an empty sum with
        anything will still result in an empty sum.

    *[static]{.pre}[ ]{.w}*[[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.MatrixOperator.identity "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator with constant value 1. The identity
        operator is the neutral element for multiplication.

        2.  

            [[identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Creates a product operator that applies the identity to the
        given target index.

    *[property]{.pre}[ ]{.w}*[[max_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperator.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperator.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperator.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term_count]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperator.term_count "Permalink to this definition"){.headerlink}

    :   Returns the number of terms in the operator.

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.MatrixOperator.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [MatrixOperator]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

    [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.MatrixOperator.trim "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[tol]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0.0]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

        2.  

            [[trim]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [MatrixOperator]{.pre}]{.n}*, *[[tol:]{.pre} [float]{.pre} [=]{.pre} [0.0]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all terms from the sum for which the absolute value of
        the coefficient is below the given tolerance.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[MatrixOperatorTerm]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorTerm "Permalink to this definition"){.headerlink}

:   

    [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.MatrixOperatorTerm.canonicalize "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Removes all identity operators from the operator.

        2.  

            [[canonicalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Expands the operator to act on all given degrees, applying
        identities as needed. The canonicalization will throw a runtime
        exception if the operator acts on any degrees of freedom that
        are not included in the given set.

    *[property]{.pre}[ ]{.w}*[[coefficient]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorTerm.coefficient "Permalink to this definition"){.headerlink}

    :   Returns the unevaluated coefficient of the operator. The
        coefficient is a callback function that can be invoked with the
        [`evaluate`{.code .docutils .literal .notranslate}]{.pre}
        method.

    [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.MatrixOperatorTerm.copy "Permalink to this definition"){.headerlink}

    :   

        [[copy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Creates a copy of the operator.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorTerm.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets. The order of degrees is from smallest to
        largest and reflects the ordering of the matrix returned by
        [`to_matrix`{.code .docutils .literal .notranslate}]{.pre}.
        Specifically, the indices of a statevector with two qubits are
        {00, 01, 10, 11}. An ordering of degrees {0, 1} then indicates
        that a state where the qubit with index 0 equals 1 with
        probability 1 is given by the vector {0., 1., 0., 0.}.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.MatrixOperatorTerm.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the string representation of the operator to the standard
        output.

    [[evaluate_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.MatrixOperatorTerm.evaluate_coefficient "Permalink to this definition"){.headerlink}

    :   

        [[evaluate_coefficient]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the evaluated coefficient of the product operator. The
        parameters is a map of parameter names to their concrete,
        complex values.

    [[is_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.MatrixOperatorTerm.is_identity "Permalink to this definition"){.headerlink}

    :   

        [[is_identity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Checks if all operators in the product are the identity. Note:
        this function returns true regardless of the value of the
        coefficient.

    *[property]{.pre}[ ]{.w}*[[max_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorTerm.max_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[min_degree]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorTerm.min_degree "Permalink to this definition"){.headerlink}

    :   Returns the smallest index of the degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[ops_count]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorTerm.ops_count "Permalink to this definition"){.headerlink}

    :   Returns the number of operators in the product.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorTerm.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    *[property]{.pre}[ ]{.w}*[[term_id]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorTerm.term_id "Permalink to this definition"){.headerlink}

    :   The term id uniquely identifies the operators and targets
        (degrees) that they act on, but does not include information
        about the coefficient.

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.MatrixOperatorTerm.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[invert_order]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [MatrixOperatorTerm]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[invert_order:]{.pre} [bool]{.pre} [=]{.pre} [False]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.The matrix is
        ordered according to the convention (endianness) used in CUDA-Q,
        and the ordering returned by [`degrees`{.code .docutils .literal
        .notranslate}]{.pre}. This order can be inverted by setting the
        optional [`invert_order`{.code .docutils .literal
        .notranslate}]{.pre} argument to [`True`{.code .docutils
        .literal .notranslate}]{.pre}. See also the documentation for
        [`degrees`{.code .docutils .literal .notranslate}]{.pre} for
        more detail.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.operators.]{.pre}]{.sig-prename .descclassname}[[MatrixOperatorElement]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorElement "Permalink to this definition"){.headerlink}

:   

    *[classmethod]{.pre}[ ]{.w}*[[define]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[id]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*, *[[expected_dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[create]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Callable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[\...]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.4)"){.reference .external}[[\[]{.pre}]{.p}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[dtype]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.4)"){.reference .external}[[\[]{.pre}]{.p}[[complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.4)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[override]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}[](#cudaq.operators.MatrixOperatorElement.define "Permalink to this definition"){.headerlink}

    :   Creates the definition of an elementary operator with the given
        id.

    *[property]{.pre}[ ]{.w}*[[degrees]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorElement.degrees "Permalink to this definition"){.headerlink}

    :   Returns a vector that lists all degrees of freedom that the
        operator targets.

    *[property]{.pre}[ ]{.w}*[[expected_dimensions]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorElement.expected_dimensions "Permalink to this definition"){.headerlink}

    :   The number of levels, that is the dimension, for each degree of
        freedom in canonical order that the operator acts on. A value of
        zero or less indicates that the operator is defined for any
        dimension of that degree.

    *[property]{.pre}[ ]{.w}*[[id]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorElement.id "Permalink to this definition"){.headerlink}

    :   Returns the id used to define and instantiate the operator.

    *[property]{.pre}[ ]{.w}*[[parameters]{.pre}]{.sig-name .descname}[](#cudaq.operators.MatrixOperatorElement.parameters "Permalink to this definition"){.headerlink}

    :   Returns a dictionary that maps each parameter name to its
        description.

    [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.MatrixOperatorElement.to_matrix "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorElement]{.pre}](#cudaq.operators.MatrixOperatorElement "cudaq.operators.MatrixOperatorElement"){.reference .internal}]{.n}*, *[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*, *[[parameters]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[{}]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

        2.  

            [[to_matrix]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [MatrixOperatorElement]{.pre}]{.n}*, *[[dimensions:]{.pre} [dict\[int]{.pre}]{.n}*, *[[int\]]{.pre} [=]{.pre} [{}]{.pre}]{.n}*, *[[\\\*\\\*kwargs]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns the matrix representation of the operator.

    [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.MatrixOperatorElement.to_string "Permalink to this definition"){.headerlink}

    :   

        [[to_string]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorElement]{.pre}](#cudaq.operators.MatrixOperatorElement "cudaq.operators.MatrixOperatorElement"){.reference .internal}]{.n}*, *[[include_degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the string representation of the operator.

[]{#module-cudaq.operators.custom .target}

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.operators.custom.canonicalized "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    2.  

        [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. The canonicalization will throw a runtime
    exception if the operator acts on any degrees of freedom that are
    not included in the given set.

    3.  

        [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Removes all identity operators from the operator.

    4.  

        [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[canonicalized]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[set]{.pre}](https://docs.python.org/3/library/stdtypes.html#set "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Expands the operator to act on all given degrees, applying
    identities as needed. If an empty set is passed, canonicalizes all
    terms in the sum to act on the same degrees of freedom.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[define]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[id]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*, *[[expected_dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Sequence]{.pre}](https://docs.python.org/3/library/typing.html#typing.Sequence "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[create]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Callable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Callable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[\...]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.4)"){.reference .external}[[\[]{.pre}]{.p}[[Any]{.pre}](https://docs.python.org/3/library/typing.html#typing.Any "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[dtype]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype "(in NumPy v2.4)"){.reference .external}[[\[]{.pre}]{.p}[[complexfloating]{.pre}](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complexfloating "(in NumPy v2.4)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*, *[[override]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[False]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}[](#cudaq.operators.custom.define "Permalink to this definition"){.headerlink}

:   Defines a matrix operator element with the given id. After
    definition, an the defined elementary operator can be instantiated
    by providing the operator id as well as the degree(s) of freedom
    that it acts on. A matrix operator element is a parameterized object
    acting on certain degrees of freedom. To evaluate an operator, for
    example to compute its matrix, the level, that is the dimension, for
    each degree of freedom it acts on must be provided, as well as all
    additional parameters. Additional parameters must be provided in the
    form of keyword arguments.

    Note: The dimensions passed during operator evaluation are
    automatically validated against the expected dimensions specified
    during definition - the [`create`{.code .docutils .literal
    .notranslate}]{.pre} function does not need to do this.

    Parameters[:]{.colon}

    :   -   **op_id** -- A string that uniquely identifies the defined
            operator.

        -   **expected_dimensions** -- defines the number of levels,
            that is the dimension, for each degree of freedom in
            canonical (that is sorted) order. A negative or zero value
            for one (or more) of the expected dimensions indicates that
            the operator is defined for any dimension of the
            corresponding degree of freedom.

        -   **create** -- Takes any number of complex-valued arguments
            and returns the matrix representing the operator in
            canonical order. If the matrix can be defined for any number
            of levels for one or more degree of freedom, the
            [`create`{.code .docutils .literal .notranslate}]{.pre}
            function must take an argument called [`dimension`{.code
            .docutils .literal .notranslate}]{.pre} (or [`dim`{.code
            .docutils .literal .notranslate}]{.pre} for short), if the
            operator acts on a single degree of freedom, and an argument
            called [`dimensions`{.code .docutils .literal
            .notranslate}]{.pre} (or [`dims`{.code .docutils .literal
            .notranslate}]{.pre} for short), if the operator acts on
            multiple degrees of freedom.

        -   **override** -- if True it allows override the definition.
            (default: False)

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[displace]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.custom.displace "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[displace]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a displacement operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.custom.empty "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[empty]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperator]{.pre}](#cudaq.operators.MatrixOperator "cudaq.operators.MatrixOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns sum operator with no terms. Note that a sum with no terms
    multiplied by anything still is a sum with no terms.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.custom.identities "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[identities]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[first]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*, *[[last]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Creates a product operator that applies an identity operation to all
    degrees of freedom in the open range \[first, last).

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[instantiate]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[op_id]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*, *[[degrees]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Union]{.pre}](https://docs.python.org/3/library/typing.html#typing.Union "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[Iterable]{.pre}](https://docs.python.org/3/library/typing.html#typing.Iterable "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}[](#cudaq.operators.custom.instantiate "Permalink to this definition"){.headerlink}

:   Instantiates a product operator containing a previously defined
    operator element.

    Parameters[:]{.colon}

    :   -   **operator_id** -- The id of the operator element as
            specified when it was defined.

        -   **degrees** -- The degree(s) of freedom that the operator
            acts on.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[momentum]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.custom.momentum "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[momentum]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a momentum operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.custom.number "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[number]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a number operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[parity]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.custom.parity "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[parity]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a parity operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[position]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.custom.position "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[position]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a position operator on the given target index.

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[squeeze]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.operators.custom.squeeze "Permalink to this definition"){.headerlink}

:   

    [[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[squeeze]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[target]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[MatrixOperatorTerm]{.pre}](#cudaq.operators.MatrixOperatorTerm "cudaq.operators.MatrixOperatorTerm"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns a squeezing operator on the given target index.
:::
:::

::: {#data-types .section}
## Data Types[](#data-types "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[SimulationPrecision]{.pre}]{.sig-name .descname}[](#cudaq.SimulationPrecision "Permalink to this definition"){.headerlink}

:   Enumeration describing the precision of the underyling simulation.

    Members:

    > <div>
    >
    > fp32
    >
    > fp64
    >
    > </div>

    *[property]{.pre}[ ]{.w}*[[name]{.pre}]{.sig-name .descname}[](#cudaq.SimulationPrecision.name "Permalink to this definition"){.headerlink}

    :   object) -\> str :noindex:

        Type[:]{.colon}

        :   

            [[name(self]{.pre}]{.sig-name .descname}

            :   

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Target]{.pre}]{.sig-name .descname}[](#cudaq.Target "Permalink to this definition"){.headerlink}

:   The [`cudaq.Target`{.code .docutils .literal .notranslate}]{.pre}
    represents the underlying infrastructure that CUDA-Q kernels will
    execute on. Instances of [`cudaq.Target`{.code .docutils .literal
    .notranslate}]{.pre} describe what simulator they may leverage, the
    quantum_platform required for execution, and a description for the
    target.

    *[property]{.pre}[ ]{.w}*[[description]{.pre}]{.sig-name .descname}[](#cudaq.Target.description "Permalink to this definition"){.headerlink}

    :   A string describing the features for this [`cudaq.Target`{.code
        .docutils .literal .notranslate}]{.pre}.

    [[get_precision]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.Target.get_precision "Permalink to this definition"){.headerlink}

    :   

        [[get_precision]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SimulationPrecision]{.pre}](#cudaq.SimulationPrecision "cudaq.SimulationPrecision"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the simulation precision for the current target.

    [[is_emulated]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.Target.is_emulated "Permalink to this definition"){.headerlink}

    :   

        [[is_emulated]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns true if the emulation mode for the target has been
        activated.

    [[is_remote]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.Target.is_remote "Permalink to this definition"){.headerlink}

    :   

        [[is_remote]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns true if the target consists of a remote REST QPU.

    [[is_remote_simulator]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.Target.is_remote_simulator "Permalink to this definition"){.headerlink}

    :   

        [[is_remote_simulator]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns true if the target consists of a remote REST Simulator
        QPU.

    *[property]{.pre}[ ]{.w}*[[name]{.pre}]{.sig-name .descname}[](#cudaq.Target.name "Permalink to this definition"){.headerlink}

    :   The name of the [`cudaq.Target`{.code .docutils .literal
        .notranslate}]{.pre}.

    [[num_qpus]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.Target.num_qpus "Permalink to this definition"){.headerlink}

    :   

        [[num_qpus]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Target]{.pre}](#cudaq.Target "cudaq.Target"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the number of QPUs available in this
        [`cudaq.Target`{.code .docutils .literal .notranslate}]{.pre}.

    *[property]{.pre}[ ]{.w}*[[platform]{.pre}]{.sig-name .descname}[](#cudaq.Target.platform "Permalink to this definition"){.headerlink}

    :   The name of the quantum_platform implementation this
        [`cudaq.Target`{.code .docutils .literal .notranslate}]{.pre}
        leverages.

    *[property]{.pre}[ ]{.w}*[[simulator]{.pre}]{.sig-name .descname}[](#cudaq.Target.simulator "Permalink to this definition"){.headerlink}

    :   The name of the simulator this [`cudaq.Target`{.code .docutils
        .literal .notranslate}]{.pre} leverages. This will be empty for
        physical QPUs.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[State]{.pre}]{.sig-name .descname}[](#cudaq.State "Permalink to this definition"){.headerlink}

:   A data-type representing the quantum state of the internal
    simulator. This type is not user-constructible and instances can
    only be retrieved via the [`cudaq.get_state(...)`{.code .docutils
    .literal .notranslate}]{.pre} function or the static
    [`cudaq.State.from_data()`{.code .docutils .literal
    .notranslate}]{.pre} method.

    [[amplitude]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.State.amplitude "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[amplitude]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the amplitude of a state in computational basis.

        ::: {.highlight-python .notranslate}
        ::: highlight
            # Example:
            # Create a simulation state.
            state = cudaq.get_state(kernel)
            # Return the amplitude of |0101>, assuming this is a 4-qubit state.
            amplitude = state.amplitude([0,1,0,1])
        :::
        :::

        2.  

            [[amplitude]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the amplitude of a state in computational basis.

        ::: {.highlight-python .notranslate}
        ::: highlight
            # Example:
            # Create a simulation state.
            state = cudaq.get_state(kernel)
            # Return the amplitude of |0101>, assuming this is a 4-qubit state.
            amplitude = state.amplitude('0101')
        :::
        :::

    [[amplitudes]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.State.amplitudes "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[amplitudes]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the amplitude of a list of states in computational basis.

        ::: {.highlight-python .notranslate}
        ::: highlight
            # Example:
            # Create a simulation state.
            state = cudaq.get_state(kernel)
            # Return the amplitude of |0101> and |1010>, assuming this is a 4-qubit state.
            amplitudes = state.amplitudes([[0,1,0,1], [1,0,1,0]])
        :::
        :::

        2.  

            [[amplitudes]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the amplitudes of a list of states in computational
        basis.

        ::: {.highlight-python .notranslate}
        ::: highlight
            # Example:
            # Create a simulation state.
            state = cudaq.get_state(kernel)
            # Return the amplitudes of |0101> and |1010>, assuming this is a 4-qubit state.
            amplitudes = state.amplitudes(['0101', '1010'])
        :::
        :::

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.State.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Print the state to the console.

    *[static]{.pre}[ ]{.w}*[[from_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.State.from_data "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[from_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[numpy.ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.4)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Return a state from data.

        2.  

            [[from_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[numpy.ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.4)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Return a state from matrix product state tensor data.

        3.  

            [[from_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[Tensor]{.pre}](#cudaq.Tensor "cudaq.Tensor"){.reference .internal}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Return a state from matrix product state tensor data.

        4.  

            [[from_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Return a state from matrix product state tensor data (as CuPy
        ndarray).

        5.  

            [[from_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Return a state from CuPy device array.

    [[getTensor]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.State.getTensor "Permalink to this definition"){.headerlink}

    :   

        [[getTensor]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[idx]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[Tensor]{.pre}](#cudaq.Tensor "cudaq.Tensor"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the [`idx`{.code .docutils .literal .notranslate}]{.pre}
        tensor making up this state representation.

    [[getTensors]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.State.getTensors "Permalink to this definition"){.headerlink}

    :   

        [[getTensors]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[Tensor]{.pre}](#cudaq.Tensor "cudaq.Tensor"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Return all the tensors that comprise this state representation.

    [[get_state_refval]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.State.get_state_refval "Permalink to this definition"){.headerlink}

    :   

        [[get_state_refval]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert the address of the state object to an integer.

    [[is_on_gpu]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.State.is_on_gpu "Permalink to this definition"){.headerlink}

    :   

        [[is_on_gpu]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return True if this state is on the GPU.

    [[num_qubits]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.State.num_qubits "Permalink to this definition"){.headerlink}

    :   

        [[num_qubits]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the number of qubits represented by this state.

    [[overlap]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.State.overlap "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[overlap]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Compute the overlap between the provided [[`State`{.xref .py
        .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.State "cudaq.State"){.reference
        .internal}'s.

        2.  

            [[overlap]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[numpy.ndarray]{.pre}](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray "(in NumPy v2.4)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Compute the overlap between the provided [[`State`{.xref .py
        .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.State "cudaq.State"){.reference
        .internal}'s.

        3.  

            [[overlap]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Compute overlap with general CuPy device array.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Tensor]{.pre}]{.sig-name .descname}[](#cudaq.Tensor "Permalink to this definition"){.headerlink}

:   The [`Tensor`{.code .docutils .literal .notranslate}]{.pre}
    describes a pointer to simulation data as well as the rank and
    extents for that tensorial data it represents.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[QuakeValue]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[mlirValue]{.pre}]{.n}*, *[[pyKernel]{.pre}]{.n}*, *[[size]{.pre}]{.n}[[=]{.pre}]{.o}[[None]{.pre}]{.default_value}*[)]{.sig-paren}[](#cudaq.QuakeValue "Permalink to this definition"){.headerlink}

:   A [[`QuakeValue`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
    .internal} represents a handle to an individual function argument of
    a [[`Kernel`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
    .internal}, or a return value from an operation within it. As
    documented in [[`make_kernel()`{.xref .py .py-func .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.make_kernel "cudaq.make_kernel"){.reference
    .internal}, a [[`QuakeValue`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
    .internal} can hold values of the following types: int, float,
    list/List, [[`qubit`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.qubit "cudaq.qubit"){.reference
    .internal}, or [[`qvector`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.qvector "cudaq.qvector"){.reference
    .internal}. The [[`QuakeValue`{.xref .py .py-class .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
    .internal} can also hold kernel operations such as qubit allocations
    and measurements.

    [[\_\_add\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.QuakeValue.__add__ "Permalink to this definition"){.headerlink}

    :   Return the sum of [`self`{.code .docutils .literal
        .notranslate}]{.pre} ([[`QuakeValue`{.xref .py .py-class
        .docutils .literal
        .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}) and [`other`{.code .docutils .literal
        .notranslate}]{.pre} (float).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.14)"){.reference
            .external} -- if the underlying [[`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: highlight
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = value + 5.0
        :::
        :::

    [[\_\_radd\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.QuakeValue.__radd__ "Permalink to this definition"){.headerlink}

    :   Return the sum of [`other`{.code .docutils .literal
        .notranslate}]{.pre} (float) and [`self`{.code .docutils
        .literal .notranslate}]{.pre} ([[`QuakeValue`{.xref .py
        .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.14)"){.reference
            .external} -- if the underlying [[`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: highlight
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = 5.0 + value
        :::
        :::

    [[\_\_sub\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.QuakeValue.__sub__ "Permalink to this definition"){.headerlink}

    :   Return the difference of [`self`{.code .docutils .literal
        .notranslate}]{.pre} ([[`QuakeValue`{.xref .py .py-class
        .docutils .literal
        .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}) and [`other`{.code .docutils .literal
        .notranslate}]{.pre} (float).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.14)"){.reference
            .external} -- if the underlying [[`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: highlight
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = value - 5.0
        :::
        :::

    [[\_\_rsub\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.QuakeValue.__rsub__ "Permalink to this definition"){.headerlink}

    :   Return the difference of [`other`{.code .docutils .literal
        .notranslate}]{.pre} (float) and [`self`{.code .docutils
        .literal .notranslate}]{.pre} ([[`QuakeValue`{.xref .py
        .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.14)"){.reference
            .external} -- if the underlying [[`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: highlight
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = 5.0 - value
        :::
        :::

    [[\_\_neg\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.QuakeValue.__neg__ "Permalink to this definition"){.headerlink}

    :   Return the negation of [`self`{.code .docutils .literal
        .notranslate}]{.pre} ([[`QuakeValue`{.xref .py .py-class
        .docutils .literal
        .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.14)"){.reference
            .external} -- if the underlying [[`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: highlight
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = -value
        :::
        :::

    [[\_\_mul\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.QuakeValue.__mul__ "Permalink to this definition"){.headerlink}

    :   Return the product of [`self`{.code .docutils .literal
        .notranslate}]{.pre} ([[`QuakeValue`{.xref .py .py-class
        .docutils .literal
        .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}) with [`other`{.code .docutils .literal
        .notranslate}]{.pre} (float).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.14)"){.reference
            .external} -- if the underlying [[`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: highlight
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = value * 5.0
        :::
        :::

    [[\_\_rmul\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[other]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.QuakeValue.__rmul__ "Permalink to this definition"){.headerlink}

    :   Return the product of [`other`{.code .docutils .literal
        .notranslate}]{.pre} (float) with [`self`{.code .docutils
        .literal .notranslate}]{.pre} ([[`QuakeValue`{.xref .py
        .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}).

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.14)"){.reference
            .external} -- if the underlying [[`QuakeValue`{.xref .py
            .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} type is not a float.

        ::: {.highlight-python .notranslate}
        ::: highlight
            # Example:
            kernel, value = cudaq.make_kernel(float)
            new_value: QuakeValue = 5.0 * value
        :::
        :::

    [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[idx]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.QuakeValue.__getitem__ "Permalink to this definition"){.headerlink}

    :   Return the element of [`self`{.code .docutils .literal
        .notranslate}]{.pre} at the provided [`index`{.code .docutils
        .literal .notranslate}]{.pre}.

        ::: {.admonition .note}
        Note

        Only [`list`{.code .docutils .literal .notranslate}]{.pre} or
        [[`qvector`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.qvector "cudaq.qvector"){.reference
        .internal} type [[`QuakeValue`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}'s may be indexed.
        :::

        Parameters[:]{.colon}

        :   **index**
            ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}) -- The element of [`self`{.code .docutils
            .literal .notranslate}]{.pre} that you'd like to return.

        Returns[:]{.colon}

        :   A new [[`QuakeValue`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal} for the [`index`{.code .docutils .literal
            .notranslate}]{.pre} element of [`self`{.code .docutils
            .literal .notranslate}]{.pre}.

        Return type[:]{.colon}

        :   [[`QuakeValue`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal}

        Raises[:]{.colon}

        :   [**RuntimeError**](https://docs.python.org/3/library/exceptions.html#RuntimeError "(in Python v3.14)"){.reference
            .external} -- if [`self`{.code .docutils .literal
            .notranslate}]{.pre} is a non-subscriptable
            [[`QuakeValue`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal}.

    [[slice]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[startIdx]{.pre}]{.n}*, *[[count]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.QuakeValue.slice "Permalink to this definition"){.headerlink}

    :   Return a slice of the given [[`QuakeValue`{.xref .py .py-class
        .docutils .literal
        .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal} as a new [[`QuakeValue`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal}.

        ::: {.admonition .note}
        Note

        The underlying [[`QuakeValue`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
        .internal} must be a [`list`{.code .docutils .literal
        .notranslate}]{.pre} or [`veq`{.code .docutils .literal
        .notranslate}]{.pre}.
        :::

        Parameters[:]{.colon}

        :   -   **start**
                ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
                .external}) -- The index to begin the slice from.

            -   **count**
                ([*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
                .external}) -- The number of elements to extract after
                the [`start`{.code .docutils .literal
                .notranslate}]{.pre} index.

        Returns[:]{.colon}

        :   A new [`QuakeValue`{.code .docutils .literal
            .notranslate}]{.pre} containing a slice of [`self`{.code
            .docutils .literal .notranslate}]{.pre} from the
            [`start`{.code .docutils .literal .notranslate}]{.pre}
            element to the [`start`{.code .docutils .literal
            .notranslate}]{.pre}` `{.code .docutils .literal
            .notranslate}[`+`{.code .docutils .literal
            .notranslate}]{.pre}` `{.code .docutils .literal
            .notranslate}[`count`{.code .docutils .literal
            .notranslate}]{.pre} element.

        Return type[:]{.colon}

        :   [[`QuakeValue`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.QuakeValue "cudaq.QuakeValue"){.reference
            .internal}

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[qubit]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.qubit "Permalink to this definition"){.headerlink}

:   The qubit is the primary unit of information in a quantum computer.
    Qubits can be created individually or as part of larger registers.

```{=html}
<!-- -->
```

[[cudaq.]{.pre}]{.sig-prename .descclassname}[[qreg]{.pre}]{.sig-name .descname}[](#cudaq.qreg "Permalink to this definition"){.headerlink}

:   alias of [[`qvector`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.qvector "cudaq.kernel_types.qvector"){.reference
    .internal}

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[qvector]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.qvector "Permalink to this definition"){.headerlink}

:   An owning, dynamically sized container for qubits. The semantics of
    the [`qvector`{.code .docutils .literal .notranslate}]{.pre} follows
    that of a [`std::vector`{.code .docutils .literal
    .notranslate}]{.pre} or list for qubits.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[ComplexMatrix]{.pre}]{.sig-name .descname}[](#cudaq.ComplexMatrix "Permalink to this definition"){.headerlink}

:   The [[`ComplexMatrix`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference
    .internal} is a thin wrapper around a matrix of complex\<double\>
    elements.

    [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.ComplexMatrix.__getitem__ "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the matrix element at i, j.

        2.  

            [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the matrix element at i, j.

    [[\_\_str\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.ComplexMatrix.__str__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_str\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the string representation of the matrix.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.ComplexMatrix.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Prints the matrix to the standard output.

    [[minimal_eigenvalue]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.ComplexMatrix.minimal_eigenvalue "Permalink to this definition"){.headerlink}

    :   

        [[minimal_eigenvalue]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[complex]{.pre}](https://docs.python.org/3/library/functions.html#complex "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the lowest eigenvalue for this [[`ComplexMatrix`{.xref
        .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference
        .internal}.

    [[num_columns]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.ComplexMatrix.num_columns "Permalink to this definition"){.headerlink}

    :   

        [[num_columns]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the number of columns in the matrix.

    [[num_rows]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.ComplexMatrix.num_rows "Permalink to this definition"){.headerlink}

    :   

        [[num_rows]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the number of rows in the matrix.

    [[to_numpy]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.ComplexMatrix.to_numpy "Permalink to this definition"){.headerlink}

    :   

        [[to_numpy]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ComplexMatrix]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[numpy.ndarray\[\]]{.pre}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert [[`ComplexMatrix`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.ComplexMatrix "cudaq.ComplexMatrix"){.reference
        .internal} to numpy.ndarray.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[SampleResult]{.pre}]{.sig-name .descname}[](#cudaq.SampleResult "Permalink to this definition"){.headerlink}

:   A data-type containing the results of a call to [[`sample()`{.xref
    .py .py-func .docutils .literal
    .notranslate}]{.pre}](#cudaq.sample "cudaq.sample"){.reference
    .internal}. This includes all measurement counts data from both
    mid-circuit and terminal measurements.

    ::: {.admonition .note}
    Note

    Conditional logic on mid-circuit measurements is no longer supported
    with

    [`sample`{.code .docutils .literal .notranslate}]{.pre}. Use
    [`run`{.code .docutils .literal .notranslate}]{.pre} instead.
    :::

    [[register_names]{.pre}]{.sig-name .descname}[](#cudaq.SampleResult.register_names "Permalink to this definition"){.headerlink}

    :   A list of the names of each measurement register that are stored
        in [`self`{.code .docutils .literal .notranslate}]{.pre}.

        Type[:]{.colon}

        :   List\[[str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
            .external}\]

    [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.__getitem__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[bitstring]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the measurement counts for the given [`bitstring`{.code
        .docutils .literal .notranslate}]{.pre}.

        Parameters[:]{.colon}

        :   **bitstring**
            ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
            .external}) -- The binary string to return the measurement
            data of.

        Returns[:]{.colon}

        :   The number of times the given [`bitstring`{.code .docutils
            .literal .notranslate}]{.pre} was measured during the
            [`shots_count`{.code .docutils .literal .notranslate}]{.pre}
            number of executions on the QPU.

        Return type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

    [[\_\_iter\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.__iter__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_iter\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[Iterator]{.pre}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Iterate through the [[`SampleResult`{.xref .py .py-class
        .docutils .literal
        .notranslate}]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} dictionary.

    [[\_\_len\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.__len__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_len\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the number of elements in [`self`{.code .docutils
        .literal .notranslate}]{.pre}. Equivalent to the number of
        uniquely measured bitstrings.

    [[clear]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.clear "Permalink to this definition"){.headerlink}

    :   

        [[clear]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Clear out all metadata from [`self`{.code .docutils .literal
        .notranslate}]{.pre}.

    [[count]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.count "Permalink to this definition"){.headerlink}

    :   

        [[count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[bitstring]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*, *[[register_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the number of times the given bitstring was observed.

        Parameters[:]{.colon}

        :   -   **bitstring**
                ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
                .external}) -- The binary string to return the
                measurement counts for.

            -   **register_name**
                (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
                .external}*\]*) -- The optional measurement register
                name to extract the probability from. Defaults to the
                '\_\_global\_\_' register.

        Returns[:]{.colon}

        :   The number of times the given bitstring was measured during
            the experiment.

        Return type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}

    [[deserialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.deserialize "Permalink to this definition"){.headerlink}

    :   

        [[deserialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Deserialize this SampleResult from an existing vector of
        integers adhering to the implicit encoding.

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Print a string of the raw measurement counts data to the
        terminal.

    [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.expectation "Permalink to this definition"){.headerlink}

    :   

        [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[register_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the expectation value in the Z-basis of the
        [[`Kernel`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal} that was sampled.

    [[expectation_z]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.expectation_z "Permalink to this definition"){.headerlink}

    :   

        [[expectation_z]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[register_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the expectation value in the Z-basis of the
        [[`Kernel`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
        .internal} that was sampled.

    [[get_marginal_counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.get_marginal_counts "Permalink to this definition"){.headerlink}

    :   

        [[get_marginal_counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[self:]{.pre} [SampleResult,]{.pre} [marginal_indices:]{.pre} [list\[int\],]{.pre} [\\\*,]{.pre} [register_name:]{.pre} [str]{.pre} [=]{.pre} [\'\_\_global\_\_\']{.pre}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Extract the measurement counts data for the provided subset of
        qubits ([`marginal_indices`{.code .docutils .literal
        .notranslate}]{.pre}).

        Parameters[:]{.colon}

        :   -   **marginal_indices**
                ([*list*](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
                .external}*\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
                .external}*\]*) -- A list of the qubit indices to
                extract the measurement data from.

            -   **register_name**
                (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
                .external}*\]*) -- The optional measurement register
                name to extract the counts data from. Defaults to the
                '\_\_global\_\_' register.

        Returns[:]{.colon}

        :   A new [`SampleResult`{.code .docutils .literal
            .notranslate}]{.pre} dictionary containing the extracted
            measurement data.

        Return type[:]{.colon}

        :   [[`SampleResult`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
            .internal}

    [[get_register_counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.get_register_counts "Permalink to this definition"){.headerlink}

    :   

        [[get_register_counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[register_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Extract the provided sub-register ([`register_name`{.code
        .docutils .literal .notranslate}]{.pre}) as a new
        [[`SampleResult`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal}.

    [[get_sequential_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.get_sequential_data "Permalink to this definition"){.headerlink}

    :   

        [[get_sequential_data]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[register_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the data from the given register ([`register_name`{.code
        .docutils .literal .notranslate}]{.pre}) as it was collected
        sequentially. A list of measurement results, not collated into a
        map.

    [[get_total_shots]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.get_total_shots "Permalink to this definition"){.headerlink}

    :   

        [[get_total_shots]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Get the total number of shots in the sample result

    [[items]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.items "Permalink to this definition"){.headerlink}

    :   

        [[items]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[Iterator]{.pre}[[\[]{.pre}]{.p}[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the key/value pairs in this [[`SampleResult`{.xref .py
        .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} dictionary.

    [[most_probable]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.most_probable "Permalink to this definition"){.headerlink}

    :   

        [[most_probable]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[register_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the bitstring that was measured most frequently in the
        experiment.

        Parameters[:]{.colon}

        :   **register_name**
            (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
            .external}*\]*) -- The optional measurement register name to
            extract the most probable bitstring from. Defaults to the
            '\_\_global\_\_' register.

        Returns[:]{.colon}

        :   The most frequently measured binary string during the
            experiment.

        Return type[:]{.colon}

        :   [str](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
            .external}

    [[probability]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.probability "Permalink to this definition"){.headerlink}

    :   

        [[probability]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*, *[[bitstring]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*, *[[register_name]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[\'\_\_global\_\_\']{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the probability of measuring the given [`bitstring`{.code
        .docutils .literal .notranslate}]{.pre}.

        Parameters[:]{.colon}

        :   -   **bitstring**
                ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
                .external}) -- The binary string to return the
                measurement probability of.

            -   **register_name**
                (*Optional\[*[*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
                .external}*\]*) -- The optional measurement register
                name to extract the probability from. Defaults to the
                '\_\_global\_\_' register.

        Returns[:]{.colon}

        :   The probability of measuring the given [`bitstring`{.code
            .docutils .literal .notranslate}]{.pre}. Equivalent to the
            proportion of the total times the bitstring was measured vs.
            the number of experiments ([`shots_count`{.code .docutils
            .literal .notranslate}]{.pre}).

        Return type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

    [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.serialize "Permalink to this definition"){.headerlink}

    :   

        [[serialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Serialize this SampleResult to a vector of integer encoding.

    [[values]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.SampleResult.values "Permalink to this definition"){.headerlink}

    :   

        [[values]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[Iterator]{.pre}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Return all values (the counts) in this [[`SampleResult`{.xref
        .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} dictionary.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[AsyncSampleResult]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.AsyncSampleResult "Permalink to this definition"){.headerlink}

:   

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[ObserveResult]{.pre}]{.sig-name .descname}[](#cudaq.ObserveResult "Permalink to this definition"){.headerlink}

:   A data-type containing the results of a call to [[`observe()`{.xref
    .py .py-func .docutils .literal
    .notranslate}]{.pre}](#cudaq.observe "cudaq.observe"){.reference
    .internal}. This includes any measurement counts data, as well as
    the global expectation value of the user-defined
    [`spin_operator`{.code .docutils .literal .notranslate}]{.pre}.

    [[counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.ObserveResult.counts "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Returns a [[`SampleResult`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} dictionary with the measurement results from the
        experiment. The result for each individual term of the
        [`spin_operator`{.code .docutils .literal .notranslate}]{.pre}
        is stored in its own measurement register. Each register name
        corresponds to the string representation of the spin term
        (without any coefficients).

        2.  

            [[counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [ObserveResult]{.pre}]{.n}*, *[[sub_term:]{.pre} [cudaq::product_op\<cudaq::spin_handler\>]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        3.  

            [[counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*, *[[sub_term]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Given a [`sub_term`{.code .docutils .literal
        .notranslate}]{.pre} of the global [`spin_operator`{.code
        .docutils .literal .notranslate}]{.pre} that was passed to
        [[`observe()`{.xref .py .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.observe "cudaq.observe"){.reference
        .internal}, return its measurement counts.

        Parameters[:]{.colon}

        :   **sub_term** ([`SpinOperator`{.code .docutils .literal
            .notranslate}]{.pre}) -- An individual sub-term of the
            [`spin_operator`{.code .docutils .literal
            .notranslate}]{.pre}.

        Returns[:]{.colon}

        :   The measurement counts data for the individual
            [`sub_term`{.code .docutils .literal .notranslate}]{.pre}.

        Return type[:]{.colon}

        :   [[`SampleResult`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
            .internal}

        4.  

            [[counts]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [ObserveResult]{.pre}]{.n}*, *[[sub_term:]{.pre} [cudaq::sum_op\<cudaq::spin_handler\>]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

            :   

        Deprecated - ensure to pass a SpinOperatorTerm instead of a
        SpinOperator

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.ObserveResult.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Dump the raw data from the [[`SampleResult`{.xref .py .py-class
        .docutils .literal
        .notranslate}]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference
        .internal} that are stored in [[`ObserveResult`{.xref .py
        .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference
        .internal} to the terminal.

    [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.ObserveResult.expectation "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the expectation value of the [`spin_operator`{.code
        .docutils .literal .notranslate}]{.pre} that was provided in
        [[`observe()`{.xref .py .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.observe "cudaq.observe"){.reference
        .internal}.

        2.  

            [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [ObserveResult]{.pre}]{.n}*, *[[sub_term:]{.pre} [cudaq::product_op\<cudaq::spin_handler\>]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        3.  

            [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*, *[[sub_term]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[object]{.pre}](https://docs.python.org/3/library/functions.html#object "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the expectation value of an individual [`sub_term`{.code
        .docutils .literal .notranslate}]{.pre} of the global
        [`spin_operator`{.code .docutils .literal .notranslate}]{.pre}
        that was passed to [[`observe()`{.xref .py .py-func .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.observe "cudaq.observe"){.reference
        .internal}.

        Parameters[:]{.colon}

        :   **sub_term** ([`SpinOperatorTerm`{.xref .py .py-class
            .docutils .literal .notranslate}]{.pre}) -- An individual
            sub-term of the [`spin_operator`{.code .docutils .literal
            .notranslate}]{.pre}.

        Returns[:]{.colon}

        :   The expectation value of the [`sub_term`{.code .docutils
            .literal .notranslate}]{.pre} with respect to the
            [[`Kernel`{.xref .py .py-class .docutils .literal
            .notranslate}]{.pre}](#cudaq.Kernel "cudaq.Kernel"){.reference
            .internal} that was passed to [[`observe()`{.xref .py
            .py-func .docutils .literal
            .notranslate}]{.pre}](#cudaq.observe "cudaq.observe"){.reference
            .internal}.

        Return type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

        4.  

            [[expectation]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self:]{.pre} [ObserveResult]{.pre}]{.n}*, *[[sub_term:]{.pre} [cudaq::sum_op\<cudaq::spin_handler\>]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Deprecated - ensure to pass a SpinOperatorTerm instead of a
        SpinOperator

    [[get_spin]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.ObserveResult.get_spin "Permalink to this definition"){.headerlink}

    :   

        [[get_spin]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[cudaq::sum_op\<cudaq::spin_handler\>]{.pre}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the [`SpinOperator`{.code .docutils .literal
        .notranslate}]{.pre} corresponding to this
        [`ObserveResult`{.code .docutils .literal .notranslate}]{.pre}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[AsyncObserveResult]{.pre}]{.sig-name .descname}[](#cudaq.AsyncObserveResult "Permalink to this definition"){.headerlink}

:   A data-type containing the results of a call to
    [[`observe_async()`{.xref .py .py-func .docutils .literal
    .notranslate}]{.pre}](#cudaq.observe_async "cudaq.observe_async"){.reference
    .internal}.

    The [`AsyncObserveResult`{.code .docutils .literal
    .notranslate}]{.pre} contains a future, whose
    [[`ObserveResult`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference
    .internal} may be returned via an invocation of the [`get`{.code
    .docutils .literal .notranslate}]{.pre} method.

    This kicks off a wait on the current thread until the results are
    available.

    See
    [future](https://en.cppreference.com/w/cpp/thread/future){.reference
    .external} for more information on this programming pattern.

    [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.AsyncObserveResult.get "Permalink to this definition"){.headerlink}

    :   

        [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[AsyncObserveResult]{.pre}](#cudaq.AsyncObserveResult "cudaq.AsyncObserveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Returns the [[`ObserveResult`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference
        .internal} from the asynchronous observe execution.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[AsyncStateResult]{.pre}]{.sig-name .descname}[](#cudaq.AsyncStateResult "Permalink to this definition"){.headerlink}

:   A data-type containing the results of a call to
    [[`get_state_async()`{.xref .py .py-func .docutils .literal
    .notranslate}]{.pre}](#cudaq.get_state_async "cudaq.get_state_async"){.reference
    .internal}. The [`AsyncStateResult`{.code .docutils .literal
    .notranslate}]{.pre} models a future-like type, whose
    [[`State`{.xref .py .py-class .docutils .literal
    .notranslate}]{.pre}](#cudaq.State "cudaq.State"){.reference
    .internal} may be returned via an invocation of the [`get`{.code
    .docutils .literal .notranslate}]{.pre} method. This kicks off a
    wait on the current thread until the results are available. See
    [future](https://en.cppreference.com/w/cpp/thread/future){.reference
    .external} for more information on this programming pattern.

    [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.AsyncStateResult.get "Permalink to this definition"){.headerlink}

    :   

        [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[AsyncStateResult]{.pre}](#cudaq.AsyncStateResult "cudaq.AsyncStateResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the [[`State`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.State "cudaq.State"){.reference
        .internal} from the asynchronous [`get_state`{.code .docutils
        .literal .notranslate}]{.pre} accessor execution.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[OptimizationResult]{.pre}]{.sig-name .descname}[](#cudaq.OptimizationResult "Permalink to this definition"){.headerlink}

:   

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[EvolveResult]{.pre}]{.sig-name .descname}[](#cudaq.EvolveResult "Permalink to this definition"){.headerlink}

:   Stores the execution data from an invocation of [[`evolve()`{.xref
    .py .py-func .docutils .literal
    .notranslate}]{.pre}](#cudaq.evolve "cudaq.evolve"){.reference
    .internal}.

    [[expectation_values]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.EvolveResult.expectation_values "Permalink to this definition"){.headerlink}

    :   

        [[expectation_values]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.EvolveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[Optional]{.pre}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Stores the expectation values, that is the results from the
        calls to [[`observe()`{.xref .py .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.observe "cudaq.observe"){.reference
        .internal}, at each step in the schedule produced by a call to
        [[`evolve()`{.xref .py .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}, including the final expectation values. Each entry
        corresponds to one observable provided in the [[`evolve()`{.xref
        .py .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal} call. This property is only populated saving
        intermediate results was requested in the call to
        [[`evolve()`{.xref .py .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}. This value will be None if no intermediate results
        were requested, or if no observables were specified in the call.

    [[final_expectation_values]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.EvolveResult.final_expectation_values "Permalink to this definition"){.headerlink}

    :   

        [[final_expectation_values]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.EvolveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[ObserveResult]{.pre}](#cudaq.ObserveResult "cudaq.ObserveResult"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Stores the final expectation values, that is the results
        produced by calls to [[`observe()`{.xref .py .py-func .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.observe "cudaq.observe"){.reference
        .internal}, triggered by a call to [[`evolve()`{.xref .py
        .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}. Each entry corresponds to one observable provided in
        the [[`evolve()`{.xref .py .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal} call. This value will be None if no observables were
        specified in the call.

    [[final_state]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.EvolveResult.final_state "Permalink to this definition"){.headerlink}

    :   

        [[final_state]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.EvolveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Stores the final state produced by a call to [[`evolve()`{.xref
        .py .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}. Represent the state of a quantum system after time
        evolution under a set of operators, see the [[`evolve()`{.xref
        .py .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal} documentation for more detail.

    [[intermediate_states]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.EvolveResult.intermediate_states "Permalink to this definition"){.headerlink}

    :   

        [[intermediate_states]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.EvolveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[Optional]{.pre}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[State]{.pre}](#cudaq.State "cudaq.State"){.reference .internal}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Stores all intermediate states, meaning the state after each
        step in a defined schedule, produced by a call to
        [[`evolve()`{.xref .py .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}, including the final state. This property is only
        populated if saving intermediate results was requested in the
        call to [[`evolve()`{.xref .py .py-func .docutils .literal
        .notranslate}]{.pre}](#cudaq.evolve "cudaq.evolve"){.reference
        .internal}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[AsyncEvolveResult]{.pre}]{.sig-name .descname}[](#cudaq.AsyncEvolveResult "Permalink to this definition"){.headerlink}

:   Stores the execution data from an invocation of
    [[`evolve_async()`{.xref .py .py-func .docutils .literal
    .notranslate}]{.pre}](#cudaq.evolve_async "cudaq.evolve_async"){.reference
    .internal}.

    [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.AsyncEvolveResult.get "Permalink to this definition"){.headerlink}

    :   

        [[get]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[AsyncEvolveResult]{.pre}](#cudaq.AsyncEvolveResult "cudaq.AsyncEvolveResult"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[EvolveResult]{.pre}](#cudaq.EvolveResult "cudaq.EvolveResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Retrieve the evolution result from the asynchronous evolve
        execution .

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Resources]{.pre}]{.sig-name .descname}[](#cudaq.Resources "Permalink to this definition"){.headerlink}

:   A data-type containing the results of a call to
    [[`estimate_resources()`{.xref .py .py-func .docutils .literal
    .notranslate}]{.pre}](#cudaq.estimate_resources "cudaq.estimate_resources"){.reference
    .internal}. This includes all gate counts.

    [[clear]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.Resources.clear "Permalink to this definition"){.headerlink}

    :   

        [[clear]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Clear out all metadata from [`self`{.code .docutils .literal
        .notranslate}]{.pre}.

    [[count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.Resources.count "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Get the number of occurrences of a given gate with any number of
        controls

        2.  

            [[count]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Get the total number of occurrences of all gates

    [[count_controls]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.Resources.count_controls "Permalink to this definition"){.headerlink}

    :   

        [[count_controls]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Get the number of occurrences of a given gate with the given
        number of controls

    [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.Resources.dump "Permalink to this definition"){.headerlink}

    :   

        [[dump]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Print a string of the raw resource counts data to the terminal.

    [[to_dict]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.Resources.to_dict "Permalink to this definition"){.headerlink}

    :   

        [[to_dict]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[Resources]{.pre}](#cudaq.Resources "cudaq.Resources"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[dict]{.pre}](https://docs.python.org/3/library/stdtypes.html#dict "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Return a dictionary of the raw resource counts that are stored
        in [`self`{.code .docutils .literal .notranslate}]{.pre}.

::: {#optimizers .section}
### Optimizers[](#optimizers "Permalink to this heading"){.headerlink}

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[optimize]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[dimensions]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*, *[[function]{.pre}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[tuple]{.pre}](https://docs.python.org/3/library/stdtypes.html#tuple "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

:   Run the optimization procedure.

    Parameters[:]{.colon}

    :   -   **dimensions** -- The number of parameters to optimize

        -   **function** -- The objective function to minimize

    Returns[:]{.colon}

    :   tuple of (optimal_value, optimal_parameters)

```{=html}
<!-- -->
```

[[cudaq.operators.custom.]{.pre}]{.sig-prename .descclassname}[[requires_gradients]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

:   Check whether this optimizer requires gradient information.

    Returns[:]{.colon}

    :   True if gradients required, False otherwise

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[GradientDescent]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.GradientDescent "Permalink to this definition"){.headerlink}

:   

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.GradientDescent.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[optimizers.GradientDescent]{.pre}](#cudaq.optimizers.GradientDescent "cudaq.optimizers.GradientDescent"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to optimizer

    *[property]{.pre}[ ]{.w}*[[initial_parameters]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.GradientDescent.initial_parameters "Permalink to this definition"){.headerlink}

    :   Initial values for the optimization parameters (optional).

        Provides a starting point for the optimization. If not
        specified, the optimizer typically initializes parameters to
        zeros. Good initial parameter values can significantly improve
        convergence speed and help avoid poor local minima. The length
        must match the problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.initial_parameters = [0.5, -0.3, 1.2]
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[lower_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.GradientDescent.lower_bounds "Permalink to this definition"){.headerlink}

    :   Lower bounds for optimization parameters (optional).

        Constrains the search space by specifying minimum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.lower_bounds = [-2.0, -2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[max_iterations]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.GradientDescent.max_iterations "Permalink to this definition"){.headerlink}

    :   Maximum number of optimizer iterations (default: unlimited).

        Sets an upper bound on the number of function evaluations or
        iterations the optimizer will perform. If not set, the optimizer
        may run until convergence or until another stopping criterion is
        met.

        Type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.GradientDescent.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.GradientDescent]{.pre}](#cudaq.optimizers.GradientDescent "cudaq.optimizers.GradientDescent"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert optimizer to JSON string

    *[property]{.pre}[ ]{.w}*[[upper_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.GradientDescent.upper_bounds "Permalink to this definition"){.headerlink}

    :   Upper bounds for optimization parameters (optional).

        Constrains the search space by specifying maximum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.upper_bounds = [2.0, 2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[COBYLA]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.COBYLA "Permalink to this definition"){.headerlink}

:   

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.COBYLA.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[optimizers.COBYLA]{.pre}](#cudaq.optimizers.COBYLA "cudaq.optimizers.COBYLA"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to optimizer

    *[property]{.pre}[ ]{.w}*[[initial_parameters]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.COBYLA.initial_parameters "Permalink to this definition"){.headerlink}

    :   Initial values for the optimization parameters (optional).

        Provides a starting point for the optimization. If not
        specified, the optimizer typically initializes parameters to
        zeros. Good initial parameter values can significantly improve
        convergence speed and help avoid poor local minima. The length
        must match the problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.initial_parameters = [0.5, -0.3, 1.2]
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[lower_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.COBYLA.lower_bounds "Permalink to this definition"){.headerlink}

    :   Lower bounds for optimization parameters (optional).

        Constrains the search space by specifying minimum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.lower_bounds = [-2.0, -2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[max_iterations]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.COBYLA.max_iterations "Permalink to this definition"){.headerlink}

    :   Maximum number of optimizer iterations (default: unlimited).

        Sets an upper bound on the number of function evaluations or
        iterations the optimizer will perform. If not set, the optimizer
        may run until convergence or until another stopping criterion is
        met.

        Type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.COBYLA.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.COBYLA]{.pre}](#cudaq.optimizers.COBYLA "cudaq.optimizers.COBYLA"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert optimizer to JSON string

    *[property]{.pre}[ ]{.w}*[[upper_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.COBYLA.upper_bounds "Permalink to this definition"){.headerlink}

    :   Upper bounds for optimization parameters (optional).

        Constrains the search space by specifying maximum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.upper_bounds = [2.0, 2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[NelderMead]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.NelderMead "Permalink to this definition"){.headerlink}

:   

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.NelderMead.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[optimizers.NelderMead]{.pre}](#cudaq.optimizers.NelderMead "cudaq.optimizers.NelderMead"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to optimizer

    *[property]{.pre}[ ]{.w}*[[initial_parameters]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.NelderMead.initial_parameters "Permalink to this definition"){.headerlink}

    :   Initial values for the optimization parameters (optional).

        Provides a starting point for the optimization. If not
        specified, the optimizer typically initializes parameters to
        zeros. Good initial parameter values can significantly improve
        convergence speed and help avoid poor local minima. The length
        must match the problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.initial_parameters = [0.5, -0.3, 1.2]
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[lower_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.NelderMead.lower_bounds "Permalink to this definition"){.headerlink}

    :   Lower bounds for optimization parameters (optional).

        Constrains the search space by specifying minimum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.lower_bounds = [-2.0, -2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[max_iterations]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.NelderMead.max_iterations "Permalink to this definition"){.headerlink}

    :   Maximum number of optimizer iterations (default: unlimited).

        Sets an upper bound on the number of function evaluations or
        iterations the optimizer will perform. If not set, the optimizer
        may run until convergence or until another stopping criterion is
        met.

        Type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.NelderMead.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.NelderMead]{.pre}](#cudaq.optimizers.NelderMead "cudaq.optimizers.NelderMead"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert optimizer to JSON string

    *[property]{.pre}[ ]{.w}*[[upper_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.NelderMead.upper_bounds "Permalink to this definition"){.headerlink}

    :   Upper bounds for optimization parameters (optional).

        Constrains the search space by specifying maximum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.upper_bounds = [2.0, 2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[LBFGS]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.LBFGS "Permalink to this definition"){.headerlink}

:   

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.LBFGS.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[optimizers.LBFGS]{.pre}](#cudaq.optimizers.LBFGS "cudaq.optimizers.LBFGS"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to optimizer

    *[property]{.pre}[ ]{.w}*[[initial_parameters]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.LBFGS.initial_parameters "Permalink to this definition"){.headerlink}

    :   Initial values for the optimization parameters (optional).

        Provides a starting point for the optimization. If not
        specified, the optimizer typically initializes parameters to
        zeros. Good initial parameter values can significantly improve
        convergence speed and help avoid poor local minima. The length
        must match the problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.initial_parameters = [0.5, -0.3, 1.2]
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[lower_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.LBFGS.lower_bounds "Permalink to this definition"){.headerlink}

    :   Lower bounds for optimization parameters (optional).

        Constrains the search space by specifying minimum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.lower_bounds = [-2.0, -2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[max_iterations]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.LBFGS.max_iterations "Permalink to this definition"){.headerlink}

    :   Maximum number of optimizer iterations (default: unlimited).

        Sets an upper bound on the number of function evaluations or
        iterations the optimizer will perform. If not set, the optimizer
        may run until convergence or until another stopping criterion is
        met.

        Type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.LBFGS.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.LBFGS]{.pre}](#cudaq.optimizers.LBFGS "cudaq.optimizers.LBFGS"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert optimizer to JSON string

    *[property]{.pre}[ ]{.w}*[[upper_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.LBFGS.upper_bounds "Permalink to this definition"){.headerlink}

    :   Upper bounds for optimization parameters (optional).

        Constrains the search space by specifying maximum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.upper_bounds = [2.0, 2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[Adam]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.Adam "Permalink to this definition"){.headerlink}

:   

    *[property]{.pre}[ ]{.w}*[[batch_size]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.Adam.batch_size "Permalink to this definition"){.headerlink}

    :   Number of samples per batch (default: 1).

        For stochastic optimization, determines how many samples are
        used to compute each gradient estimate. Batch size of 1
        corresponds to online learning. Larger batch sizes can provide
        more stable gradient estimates but require more computation per
        iteration.

        Type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}

    *[property]{.pre}[ ]{.w}*[[beta1]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.Adam.beta1 "Permalink to this definition"){.headerlink}

    :   Exponential decay rate for the first moment estimates (default:
        0.9).

        Controls the exponential moving average of past gradients
        (momentum term). Values are typically in the range \[0.9,
        0.999\]. Higher values give more weight to past gradients,
        providing smoother updates but slower adaptation.

        Type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

    *[property]{.pre}[ ]{.w}*[[beta2]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.Adam.beta2 "Permalink to this definition"){.headerlink}

    :   Exponential decay rate for the second moment estimates (default:
        0.999).

        Controls the exponential moving average of past squared
        gradients. Values are typically in the range \[0.99, 0.9999\].
        Higher values provide more stable learning rates but slower
        adaptation to changing gradient magnitudes.

        Type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

    *[property]{.pre}[ ]{.w}*[[epsilon]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.Adam.epsilon "Permalink to this definition"){.headerlink}

    :   Small constant for numerical stability (default: 1e-8).

        Added to the denominator to prevent division by zero when
        computing adaptive learning rates. Should be a small positive
        value, typically between 1e-8 and 1e-6.

        Type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

    *[property]{.pre}[ ]{.w}*[[f_tol]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.Adam.f_tol "Permalink to this definition"){.headerlink}

    :   Convergence tolerance on the objective function value (default:
        1e-4).

        Optimization terminates when the change in objective function
        value between iterations falls below this threshold. Smaller
        values lead to tighter convergence but may require more
        iterations.

        Type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.Adam.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[optimizers.Adam]{.pre}](#cudaq.optimizers.Adam "cudaq.optimizers.Adam"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to optimizer

    *[property]{.pre}[ ]{.w}*[[initial_parameters]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.Adam.initial_parameters "Permalink to this definition"){.headerlink}

    :   Initial values for the optimization parameters (optional).

        Provides a starting point for the optimization. If not
        specified, the optimizer typically initializes parameters to
        zeros. Good initial parameter values can significantly improve
        convergence speed and help avoid poor local minima. The length
        must match the problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.initial_parameters = [0.5, -0.3, 1.2]
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[lower_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.Adam.lower_bounds "Permalink to this definition"){.headerlink}

    :   Lower bounds for optimization parameters (optional).

        Constrains the search space by specifying minimum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.lower_bounds = [-2.0, -2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[max_iterations]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.Adam.max_iterations "Permalink to this definition"){.headerlink}

    :   Maximum number of optimizer iterations (default: unlimited).

        Sets an upper bound on the number of function evaluations or
        iterations the optimizer will perform. If not set, the optimizer
        may run until convergence or until another stopping criterion is
        met.

        Type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}

    *[property]{.pre}[ ]{.w}*[[step_size]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.Adam.step_size "Permalink to this definition"){.headerlink}

    :   Learning rate (step size) for parameter updates (default: 0.01).

        Controls the magnitude of parameter updates at each iteration.
        Typical values range from 0.001 to 0.1. The effective learning
        rate is adapted per parameter based on gradient history. Start
        with 0.001 or 0.01 and adjust based on convergence behavior.

        Type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.Adam.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.Adam]{.pre}](#cudaq.optimizers.Adam "cudaq.optimizers.Adam"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert optimizer to JSON string

    *[property]{.pre}[ ]{.w}*[[upper_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.Adam.upper_bounds "Permalink to this definition"){.headerlink}

    :   Upper bounds for optimization parameters (optional).

        Constrains the search space by specifying maximum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.upper_bounds = [2.0, 2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[SGD]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SGD "Permalink to this definition"){.headerlink}

:   

    *[property]{.pre}[ ]{.w}*[[batch_size]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SGD.batch_size "Permalink to this definition"){.headerlink}

    :   Number of samples per batch (default: 1).

        For stochastic optimization, determines how many samples are
        used to compute each gradient estimate. Batch size of 1
        corresponds to true stochastic gradient descent. Larger batch
        sizes (mini-batch SGD) can provide more stable gradient
        estimates but require more computation per iteration.

        Type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}

    *[property]{.pre}[ ]{.w}*[[f_tol]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SGD.f_tol "Permalink to this definition"){.headerlink}

    :   Convergence tolerance on the objective function value (default:
        1e-4).

        Optimization terminates when the change in objective function
        value between iterations falls below this threshold. Smaller
        values lead to tighter convergence but may require more
        iterations. Note that with stochastic gradients, convergence may
        be noisy.

        Type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.SGD.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[optimizers.SGD]{.pre}](#cudaq.optimizers.SGD "cudaq.optimizers.SGD"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to optimizer

    *[property]{.pre}[ ]{.w}*[[initial_parameters]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SGD.initial_parameters "Permalink to this definition"){.headerlink}

    :   Initial values for the optimization parameters (optional).

        Provides a starting point for the optimization. If not
        specified, the optimizer typically initializes parameters to
        zeros. Good initial parameter values can significantly improve
        convergence speed and help avoid poor local minima. The length
        must match the problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.initial_parameters = [0.5, -0.3, 1.2]
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[lower_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SGD.lower_bounds "Permalink to this definition"){.headerlink}

    :   Lower bounds for optimization parameters (optional).

        Constrains the search space by specifying minimum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.lower_bounds = [-2.0, -2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[max_iterations]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SGD.max_iterations "Permalink to this definition"){.headerlink}

    :   Maximum number of optimizer iterations (default: unlimited).

        Sets an upper bound on the number of function evaluations or
        iterations the optimizer will perform. If not set, the optimizer
        may run until convergence or until another stopping criterion is
        met.

        Type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}

    *[property]{.pre}[ ]{.w}*[[step_size]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SGD.step_size "Permalink to this definition"){.headerlink}

    :   Learning rate (step size) for parameter updates (default: 0.01).

        Controls the magnitude of parameter updates at each iteration.
        The update rule is: x_new = x_old - step_size \* gradient.
        Typical values range from 0.001 to 0.1. Too large values can
        cause divergence, while too small values lead to slow
        convergence.

        Type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.SGD.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.SGD]{.pre}](#cudaq.optimizers.SGD "cudaq.optimizers.SGD"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert optimizer to JSON string

    *[property]{.pre}[ ]{.w}*[[upper_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SGD.upper_bounds "Permalink to this definition"){.headerlink}

    :   Upper bounds for optimization parameters (optional).

        Constrains the search space by specifying maximum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.upper_bounds = [2.0, 2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.optimizers.]{.pre}]{.sig-prename .descclassname}[[SPSA]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SPSA "Permalink to this definition"){.headerlink}

:   

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.SPSA.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[optimizers.SPSA]{.pre}](#cudaq.optimizers.SPSA "cudaq.optimizers.SPSA"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to optimizer

    *[property]{.pre}[ ]{.w}*[[gamma]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SPSA.gamma "Permalink to this definition"){.headerlink}

    :   Scaling exponent for the step size schedule (default: 0.101).

        Controls how the step size decreases over iterations. The step
        size at iteration k is proportional to (A + k + 1)\^(-gamma),
        where A is a stability constant. Common values are in the range
        \[0.1, 0.6\].

        Type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

    *[property]{.pre}[ ]{.w}*[[initial_parameters]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SPSA.initial_parameters "Permalink to this definition"){.headerlink}

    :   Initial values for the optimization parameters (optional).

        Provides a starting point for the optimization. If not
        specified, the optimizer typically initializes parameters to
        zeros. Good initial parameter values can significantly improve
        convergence speed and help avoid poor local minima. The length
        must match the problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.initial_parameters = [0.5, -0.3, 1.2]
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[lower_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SPSA.lower_bounds "Permalink to this definition"){.headerlink}

    :   Lower bounds for optimization parameters (optional).

        Constrains the search space by specifying minimum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.lower_bounds = [-2.0, -2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]

    *[property]{.pre}[ ]{.w}*[[max_iterations]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SPSA.max_iterations "Permalink to this definition"){.headerlink}

    :   Maximum number of optimizer iterations (default: unlimited).

        Sets an upper bound on the number of function evaluations or
        iterations the optimizer will perform. If not set, the optimizer
        may run until convergence or until another stopping criterion is
        met.

        Type[:]{.colon}

        :   [int](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
            .external}

    *[property]{.pre}[ ]{.w}*[[step_size]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SPSA.step_size "Permalink to this definition"){.headerlink}

    :   Evaluation step size for gradient approximation (default: 0.3).

        Controls the magnitude of perturbations used to approximate
        gradients. Larger values provide coarser gradient estimates but
        may be more robust to noise. Typical values range from 0.1 to
        0.5.

        Type[:]{.colon}

        :   [float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.optimizers.SPSA.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[optimizers.SPSA]{.pre}](#cudaq.optimizers.SPSA "cudaq.optimizers.SPSA"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert optimizer to JSON string

    *[property]{.pre}[ ]{.w}*[[upper_bounds]{.pre}]{.sig-name .descname}[](#cudaq.optimizers.SPSA.upper_bounds "Permalink to this definition"){.headerlink}

    :   Upper bounds for optimization parameters (optional).

        Constrains the search space by specifying maximum allowed values
        for each parameter. When specified, the length must match the
        problem dimension.

        Example

        ::: {.highlight-python .notranslate}
        ::: highlight
            optimizer.upper_bounds = [2.0, 2.0]  # For 2D problem
        :::
        :::

        Type[:]{.colon}

        :   [list](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference
            .external}\[[float](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference
            .external}\]
:::

::: {#gradients .section}
### Gradients[](#gradients "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.gradients.]{.pre}]{.sig-prename .descclassname}[[gradient]{.pre}]{.sig-name .descname}[](#cudaq.gradients.gradient "Permalink to this definition"){.headerlink}

:   

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.gradients.]{.pre}]{.sig-prename .descclassname}[[CentralDifference]{.pre}]{.sig-name .descname}[](#cudaq.gradients.CentralDifference "Permalink to this definition"){.headerlink}

:   

    [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.gradients.CentralDifference.compute "Permalink to this definition"){.headerlink}

    :   

        [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.gradient]{.pre}](#cudaq.gradients.gradient "cudaq.gradients.gradient"){.reference .internal}]{.n}*, *[[parameter_vector]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*, *[[funcAtX]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Compute the gradient of the provided [`parameter_vector`{.code
        .docutils .literal .notranslate}]{.pre} with respect to its loss
        function, using the [`CentralDifference`{.code .docutils
        .literal .notranslate}]{.pre} method.

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.gradients.CentralDifference.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[gradients.CentralDifference]{.pre}](#cudaq.gradients.CentralDifference "cudaq.gradients.CentralDifference"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to gradient

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.gradients.CentralDifference.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.CentralDifference]{.pre}](#cudaq.gradients.CentralDifference "cudaq.gradients.CentralDifference"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert gradient to JSON string

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.gradients.]{.pre}]{.sig-prename .descclassname}[[ForwardDifference]{.pre}]{.sig-name .descname}[](#cudaq.gradients.ForwardDifference "Permalink to this definition"){.headerlink}

:   

    [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.gradients.ForwardDifference.compute "Permalink to this definition"){.headerlink}

    :   

        [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.gradient]{.pre}](#cudaq.gradients.gradient "cudaq.gradients.gradient"){.reference .internal}]{.n}*, *[[parameter_vector]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*, *[[funcAtX]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Compute the gradient of the provided [`parameter_vector`{.code
        .docutils .literal .notranslate}]{.pre} with respect to its loss
        function, using the [`ForwardDifference`{.code .docutils
        .literal .notranslate}]{.pre} method.

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.gradients.ForwardDifference.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[gradients.ForwardDifference]{.pre}](#cudaq.gradients.ForwardDifference "cudaq.gradients.ForwardDifference"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to gradient

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.gradients.ForwardDifference.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.ForwardDifference]{.pre}](#cudaq.gradients.ForwardDifference "cudaq.gradients.ForwardDifference"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert gradient to JSON string

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.gradients.]{.pre}]{.sig-prename .descclassname}[[ParameterShift]{.pre}]{.sig-name .descname}[](#cudaq.gradients.ParameterShift "Permalink to this definition"){.headerlink}

:   

    [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.gradients.ParameterShift.compute "Permalink to this definition"){.headerlink}

    :   

        [[compute]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.gradient]{.pre}](#cudaq.gradients.gradient "cudaq.gradients.gradient"){.reference .internal}]{.n}*, *[[parameter_vector]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[function]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}]{.n}*, *[[funcAtX]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Compute the gradient of the provided [`parameter_vector`{.code
        .docutils .literal .notranslate}]{.pre} with respect to its loss
        function, using the [`ParameterShift`{.code .docutils .literal
        .notranslate}]{.pre} method.

    *[static]{.pre}[ ]{.w}*[[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.gradients.ParameterShift.from_json "Permalink to this definition"){.headerlink}

    :   

        [[from_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[gradients.ParameterShift]{.pre}](#cudaq.gradients.ParameterShift "cudaq.gradients.ParameterShift"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert JSON string to gradient

    [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.gradients.ParameterShift.to_json "Permalink to this definition"){.headerlink}

    :   

        [[to_json]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[gradients.ParameterShift]{.pre}](#cudaq.gradients.ParameterShift "cudaq.gradients.ParameterShift"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Convert gradient to JSON string
:::

::: {#noisy-simulation .section}
### Noisy Simulation[](#noisy-simulation "Permalink to this heading"){.headerlink}

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[NoiseModel]{.pre}]{.sig-name .descname}[](#cudaq.NoiseModel "Permalink to this definition"){.headerlink}

:   The [`NoiseModel`{.code .docutils .literal .notranslate}]{.pre}
    defines a set of [[`KrausChannel`{.xref .py .py-class .docutils
    .literal
    .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
    .internal}'s applied to specific qubits after the invocation of
    specified quantum operations.

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.NoiseModel.__init__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Construct a noise model with all built-in channels
        pre-registered.

    [[add_all_qubit_channel]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.NoiseModel.add_all_qubit_channel "Permalink to this definition"){.headerlink}

    :   

        [[add_all_qubit_channel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*, *[[operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*, *[[channel]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}]{.n}*, *[[num_controls]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Add the given [[`KrausChannel`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal} to be applied after invocation of the specified
        quantum operation on arbitrary qubits.

        Parameters[:]{.colon}

        :   -   **operator**
                ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
                .external}) -- The quantum operator to apply the noise
                channel to.

            -   **channel**
                ([*cudaq.KrausChannel*](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
                .internal}) -- The [[`KrausChannel`{.xref .py .py-class
                .docutils .literal
                .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
                .internal} to apply to the specified [`operator`{.code
                .docutils .literal .notranslate}]{.pre} on any arbitrary
                qubits.

            -   **num_controls** -- Number of control bits. Default is 0
                (no control bits).

    [[add_channel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.NoiseModel.add_channel "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[add_channel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*, *[[operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*, *[[qubits]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[channel]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[cudaq.KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Add the given [[`KrausChannel`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal} to be applied after invocation of the specified
        quantum operation.

        Parameters[:]{.colon}

        :   -   **operator**
                ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
                .external}) -- The quantum operator to apply the noise
                channel to.

            -   **qubits**
                (*List\[*[*int*](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference
                .external}*\]*) -- The qubit/s to apply the noise
                channel to.

            -   **channel**
                ([*cudaq.KrausChannel*](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
                .internal}) -- The [[`KrausChannel`{.xref .py .py-class
                .docutils .literal
                .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
                .internal} to apply to the specified [`operator`{.code
                .docutils .literal .notranslate}]{.pre} on the specified
                [`qubits`{.code .docutils .literal .notranslate}]{.pre}.

        2.  

            [[add_channel]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*, *[[operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*, *[[pre]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[Callable]{.pre}[[\[]{.pre}]{.p}[[\[]{.pre}]{.p}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}[[\]]{.pre}]{.p}[[,]{.pre}]{.p}[ ]{.w}[[cudaq.KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Add the given [[`KrausChannel`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal} generator callback to be applied after invocation of
        the specified quantum operation.

        Parameters[:]{.colon}

        :   -   **operator**
                ([*str*](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference
                .external}) -- The quantum operator to apply the noise
                channel to.

            -   **pre** (*Callable*) -- The callback which takes qubits
                operands and gate parameters and returns a concrete
                [[`KrausChannel`{.xref .py .py-class .docutils .literal
                .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
                .internal} to apply to the specified [`operator`{.code
                .docutils .literal .notranslate}]{.pre}.

    [[get_channels]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.NoiseModel.get_channels "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[get_channels]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*, *[[operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*, *[[qubits]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the [[`KrausChannel`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal}'s that make up this noise model.

        2.  

            [[get_channels]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[NoiseModel]{.pre}](#cudaq.NoiseModel "cudaq.NoiseModel"){.reference .internal}]{.n}*, *[[operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[str]{.pre}](https://docs.python.org/3/library/stdtypes.html#str "(in Python v3.14)"){.reference .external}]{.n}*, *[[qubits]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[controls]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[cudaq.KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

            :   

        Return the [[`KrausChannel`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal}'s that make up this noise model.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[BitFlipChannel]{.pre}]{.sig-name .descname}[](#cudaq.BitFlipChannel "Permalink to this definition"){.headerlink}

:   Models the decoherence of the qubit state. Its constructor expects a
    float value, [`probability`{.code .docutils .literal
    .notranslate}]{.pre}, representing the probability that the qubit
    flips from the 1-state to the 0-state, or vice versa. E.g, the
    probability of a random X-180 rotation being applied to the qubit.

    The Kraus Channels are thereby defined to be:

    K_0 = sqrt(1 - probability) \* I

    K_1 = sqrt(probability ) \* X

    The probability of the qubit remaining in the same state is
    therefore [`1`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`-`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`probability`{.code .docutils .literal
    .notranslate}]{.pre}.

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.BitFlipChannel.__init__ "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BitFlipChannel]{.pre}](#cudaq.BitFlipChannel "cudaq.BitFlipChannel"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        2.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[BitFlipChannel]{.pre}](#cudaq.BitFlipChannel "cudaq.BitFlipChannel"){.reference .internal}]{.n}*, *[[probability]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Initialize the [`BitFlipChannel`{.code .docutils .literal
        .notranslate}]{.pre} with the provided [`probability`{.code
        .docutils .literal .notranslate}]{.pre}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[PhaseFlipChannel]{.pre}]{.sig-name .descname}[](#cudaq.PhaseFlipChannel "Permalink to this definition"){.headerlink}

:   Models the decoherence of the qubit phase. Its constructor expects a
    float value, [`probability`{.code .docutils .literal
    .notranslate}]{.pre}, representing the probability of a random Z-180
    rotation being applied to the qubit.

    The Kraus Channels are thereby defined to be:

    K_0 = sqrt(1 - probability) \* I

    K_1 = sqrt(probability ) \* Z

    The probability of the qubit phase remaining untouched is therefore
    [`1`{.code .docutils .literal .notranslate}]{.pre}` `{.code
    .docutils .literal .notranslate}[`-`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`probability`{.code .docutils .literal
    .notranslate}]{.pre}.

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.PhaseFlipChannel.__init__ "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[PhaseFlipChannel]{.pre}](#cudaq.PhaseFlipChannel "cudaq.PhaseFlipChannel"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        2.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[PhaseFlipChannel]{.pre}](#cudaq.PhaseFlipChannel "cudaq.PhaseFlipChannel"){.reference .internal}]{.n}*, *[[probability]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Initialize the [`PhaseFlipChannel`{.code .docutils .literal
        .notranslate}]{.pre} with the provided [`probability`{.code
        .docutils .literal .notranslate}]{.pre}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[DepolarizationChannel]{.pre}]{.sig-name .descname}[](#cudaq.DepolarizationChannel "Permalink to this definition"){.headerlink}

:   Models the decoherence of the qubit state and phase into a mixture "
    of the computational basis states, [`|0>`{.code .docutils .literal
    .notranslate}]{.pre} and [`|1>`{.code .docutils .literal
    .notranslate}]{.pre}.

    The Kraus Channels are thereby defined to be:

    K_0 = sqrt(1 - probability) \* I

    K_1 = sqrt(probability / 3) \* X

    K_2 = sqrt(probability / 3) \* Y

    K_3 = sqrt(probability / 3) \* Z

    where I, X, Y, Z are the 2x2 Pauli matrices.

    The constructor expects a float value, [`probability`{.code
    .docutils .literal .notranslate}]{.pre}, representing the
    probability the state decay will occur. The qubit will remain
    untouched, therefore, with a probability of [`1`{.code .docutils
    .literal .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`-`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`probability`{.code .docutils .literal
    .notranslate}]{.pre}. And the X,Y,Z operators will be applied with a
    probability of [`probability`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`/`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`3`{.code .docutils .literal .notranslate}]{.pre}.

    For [`probability`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`=`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`0.0`{.code .docutils .literal .notranslate}]{.pre},
    the channel will behave noise-free. For [`probability`{.code
    .docutils .literal .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`=`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`0.75`{.code .docutils .literal .notranslate}]{.pre},
    the channel will fully depolarize the state. For
    [`probability`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`=`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`1.0`{.code .docutils .literal .notranslate}]{.pre},
    the channel will be uniform.

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.DepolarizationChannel.__init__ "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[DepolarizationChannel]{.pre}](#cudaq.DepolarizationChannel "cudaq.DepolarizationChannel"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        2.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[DepolarizationChannel]{.pre}](#cudaq.DepolarizationChannel "cudaq.DepolarizationChannel"){.reference .internal}]{.n}*, *[[probability]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Initialize the [`DepolarizationChannel`{.code .docutils .literal
        .notranslate}]{.pre} with the provided [`probability`{.code
        .docutils .literal .notranslate}]{.pre}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[AmplitudeDampingChannel]{.pre}]{.sig-name .descname}[](#cudaq.AmplitudeDampingChannel "Permalink to this definition"){.headerlink}

:   Models the dissipation of energy due to system interactions with the
    environment.

    The Kraus Channels are thereby defined to be:

    K_0 = sqrt(1 - probability) \* I

    K_1 = sqrt(probability) \* 0.5 \* (X + iY)

    Its constructor expects a float value, [`probability`{.code
    .docutils .literal .notranslate}]{.pre}, representing the probablity
    that the qubit will decay to its ground state. The probability of
    the qubit remaining in the same state is therefore [`1`{.code
    .docutils .literal .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`-`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`probability`{.code .docutils .literal
    .notranslate}]{.pre}.

    [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.AmplitudeDampingChannel.__init__ "Permalink to this definition"){.headerlink}

    :   Overloaded function.

        1.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[AmplitudeDampingChannel]{.pre}](#cudaq.AmplitudeDampingChannel "cudaq.AmplitudeDampingChannel"){.reference .internal}]{.n}*, *[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        2.  

            [[\_\_init\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[AmplitudeDampingChannel]{.pre}](#cudaq.AmplitudeDampingChannel "cudaq.AmplitudeDampingChannel"){.reference .internal}]{.n}*, *[[probability]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

            :   

        Initialize the [`AmplitudeDampingChannel`{.code .docutils
        .literal .notranslate}]{.pre} with the provided
        [`probability`{.code .docutils .literal .notranslate}]{.pre}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[PhaseDamping]{.pre}]{.sig-name .descname}[](#cudaq.PhaseDamping "Permalink to this definition"){.headerlink}

:   A Kraus channel that models the single-qubit phase damping error.
    This is similar to AmplitudeDamping, but for phase.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[XError]{.pre}]{.sig-name .descname}[](#cudaq.XError "Permalink to this definition"){.headerlink}

:   A Pauli error that applies the X operator when an error occurs. It
    is the same as BitFlipChannel.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[YError]{.pre}]{.sig-name .descname}[](#cudaq.YError "Permalink to this definition"){.headerlink}

:   A Pauli error that applies the Y operator when an error occurs.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[ZError]{.pre}]{.sig-name .descname}[](#cudaq.ZError "Permalink to this definition"){.headerlink}

:   A Pauli error that applies the Z operator when an error occurs. It
    is the same as PhaseFlipChannel.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Pauli1]{.pre}]{.sig-name .descname}[](#cudaq.Pauli1 "Permalink to this definition"){.headerlink}

:   A single-qubit Pauli error that applies either an X error, Y error,
    or Z error. The probability of each X, Y, or Z error is supplied as
    a parameter.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Pauli2]{.pre}]{.sig-name .descname}[](#cudaq.Pauli2 "Permalink to this definition"){.headerlink}

:   A 2-qubit Pauli error that applies one of the following errors, with
    the probabilities specified as a vector. Possible errors: IX, IY,
    IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, and ZZ.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Depolarization1]{.pre}]{.sig-name .descname}[](#cudaq.Depolarization1 "Permalink to this definition"){.headerlink}

:   The same as DepolarizationChannel (single qubit depolarization)

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[Depolarization2]{.pre}]{.sig-name .descname}[](#cudaq.Depolarization2 "Permalink to this definition"){.headerlink}

:   A 2-qubit depolarization error that applies one of the following
    errors. Possible errors: IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ,
    ZI, ZX, ZY, and ZZ.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[KrausChannel]{.pre}]{.sig-name .descname}[](#cudaq.KrausChannel "Permalink to this definition"){.headerlink}

:   The [`KrausChannel`{.code .docutils .literal .notranslate}]{.pre} is
    composed of a list of [[`KrausOperator`{.xref .py .py-class
    .docutils .literal
    .notranslate}]{.pre}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference
    .internal}'s and is applied to a specific qubit or set of qubits.

    [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.KrausChannel.__getitem__ "Permalink to this definition"){.headerlink}

    :   

        [[\_\_getitem\_\_]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}]{.n}*, *[[index]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[KrausOperator]{.pre}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the [[`KrausOperator`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference
        .internal} at the given index in this [[`KrausChannel`{.xref .py
        .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal}.

    [[append]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.KrausChannel.append "Permalink to this definition"){.headerlink}

    :   

        [[append]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}]{.n}*, *[[operator]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[KrausOperator]{.pre}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

        :   

        Add a [[`KrausOperator`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference
        .internal} to this [[`KrausChannel`{.xref .py .py-class
        .docutils .literal
        .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal}.

    [[get_ops]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.KrausChannel.get_ops "Permalink to this definition"){.headerlink}

    :   

        [[get_ops]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[self]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[KrausChannel]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference .internal}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[KrausOperator]{.pre}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference .internal}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

        Return the [[`KrausOperator`{.xref .py .py-class .docutils
        .literal
        .notranslate}]{.pre}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference
        .internal}'s in this [[`KrausChannel`{.xref .py .py-class
        .docutils .literal
        .notranslate}]{.pre}](#cudaq.KrausChannel "cudaq.KrausChannel"){.reference
        .internal}.

```{=html}
<!-- -->
```

*[class]{.pre}[ ]{.w}*[[cudaq.]{.pre}]{.sig-prename .descclassname}[[KrausOperator]{.pre}]{.sig-name .descname}[](#cudaq.KrausOperator "Permalink to this definition"){.headerlink}

:   The [`KrausOperator`{.code .docutils .literal .notranslate}]{.pre}
    is represented by a matrix and serves as an element of a quantum
    channel such that [`Sum`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`Ki`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`Ki^dag`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`=`{.code .docutils .literal
    .notranslate}]{.pre}` `{.code .docutils .literal
    .notranslate}[`I.`{.code .docutils .literal .notranslate}]{.pre}

    *[property]{.pre}[ ]{.w}*[[col_count]{.pre}]{.sig-name .descname}[](#cudaq.KrausOperator.col_count "Permalink to this definition"){.headerlink}

    :   The number of columns in the matrix representation of this
        [[`KrausOperator`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference
        .internal}.

    *[property]{.pre}[ ]{.w}*[[row_count]{.pre}]{.sig-name .descname}[](#cudaq.KrausOperator.row_count "Permalink to this definition"){.headerlink}

    :   The number of rows in the matrix representation of this
        [[`KrausOperator`{.xref .py .py-class .docutils .literal
        .notranslate}]{.pre}](#cudaq.KrausOperator "cudaq.KrausOperator"){.reference
        .internal}.
:::
:::

::: {#mpi-submodule .section}
## MPI Submodule[](#mpi-submodule "Permalink to this heading"){.headerlink}

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[initialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.mpi.initialize "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[initialize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Initialize MPI if available.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[rank]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.mpi.rank "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[rank]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Return the rank of this process.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[num_ranks]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.mpi.num_ranks "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[num_ranks]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Return the total number of ranks.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[all_gather]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.mpi.all_gather "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[all_gather]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

    Gather and scatter the [`local`{.code .docutils .literal
    .notranslate}]{.pre} list of floating-point numbers, returning a
    concatenation of all lists across all ranks. The total global list
    size must be provided.

    2.  

        [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[all_gather]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

        :   

    Gather and scatter the [`local`{.code .docutils .literal
    .notranslate}]{.pre} list of integers, returning a concatenation of
    all lists across all ranks. The total global list size must be
    provided.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[broadcast]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.mpi.broadcast "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[broadcast]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[arg0]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[arg1]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*, *[[arg2]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}*[)]{.sig-paren} [[]{.sig-return-icon} [[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.sig-return-typehint}]{.sig-return}

    :   

    Broadcast an array from a process (rootRank) to all other processes.
    The size of broadcast array must be provided.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[is_initialized]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.mpi.is_initialized "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[is_initialized]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[bool]{.pre}](https://docs.python.org/3/library/functions.html#bool "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Returns true if MPI has already been initialized.

```{=html}
<!-- -->
```

[[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[finalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren}[](#cudaq.mpi.finalize "Permalink to this definition"){.headerlink}

:   

    [[cudaq.mpi.]{.pre}]{.sig-prename .descclassname}[[finalize]{.pre}]{.sig-name .descname}[(]{.sig-paren}[)]{.sig-paren} [[]{.sig-return-icon} [[[None]{.pre}](https://docs.python.org/3/library/constants.html#None "(in Python v3.14)"){.reference .external}]{.sig-return-typehint}]{.sig-return}

    :   

    Finalize MPI.
:::

::: {#orca-submodule .section}
## ORCA Submodule[](#orca-submodule "Permalink to this heading"){.headerlink}

[[cudaq.orca.]{.pre}]{.sig-prename .descclassname}[[sample]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[\*]{.pre}]{.o}[[args]{.pre}]{.n}*, *[[\*\*]{.pre}]{.o}[[kwargs]{.pre}]{.n}*[)]{.sig-paren}[](#cudaq.orca.sample "Permalink to this definition"){.headerlink}

:   Overloaded function.

    1.  

        [[cudaq.orca.]{.pre}]{.sig-prename .descclassname}[[sample]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[input_state]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[loop_lengths]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[bs_angles]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[ps_angles]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[n_samples]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[10000]{.pre}]{.default_value}*, *[[qpu_id]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Performs Time Bin Interferometer (TBI) boson sampling experiments on
    ORCA's backends

    2.  

        [[cudaq.orca.]{.pre}]{.sig-prename .descclassname}[[sample]{.pre}]{.sig-name .descname}[(]{.sig-paren}*[[input_state]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[loop_lengths]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[bs_angles]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[list]{.pre}](https://docs.python.org/3/library/stdtypes.html#list "(in Python v3.14)"){.reference .external}[[\[]{.pre}]{.p}[[float]{.pre}](https://docs.python.org/3/library/functions.html#float "(in Python v3.14)"){.reference .external}[[\]]{.pre}]{.p}]{.n}*, *[[n_samples]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[10000]{.pre}]{.default_value}*, *[[qpu_id]{.pre}]{.n}[[:]{.pre}]{.p}[ ]{.w}[[[int]{.pre}](https://docs.python.org/3/library/functions.html#int "(in Python v3.14)"){.reference .external}]{.n}[ ]{.w}[[=]{.pre}]{.o}[ ]{.w}[[0]{.pre}]{.default_value}*[)]{.sig-paren} [[]{.sig-return-icon} [[[SampleResult]{.pre}](#cudaq.SampleResult "cudaq.SampleResult"){.reference .internal}]{.sig-return-typehint}]{.sig-return}

        :   

    Performs Time Bin Interferometer (TBI) boson sampling experiments on
    ORCA's backends
:::
:::
:::
:::

::: {.rst-footer-buttons role="navigation" aria-label="Footer"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](cpp_api.html "CUDA-Q C++ API"){.btn .btn-neutral .float-left
accesskey="p" rel="prev"} [Next []{.fa .fa-arrow-circle-right
aria-hidden="true"}](../default_ops.html "Quantum Operations"){.btn
.btn-neutral .float-right accesskey="n" rel="next"}
:::

------------------------------------------------------------------------

::: {role="contentinfo"}
 Copyright 2026, NVIDIA Corporation & Affiliates.
:::

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme) provided by
[Read the Docs](https://readthedocs.org).
:::
:::
:::
:::
