::: wy-grid-for-nav
::: wy-side-scroll
::: {.wy-side-nav-search style="background: #76b900"}
[NVIDIA CUDA-Q](../../index.html){.icon .icon-home}

::: version
pr-3592
:::

::: {role="search"}
:::
:::

::: {.wy-menu .wy-menu-vertical spy="affix" role="navigation" aria-label="Navigation menu"}
[Contents]{.caption-text}

-   [Quick Start](../../using/quick_start.html){.reference .internal}
    -   [Install
        CUDA-Q](../../using/quick_start.html#install-cuda-q){.reference
        .internal}
    -   [Validate your
        Installation](../../using/quick_start.html#validate-your-installation){.reference
        .internal}
    -   [CUDA-Q
        Academic](../../using/quick_start.html#cuda-q-academic){.reference
        .internal}
-   [Basics](../../using/basics/basics.html){.reference .internal}
    -   [What is a CUDA-Q
        Kernel?](../../using/basics/kernel_intro.html){.reference
        .internal}
    -   [Building your first CUDA-Q
        Program](../../using/basics/build_kernel.html){.reference
        .internal}
    -   [Running your first CUDA-Q
        Program](../../using/basics/run_kernel.html){.reference
        .internal}
        -   [Sample](../../using/basics/run_kernel.html#sample){.reference
            .internal}
        -   [Run](../../using/basics/run_kernel.html#run){.reference
            .internal}
        -   [Observe](../../using/basics/run_kernel.html#observe){.reference
            .internal}
        -   [Running on a
            GPU](../../using/basics/run_kernel.html#running-on-a-gpu){.reference
            .internal}
    -   [Troubleshooting](../../using/basics/troubleshooting.html){.reference
        .internal}
        -   [Debugging and Verbose Simulation
            Output](../../using/basics/troubleshooting.html#debugging-and-verbose-simulation-output){.reference
            .internal}
-   [Examples](../../using/examples/examples.html){.reference .internal}
    -   [Introduction](../../using/examples/introduction.html){.reference
        .internal}
    -   [Building
        Kernels](../../using/examples/building_kernels.html){.reference
        .internal}
        -   [Defining
            Kernels](../../using/examples/building_kernels.html#defining-kernels){.reference
            .internal}
        -   [Initializing
            states](../../using/examples/building_kernels.html#initializing-states){.reference
            .internal}
        -   [Applying
            Gates](../../using/examples/building_kernels.html#applying-gates){.reference
            .internal}
        -   [Controlled
            Operations](../../using/examples/building_kernels.html#controlled-operations){.reference
            .internal}
        -   [Multi-Controlled
            Operations](../../using/examples/building_kernels.html#multi-controlled-operations){.reference
            .internal}
        -   [Adjoint
            Operations](../../using/examples/building_kernels.html#adjoint-operations){.reference
            .internal}
        -   [Custom
            Operations](../../using/examples/building_kernels.html#custom-operations){.reference
            .internal}
        -   [Building Kernels with
            Kernels](../../using/examples/building_kernels.html#building-kernels-with-kernels){.reference
            .internal}
        -   [Parameterized
            Kernels](../../using/examples/building_kernels.html#parameterized-kernels){.reference
            .internal}
    -   [Quantum
        Operations](../../using/examples/quantum_operations.html){.reference
        .internal}
        -   [Quantum
            States](../../using/examples/quantum_operations.html#quantum-states){.reference
            .internal}
        -   [Quantum
            Gates](../../using/examples/quantum_operations.html#quantum-gates){.reference
            .internal}
        -   [Measurements](../../using/examples/quantum_operations.html#measurements){.reference
            .internal}
    -   [Measuring
        Kernels](../../using/examples/measuring_kernels.html){.reference
        .internal}
        -   [Mid-circuit Measurement and Conditional
            Logic](../../using/examples/measuring_kernels.html#mid-circuit-measurement-and-conditional-logic){.reference
            .internal}
    -   [Visualizing
        Kernels](../../examples/python/visualization.html){.reference
        .internal}
        -   [Qubit
            Visualization](../../examples/python/visualization.html#Qubit-Visualization){.reference
            .internal}
        -   [Kernel
            Visualization](../../examples/python/visualization.html#Kernel-Visualization){.reference
            .internal}
    -   [Executing
        Kernels](../../using/examples/executing_kernels.html){.reference
        .internal}
        -   [Sample](../../using/examples/executing_kernels.html#sample){.reference
            .internal}
            -   [Sample
                Asynchronous](../../using/examples/executing_kernels.html#sample-asynchronous){.reference
                .internal}
        -   [Run](../../using/examples/executing_kernels.html#run){.reference
            .internal}
            -   [Return Custom Data
                Types](../../using/examples/executing_kernels.html#return-custom-data-types){.reference
                .internal}
            -   [Run
                Asynchronous](../../using/examples/executing_kernels.html#run-asynchronous){.reference
                .internal}
        -   [Observe](../../using/examples/executing_kernels.html#observe){.reference
            .internal}
            -   [Observe
                Asynchronous](../../using/examples/executing_kernels.html#observe-asynchronous){.reference
                .internal}
        -   [Get
            State](../../using/examples/executing_kernels.html#get-state){.reference
            .internal}
            -   [Get State
                Asynchronous](../../using/examples/executing_kernels.html#get-state-asynchronous){.reference
                .internal}
    -   [Computing Expectation
        Values](../../using/examples/expectation_values.html){.reference
        .internal}
        -   [Parallelizing across Multiple
            Processors](../../using/examples/expectation_values.html#parallelizing-across-multiple-processors){.reference
            .internal}
    -   [Multi-GPU
        Workflows](../../using/examples/multi_gpu_workflows.html){.reference
        .internal}
        -   [From CPU to
            GPU](../../using/examples/multi_gpu_workflows.html#from-cpu-to-gpu){.reference
            .internal}
        -   [Pooling the memory of multiple GPUs ([`mgpu`{.code
            .docutils .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#pooling-the-memory-of-multiple-gpus-mgpu){.reference
            .internal}
        -   [Parallel execution over multiple QPUs ([`mqpu`{.code
            .docutils .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#parallel-execution-over-multiple-qpus-mqpu){.reference
            .internal}
            -   [Batching Hamiltonian
                Terms](../../using/examples/multi_gpu_workflows.html#batching-hamiltonian-terms){.reference
                .internal}
            -   [Circuit
                Batching](../../using/examples/multi_gpu_workflows.html#circuit-batching){.reference
                .internal}
        -   [Multi-QPU + Other Backends ([`remote-mqpu`{.code .docutils
            .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#multi-qpu-other-backends-remote-mqpu){.reference
            .internal}
    -   [Optimizers &
        Gradients](../../examples/python/optimizers_gradients.html){.reference
        .internal}
        -   [Built in CUDA-Q Optimizers and
            Gradients](../../examples/python/optimizers_gradients.html#Built-in-CUDA-Q-Optimizers-and-Gradients){.reference
            .internal}
        -   [Third-Party
            Optimizers](../../examples/python/optimizers_gradients.html#Third-Party-Optimizers){.reference
            .internal}
        -   [Parallel Parameter Shift
            Gradients](../../examples/python/optimizers_gradients.html#Parallel-Parameter-Shift-Gradients){.reference
            .internal}
    -   [Noisy
        Simulations](../../examples/python/noisy_simulations.html){.reference
        .internal}
    -   [Constructing
        Operators](../../using/examples/operators.html){.reference
        .internal}
        -   [Constructing Spin
            Operators](../../using/examples/operators.html#constructing-spin-operators){.reference
            .internal}
        -   [Pauli Words and Exponentiating Pauli
            Words](../../using/examples/operators.html#pauli-words-and-exponentiating-pauli-words){.reference
            .internal}
    -   [Performance
        Optimizations](../../examples/python/performance_optimizations.html){.reference
        .internal}
        -   [Gate
            Fusion](../../examples/python/performance_optimizations.html#Gate-Fusion){.reference
            .internal}
    -   [Using Quantum Hardware
        Providers](../../using/examples/hardware_providers.html){.reference
        .internal}
        -   [Amazon
            Braket](../../using/examples/hardware_providers.html#amazon-braket){.reference
            .internal}
        -   [Anyon
            Technologies](../../using/examples/hardware_providers.html#anyon-technologies){.reference
            .internal}
        -   [Infleqtion](../../using/examples/hardware_providers.html#infleqtion){.reference
            .internal}
        -   [IonQ](../../using/examples/hardware_providers.html#ionq){.reference
            .internal}
        -   [IQM](../../using/examples/hardware_providers.html#iqm){.reference
            .internal}
        -   [OQC](../../using/examples/hardware_providers.html#oqc){.reference
            .internal}
        -   [ORCA
            Computing](../../using/examples/hardware_providers.html#orca-computing){.reference
            .internal}
        -   [Pasqal](../../using/examples/hardware_providers.html#pasqal){.reference
            .internal}
        -   [Quantinuum](../../using/examples/hardware_providers.html#quantinuum){.reference
            .internal}
        -   [Quantum Circuits,
            Inc.](../../using/examples/hardware_providers.html#quantum-circuits-inc){.reference
            .internal}
        -   [Quantum
            Machines](../../using/examples/hardware_providers.html#quantum-machines){.reference
            .internal}
        -   [QuEra
            Computing](../../using/examples/hardware_providers.html#quera-computing){.reference
            .internal}
    -   [Dynamics
        Examples](../../using/examples/dynamics_examples.html){.reference
        .internal}
        -   [Introduction to CUDA-Q Dynamics (Jaynes-Cummings
            Model)](../../examples/python/dynamics/dynamics_intro_1.html){.reference
            .internal}
            -   [Why dynamics simulations vs. circuit
                simulations?](../../examples/python/dynamics/dynamics_intro_1.html#Why-dynamics-simulations-vs.-circuit-simulations?){.reference
                .internal}
            -   [Functionality](../../examples/python/dynamics/dynamics_intro_1.html#Functionality){.reference
                .internal}
            -   [Performance](../../examples/python/dynamics/dynamics_intro_1.html#Performance){.reference
                .internal}
            -   [Section 1 - Simulating the Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Section-1---Simulating-the-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Exercise 1 - Simulating a many-photon Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-1---Simulating-a-many-photon-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Section 2 - Simulating open quantum systems with the
                [`collapse_operators`{.docutils .literal
                .notranslate}]{.pre}](../../examples/python/dynamics/dynamics_intro_1.html#Section-2---Simulating-open-quantum-systems-with-the-collapse_operators){.reference
                .internal}
            -   [Exercise 2 - Adding additional jump operators
                [\\(L_i\\)]{.math .notranslate
                .nohighlight}](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-2---Adding-additional-jump-operators-L_i){.reference
                .internal}
            -   [Section 3 - Many qubits coupled to the
                resonator](../../examples/python/dynamics/dynamics_intro_1.html#Section-3---Many-qubits-coupled-to-the-resonator){.reference
                .internal}
        -   [Introduction to CUDA-Q Dynamics (Time Dependent
            Hamiltonians)](../../examples/python/dynamics/dynamics_intro_2.html){.reference
            .internal}
            -   [The Landau-Zener
                model](../../examples/python/dynamics/dynamics_intro_2.html#The-Landau-Zener-model){.reference
                .internal}
            -   [Section 1 - Implementing time dependent
                terms](../../examples/python/dynamics/dynamics_intro_2.html#Section-1---Implementing-time-dependent-terms){.reference
                .internal}
            -   [Section 2 - Implementing custom
                operators](../../examples/python/dynamics/dynamics_intro_2.html#Section-2---Implementing-custom-operators){.reference
                .internal}
            -   [Section 3 - Heisenberg Model with a time-varying
                magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Section-3---Heisenberg-Model-with-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 1 - Define a time-varying magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-1---Define-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 2
                (Optional)](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-2-(Optional)){.reference
                .internal}
        -   [Superconducting
            Qubits](../../examples/python/dynamics/superconducting.html){.reference
            .internal}
            -   [Cavity
                QED](../../examples/python/dynamics/superconducting.html#Cavity-QED){.reference
                .internal}
            -   [Cross
                Resonance](../../examples/python/dynamics/superconducting.html#Cross-Resonance){.reference
                .internal}
            -   [Transmon
                Resonator](../../examples/python/dynamics/superconducting.html#Transmon-Resonator){.reference
                .internal}
        -   [Spin
            Qubits](../../examples/python/dynamics/spinqubits.html){.reference
            .internal}
            -   [Silicon Spin
                Qubit](../../examples/python/dynamics/spinqubits.html#Silicon-Spin-Qubit){.reference
                .internal}
            -   [Heisenberg
                Model](../../examples/python/dynamics/spinqubits.html#Heisenberg-Model){.reference
                .internal}
        -   [Trapped Ion
            Qubits](../../examples/python/dynamics/iontrap.html){.reference
            .internal}
            -   [GHZ
                state](../../examples/python/dynamics/iontrap.html#GHZ-state){.reference
                .internal}
        -   [Control](../../examples/python/dynamics/control.html){.reference
            .internal}
            -   [Gate
                Calibration](../../examples/python/dynamics/control.html#Gate-Calibration){.reference
                .internal}
            -   [Pulse](../../examples/python/dynamics/control.html#Pulse){.reference
                .internal}
            -   [Qubit
                Control](../../examples/python/dynamics/control.html#Qubit-Control){.reference
                .internal}
            -   [Qubit
                Dynamics](../../examples/python/dynamics/control.html#Qubit-Dynamics){.reference
                .internal}
            -   [Landau-Zenner](../../examples/python/dynamics/control.html#Landau-Zenner){.reference
                .internal}
-   [Applications](../../using/applications.html){.reference .internal}
    -   [Max-Cut with QAOA](qaoa.html){.reference .internal}
    -   [Molecular docking via
        DC-QAOA](digitized_counterdiabatic_qaoa.html){.reference
        .internal}
        -   [Setting up the Molecular Docking
            Problem](digitized_counterdiabatic_qaoa.html#Setting-up-the-Molecular-Docking-Problem){.reference
            .internal}
        -   [CUDA-Q
            Implementation](digitized_counterdiabatic_qaoa.html#CUDA-Q-Implementation){.reference
            .internal}
    -   [Multi-reference Quantum Krylov Algorithm - [\\(H_2\\)]{.math
        .notranslate .nohighlight} Molecule](krylov.html){.reference
        .internal}
        -   [Setup](krylov.html#Setup){.reference .internal}
        -   [Computing the matrix
            elements](krylov.html#Computing-the-matrix-elements){.reference
            .internal}
        -   [Determining the ground state energy of the
            subspace](krylov.html#Determining-the-ground-state-energy-of-the-subspace){.reference
            .internal}
    -   [Quantum-Selected Configuration Interaction
        (QSCI)](qsci.html){.reference .internal}
        -   [0. Problem
            definition](qsci.html#0.-Problem-definition){.reference
            .internal}
        -   [1. Prepare an Approximate Quantum
            State](qsci.html#1.-Prepare-an-Approximate-Quantum-State){.reference
            .internal}
        -   [2 Quantum Sampling to Select
            Configuration](qsci.html#2-Quantum-Sampling-to-Select-Configuration){.reference
            .internal}
        -   [3. Classical Diagonalization on the Selected
            Subspace](qsci.html#3.-Classical-Diagonalization-on-the-Selected-Subspace){.reference
            .internal}
        -   [5. Compuare
            results](qsci.html#5.-Compuare-results){.reference
            .internal}
        -   [Reference](qsci.html#Reference){.reference .internal}
    -   [Bernstein-Vazirani
        Algorithm](bernstein_vazirani.html){.reference .internal}
        -   [Classical
            case](bernstein_vazirani.html#Classical-case){.reference
            .internal}
        -   [Quantum
            case](bernstein_vazirani.html#Quantum-case){.reference
            .internal}
        -   [Implementing in
            CUDA-Q](bernstein_vazirani.html#Implementing-in-CUDA-Q){.reference
            .internal}
    -   [Cost Minimization](cost_minimization.html){.reference
        .internal}
    -   [Deutsch's Algorithm](deutsch_algorithm.html){.reference
        .internal}
        -   [XOR [\\(\\oplus\\)]{.math .notranslate
            .nohighlight}](deutsch_algorithm.html#XOR-\oplus){.reference
            .internal}
        -   [Quantum
            oracles](deutsch_algorithm.html#Quantum-oracles){.reference
            .internal}
        -   [Phase
            oracle](deutsch_algorithm.html#Phase-oracle){.reference
            .internal}
        -   [Quantum
            parallelism](deutsch_algorithm.html#Quantum-parallelism){.reference
            .internal}
        -   [Deutsch's
            Algorithm:](deutsch_algorithm.html#Deutsch's-Algorithm:){.reference
            .internal}
    -   [Divisive Clustering With Coresets Using
        CUDA-Q](divisive_clustering_coresets.html){.reference .internal}
        -   [Data
            preprocessing](divisive_clustering_coresets.html#Data-preprocessing){.reference
            .internal}
        -   [Quantum
            functions](divisive_clustering_coresets.html#Quantum-functions){.reference
            .internal}
        -   [Divisive Clustering
            Function](divisive_clustering_coresets.html#Divisive-Clustering-Function){.reference
            .internal}
        -   [QAOA
            Implementation](divisive_clustering_coresets.html#QAOA-Implementation){.reference
            .internal}
        -   [Scaling simulations with
            CUDA-Q](divisive_clustering_coresets.html#Scaling-simulations-with-CUDA-Q){.reference
            .internal}
    -   [Hybrid Quantum Neural
        Networks](hybrid_quantum_neural_networks.html){.reference
        .internal}
    -   [Using the Hadamard Test to Determine Quantum Krylov Subspace
        Decomposition Matrix Elements](hadamard_test.html){.reference
        .internal}
        -   [Numerical result as a
            reference:](hadamard_test.html#Numerical-result-as-a-reference:){.reference
            .internal}
        -   [Using [`Sample`{.docutils .literal .notranslate}]{.pre} to
            perform the Hadamard
            test](hadamard_test.html#Using-Sample-to-perform-the-Hadamard-test){.reference
            .internal}
        -   [Multi-GPU evaluation of QKSD matrix elements using the
            Hadamard
            Test](hadamard_test.html#Multi-GPU-evaluation-of-QKSD-matrix-elements-using-the-Hadamard-Test){.reference
            .internal}
            -   [Classically Diagonalize the Subspace
                Matrix](hadamard_test.html#Classically-Diagonalize-the-Subspace-Matrix){.reference
                .internal}
    -   [Anderson Impurity Model ground state solver on Infleqtion's
        Sqale](#){.current .reference .internal}
        -   [Performing logical Variational Quantum Eigensolver (VQE)
            with
            CUDA-QX](#Performing-logical-Variational-Quantum-Eigensolver-(VQE)-with-CUDA-QX){.reference
            .internal}
        -   [Constructing circuits in the [`[[4,2,2]]`{.docutils
            .literal .notranslate}]{.pre}
            encoding](#Constructing-circuits-in-the-%5B%5B4,2,2%5D%5D-encoding){.reference
            .internal}
        -   [Setting up submission and decoding
            workflow](#Setting-up-submission-and-decoding-workflow){.reference
            .internal}
        -   [Running a CUDA-Q noisy
            simulation](#Running-a-CUDA-Q-noisy-simulation){.reference
            .internal}
        -   [Running logical AIM on Infleqtion's
            hardware](#Running-logical-AIM-on-Infleqtion's-hardware){.reference
            .internal}
    -   [Spin-Hamiltonian Simulation Using
        CUDA-Q](hamiltonian_simulation.html){.reference .internal}
        -   [Introduction](hamiltonian_simulation.html#Introduction){.reference
            .internal}
            -   [Heisenberg
                Hamiltonian](hamiltonian_simulation.html#Heisenberg-Hamiltonian){.reference
                .internal}
            -   [Transverse Field Ising Model
                (TFIM)](hamiltonian_simulation.html#Transverse-Field-Ising-Model-(TFIM)){.reference
                .internal}
            -   [Time Evolution and Trotter
                Decomposition](hamiltonian_simulation.html#Time-Evolution-and-Trotter-Decomposition){.reference
                .internal}
        -   [Key
            steps](hamiltonian_simulation.html#Key-steps){.reference
            .internal}
            -   [1. Prepare initial
                state](hamiltonian_simulation.html#1.-Prepare-initial-state){.reference
                .internal}
            -   [2. Hamiltonian
                Trotterization](hamiltonian_simulation.html#2.-Hamiltonian-Trotterization){.reference
                .internal}
            -   [3. [`Compute`{.docutils .literal
                .notranslate}]{.pre}` `{.docutils .literal
                .notranslate}[`overlap`{.docutils .literal
                .notranslate}]{.pre}](hamiltonian_simulation.html#3.-Compute-overlap){.reference
                .internal}
            -   [4. Construct Heisenberg
                Hamiltonian](hamiltonian_simulation.html#4.-Construct-Heisenberg-Hamiltonian){.reference
                .internal}
            -   [5. Construct TFIM
                Hamiltonian](hamiltonian_simulation.html#5.-Construct-TFIM-Hamiltonian){.reference
                .internal}
            -   [6. Extract coefficients and Pauli
                words](hamiltonian_simulation.html#6.-Extract-coefficients-and-Pauli-words){.reference
                .internal}
        -   [Main
            code](hamiltonian_simulation.html#Main-code){.reference
            .internal}
        -   [Visualization of probablity over
            time](hamiltonian_simulation.html#Visualization-of-probablity-over-time){.reference
            .internal}
        -   [Expectation value over
            time:](hamiltonian_simulation.html#Expectation-value-over-time:){.reference
            .internal}
        -   [Visualization of expectation over
            time](hamiltonian_simulation.html#Visualization-of-expectation-over-time){.reference
            .internal}
        -   [Additional
            information](hamiltonian_simulation.html#Additional-information){.reference
            .internal}
        -   [Relevant
            references](hamiltonian_simulation.html#Relevant-references){.reference
            .internal}
    -   [Quantum Fourier
        Transform](quantum_fourier_transform.html){.reference .internal}
        -   [Quantum Fourier Transform
            revisited](quantum_fourier_transform.html#Quantum-Fourier-Transform-revisited){.reference
            .internal}
    -   [Quantum Teleporation](quantum_teleportation.html){.reference
        .internal}
        -   [Teleportation
            explained](quantum_teleportation.html#Teleportation-explained){.reference
            .internal}
    -   [Quantum Volume](quantum_volume.html){.reference .internal}
    -   [Readout Error
        Mitigation](readout_error_mitigation.html){.reference .internal}
        -   [Inverse confusion matrix from single-qubit noise
            model](readout_error_mitigation.html#Inverse-confusion-matrix-from-single-qubit-noise-model){.reference
            .internal}
        -   [Inverse confusion matrix from k local confusion
            matrices](readout_error_mitigation.html#Inverse-confusion-matrix-from-k-local-confusion-matrices){.reference
            .internal}
        -   [Inverse of full confusion
            matrix](readout_error_mitigation.html#Inverse-of-full-confusion-matrix){.reference
            .internal}
    -   [Compiling Unitaries Using Diffusion
        Models](unitary_compilation_diffusion_models.html){.reference
        .internal}
        -   [Diffusion model
            pipeline](unitary_compilation_diffusion_models.html#Diffusion-model-pipeline){.reference
            .internal}
        -   [Setup and load
            models](unitary_compilation_diffusion_models.html#Setup-and-load-models){.reference
            .internal}
            -   [Load discrete
                model](unitary_compilation_diffusion_models.html#Load-discrete-model){.reference
                .internal}
            -   [Load continuous
                model](unitary_compilation_diffusion_models.html#Load-continuous-model){.reference
                .internal}
            -   [Create helper
                functions](unitary_compilation_diffusion_models.html#Create-helper-functions){.reference
                .internal}
        -   [Unitary
            compilation](unitary_compilation_diffusion_models.html#Unitary-compilation){.reference
            .internal}
            -   [Random
                unitary](unitary_compilation_diffusion_models.html#Random-unitary){.reference
                .internal}
            -   [Discrete
                model](unitary_compilation_diffusion_models.html#Discrete-model){.reference
                .internal}
            -   [Continuous
                model](unitary_compilation_diffusion_models.html#Continuous-model){.reference
                .internal}
            -   [Quantum Fourier
                transform](unitary_compilation_diffusion_models.html#Quantum-Fourier-transform){.reference
                .internal}
            -   [XXZ-Hamiltonian
                evolution](unitary_compilation_diffusion_models.html#XXZ-Hamiltonian-evolution){.reference
                .internal}
        -   [Choosing the circuit you
            need](unitary_compilation_diffusion_models.html#Choosing-the-circuit-you-need){.reference
            .internal}
    -   [VQE with gradients, active spaces, and gate
        fusion](vqe_advanced.html){.reference .internal}
        -   [The Basics of
            VQE](vqe_advanced.html#The-Basics-of-VQE){.reference
            .internal}
        -   [Installing/Loading Relevant
            Packages](vqe_advanced.html#Installing/Loading-Relevant-Packages){.reference
            .internal}
        -   [Implementing VQE in
            CUDA-Q](vqe_advanced.html#Implementing-VQE-in-CUDA-Q){.reference
            .internal}
        -   [Parallel Parameter Shift
            Gradients](vqe_advanced.html#Parallel-Parameter-Shift-Gradients){.reference
            .internal}
        -   [Using an Active
            Space](vqe_advanced.html#Using-an-Active-Space){.reference
            .internal}
        -   [Gate Fusion for Larger
            Circuits](vqe_advanced.html#Gate-Fusion-for-Larger-Circuits){.reference
            .internal}
    -   [Quantum Transformer](quantum_transformer.html){.reference
        .internal}
        -   [Installation](quantum_transformer.html#Installation){.reference
            .internal}
        -   [Algorithm and
            Example](quantum_transformer.html#Algorithm-and-Example){.reference
            .internal}
            -   [Creating the self-attention
                circuits](quantum_transformer.html#Creating-the-self-attention-circuits){.reference
                .internal}
        -   [Usage](quantum_transformer.html#Usage){.reference
            .internal}
            -   [Model
                Training](quantum_transformer.html#Model-Training){.reference
                .internal}
            -   [Generating
                Molecules](quantum_transformer.html#Generating-Molecules){.reference
                .internal}
            -   [Attention
                Maps](quantum_transformer.html#Attention-Maps){.reference
                .internal}
    -   [Quantum Enhanced Auxiliary Field Quantum Monte
        Carlo](afqmc.html){.reference .internal}
        -   [Hamiltonian preparation for
            VQE](afqmc.html#Hamiltonian-preparation-for-VQE){.reference
            .internal}
        -   [Run VQE with
            CUDA-Q](afqmc.html#Run-VQE-with-CUDA-Q){.reference
            .internal}
        -   [Auxiliary Field Quantum Monte Carlo
            (AFQMC)](afqmc.html#Auxiliary-Field-Quantum-Monte-Carlo-(AFQMC)){.reference
            .internal}
        -   [Preparation of the molecular
            Hamiltonian](afqmc.html#Preparation-of-the-molecular-Hamiltonian){.reference
            .internal}
        -   [Preparation of the trial wave
            function](afqmc.html#Preparation-of-the-trial-wave-function){.reference
            .internal}
        -   [Setup of the AFQMC
            parameters](afqmc.html#Setup-of-the-AFQMC-parameters){.reference
            .internal}
    -   [ADAPT-QAOA algorithm](adapt_qaoa.html){.reference .internal}
        -   [Simulation
            input:](adapt_qaoa.html#Simulation-input:){.reference
            .internal}
        -   [The problem Hamiltonian [\\(H_C\\)]{.math .notranslate
            .nohighlight} of the max-cut
            graph:](adapt_qaoa.html#The-problem-Hamiltonian-H_C-of-the-max-cut-graph:){.reference
            .internal}
        -   [Th operator pool [\\(A_j\\)]{.math .notranslate
            .nohighlight}:](adapt_qaoa.html#Th-operator-pool-A_j:){.reference
            .internal}
        -   [The commutator [\\(\[H_C,A_j\]\\)]{.math .notranslate
            .nohighlight}:](adapt_qaoa.html#The-commutator-%5BH_C,A_j%5D:){.reference
            .internal}
        -   [Beginning of ADAPT-QAOA
            iteration:](adapt_qaoa.html#Beginning-of-ADAPT-QAOA-iteration:){.reference
            .internal}
    -   [ADAPT-VQE algorithm](adapt_vqe.html){.reference .internal}
        -   [Classical
            pre-processing](adapt_vqe.html#Classical-pre-processing){.reference
            .internal}
        -   [Jordan Wigner:](adapt_vqe.html#Jordan-Wigner:){.reference
            .internal}
        -   [UCCSD operator
            pool](adapt_vqe.html#UCCSD-operator-pool){.reference
            .internal}
            -   [Single
                excitation](adapt_vqe.html#Single-excitation){.reference
                .internal}
            -   [Double
                excitation](adapt_vqe.html#Double-excitation){.reference
                .internal}
        -   [Commutator \[[\\(H\\)]{.math .notranslate .nohighlight},
            [\\(A_i\\)]{.math .notranslate
            .nohighlight}\]](adapt_vqe.html#Commutator-%5BH,-A_i%5D){.reference
            .internal}
        -   [Reference
            State:](adapt_vqe.html#Reference-State:){.reference
            .internal}
        -   [Quantum
            kernels:](adapt_vqe.html#Quantum-kernels:){.reference
            .internal}
        -   [Beginning of
            ADAPT-VQE:](adapt_vqe.html#Beginning-of-ADAPT-VQE:){.reference
            .internal}
    -   [Quantum edge detection](edge_detection.html){.reference
        .internal}
        -   [Image](edge_detection.html#Image){.reference .internal}
        -   [Quantum Probability Image Encoding
            (QPIE):](edge_detection.html#Quantum-Probability-Image-Encoding-(QPIE):){.reference
            .internal}
            -   [Below we show how to encode an image using QPIE in
                cudaq.](edge_detection.html#Below-we-show-how-to-encode-an-image-using-QPIE-in-cudaq.){.reference
                .internal}
        -   [Flexible Representation of Quantum Images
            (FRQI):](edge_detection.html#Flexible-Representation-of-Quantum-Images-(FRQI):){.reference
            .internal}
            -   [Building the FRQI
                State:](edge_detection.html#Building-the-FRQI-State:){.reference
                .internal}
        -   [Quantum Hadamard Edge Detection
            (QHED)](edge_detection.html#Quantum-Hadamard-Edge-Detection-(QHED)){.reference
            .internal}
            -   [Post-processing](edge_detection.html#Post-processing){.reference
                .internal}
    -   [Factoring Integers With Shor's
        Algorithm](shors.html){.reference .internal}
        -   [Shor's algorithm](shors.html#Shor's-algorithm){.reference
            .internal}
            -   [Solving the order-finding problem
                classically](shors.html#Solving-the-order-finding-problem-classically){.reference
                .internal}
            -   [Solving the order-finding problem with a quantum
                algorithm](shors.html#Solving-the-order-finding-problem-with-a-quantum-algorithm){.reference
                .internal}
            -   [Determining the order from the measurement results of
                the phase
                kernel](shors.html#Determining-the-order-from-the-measurement-results-of-the-phase-kernel){.reference
                .internal}
            -   [Postscript](shors.html#Postscript){.reference
                .internal}
    -   [Generating the electronic
        Hamiltonian](generate_fermionic_ham.html){.reference .internal}
        -   [Second Quantized
            formulation.](generate_fermionic_ham.html#Second-Quantized-formulation.){.reference
            .internal}
            -   [Computational
                Implementation](generate_fermionic_ham.html#Computational-Implementation){.reference
                .internal}
            -   [(a) Generate the molecular Hamiltonian using Restricted
                Hartree Fock molecular
                orbitals](generate_fermionic_ham.html#(a)-Generate-the-molecular-Hamiltonian-using-Restricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(b) Generate the molecular Hamiltonian using
                Unrestricted Hartree Fock molecular
                orbitals](generate_fermionic_ham.html#(b)-Generate-the-molecular-Hamiltonian-using-Unrestricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(a) Generate the active space hamiltonian using RHF
                molecular
                orbitals.](generate_fermionic_ham.html#(a)-Generate-the-active-space-hamiltonian-using-RHF-molecular-orbitals.){.reference
                .internal}
            -   [(b) Generate the active space Hamiltonian using the
                natural orbitals computed from MP2
                simulation](generate_fermionic_ham.html#(b)-Generate-the-active-space-Hamiltonian-using-the-natural-orbitals-computed-from-MP2-simulation){.reference
                .internal}
            -   [(c) Generate the active space Hamiltonian computed from
                the CASSCF molecular
                orbitals](generate_fermionic_ham.html#(c)-Generate-the-active-space-Hamiltonian-computed-from-the-CASSCF-molecular-orbitals){.reference
                .internal}
            -   [(d) Generate the electronic Hamiltonian using
                ROHF](generate_fermionic_ham.html#(d)-Generate-the-electronic-Hamiltonian-using-ROHF){.reference
                .internal}
            -   [(e) Generate electronic Hamiltonian using
                UHF](generate_fermionic_ham.html#(e)-Generate-electronic-Hamiltonian-using-UHF){.reference
                .internal}
    -   [Grover's Algorithm](grovers.html){.reference .internal}
        -   [Overview](grovers.html#Overview){.reference .internal}
        -   [Problem](grovers.html#Problem){.reference .internal}
        -   [Structure of Grover's
            Algorithm](grovers.html#Structure-of-Grover's-Algorithm){.reference
            .internal}
            -   [Step 1:
                Preparation](grovers.html#Step-1:-Preparation){.reference
                .internal}
            -   [Good and Bad
                States](grovers.html#Good-and-Bad-States){.reference
                .internal}
            -   [Step 2: Oracle
                application](grovers.html#Step-2:-Oracle-application){.reference
                .internal}
            -   [Step 3: Amplitude
                amplification](grovers.html#Step-3:-Amplitude-amplification){.reference
                .internal}
            -   [Steps 4 and 5: Iteration and
                measurement](grovers.html#Steps-4-and-5:-Iteration-and-measurement){.reference
                .internal}
    -   [Quantum PageRank](quantum_pagerank.html){.reference .internal}
        -   [Problem
            Definition](quantum_pagerank.html#Problem-Definition){.reference
            .internal}
        -   [Simulating Quantum PageRank by CUDA-Q
            dynamics](quantum_pagerank.html#Simulating-Quantum-PageRank-by-CUDA-Q-dynamics){.reference
            .internal}
        -   [Breakdown of
            Terms](quantum_pagerank.html#Breakdown-of-Terms){.reference
            .internal}
    -   [The UCCSD Wavefunction ansatz](uccsd_wf_ansatz.html){.reference
        .internal}
        -   [What is
            UCCSD?](uccsd_wf_ansatz.html#What-is-UCCSD?){.reference
            .internal}
        -   [Implementation in Quantum
            Computing](uccsd_wf_ansatz.html#Implementation-in-Quantum-Computing){.reference
            .internal}
        -   [Run VQE](uccsd_wf_ansatz.html#Run-VQE){.reference
            .internal}
        -   [Challenges and
            consideration](uccsd_wf_ansatz.html#Challenges-and-consideration){.reference
            .internal}
    -   [Approximate State Preparation using MPS Sequential
        Encoding](mps_encoding.html){.reference .internal}
        -   [Ran's
            approach](mps_encoding.html#Ran's-approach){.reference
            .internal}
    -   [QM/MM simulation: VQE within a Polarizable Embedded
        Framework.](qm_mm_pe.html){.reference .internal}
        -   [Key concepts:](qm_mm_pe.html#Key-concepts:){.reference
            .internal}
        -   [PE-VQE-SCF Algorithm
            Steps](qm_mm_pe.html#PE-VQE-SCF-Algorithm-Steps){.reference
            .internal}
            -   [Step 1: Initialize (Classical
                pre-processing)](qm_mm_pe.html#Step-1:-Initialize-(Classical-pre-processing)){.reference
                .internal}
            -   [Step 2: Build the
                Hamiltonian](qm_mm_pe.html#Step-2:-Build-the-Hamiltonian){.reference
                .internal}
            -   [Step 3: Run
                VQE](qm_mm_pe.html#Step-3:-Run-VQE){.reference
                .internal}
            -   [Step 4: Update
                Environment](qm_mm_pe.html#Step-4:-Update-Environment){.reference
                .internal}
            -   [Step 5: Self-Consistency
                Loop](qm_mm_pe.html#Step-5:-Self-Consistency-Loop){.reference
                .internal}
            -   [Requirments:](qm_mm_pe.html#Requirments:){.reference
                .internal}
            -   [Example 1: LiH with 2 water
                molecules.](qm_mm_pe.html#Example-1:-LiH-with-2-water-molecules.){.reference
                .internal}
            -   [VQE, update environment, and scf
                loop.](qm_mm_pe.html#VQE,-update-environment,-and-scf-loop.){.reference
                .internal}
            -   [Example 2: NH3 with 46 water molecule using active
                space.](qm_mm_pe.html#Example-2:-NH3-with-46-water-molecule-using-active-space.){.reference
                .internal}
    -   [Sample-Based Krylov Quantum Diagonalization
        (SKQD)](skqd.html){.reference .internal}
        -   [Why SKQD?](skqd.html#Why-SKQD?){.reference .internal}
        -   [Setup and Imports](skqd.html#Setup-and-Imports){.reference
            .internal}
        -   [Understanding Krylov
            Subspaces](skqd.html#Understanding-Krylov-Subspaces){.reference
            .internal}
            -   [What is a Krylov
                Subspace?](skqd.html#What-is-a-Krylov-Subspace?){.reference
                .internal}
            -   [The SKQD
                Algorithm](skqd.html#The-SKQD-Algorithm){.reference
                .internal}
        -   [Krylov State Generation via Repeated
            Evolution](skqd.html#Krylov-State-Generation-via-Repeated-Evolution){.reference
            .internal}
        -   [Quantum Measurements and
            Sampling](skqd.html#Quantum-Measurements-and-Sampling){.reference
            .internal}
            -   [The Sampling
                Process](skqd.html#The-Sampling-Process){.reference
                .internal}
        -   [Classical Post-Processing and
            Diagonalization](skqd.html#Classical-Post-Processing-and-Diagonalization){.reference
            .internal}
            -   [The SKQD Algorithm: Matrix Construction
                Details](skqd.html#The-SKQD-Algorithm:-Matrix-Construction-Details){.reference
                .internal}
        -   [Results Analysis and
            Convergence](skqd.html#Results-Analysis-and-Convergence){.reference
            .internal}
            -   [What to Expect:](skqd.html#What-to-Expect:){.reference
                .internal}
    -   [Entanglement Accelerates Quantum
        Simulation](entanglement_acc_hamiltonian_simulation.html){.reference
        .internal}
        -   [2. Model
            Definition](entanglement_acc_hamiltonian_simulation.html#2.-Model-Definition){.reference
            .internal}
            -   [2.1 Initial product
                state](entanglement_acc_hamiltonian_simulation.html#2.1-Initial-product-state){.reference
                .internal}
            -   [2.2 QIMF
                Hamiltonian](entanglement_acc_hamiltonian_simulation.html#2.2-QIMF-Hamiltonian){.reference
                .internal}
            -   [2.3 First-Order Trotter Formula
                (PF1)](entanglement_acc_hamiltonian_simulation.html#2.3-First-Order-Trotter-Formula-(PF1)){.reference
                .internal}
            -   [2.4 PF1 step for the QIMF
                partition](entanglement_acc_hamiltonian_simulation.html#2.4-PF1-step-for-the-QIMF-partition){.reference
                .internal}
            -   [2.5 Hamiltonian
                helpers](entanglement_acc_hamiltonian_simulation.html#2.5-Hamiltonian-helpers){.reference
                .internal}
        -   [3. Entanglement
            metrics](entanglement_acc_hamiltonian_simulation.html#3.-Entanglement-metrics){.reference
            .internal}
        -   [4. Simulation
            workflow](entanglement_acc_hamiltonian_simulation.html#4.-Simulation-workflow){.reference
            .internal}
            -   [4.1 Single-step Trotter
                error](entanglement_acc_hamiltonian_simulation.html#4.1-Single-step-Trotter-error){.reference
                .internal}
            -   [4.2 Dual trajectory
                update](entanglement_acc_hamiltonian_simulation.html#4.2-Dual-trajectory-update){.reference
                .internal}
        -   [5. Reproducing the paper's Figure
            1a](entanglement_acc_hamiltonian_simulation.html#5.-Reproducing-the-paperâ€™s-Figure-1a){.reference
            .internal}
            -   [5.1 Visualising the joint
                behaviour](entanglement_acc_hamiltonian_simulation.html#5.1-Visualising-the-joint-behaviour){.reference
                .internal}
            -   [5.2 Interpreting the
                result](entanglement_acc_hamiltonian_simulation.html#5.2-Interpreting-the-result){.reference
                .internal}
        -   [6. References and further
            reading](entanglement_acc_hamiltonian_simulation.html#6.-References-and-further-reading){.reference
            .internal}
-   [Backends](../../using/backends/backends.html){.reference .internal}
    -   [Circuit
        Simulation](../../using/backends/simulators.html){.reference
        .internal}
        -   [State Vector
            Simulators](../../using/backends/sims/svsims.html){.reference
            .internal}
            -   [CPU](../../using/backends/sims/svsims.html#cpu){.reference
                .internal}
            -   [Single-GPU](../../using/backends/sims/svsims.html#single-gpu){.reference
                .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/svsims.html#multi-gpu-multi-node){.reference
                .internal}
        -   [Tensor Network
            Simulators](../../using/backends/sims/tnsims.html){.reference
            .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/tnsims.html#multi-gpu-multi-node){.reference
                .internal}
            -   [Matrix product
                state](../../using/backends/sims/tnsims.html#matrix-product-state){.reference
                .internal}
            -   [Fermioniq](../../using/backends/sims/tnsims.html#fermioniq){.reference
                .internal}
        -   [Multi-QPU
            Simulators](../../using/backends/sims/mqpusims.html){.reference
            .internal}
            -   [Simulate Multiple QPUs in
                Parallel](../../using/backends/sims/mqpusims.html#simulate-multiple-qpus-in-parallel){.reference
                .internal}
            -   [Multi-QPU + Other
                Backends](../../using/backends/sims/mqpusims.html#multi-qpu-other-backends){.reference
                .internal}
        -   [Noisy
            Simulators](../../using/backends/sims/noisy.html){.reference
            .internal}
            -   [Trajectory Noisy
                Simulation](../../using/backends/sims/noisy.html#trajectory-noisy-simulation){.reference
                .internal}
            -   [Density
                Matrix](../../using/backends/sims/noisy.html#density-matrix){.reference
                .internal}
            -   [Stim](../../using/backends/sims/noisy.html#stim){.reference
                .internal}
        -   [Photonics
            Simulators](../../using/backends/sims/photonics.html){.reference
            .internal}
            -   [orca-photonics](../../using/backends/sims/photonics.html#orca-photonics){.reference
                .internal}
    -   [Quantum Hardware
        (QPUs)](../../using/backends/hardware.html){.reference
        .internal}
        -   [Ion Trap
            QPUs](../../using/backends/hardware/iontrap.html){.reference
            .internal}
            -   [IonQ](../../using/backends/hardware/iontrap.html#ionq){.reference
                .internal}
            -   [Quantinuum](../../using/backends/hardware/iontrap.html#quantinuum){.reference
                .internal}
        -   [Superconducting
            QPUs](../../using/backends/hardware/superconducting.html){.reference
            .internal}
            -   [Anyon Technologies/Anyon
                Computing](../../using/backends/hardware/superconducting.html#anyon-technologies-anyon-computing){.reference
                .internal}
            -   [IQM](../../using/backends/hardware/superconducting.html#iqm){.reference
                .internal}
            -   [OQC](../../using/backends/hardware/superconducting.html#oqc){.reference
                .internal}
            -   [Quantum Circuits,
                Inc.](../../using/backends/hardware/superconducting.html#quantum-circuits-inc){.reference
                .internal}
        -   [Neutral Atom
            QPUs](../../using/backends/hardware/neutralatom.html){.reference
            .internal}
            -   [Infleqtion](../../using/backends/hardware/neutralatom.html#infleqtion){.reference
                .internal}
            -   [Pasqal](../../using/backends/hardware/neutralatom.html#pasqal){.reference
                .internal}
            -   [QuEra
                Computing](../../using/backends/hardware/neutralatom.html#quera-computing){.reference
                .internal}
        -   [Photonic
            QPUs](../../using/backends/hardware/photonic.html){.reference
            .internal}
            -   [ORCA
                Computing](../../using/backends/hardware/photonic.html#orca-computing){.reference
                .internal}
        -   [Quantum Control
            Systems](../../using/backends/hardware/qcontrol.html){.reference
            .internal}
            -   [Quantum
                Machines](../../using/backends/hardware/qcontrol.html#quantum-machines){.reference
                .internal}
    -   [Dynamics
        Simulation](../../using/backends/dynamics_backends.html){.reference
        .internal}
    -   [Cloud](../../using/backends/cloud.html){.reference .internal}
        -   [Amazon Braket
            (braket)](../../using/backends/cloud/braket.html){.reference
            .internal}
            -   [Setting
                Credentials](../../using/backends/cloud/braket.html#setting-credentials){.reference
                .internal}
            -   [Submission from
                C++](../../using/backends/cloud/braket.html#submission-from-c){.reference
                .internal}
            -   [Submission from
                Python](../../using/backends/cloud/braket.html#submission-from-python){.reference
                .internal}
        -   [NVIDIA Quantum Cloud
            (nvqc)](../../using/backends/cloud/nvqc.html){.reference
            .internal}
            -   [Quick
                Start](../../using/backends/cloud/nvqc.html#quick-start){.reference
                .internal}
            -   [Simulator Backend
                Selection](../../using/backends/cloud/nvqc.html#simulator-backend-selection){.reference
                .internal}
            -   [Multiple
                GPUs](../../using/backends/cloud/nvqc.html#multiple-gpus){.reference
                .internal}
            -   [Multiple QPUs Asynchronous
                Execution](../../using/backends/cloud/nvqc.html#multiple-qpus-asynchronous-execution){.reference
                .internal}
            -   [FAQ](../../using/backends/cloud/nvqc.html#faq){.reference
                .internal}
-   [Dynamics](../../using/dynamics.html){.reference .internal}
    -   [Quick Start](../../using/dynamics.html#quick-start){.reference
        .internal}
    -   [Operator](../../using/dynamics.html#operator){.reference
        .internal}
    -   [Time-Dependent
        Dynamics](../../using/dynamics.html#time-dependent-dynamics){.reference
        .internal}
    -   [Super-operator
        Representation](../../using/dynamics.html#super-operator-representation){.reference
        .internal}
    -   [Numerical
        Integrators](../../using/dynamics.html#numerical-integrators){.reference
        .internal}
    -   [Batch
        simulation](../../using/dynamics.html#batch-simulation){.reference
        .internal}
    -   [Multi-GPU Multi-Node
        Execution](../../using/dynamics.html#multi-gpu-multi-node-execution){.reference
        .internal}
    -   [Examples](../../using/dynamics.html#examples){.reference
        .internal}
-   [CUDA-QX](../../using/cudaqx/cudaqx.html){.reference .internal}
    -   [CUDA-Q
        Solvers](../../using/cudaqx/cudaqx.html#cuda-q-solvers){.reference
        .internal}
    -   [CUDA-Q
        QEC](../../using/cudaqx/cudaqx.html#cuda-q-qec){.reference
        .internal}
-   [Installation](../../using/install/install.html){.reference
    .internal}
    -   [Local
        Installation](../../using/install/local_installation.html){.reference
        .internal}
        -   [Introduction](../../using/install/local_installation.html#introduction){.reference
            .internal}
            -   [Docker](../../using/install/local_installation.html#docker){.reference
                .internal}
            -   [Known Blackwell
                Issues](../../using/install/local_installation.html#known-blackwell-issues){.reference
                .internal}
            -   [Singularity](../../using/install/local_installation.html#singularity){.reference
                .internal}
            -   [Python
                wheels](../../using/install/local_installation.html#python-wheels){.reference
                .internal}
            -   [Pre-built
                binaries](../../using/install/local_installation.html#pre-built-binaries){.reference
                .internal}
        -   [Development with VS
            Code](../../using/install/local_installation.html#development-with-vs-code){.reference
            .internal}
            -   [Using a Docker
                container](../../using/install/local_installation.html#using-a-docker-container){.reference
                .internal}
            -   [Using a Singularity
                container](../../using/install/local_installation.html#using-a-singularity-container){.reference
                .internal}
        -   [Connecting to a Remote
            Host](../../using/install/local_installation.html#connecting-to-a-remote-host){.reference
            .internal}
            -   [Developing with Remote
                Tunnels](../../using/install/local_installation.html#developing-with-remote-tunnels){.reference
                .internal}
            -   [Remote Access via
                SSH](../../using/install/local_installation.html#remote-access-via-ssh){.reference
                .internal}
        -   [DGX
            Cloud](../../using/install/local_installation.html#dgx-cloud){.reference
            .internal}
            -   [Get
                Started](../../using/install/local_installation.html#get-started){.reference
                .internal}
            -   [Use
                JupyterLab](../../using/install/local_installation.html#use-jupyterlab){.reference
                .internal}
            -   [Use VS
                Code](../../using/install/local_installation.html#use-vs-code){.reference
                .internal}
        -   [Additional CUDA
            Tools](../../using/install/local_installation.html#additional-cuda-tools){.reference
            .internal}
            -   [Installation via
                PyPI](../../using/install/local_installation.html#installation-via-pypi){.reference
                .internal}
            -   [Installation In Container
                Images](../../using/install/local_installation.html#installation-in-container-images){.reference
                .internal}
            -   [Installing Pre-built
                Binaries](../../using/install/local_installation.html#installing-pre-built-binaries){.reference
                .internal}
        -   [Distributed Computing with
            MPI](../../using/install/local_installation.html#distributed-computing-with-mpi){.reference
            .internal}
        -   [Updating
            CUDA-Q](../../using/install/local_installation.html#updating-cuda-q){.reference
            .internal}
        -   [Dependencies and
            Compatibility](../../using/install/local_installation.html#dependencies-and-compatibility){.reference
            .internal}
        -   [Next
            Steps](../../using/install/local_installation.html#next-steps){.reference
            .internal}
    -   [Data Center
        Installation](../../using/install/data_center_install.html){.reference
        .internal}
        -   [Prerequisites](../../using/install/data_center_install.html#prerequisites){.reference
            .internal}
        -   [Build
            Dependencies](../../using/install/data_center_install.html#build-dependencies){.reference
            .internal}
            -   [CUDA](../../using/install/data_center_install.html#cuda){.reference
                .internal}
            -   [Toolchain](../../using/install/data_center_install.html#toolchain){.reference
                .internal}
        -   [Building
            CUDA-Q](../../using/install/data_center_install.html#building-cuda-q){.reference
            .internal}
        -   [Python
            Support](../../using/install/data_center_install.html#python-support){.reference
            .internal}
        -   [C++
            Support](../../using/install/data_center_install.html#c-support){.reference
            .internal}
        -   [Installation on the
            Host](../../using/install/data_center_install.html#installation-on-the-host){.reference
            .internal}
            -   [CUDA Runtime
                Libraries](../../using/install/data_center_install.html#cuda-runtime-libraries){.reference
                .internal}
            -   [MPI](../../using/install/data_center_install.html#mpi){.reference
                .internal}
-   [Integration](../../using/integration/integration.html){.reference
    .internal}
    -   [Downstream CMake
        Integration](../../using/integration/cmake_app.html){.reference
        .internal}
    -   [Combining CUDA with
        CUDA-Q](../../using/integration/cuda_gpu.html){.reference
        .internal}
    -   [Integrating with Third-Party
        Libraries](../../using/integration/libraries.html){.reference
        .internal}
        -   [Calling a CUDA-Q library from
            C++](../../using/integration/libraries.html#calling-a-cuda-q-library-from-c){.reference
            .internal}
        -   [Calling an C++ library from
            CUDA-Q](../../using/integration/libraries.html#calling-an-c-library-from-cuda-q){.reference
            .internal}
        -   [Interfacing between binaries compiled with a different
            toolchains](../../using/integration/libraries.html#interfacing-between-binaries-compiled-with-a-different-toolchains){.reference
            .internal}
-   [Extending](../../using/extending/extending.html){.reference
    .internal}
    -   [Add a new Hardware
        Backend](../../using/extending/backend.html){.reference
        .internal}
        -   [Overview](../../using/extending/backend.html#overview){.reference
            .internal}
        -   [Server Helper
            Implementation](../../using/extending/backend.html#server-helper-implementation){.reference
            .internal}
            -   [Directory
                Structure](../../using/extending/backend.html#directory-structure){.reference
                .internal}
            -   [Server Helper
                Class](../../using/extending/backend.html#server-helper-class){.reference
                .internal}
            -   [[`CMakeLists.txt`{.docutils .literal
                .notranslate}]{.pre}](../../using/extending/backend.html#cmakelists-txt){.reference
                .internal}
        -   [Target
            Configuration](../../using/extending/backend.html#target-configuration){.reference
            .internal}
            -   [Update Parent [`CMakeLists.txt`{.docutils .literal
                .notranslate}]{.pre}](../../using/extending/backend.html#update-parent-cmakelists-txt){.reference
                .internal}
        -   [Testing](../../using/extending/backend.html#testing){.reference
            .internal}
            -   [Unit
                Tests](../../using/extending/backend.html#unit-tests){.reference
                .internal}
            -   [Mock
                Server](../../using/extending/backend.html#mock-server){.reference
                .internal}
            -   [Python
                Tests](../../using/extending/backend.html#python-tests){.reference
                .internal}
            -   [Integration
                Tests](../../using/extending/backend.html#integration-tests){.reference
                .internal}
        -   [Documentation](../../using/extending/backend.html#documentation){.reference
            .internal}
        -   [Example
            Usage](../../using/extending/backend.html#example-usage){.reference
            .internal}
        -   [Code
            Review](../../using/extending/backend.html#code-review){.reference
            .internal}
        -   [Maintaining a
            Backend](../../using/extending/backend.html#maintaining-a-backend){.reference
            .internal}
        -   [Conclusion](../../using/extending/backend.html#conclusion){.reference
            .internal}
    -   [Create a new NVQIR
        Simulator](../../using/extending/nvqir_simulator.html){.reference
        .internal}
        -   [[`CircuitSimulator`{.code .docutils .literal
            .notranslate}]{.pre}](../../using/extending/nvqir_simulator.html#circuitsimulator){.reference
            .internal}
        -   [Let's see this in
            action](../../using/extending/nvqir_simulator.html#let-s-see-this-in-action){.reference
            .internal}
    -   [Working with CUDA-Q
        IR](../../using/extending/cudaq_ir.html){.reference .internal}
    -   [Create an MLIR Pass for
        CUDA-Q](../../using/extending/mlir_pass.html){.reference
        .internal}
-   [Specifications](../../specification/index.html){.reference
    .internal}
    -   [Language
        Specification](../../specification/cudaq.html){.reference
        .internal}
        -   [1. Machine
            Model](../../specification/cudaq/machine_model.html){.reference
            .internal}
        -   [2. Namespace and
            Standard](../../specification/cudaq/namespace.html){.reference
            .internal}
        -   [3. Quantum
            Types](../../specification/cudaq/types.html){.reference
            .internal}
            -   [3.1. [`cudaq::qudit<Levels>`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/types.html#cudaq-qudit-levels){.reference
                .internal}
            -   [3.2. [`cudaq::qubit`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/types.html#cudaq-qubit){.reference
                .internal}
            -   [3.3. Quantum
                Containers](../../specification/cudaq/types.html#quantum-containers){.reference
                .internal}
        -   [4. Quantum
            Operators](../../specification/cudaq/operators.html){.reference
            .internal}
            -   [4.1. [`cudaq::spin_op`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/operators.html#cudaq-spin-op){.reference
                .internal}
        -   [5. Quantum
            Operations](../../specification/cudaq/operations.html){.reference
            .internal}
            -   [5.1. Operations on [`cudaq::qubit`{.code .docutils
                .literal
                .notranslate}]{.pre}](../../specification/cudaq/operations.html#operations-on-cudaq-qubit){.reference
                .internal}
        -   [6. Quantum
            Kernels](../../specification/cudaq/kernels.html){.reference
            .internal}
        -   [7. Sub-circuit
            Synthesis](../../specification/cudaq/synthesis.html){.reference
            .internal}
        -   [8. Control
            Flow](../../specification/cudaq/control_flow.html){.reference
            .internal}
        -   [9. Just-in-Time Kernel
            Creation](../../specification/cudaq/dynamic_kernels.html){.reference
            .internal}
        -   [10. Quantum
            Patterns](../../specification/cudaq/patterns.html){.reference
            .internal}
            -   [10.1.
                Compute-Action-Uncompute](../../specification/cudaq/patterns.html#compute-action-uncompute){.reference
                .internal}
        -   [11.
            Platform](../../specification/cudaq/platform.html){.reference
            .internal}
        -   [12. Algorithmic
            Primitives](../../specification/cudaq/algorithmic_primitives.html){.reference
            .internal}
            -   [12.1. [`cudaq::sample`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/algorithmic_primitives.html#cudaq-sample){.reference
                .internal}
            -   [12.2. [`cudaq::run`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/algorithmic_primitives.html#cudaq-run){.reference
                .internal}
            -   [12.3. [`cudaq::observe`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/algorithmic_primitives.html#cudaq-observe){.reference
                .internal}
            -   [12.4. [`cudaq::optimizer`{.code .docutils .literal
                .notranslate}]{.pre} (deprecated, functionality moved to
                CUDA-Q
                libraries)](../../specification/cudaq/algorithmic_primitives.html#cudaq-optimizer-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
            -   [12.5. [`cudaq::gradient`{.code .docutils .literal
                .notranslate}]{.pre} (deprecated, functionality moved to
                CUDA-Q
                libraries)](../../specification/cudaq/algorithmic_primitives.html#cudaq-gradient-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
        -   [13. Example
            Programs](../../specification/cudaq/examples.html){.reference
            .internal}
            -   [13.1. Hello World - Simple Bell
                State](../../specification/cudaq/examples.html#hello-world-simple-bell-state){.reference
                .internal}
            -   [13.2. GHZ State Preparation and
                Sampling](../../specification/cudaq/examples.html#ghz-state-preparation-and-sampling){.reference
                .internal}
            -   [13.3. Quantum Phase
                Estimation](../../specification/cudaq/examples.html#quantum-phase-estimation){.reference
                .internal}
            -   [13.4. Deuteron Binding Energy Parameter
                Sweep](../../specification/cudaq/examples.html#deuteron-binding-energy-parameter-sweep){.reference
                .internal}
            -   [13.5. Grover's
                Algorithm](../../specification/cudaq/examples.html#grover-s-algorithm){.reference
                .internal}
            -   [13.6. Iterative Phase
                Estimation](../../specification/cudaq/examples.html#iterative-phase-estimation){.reference
                .internal}
    -   [Quake
        Specification](../../specification/quake-dialect.html){.reference
        .internal}
        -   [General
            Introduction](../../specification/quake-dialect.html#general-introduction){.reference
            .internal}
        -   [Motivation](../../specification/quake-dialect.html#motivation){.reference
            .internal}
-   [API Reference](../../api/api.html){.reference .internal}
    -   [C++ API](../../api/languages/cpp_api.html){.reference
        .internal}
        -   [Operators](../../api/languages/cpp_api.html#operators){.reference
            .internal}
        -   [Quantum](../../api/languages/cpp_api.html#quantum){.reference
            .internal}
        -   [Common](../../api/languages/cpp_api.html#common){.reference
            .internal}
        -   [Noise
            Modeling](../../api/languages/cpp_api.html#noise-modeling){.reference
            .internal}
        -   [Kernel
            Builder](../../api/languages/cpp_api.html#kernel-builder){.reference
            .internal}
        -   [Algorithms](../../api/languages/cpp_api.html#algorithms){.reference
            .internal}
        -   [Platform](../../api/languages/cpp_api.html#platform){.reference
            .internal}
        -   [Utilities](../../api/languages/cpp_api.html#utilities){.reference
            .internal}
        -   [Namespaces](../../api/languages/cpp_api.html#namespaces){.reference
            .internal}
    -   [Python API](../../api/languages/python_api.html){.reference
        .internal}
        -   [Program
            Construction](../../api/languages/python_api.html#program-construction){.reference
            .internal}
            -   [[`make_kernel()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.make_kernel){.reference
                .internal}
            -   [[`PyKernel`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.PyKernel){.reference
                .internal}
            -   [[`Kernel`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Kernel){.reference
                .internal}
            -   [[`PyKernelDecorator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.PyKernelDecorator){.reference
                .internal}
            -   [[`kernel()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.kernel){.reference
                .internal}
        -   [Kernel
            Execution](../../api/languages/python_api.html#kernel-execution){.reference
            .internal}
            -   [[`sample()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.sample){.reference
                .internal}
            -   [[`sample_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.sample_async){.reference
                .internal}
            -   [[`run()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.run){.reference
                .internal}
            -   [[`run_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.run_async){.reference
                .internal}
            -   [[`observe()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.observe){.reference
                .internal}
            -   [[`observe_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.observe_async){.reference
                .internal}
            -   [[`get_state()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_state){.reference
                .internal}
            -   [[`get_state_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_state_async){.reference
                .internal}
            -   [[`vqe()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.vqe){.reference
                .internal}
            -   [[`draw()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.draw){.reference
                .internal}
            -   [[`translate()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.translate){.reference
                .internal}
            -   [[`estimate_resources()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.estimate_resources){.reference
                .internal}
        -   [Backend
            Configuration](../../api/languages/python_api.html#backend-configuration){.reference
            .internal}
            -   [[`has_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.has_target){.reference
                .internal}
            -   [[`get_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_target){.reference
                .internal}
            -   [[`get_targets()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_targets){.reference
                .internal}
            -   [[`set_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.set_target){.reference
                .internal}
            -   [[`reset_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.reset_target){.reference
                .internal}
            -   [[`set_noise()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.set_noise){.reference
                .internal}
            -   [[`unset_noise()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.unset_noise){.reference
                .internal}
            -   [[`register_set_target_callback()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.register_set_target_callback){.reference
                .internal}
            -   [[`unregister_set_target_callback()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.unregister_set_target_callback){.reference
                .internal}
            -   [[`cudaq.apply_noise()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.cudaq.apply_noise){.reference
                .internal}
            -   [[`initialize_cudaq()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.initialize_cudaq){.reference
                .internal}
            -   [[`num_available_gpus()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.num_available_gpus){.reference
                .internal}
            -   [[`set_random_seed()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.set_random_seed){.reference
                .internal}
        -   [Dynamics](../../api/languages/python_api.html#dynamics){.reference
            .internal}
            -   [[`evolve()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.evolve){.reference
                .internal}
            -   [[`evolve_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.evolve_async){.reference
                .internal}
            -   [[`Schedule`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Schedule){.reference
                .internal}
            -   [[`BaseIntegrator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.dynamics.integrator.BaseIntegrator){.reference
                .internal}
            -   [[`InitialState`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.dynamics.helpers.InitialState){.reference
                .internal}
            -   [[`InitialStateType`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.InitialStateType){.reference
                .internal}
            -   [[`IntermediateResultSave`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.IntermediateResultSave){.reference
                .internal}
        -   [Operators](../../api/languages/python_api.html#operators){.reference
            .internal}
            -   [[`OperatorSum`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.OperatorSum){.reference
                .internal}
            -   [[`ProductOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.ProductOperator){.reference
                .internal}
            -   [[`ElementaryOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.ElementaryOperator){.reference
                .internal}
            -   [[`ScalarOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.ScalarOperator){.reference
                .internal}
            -   [[`RydbergHamiltonian`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.RydbergHamiltonian){.reference
                .internal}
            -   [[`SuperOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.SuperOperator){.reference
                .internal}
            -   [[`operators.define()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.define){.reference
                .internal}
            -   [[`operators.instantiate()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.instantiate){.reference
                .internal}
            -   [Spin
                Operators](../../api/languages/python_api.html#spin-operators){.reference
                .internal}
            -   [Fermion
                Operators](../../api/languages/python_api.html#fermion-operators){.reference
                .internal}
            -   [Boson
                Operators](../../api/languages/python_api.html#boson-operators){.reference
                .internal}
            -   [General
                Operators](../../api/languages/python_api.html#general-operators){.reference
                .internal}
        -   [Data
            Types](../../api/languages/python_api.html#data-types){.reference
            .internal}
            -   [[`SimulationPrecision`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.SimulationPrecision){.reference
                .internal}
            -   [[`Target`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Target){.reference
                .internal}
            -   [[`State`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.State){.reference
                .internal}
            -   [[`Tensor`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Tensor){.reference
                .internal}
            -   [[`QuakeValue`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.QuakeValue){.reference
                .internal}
            -   [[`qubit`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.qubit){.reference
                .internal}
            -   [[`qreg`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.qreg){.reference
                .internal}
            -   [[`qvector`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.qvector){.reference
                .internal}
            -   [[`ComplexMatrix`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.ComplexMatrix){.reference
                .internal}
            -   [[`SampleResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.SampleResult){.reference
                .internal}
            -   [[`AsyncSampleResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncSampleResult){.reference
                .internal}
            -   [[`ObserveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.ObserveResult){.reference
                .internal}
            -   [[`AsyncObserveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncObserveResult){.reference
                .internal}
            -   [[`AsyncStateResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncStateResult){.reference
                .internal}
            -   [[`OptimizationResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.OptimizationResult){.reference
                .internal}
            -   [[`EvolveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.EvolveResult){.reference
                .internal}
            -   [[`AsyncEvolveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncEvolveResult){.reference
                .internal}
            -   [[`Resources`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Resources){.reference
                .internal}
            -   [Optimizers](../../api/languages/python_api.html#optimizers){.reference
                .internal}
            -   [Gradients](../../api/languages/python_api.html#gradients){.reference
                .internal}
            -   [Noisy
                Simulation](../../api/languages/python_api.html#noisy-simulation){.reference
                .internal}
        -   [MPI
            Submodule](../../api/languages/python_api.html#mpi-submodule){.reference
            .internal}
            -   [[`initialize()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.initialize){.reference
                .internal}
            -   [[`rank()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.rank){.reference
                .internal}
            -   [[`num_ranks()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.num_ranks){.reference
                .internal}
            -   [[`all_gather()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.all_gather){.reference
                .internal}
            -   [[`broadcast()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.broadcast){.reference
                .internal}
            -   [[`is_initialized()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.is_initialized){.reference
                .internal}
            -   [[`finalize()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.finalize){.reference
                .internal}
        -   [ORCA
            Submodule](../../api/languages/python_api.html#orca-submodule){.reference
            .internal}
            -   [[`sample()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.orca.sample){.reference
                .internal}
    -   [Quantum Operations](../../api/default_ops.html){.reference
        .internal}
        -   [Unitary Operations on
            Qubits](../../api/default_ops.html#unitary-operations-on-qubits){.reference
            .internal}
            -   [[`x`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#x){.reference
                .internal}
            -   [[`y`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#y){.reference
                .internal}
            -   [[`z`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#z){.reference
                .internal}
            -   [[`h`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#h){.reference
                .internal}
            -   [[`r1`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#r1){.reference
                .internal}
            -   [[`rx`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#rx){.reference
                .internal}
            -   [[`ry`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#ry){.reference
                .internal}
            -   [[`rz`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#rz){.reference
                .internal}
            -   [[`s`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#s){.reference
                .internal}
            -   [[`t`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#t){.reference
                .internal}
            -   [[`swap`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#swap){.reference
                .internal}
            -   [[`u3`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#u3){.reference
                .internal}
        -   [Adjoint and Controlled
            Operations](../../api/default_ops.html#adjoint-and-controlled-operations){.reference
            .internal}
        -   [Measurements on
            Qubits](../../api/default_ops.html#measurements-on-qubits){.reference
            .internal}
            -   [[`mz`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#mz){.reference
                .internal}
            -   [[`mx`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#mx){.reference
                .internal}
            -   [[`my`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#my){.reference
                .internal}
        -   [User-Defined Custom
            Operations](../../api/default_ops.html#user-defined-custom-operations){.reference
            .internal}
        -   [Photonic Operations on
            Qudits](../../api/default_ops.html#photonic-operations-on-qudits){.reference
            .internal}
            -   [[`create`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#create){.reference
                .internal}
            -   [[`annihilate`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#annihilate){.reference
                .internal}
            -   [[`phase_shift`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#phase-shift){.reference
                .internal}
            -   [[`beam_splitter`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#beam-splitter){.reference
                .internal}
            -   [[`mz`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#id1){.reference
                .internal}
-   [Other Versions](../../versions.html){.reference .internal}
:::
:::

::: {.section .wy-nav-content-wrap toggle="wy-nav-shift"}
[NVIDIA CUDA-Q](../../index.html)

::: wy-nav-content
::: rst-content
::: {role="navigation" aria-label="Page navigation"}
-   [](../../index.html){.icon .icon-home aria-label="Home"}
-   [CUDA-Q Applications](../../using/applications.html)
-   Anderson Impurity Model ground state solver on Infleqtion's Sqale
-   

::: {.rst-breadcrumbs-buttons role="navigation" aria-label="Sequential page navigation"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](hadamard_test.html "Using the Hadamard Test to Determine Quantum Krylov Subspace Decomposition Matrix Elements"){.btn
.btn-neutral .float-left accesskey="p"} [Next []{.fa
.fa-arrow-circle-right
aria-hidden="true"}](hamiltonian_simulation.html "Spin-Hamiltonian Simulation Using CUDA-Q"){.btn
.btn-neutral .float-right accesskey="n"}
:::

------------------------------------------------------------------------
:::

::: {.document role="main" itemscope="itemscope" itemtype="http://schema.org/Article"}
::: {itemprop="articleBody"}
::: {#Anderson-Impurity-Model-ground-state-solver-on-Infleqtion's-Sqale .section}
# Anderson Impurity Model ground state solver on Infleqtion's Sqale[Â¶](#Anderson-Impurity-Model-ground-state-solver-on-Infleqtion's-Sqale "Permalink to this heading"){.headerlink}

Ground state quantum chemistry---computing total energies of molecular
configurations to within chemical accuracy---is perhaps the most
highly-touted industrial application of fault-tolerant quantum
computers. Strongly correlated materials, for example, are particularly
interesting, and tools like dynamical mean-field theory (DMFT) allow one
to account for the effect of their strong, localized electronic
correlations. These DMFT models help predict material properties by
approximating the system as a single site impurity inside a "bath" that
encompasses the rest of the system. Simulating such dynamics can be a
tough task using classical methods, but can be done efficiently on a
quantum computer via quantum simulation.

In this notebook, we showcase a workflow for preparing the ground state
of the minimal single-impurity Anderson model (SIAM) using the
Hamiltonian Variational Ansatz for a range of realistic parameters. As a
first step towards running DMFT on a fault-tolerant quantum computer, we
will use logical qubits encoded in the [`[[4,`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal .notranslate}[`2,`{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`2]]`{.docutils .literal .notranslate}]{.pre} code. Using
this workflow, we will obtain the ground state energy estimates via
noisy simulation, and then also execute the corresponding optimized
circuits on Infleqtion's gate-based neutral-atom quantum computer,
making the benefits of logical qubits apparent. More details can be
found in our [paper](https://arxiv.org/abs/2412.07670){.reference
.external}.

This demo notebook uses CUDA-Q ([`cudaq`{.docutils .literal
.notranslate}]{.pre}) and a CUDA-QX library, [`cudaq-solvers`{.docutils
.literal .notranslate}]{.pre}; let us first begin by importing (and
installing as needed) these packages:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [1]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    try:
        import cudaq_solvers as solvers
        import cudaq
        import matplotlib.pyplot as plt
    except ImportError:
        print("Installing required packages...")
        %pip install --quiet 'cudaq-solvers' 'matplotlib'
        print("Installed `cudaq`, `cudaq-solvers`, and `matplotlib` packages.")
        print("You may need to restart the kernel to import newly installed packages.")
        import cudaq_solvers as solvers
        import cudaq
        import matplotlib.pyplot as plt

    from collections.abc import Mapping, Sequence
    import numpy as np
    from scipy.optimize import minimize
    import os
:::
:::
:::

::: {#Performing-logical-Variational-Quantum-Eigensolver-(VQE)-with-CUDA-QX .section}
## Performing logical Variational Quantum Eigensolver (VQE) with CUDA-QX[Â¶](#Performing-logical-Variational-Quantum-Eigensolver-(VQE)-with-CUDA-QX "Permalink to this heading"){.headerlink}

To prepare our ground state quantum Anderson impurity model circuits
(referred to as AIM circuits in this notebook for short), we use VQE to
train an ansatz to minimize a Hamiltonian and obtain optimal angles that
can be used to set the AIM circuits. As described in our
[paper](https://arxiv.org/abs/2412.07670){.reference .external}, the
associated restricted Hamiltonian for our SIAM can be reduced to,

::: {.math .notranslate .nohighlight}
\\\[\\begin{equation} H\_{(U, V)} = U (Z_0 Z_2 - 1) / 4 + V (X_0 + X_2),
\\end{equation}\\\]
:::

where [\\(U\\)]{.math .notranslate .nohighlight} is the Coulomb
interaction and [\\(V\\)]{.math .notranslate .nohighlight} the
hybridization strength. In this notebook workflow, we will optimize over
a 2-dimensional grid of Hamiltonian parameter values, namely [\\(U\\in
\\{1, 5, 9\\}\\)]{.math .notranslate .nohighlight} and [\\(V\\in \\{-9,
-1, 7\\}\\)]{.math .notranslate .nohighlight} (with all values assumed
to be in units of eV), to ensure that the ansatz is generally trainable
and expressive, and obtain 9 different circuit layers identified by the
key [\\((U, V)\\)]{.math .notranslate .nohighlight}. We will simulate
the VQE on GPU (or optionally on CPU if you do not have GPU access),
enabled by CUDA-Q, in the absence of noise:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [2]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    if cudaq.num_available_gpus() == 0:
        cudaq.set_target("qpp-cpu", option="fp64")
    else:
        cudaq.set_target("nvidia", option="fp64")
:::
:::
:::

This workflow can be easily defined in CUDA-Q as shown in the cell
below, using the CUDA-QX Solvers library (which accelerates quantum
algorithms like the VQE):

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [3]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    def ansatz(n_qubits: int) -> cudaq.Kernel:
        # Create a CUDA-Q parameterized kernel
        paramterized_ansatz, variational_angles = cudaq.make_kernel(list)
        qubits = paramterized_ansatz.qalloc(n_qubits)

        # Using |+> as the initial state:
        paramterized_ansatz.h(qubits[0])
        paramterized_ansatz.cx(qubits[0], qubits[1])

        paramterized_ansatz.rx(variational_angles[0], qubits[0])
        paramterized_ansatz.cx(qubits[0], qubits[1])
        paramterized_ansatz.rz(variational_angles[1], qubits[1])
        paramterized_ansatz.cx(qubits[0], qubits[1])
        return paramterized_ansatz


    def run_logical_vqe(cudaq_hamiltonian: cudaq.SpinOperator) -> tuple[float, list[float]]:
        # Set seed for easier reproduction
        np.random.seed(42)

        # Initial angles for the optimizer
        init_angles = np.random.random(2) * 1e-1

        # Obtain CUDA-Q Ansatz
        num_qubits = cudaq_hamiltonian.get_qubit_count()
        variational_kernel = ansatz(num_qubits)

        # Perform VQE optimization
        energy, params, _ = solvers.vqe(
            variational_kernel,
            cudaq_hamiltonian,
            init_angles,
            optimizer=minimize,
            method="SLSQP",
            tol=1e-10,
        )
        return energy, params
:::
:::
:::
:::

::: {#Constructing-circuits-in-the-[[4,2,2]]-encoding .section}
## Constructing circuits in the [`[[4,2,2]]`{.docutils .literal .notranslate}]{.pre} encoding[Â¶](#Constructing-circuits-in-the-%5B%5B4,2,2%5D%5D-encoding "Permalink to this heading"){.headerlink}

The [`[[4,2,2]]`{.docutils .literal .notranslate}]{.pre} code is a
quantum error detection code that uses four physical qubits to encode
two logical qubits. In this notebook, we will construct two variants of
quantum circuits: physical (bare, unencoded) and logical (encoded).
These circuits will be informed by the Hamiltonian Variational Ansatz
described earlier. To measure all the terms in our Hamiltonian, we will
measure the data qubits in both the [\\(Z\\)]{.math .notranslate
.nohighlight}- and [\\(X\\)]{.math .notranslate .nohighlight}-basis, as
allowed by the [`[[4,2,2]]`{.docutils .literal .notranslate}]{.pre}
logical gateset. Full details on the circuit constructions are outlined
in our [paper](https://arxiv.org/abs/2412.07670){.reference .external}.

Below, we create functions to build our CUDA-Q AIM circuits, both
physical and logical versions. As we consider noisy simulation in this
notebook, we will include some noisy gates. Here, for simplicity, we
will just register a custom identity gate -- to be later used as a noisy
operation to model readout error:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [4]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    cudaq.register_operation("meas_id", np.identity(2))
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [5]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    def aim_physical_circuit(
        angles: list[float], basis: str, *, ignore_meas_id: bool = False
    ) -> cudaq.Kernel:
        kernel = cudaq.make_kernel()
        qubits = kernel.qalloc(2)

        # Bell state prep
        kernel.h(qubits[0])
        kernel.cx(qubits[0], qubits[1])

        # Rx Gate
        kernel.rx(angles[0], qubits[0])

        # ZZ rotation
        kernel.cx(qubits[0], qubits[1])
        kernel.rz(angles[1], qubits[1])
        kernel.cx(qubits[0], qubits[1])

        if basis == "z_basis":
            if not ignore_meas_id:
                kernel.for_loop(
                    start=0, stop=2, function=lambda q_idx: getattr(kernel, "meas_id")(qubits[q_idx])
                )
            kernel.mz(qubits)
        elif basis == "x_basis":
            kernel.h(qubits)
            if not ignore_meas_id:
                kernel.for_loop(
                    start=0, stop=2, function=lambda q_idx: getattr(kernel, "meas_id")(qubits[q_idx])
                )
            kernel.mz(qubits)
        else:
            raise ValueError("Unsupported basis provided:", basis)
        return kernel
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [6]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    def aim_logical_circuit(
        angles: list[float], basis: str, *, ignore_meas_id: bool = False
    ) -> cudaq.Kernel:
        kernel = cudaq.make_kernel()
        qubits = kernel.qalloc(6)

        kernel.for_loop(start=0, stop=3, function=lambda idx: kernel.h(qubits[idx]))
        kernel.cx(qubits[1], qubits[4])
        kernel.cx(qubits[2], qubits[3])
        kernel.cx(qubits[0], qubits[1])
        kernel.cx(qubits[0], qubits[3])

        # Rx teleportation
        kernel.rx(angles[0], qubits[0])

        kernel.cx(qubits[0], qubits[1])
        kernel.cx(qubits[0], qubits[3])
        kernel.h(qubits[0])

        if basis == "z_basis":
            if not ignore_meas_id:
                kernel.for_loop(
                    start=0, stop=5, function=lambda idx: getattr(kernel, "meas_id")(qubits[idx])
                )
            kernel.mz(qubits)
        elif basis == "x_basis":
            # ZZ rotation and teleportation
            kernel.cx(qubits[3], qubits[5])
            kernel.cx(qubits[2], qubits[5])
            kernel.rz(angles[1], qubits[5])
            kernel.cx(qubits[1], qubits[5])
            kernel.cx(qubits[4], qubits[5])
            kernel.for_loop(start=1, stop=5, function=lambda idx: kernel.h(qubits[idx]))
            if not ignore_meas_id:
                kernel.for_loop(
                    start=0, stop=6, function=lambda idx: getattr(kernel, "meas_id")(qubits[idx])
                )
            kernel.mz(qubits)
        else:
            raise ValueError("Unsupported basis provided:", basis)
        return kernel
:::
:::
:::

With the circuit definitions above, we can now define a function that
automatically runs the VQE and constructs a dictionary containing all
the AIM circuits we want to submit to hardware (or noisily simulate):

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [7]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    def generate_circuit_set(ignore_meas_id: bool = False) -> object:
        u_vals = [1, 5, 9]
        v_vals = [-9, -1, 7]
        circuit_dict = {}
        for u in u_vals:
            for v in v_vals:
                qubit_hamiltonian = (
                    0.25 * u * cudaq.spin.z(0) * cudaq.spin.z(1)
                    - 0.25 * u
                    + v * cudaq.spin.x(0)
                    + v * cudaq.spin.x(1)
                )
                _, opt_params = run_logical_vqe(qubit_hamiltonian)
                angles = [float(angle) for angle in opt_params]
                print(f"Computed optimal angles={angles} for U={u}, V={v}")

                tmp_physical_dict = {}
                tmp_logical_dict = {}
                for basis in ("z_basis", "x_basis"):
                    tmp_physical_dict[basis] = aim_physical_circuit(
                        angles, basis, ignore_meas_id=ignore_meas_id
                    )
                    tmp_logical_dict[basis] = aim_logical_circuit(
                        angles, basis, ignore_meas_id=ignore_meas_id
                    )

                circuit_dict[f"{u}:{v}"] = {
                    "physical": tmp_physical_dict,
                    "logical": tmp_logical_dict,
                }
        print("\nFinished building optimized circuits!")
        return circuit_dict
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [8]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    sim_circuit_dict = generate_circuit_set()
    circuit_layers = sim_circuit_dict.keys()
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Computed optimal angles=[1.5846845738799267, 1.5707961678256028] for U=1, V=-9
    Computed optimal angles=[4.588033710930825, 4.712388365176642] for U=1, V=-1
    Computed optimal angles=[-1.588651490745171, 1.5707962742876598] for U=1, V=7
    Computed optimal angles=[1.64012940802256, 1.5707963354922125] for U=5, V=-9
    Computed optimal angles=[2.1293956916868737, 1.5707963294715355] for U=5, V=-1
    Computed optimal angles=[-1.6598458659836037, 1.570796331040382] for U=5, V=7
    Computed optimal angles=[1.695151467539617, 1.5707960973500679] for U=9, V=-9
    Computed optimal angles=[2.4149519241823376, 1.5707928509325972] for U=9, V=-1
    Computed optimal angles=[-1.7301462729177735, 1.570796033796985] for U=9, V=7

    Finished building optimized circuits!
:::
:::
:::
:::

::: {#Setting-up-submission-and-decoding-workflow .section}
## Setting up submission and decoding workflow[Â¶](#Setting-up-submission-and-decoding-workflow "Permalink to this heading"){.headerlink}

In this section, we define various helper functions that will play a
role in generating the associated energies of the AIM circuits based on
the circuit samples (in the different bases), as well as decode the
logical circuits with post-selection informed by the
[`[[4,2,2]]`{.docutils .literal .notranslate}]{.pre} code:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [9]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    def _num_qubits(counts: Mapping[str, float]) -> int:
        for key in counts:
            if key.isdecimal():
                return len(key)
        return 0


    def process_counts(
        counts: Mapping[str, float],
        data_qubits: Sequence[int],
        flag_qubits: Sequence[int] = (),
    ) -> dict[str, float]:
        new_data: dict[str, float] = {}
        for key, val in counts.items():
            if not all(key[i] == "0" for i in flag_qubits):
                continue

            new_key = "".join(key[i] for i in data_qubits)

            if not set("01").issuperset(new_key):
                continue

            new_data.setdefault(new_key, 0)
            new_data[new_key] += val

        return new_data


    def decode(counts: Mapping[str, float]) -> dict[str, float]:
        """Decode physical counts into logical counts. Should be called after `process_counts`."""

        if not counts:
            return {}

        num_qubits = _num_qubits(counts)
        assert num_qubits % 4 == 0

        physical_to_logical = {
            "0000": "00",
            "1111": "00",
            "0011": "01",
            "1100": "01",
            "0101": "10",
            "1010": "10",
            "0110": "11",
            "1001": "11",
        }

        new_data: dict[str, float] = {}
        for key, val in counts.items():
            physical_keys = [key[i : i + 4] for i in range(0, num_qubits, 4)]
            logical_keys = [physical_to_logical.get(physical_key) for physical_key in physical_keys]
            if None not in logical_keys:
                new_key = "".join(logical_keys)
                new_data.setdefault(new_key, 0)
                new_data[new_key] += val

        return new_data


    def ev_x(counts: Mapping[str, float]) -> float:
        ev = 0.0

        for k, val in counts.items():
            ev += val * ((-1) ** int(k[0]) + (-1) ** int(k[1]))

        total = sum(counts.values())
        ev /= total
        return ev


    def ev_xx(counts: Mapping[str, float]) -> float:
        ev = 0.0

        for k, val in counts.items():
            ev += val * (-1) ** k.count("1")

        total = sum(counts.values())
        ev /= total
        return ev


    def ev_zz(counts: Mapping[str, float]) -> float:
        ev = 0.0

        for k, val in counts.items():
            ev += val * (-1) ** k.count("1")

        total = sum(counts.values())
        ev /= total
        return ev


    def aim_logical_energies(
        data_ordering: object, counts_list: Sequence[dict[str, float]]
    ) -> tuple[dict[tuple[int, int], float], dict[tuple[int, int], float]]:
        counts_data = {
            data_ordering[i]: decode(
                process_counts(
                    counts,
                    data_qubits=[1, 2, 3, 4],
                    flag_qubits=[0, 5],
                )
            )
            for i, counts in enumerate(counts_list)
        }
        return _aim_energies(counts_data)


    def aim_physical_energies(
        data_ordering: object, counts_list: Sequence[dict[str, float]]
    ) -> tuple[dict[tuple[int, int], float], dict[tuple[int, int], float]]:
        counts_data = {
            data_ordering[i]: process_counts(
                counts,
                data_qubits=[0, 1],
            )
            for i, counts in enumerate(counts_list)
        }
        return _aim_energies(counts_data)


    def _aim_energies(
        counts_data: Mapping[tuple[int, int, str], dict[str, float]],
    ) -> tuple[dict[tuple[int, int], float], dict[tuple[int, int], float]]:
        evxs: dict[tuple[int, int], float] = {}
        evxxs: dict[tuple[int, int], float] = {}
        evzzs: dict[tuple[int, int], float] = {}
        totals: dict[tuple[int, int], float] = {}

        for key, counts in counts_data.items():
            h_params, basis = key
            key_a, key_b = h_params.split(":")
            u, v = int(key_a), int(key_b)
            if basis.startswith("x"):
                evxs[u, v] = ev_x(counts)
                evxxs[u, v] = ev_xx(counts)
            else:
                evzzs[u, v] = ev_zz(counts)

            totals.setdefault((u, v), 0)
            totals[u, v] += sum(counts.values())

        energies = {}
        uncertainties = {}
        for u, v in evxs.keys() & evzzs.keys():
            string_key = f"{u}:{v}"
            energies[string_key] = u * (evzzs[u, v] - 1) / 4 + v * evxs[u, v]

            uncertainty_xx = 2 * v**2 * (1 + evxxs[u, v]) - u * v * evxs[u, v] / 2
            uncertainty_zz = u**2 * (1 - evzzs[u, v]) / 2

            uncertainties[string_key] = np.sqrt(
                (uncertainty_zz + uncertainty_xx - energies[string_key] ** 2) / (totals[u, v] / 2)
            )

        return energies, uncertainties


    def _get_energy_diff(
        bf_energies: dict[str, float],
        physical_energies: dict[str, float],
        logical_energies: dict[str, float],
    ) -> tuple[list[float], list[float]]:
        physical_energy_diff = []
        logical_energy_diff = []

        # Data ordering following `bf_energies` keys
        for layer in bf_energies.keys():
            physical_sim_energy = physical_energies[layer]
            logical_sim_energy = logical_energies[layer]
            true_energy = bf_energies[layer]
            u, v = layer.split(":")
            print(f"Layer=({u}, {v}) has brute-force energy of: {true_energy}")
            print(f"Physical circuit of layer=({u}, {v}) got an energy of: {physical_sim_energy}")
            print(f"Logical circuit of layer=({u}, {v}) got an energy of: {logical_sim_energy}")
            print("-" * 72)

            if logical_sim_energy < physical_sim_energy:
                print("Logical circuit achieved the lower energy!")
            else:
                print("Physical circuit achieved the lower energy")
            print("-" * 72, "\n")

            physical_energy_diff.append(
                -1 * (true_energy - physical_sim_energy)
            )  # Multiply by -1 since negative energies
            logical_energy_diff.append(-1 * (true_energy - logical_sim_energy))
        return physical_energy_diff, logical_energy_diff
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [10]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    def submit_aim_circuits(
        circuit_dict: object,
        *,
        folder_path: str = "future_aim_results",
        shots_count: int = 1000,
        noise_model: cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.NoiseModel | None = None,
        run_async: bool = False,
    ) -> dict[str, list[dict[str, int]]] | None:
        if run_async:
            os.makedirs(folder_path, exist_ok=True)
        else:
            aim_results = {"physical": [], "logical": []}

        for layer in circuit_dict.keys():
            if run_async:
                print(f"Posting circuits associated with layer=('{layer}')")
            else:
                print(f"Running circuits associated with layer=('{layer}')")

            for basis in ("z_basis", "x_basis"):
                if run_async:
                    u, v = layer.split(":")

                    tmp_physical_results = cudaq.sample_async(
                        circuit_dict[layer]["physical"][basis], shots_count=shots_count
                    )
                    file = open(f"{folder_path}/physical_{basis}_job_u={u}_v={v}_result.txt", "w")
                    file.write(str(tmp_physical_results))
                    file.close()

                    tmp_logical_results = cudaq.sample_async(
                        circuit_dict[layer]["logical"][basis], shots_count=shots_count
                    )
                    file = open(f"{folder_path}/logical_{basis}_job_u={u}_v={v}_result.txt", "w")
                    file.write(str(tmp_logical_results))
                    file.close()
                else:
                    tmp_physical_results = cudaq.sample(
                        circuit_dict[layer]["physical"][basis],
                        shots_count=shots_count,
                        noise_model=noise_model,
                    )
                    tmp_logical_results = cudaq.sample(
                        circuit_dict[layer]["logical"][basis],
                        shots_count=shots_count,
                        noise_model=noise_model,
                    )
                    aim_results["physical"].append({k: v for k, v in tmp_physical_results.items()})
                    aim_results["logical"].append({k: v for k, v in tmp_logical_results.items()})
        if not run_async:
            print("\nCompleted all circuit sampling!")
            return aim_results
        else:
            print("\nAll circuits submitted for async sampling!")
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [11]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    def _get_async_results(
        layers: object, *, folder_path: str = "future_aim_results"
    ) -> dict[str, list[dict[str, int]]]:
        aim_results = {"physical": [], "logical": []}
        for layer in layers:
            print(f"Retrieving all circuits counts associated with layer=('{layer}')")
            u, v = layer.split(":")
            for basis in ("z_basis", "x_basis"):
                file = open(f"{folder_path}/physical_{basis}_job_u={u}_v={v}_result.txt", "r")
                tmp_physical_results = cudaq.AsyncSampleResult(str(file.read()))
                physical_counts = tmp_physical_results.get()

                file = open(f"{folder_path}/logical_{basis}_job_u={u}_v={v}_result.txt", "r")
                tmp_logical_results = cudaq.AsyncSampleResult(str(file.read()))
                logical_counts = tmp_logical_results.get()

                aim_results["physical"].append({k: v for k, v in physical_counts.items()})
                aim_results["logical"].append({k: v for k, v in logical_counts.items()})

        print("\nObtained all circuit samples!")
        return aim_results
:::
:::
:::
:::

::: {#Running-a-CUDA-Q-noisy-simulation .section}
## Running a CUDA-Q noisy simulation[Â¶](#Running-a-CUDA-Q-noisy-simulation "Permalink to this heading"){.headerlink}

In this section, we will first explore the performance of the physical
and logical circuits under the influence of a device noise model. This
will help us predict experimental results, as well as understand the
dominant error sources at play. Such a simulation can be achieved via
CUDA-Q's density matrix simulator:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [12]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    cudaq.reset_target()
    cudaq.set_target("density-matrix-cpu")
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [13]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    def get_device_noise(
        depolar_prob_1q: float,
        depolar_prob_2q: float,
        *,
        readout_error_prob: float | None = None,
        custom_gates: list[str] | None = None,
    ) -> cudaq.mlir._mlir_libs._quakeDialects.cudaq_runtime.NoiseModel:
        noise = cudaq.NoiseModel()
        depolar_noise = cudaq.DepolarizationChannel(depolar_prob_1q)

        noisy_ops = ["z", "s", "x", "h", "rx", "rz"]
        for op in noisy_ops:
            noise.add_all_qubit_channel(op, depolar_noise)

        if custom_gates:
            custom_depolar_channel = cudaq.DepolarizationChannel(depolar_prob_1q)
            for op in custom_gates:
                noise.add_all_qubit_channel(op, custom_depolar_channel)

        # Two qubit depolarization error
        p_0 = 1 - depolar_prob_2q
        p_1 = np.sqrt((1 - p_0**2) / 3)

        k0 = np.array(
            [[p_0, 0.0, 0.0, 0.0], [0.0, p_0, 0.0, 0.0], [0.0, 0.0, p_0, 0.0], [0.0, 0.0, 0.0, p_0]],
            dtype=np.complex128,
        )
        k1 = np.array(
            [[0.0, 0.0, p_1, 0.0], [0.0, 0.0, 0.0, p_1], [p_1, 0.0, 0.0, 0.0], [0.0, p_1, 0.0, 0.0]],
            dtype=np.complex128,
        )
        k2 = np.array(
            [
                [0.0, 0.0, -1j * p_1, 0.0],
                [0.0, 0.0, 0.0, -1j * p_1],
                [1j * p_1, 0.0, 0.0, 0.0],
                [0.0, 1j * p_1, 0.0, 0.0],
            ],
            dtype=np.complex128,
        )
        k3 = np.array(
            [[p_1, 0.0, 0.0, 0.0], [0.0, p_1, 0.0, 0.0], [0.0, 0.0, -p_1, 0.0], [0.0, 0.0, 0.0, -p_1]],
            dtype=np.complex128,
        )
        kraus_channel = cudaq.KrausChannel([k0, k1, k2, k3])

        noise.add_all_qubit_channel("cz", kraus_channel)
        noise.add_all_qubit_channel("cx", kraus_channel)

        if readout_error_prob is not None:
            # Readout error modeled with a Bit flip channel on identity before measurement
            bit_flip = cudaq.BitFlipChannel(readout_error_prob)
            noise.add_all_qubit_channel("meas_id", bit_flip)
        return noise
:::
:::
:::

Finally, with our example noise model defined above, we can
synchronously & noisily sample all of our AIM circuits by passing
[`noise_model=cudaq_noise_model`{.docutils .literal .notranslate}]{.pre}
to the workflow containing function [`submit_aim_circuits()`{.docutils
.literal .notranslate}]{.pre}:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [14]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    # Example parameters that can model execution on hardware at the high, simulation, level:
    # Take single-qubit gate depolarization rate: ~0.2% or better (fidelity â‰¥99.8%)
    # Take two-qubit gate depolarization rate: ~1â€“2% (fidelity ~98â€“99%)
    cudaq_noise_model = get_device_noise(0.002, 0.02, readout_error_prob=0.02)
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [15]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    aim_sim_data = submit_aim_circuits(sim_circuit_dict, noise_model=cudaq_noise_model)
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Running circuits associated with layer=('1:-9')
    Running circuits associated with layer=('1:-1')
    Running circuits associated with layer=('1:7')
    Running circuits associated with layer=('5:-9')
    Running circuits associated with layer=('5:-1')
    Running circuits associated with layer=('5:7')
    Running circuits associated with layer=('9:-9')
    Running circuits associated with layer=('9:-1')
    Running circuits associated with layer=('9:7')

    Completed all circuit sampling!
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [16]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    data_ordering = []
    for key in circuit_layers:
        for basis in ("z_basis", "x_basis"):
            data_ordering.append((key, basis))
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [17]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    sim_physical_energies, sim_physical_uncertainties = aim_physical_energies(
        data_ordering, aim_sim_data["physical"]
    )
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [18]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    sim_logical_energies, sim_logical_uncertainties = aim_logical_energies(
        data_ordering, aim_sim_data["logical"]
    )
:::
:::
:::

To analyze our simulated energy results in the above cells, we will
compare them to the brute-force computed exact ground state energies for
the AIM Hamiltonian. For simplicity, these are already stored in the
dictionary [`bf_energies`{.docutils .literal .notranslate}]{.pre} below:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [19]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    bf_energies = {
        "1:-9": -18.251736027394713,
        "1:-1": -2.265564437074638,
        "1:7": -14.252231964940428,
        "5:-9": -19.293350575766127,
        "5:-1": -3.608495283014149,
        "5:7": -15.305692796870582,
        "9:-9": -20.39007993367173,
        "9:-1": -5.260398644698076,
        "9:7": -16.429650912487233,
    }
:::
:::
:::

With the above metric, we can assess the performance of the logical
circuits against the physical circuits by considering how far away the
respective energies are from the brute-force expected energies. The cell
below computes these energy deviations:

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [20]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    sim_physical_energy_diff, sim_logical_energy_diff = _get_energy_diff(
        bf_energies, sim_physical_energies, sim_logical_energies
    )
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Layer=(1, -9) has brute-force energy of: -18.251736027394713
    Physical circuit of layer=(1, -9) got an energy of: -15.929
    Logical circuit of layer=(1, -9) got an energy of: -17.46016175277361
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(1, -1) has brute-force energy of: -2.265564437074638
    Physical circuit of layer=(1, -1) got an energy of: -1.97
    Logical circuit of layer=(1, -1) got an energy of: -2.176531948420889
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(1, 7) has brute-force energy of: -14.252231964940428
    Physical circuit of layer=(1, 7) got an energy of: -12.268
    Logical circuit of layer=(1, 7) got an energy of: -13.26321740664324
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(5, -9) has brute-force energy of: -19.293350575766127
    Physical circuit of layer=(5, -9) got an energy of: -16.8495
    Logical circuit of layer=(5, -9) got an energy of: -18.46681284816878
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(5, -1) has brute-force energy of: -3.608495283014149
    Physical circuit of layer=(5, -1) got an energy of: -3.1965000000000003
    Logical circuit of layer=(5, -1) got an energy of: -3.4531715120183297
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(5, 7) has brute-force energy of: -15.305692796870582
    Physical circuit of layer=(5, 7) got an energy of: -13.336
    Logical circuit of layer=(5, 7) got an energy of: -14.341784541550897
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(9, -9) has brute-force energy of: -20.39007993367173
    Physical circuit of layer=(9, -9) got an energy of: -17.802
    Logical circuit of layer=(9, -9) got an energy of: -19.339249509416753
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(9, -1) has brute-force energy of: -5.260398644698076
    Physical circuit of layer=(9, -1) got an energy of: -4.8580000000000005
    Logical circuit of layer=(9, -1) got an energy of: -5.1227150992242025
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(9, 7) has brute-force energy of: -16.429650912487233
    Physical circuit of layer=(9, 7) got an energy of: -14.3635
    Logical circuit of layer=(9, 7) got an energy of: -15.448422736181264
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------
:::
:::
:::

Both physical and logical circuits were subject to the same noise model,
but the [`[[4,2,2]]`{.docutils .literal .notranslate}]{.pre} provides
additional information that can help overcome some errors. Visualizing
the computed energy differences from the above the cell, our noisy
simulation provides a preview of the benefits logical qubits can offer:

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [21]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    fig, ax = plt.subplots(figsize=(11, 7), dpi=200)

    layer_labels = [(int(key.split(":")[0]), int(key.split(":")[1])) for key in bf_energies.keys()]
    plot_labels = [str(item) for item in layer_labels]

    plt.errorbar(
        plot_labels,
        sim_physical_energy_diff,
        yerr=sim_physical_uncertainties.values(),
        ecolor=(20 / 255.0, 26 / 255.0, 94 / 255.0),
        color=(20 / 255.0, 26 / 255.0, 94 / 255.0),
        capsize=4,
        elinewidth=1.5,
        fmt="o",
        markersize=8,
        markeredgewidth=1,
        label="Physical",
    )

    plt.errorbar(
        plot_labels,
        sim_logical_energy_diff,
        yerr=sim_logical_uncertainties.values(),
        color=(0, 177 / 255.0, 152 / 255.0),
        ecolor=(0, 177 / 255.0, 152 / 255.0),
        capsize=4,
        elinewidth=1.5,
        fmt="o",
        markersize=8,
        markeredgewidth=1,
        label="Logical",
    )

    ax.set_xlabel("Hamiltonian Parameters (U, V)", fontsize=18)
    ax.set_ylabel("Energy above true ground state (in eV)", fontsize=18)
    ax.set_title("CUDA-Q AIM Circuits Simulation (lower is better)", fontsize=20)
    ax.legend(loc="upper right", fontsize=18.5)
    plt.xticks(fontsize=16)
    plt.yticks(fontsize=16)

    ax.axhline(y=0, color="black", linestyle="--", linewidth=2)
    plt.ylim(
        top=max(sim_physical_energy_diff) + max(sim_physical_uncertainties.values()) + 0.2, bottom=-0.2
    )
    plt.tight_layout()
    plt.show()
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
![](../../_images/applications_python_logical_aim_sqale_38_0.png)
:::
:::
:::

::: {#Running-logical-AIM-on-Infleqtion's-hardware .section}
## Running logical AIM on Infleqtion's hardware[Â¶](#Running-logical-AIM-on-Infleqtion's-hardware "Permalink to this heading"){.headerlink}

The entire workflow we've seen thus far can be seamlessly executed on
real quantum hardware as well. CUDA-Q has integration with Infleqtion's
gate-based neutral atom quantum computer,
[Sqale](https://arxiv.org/html/2408.08288v2){.reference .external},
allowing execution of CUDA-Q kernels on neutral-atom hardware via
Infleqtion's cross-platform Superstaq compiler API that performs
low-level compilation and optimization under the hood. Indeed, the AIM
research results seen in [our
paper](https://arxiv.org/abs/2412.07670){.reference .external} were
obtained via this complete end-to-end workflow.

To do so, users can obtain a Superstaq API key from
[superstaq.infleqtion.com](https://superstaq.infleqtion.com/){.reference
.external} to gain access to Infleqtion's neutral-atom simulator, with
[pre-registration](https://www.infleqtion.com/sqale-preregistration){.reference
.external} open for access to Infleqtion's neutral atom QPU.

As a tutorial, let us reproduce the workflow we've run so far but on
Infleqtion's QPU. We begin with the same GPU-enhanced VQE to generate
the AIM circuits:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [22]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    cudaq.reset_target()

    if cudaq.num_available_gpus() == 0:
        cudaq.set_target("qpp-cpu", option="fp64")
    else:
        cudaq.set_target("nvidia", option="fp64")
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [23]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    device_circuit_dict = generate_circuit_set(
        ignore_meas_id=True
    )  # Setting `ignore_meas_id=True` drops the noisy-identity gate from earlier
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Computed optimal angles=[1.5846845738799267, 1.5707961678256028] for U=1, V=-9
    Computed optimal angles=[4.588033710930825, 4.712388365176642] for U=1, V=-1
    Computed optimal angles=[-1.588651490745171, 1.5707962742876598] for U=1, V=7
    Computed optimal angles=[1.64012940802256, 1.5707963354922125] for U=5, V=-9
    Computed optimal angles=[2.1293956916868737, 1.5707963294715355] for U=5, V=-1
    Computed optimal angles=[-1.6598458659836037, 1.570796331040382] for U=5, V=7
    Computed optimal angles=[1.695151467539617, 1.5707960973500679] for U=9, V=-9
    Computed optimal angles=[2.4149519241823376, 1.5707928509325972] for U=9, V=-1
    Computed optimal angles=[-1.7301462945564499, 1.570796044872433] for U=9, V=7

    Finished building optimized circuits!
:::
:::
:::

And now, we change backends! Before selecting an Infleqtion machine in
CUDA-Q, we must first set our Superstaq API key, like so:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [24]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    # os.environ['SUPERSTAQ_API_KEY'] = "api_key"
:::
:::
:::

Next, we declare the type of execution we would like on Infleqtion's
machine based on the keyword options specified:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [25]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    cudaq.reset_target()

    # Set the following to run on Infleqtion's Sqale QPU:
    cudaq.set_target("infleqtion", machine="cq_sqale_qpu")

    # Set the following to run an ideal dry-run on Infleqtion's Sqale QPU:
    # cudaq.set_target("infleqtion", machine="cq_sqale_qpu", method="dry-run")

    # Set the following to run a device-realistic noisy simulation of Infleqtion's Sqale QPU:
    # cudaq.set_target("infleqtion", machine="cq_sqale_qpu", method="noise-sim")

    # Set the following to run a local, ideal emulation:
    # cudaq.set_target("infleqtion", emulate=True)
:::
:::
:::

With that, we're all set! That simple change instructs our AIM circuits
to execute on Infleqtion's QPU (or simulator). Due to the general queue
wait time of running on hardware, we optionally recommend enabling the
[`run_async=True`{.docutils .literal .notranslate}]{.pre} flag to
asynchronously sample the circuits. This will allow the cell to be
executed and not wait synchronously until all the jobs are complete,
allowing other classical code to be run in the meantime. When using
[`run_async`{.docutils .literal .notranslate}]{.pre}, an optional
directory to store the job information can be specified with
[`folder_path`{.docutils .literal .notranslate}]{.pre} (this will be
important to later retrieve the job results from the same directory)

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [26]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    submit_aim_circuits(
        device_circuit_dict, folder_path="hardware_aim_future_results", shots_count=1000, run_async=True
    )
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Posting circuits associated with layer=('1:-9')
    Posting circuits associated with layer=('1:-1')
    Posting circuits associated with layer=('1:7')
    Posting circuits associated with layer=('5:-9')
    Posting circuits associated with layer=('5:-1')
    Posting circuits associated with layer=('5:7')
    Posting circuits associated with layer=('9:-9')
    Posting circuits associated with layer=('9:-1')
    Posting circuits associated with layer=('9:7')

    All circuits submitted for async sampling!
:::
:::
:::

With the above cell execution, all the circuits will post to execute on
QPU. We can then return at a later time to retrieve the job results with
the cell below:

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [27]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    aim_device_data = _get_async_results(circuit_layers, folder_path="hardware_aim_future_results")
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Retrieving all circuits counts associated with layer=('1:-9')
    Retrieving all circuits counts associated with layer=('1:-1')
    Retrieving all circuits counts associated with layer=('1:7')
    Retrieving all circuits counts associated with layer=('5:-9')
    Retrieving all circuits counts associated with layer=('5:-1')
    Retrieving all circuits counts associated with layer=('5:7')
    Retrieving all circuits counts associated with layer=('9:-9')
    Retrieving all circuits counts associated with layer=('9:-1')
    Retrieving all circuits counts associated with layer=('9:7')

    Obtained all circuit samples!
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [28]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    physical_energies, physical_uncertainties = aim_physical_energies(
        data_ordering, aim_device_data["physical"]
    )
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [29]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    logical_energies, logical_uncertainties = aim_logical_energies(
        data_ordering, aim_device_data["logical"]
    )
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [30]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    physical_energy_diff, logical_energy_diff = _get_energy_diff(
        bf_energies, physical_energies, logical_energies
    )
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Layer=(1, -9) has brute-force energy of: -18.251736027394713
    Physical circuit of layer=(1, -9) got an energy of: -17.626499999999997
    Logical circuit of layer=(1, -9) got an energy of: -17.69666562801761
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(1, -1) has brute-force energy of: -2.265564437074638
    Physical circuit of layer=(1, -1) got an energy of: -2.1415
    Logical circuit of layer=(1, -1) got an energy of: -2.2032104443266585
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(1, 7) has brute-force energy of: -14.252231964940428
    Physical circuit of layer=(1, 7) got an energy of: -12.9955
    Logical circuit of layer=(1, 7) got an energy of: -13.76919450035401
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(5, -9) has brute-force energy of: -19.293350575766127
    Physical circuit of layer=(5, -9) got an energy of: -18.331
    Logical circuit of layer=(5, -9) got an energy of: -18.85730052910377
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(5, -1) has brute-force energy of: -3.608495283014149
    Physical circuit of layer=(5, -1) got an energy of: -3.476
    Logical circuit of layer=(5, -1) got an energy of: -3.5425689231532203
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(5, 7) has brute-force energy of: -15.305692796870582
    Physical circuit of layer=(5, 7) got an energy of: -14.043500000000002
    Logical circuit of layer=(5, 7) got an energy of: -14.795918428433312
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(9, -9) has brute-force energy of: -20.39007993367173
    Physical circuit of layer=(9, -9) got an energy of: -19.4715
    Logical circuit of layer=(9, -9) got an energy of: -19.96524696701215
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(9, -1) has brute-force energy of: -5.260398644698076
    Physical circuit of layer=(9, -1) got an energy of: -4.973
    Logical circuit of layer=(9, -1) got an energy of: -5.207315773582224
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------

    Layer=(9, 7) has brute-force energy of: -16.429650912487233
    Physical circuit of layer=(9, 7) got an energy of: -15.182
    Logical circuit of layer=(9, 7) got an energy of: -16.241375689575516
    ------------------------------------------------------------------------
    Logical circuit achieved the lower energy!
    ------------------------------------------------------------------------
:::
:::
:::

As before, we use the same metric of comparing against the true ground
state energies; however, this time, both the physical and logical
circuits are fully exposed to real hardware noise. Yet, we expect the
use of logical qubits afforded to us by the [`[[4,2,2]]`{.docutils
.literal .notranslate}]{.pre} code to achieve energies closer to the
true ground state than the bare physical circuits (up to a certain error
threshold). And indeed they do! Visually, we can plot the energy
deviations of both the physical and logical circuits from the cell above
and observe that the logical circuits are able to outperform the
physical circuits by obtaining much lower energies, demonstrating the
power of error detection and the beginning possibilities of
fault-tolerant quantum computation:

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [31]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: highlight
    fig, ax = plt.subplots(figsize=(11, 7), dpi=200)

    plt.errorbar(
        plot_labels,
        physical_energy_diff,
        yerr=physical_uncertainties.values(),
        ecolor=(20 / 255.0, 26 / 255.0, 94 / 255.0),
        color=(20 / 255.0, 26 / 255.0, 94 / 255.0),
        capsize=4,
        elinewidth=1.5,
        fmt="o",
        markersize=8,
        markeredgewidth=1,
        label="Physical",
    )
    plt.errorbar(
        plot_labels,
        logical_energy_diff,
        yerr=logical_uncertainties.values(),
        color=(0, 177 / 255.0, 152 / 255.0),
        ecolor=(0, 177 / 255.0, 152 / 255.0),
        capsize=4,
        elinewidth=1.5,
        fmt="o",
        markersize=8,
        markeredgewidth=1,
        label="Logical",
    )

    ax.set_xlabel("Hamiltonian Parameters (U, V)", fontsize=18)
    ax.set_ylabel("Energy above true ground state (in eV)", fontsize=18)
    ax.set_title("CUDA-Q AIM Infleqtion Hardware Execution (lower is better)", fontsize=20)
    ax.legend(loc="upper left", fontsize=18.5)
    plt.xticks(fontsize=16)
    plt.yticks(fontsize=16)

    ax.axhline(y=0, color="black", linestyle="--", linewidth=2)
    plt.ylim(top=max(physical_energy_diff) + max(physical_uncertainties.values()) + 0.2, bottom=-0.2)
    plt.tight_layout()
    plt.show()
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
![](../../_images/applications_python_logical_aim_sqale_56_0.png)
:::
:::
:::
:::
:::
:::

::: {.rst-footer-buttons role="navigation" aria-label="Footer"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](hadamard_test.html "Using the Hadamard Test to Determine Quantum Krylov Subspace Decomposition Matrix Elements"){.btn
.btn-neutral .float-left accesskey="p" rel="prev"} [Next []{.fa
.fa-arrow-circle-right
aria-hidden="true"}](hamiltonian_simulation.html "Spin-Hamiltonian Simulation Using CUDA-Q"){.btn
.btn-neutral .float-right accesskey="n" rel="next"}
:::

------------------------------------------------------------------------

::: {role="contentinfo"}
Â© Copyright 2025, NVIDIA Corporation & Affiliates.
:::

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme) provided by
[Read the Docs](https://readthedocs.org).
:::
:::
:::
:::
