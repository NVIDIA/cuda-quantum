::: wy-grid-for-nav
::: wy-side-scroll
::: {.wy-side-nav-search style="background: #76b900"}
[NVIDIA CUDA-Q](../../index.html){.icon .icon-home}

::: version
pr-3470
:::

::: {role="search"}
:::
:::

::: {.wy-menu .wy-menu-vertical spy="affix" role="navigation" aria-label="Navigation menu"}
[Contents]{.caption-text}

-   [Quick Start](../../using/quick_start.html){.reference .internal}
    -   [Install
        CUDA-Q](../../using/quick_start.html#install-cuda-q){.reference
        .internal}
    -   [Validate your
        Installation](../../using/quick_start.html#validate-your-installation){.reference
        .internal}
    -   [CUDA-Q
        Academic](../../using/quick_start.html#cuda-q-academic){.reference
        .internal}
-   [Basics](../../using/basics/basics.html){.reference .internal}
    -   [What is a CUDA-Q
        Kernel?](../../using/basics/kernel_intro.html){.reference
        .internal}
    -   [Building your first CUDA-Q
        Program](../../using/basics/build_kernel.html){.reference
        .internal}
    -   [Running your first CUDA-Q
        Program](../../using/basics/run_kernel.html){.reference
        .internal}
        -   [Sample](../../using/basics/run_kernel.html#sample){.reference
            .internal}
        -   [Run](../../using/basics/run_kernel.html#run){.reference
            .internal}
        -   [Observe](../../using/basics/run_kernel.html#observe){.reference
            .internal}
        -   [Running on a
            GPU](../../using/basics/run_kernel.html#running-on-a-gpu){.reference
            .internal}
    -   [Troubleshooting](../../using/basics/troubleshooting.html){.reference
        .internal}
        -   [Debugging and Verbose Simulation
            Output](../../using/basics/troubleshooting.html#debugging-and-verbose-simulation-output){.reference
            .internal}
-   [Examples](../../using/examples/examples.html){.reference .internal}
    -   [Introduction](../../using/examples/introduction.html){.reference
        .internal}
    -   [Building
        Kernels](../../using/examples/building_kernels.html){.reference
        .internal}
        -   [Defining
            Kernels](../../using/examples/building_kernels.html#defining-kernels){.reference
            .internal}
        -   [Initializing
            states](../../using/examples/building_kernels.html#initializing-states){.reference
            .internal}
        -   [Applying
            Gates](../../using/examples/building_kernels.html#applying-gates){.reference
            .internal}
        -   [Controlled
            Operations](../../using/examples/building_kernels.html#controlled-operations){.reference
            .internal}
        -   [Multi-Controlled
            Operations](../../using/examples/building_kernels.html#multi-controlled-operations){.reference
            .internal}
        -   [Adjoint
            Operations](../../using/examples/building_kernels.html#adjoint-operations){.reference
            .internal}
        -   [Custom
            Operations](../../using/examples/building_kernels.html#custom-operations){.reference
            .internal}
        -   [Building Kernels with
            Kernels](../../using/examples/building_kernels.html#building-kernels-with-kernels){.reference
            .internal}
        -   [Parameterized
            Kernels](../../using/examples/building_kernels.html#parameterized-kernels){.reference
            .internal}
    -   [Quantum
        Operations](../../using/examples/quantum_operations.html){.reference
        .internal}
        -   [Quantum
            States](../../using/examples/quantum_operations.html#quantum-states){.reference
            .internal}
        -   [Quantum
            Gates](../../using/examples/quantum_operations.html#quantum-gates){.reference
            .internal}
        -   [Measurements](../../using/examples/quantum_operations.html#measurements){.reference
            .internal}
    -   [Measuring
        Kernels](../../using/examples/measuring_kernels.html){.reference
        .internal}
        -   [Mid-circuit Measurement and Conditional
            Logic](../../using/examples/measuring_kernels.html#mid-circuit-measurement-and-conditional-logic){.reference
            .internal}
    -   [Visualizing
        Kernels](../../examples/python/visualization.html){.reference
        .internal}
        -   [Qubit
            Visualization](../../examples/python/visualization.html#Qubit-Visualization){.reference
            .internal}
        -   [Kernel
            Visualization](../../examples/python/visualization.html#Kernel-Visualization){.reference
            .internal}
    -   [Executing
        Kernels](../../using/examples/executing_kernels.html){.reference
        .internal}
        -   [Sample](../../using/examples/executing_kernels.html#sample){.reference
            .internal}
            -   [Sample
                Asynchronous](../../using/examples/executing_kernels.html#sample-asynchronous){.reference
                .internal}
        -   [Run](../../using/examples/executing_kernels.html#run){.reference
            .internal}
            -   [Return Custom Data
                Types](../../using/examples/executing_kernels.html#return-custom-data-types){.reference
                .internal}
            -   [Run
                Asynchronous](../../using/examples/executing_kernels.html#run-asynchronous){.reference
                .internal}
        -   [Observe](../../using/examples/executing_kernels.html#observe){.reference
            .internal}
            -   [Observe
                Asynchronous](../../using/examples/executing_kernels.html#observe-asynchronous){.reference
                .internal}
        -   [Get
            State](../../using/examples/executing_kernels.html#get-state){.reference
            .internal}
            -   [Get State
                Asynchronous](../../using/examples/executing_kernels.html#get-state-asynchronous){.reference
                .internal}
    -   [Computing Expectation
        Values](../../using/examples/expectation_values.html){.reference
        .internal}
        -   [Parallelizing across Multiple
            Processors](../../using/examples/expectation_values.html#parallelizing-across-multiple-processors){.reference
            .internal}
    -   [Multi-GPU
        Workflows](../../using/examples/multi_gpu_workflows.html){.reference
        .internal}
        -   [From CPU to
            GPU](../../using/examples/multi_gpu_workflows.html#from-cpu-to-gpu){.reference
            .internal}
        -   [Pooling the memory of multiple GPUs ([`mgpu`{.code
            .docutils .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#pooling-the-memory-of-multiple-gpus-mgpu){.reference
            .internal}
        -   [Parallel execution over multiple QPUs ([`mqpu`{.code
            .docutils .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#parallel-execution-over-multiple-qpus-mqpu){.reference
            .internal}
            -   [Batching Hamiltonian
                Terms](../../using/examples/multi_gpu_workflows.html#batching-hamiltonian-terms){.reference
                .internal}
            -   [Circuit
                Batching](../../using/examples/multi_gpu_workflows.html#circuit-batching){.reference
                .internal}
        -   [Multi-QPU + Other Backends ([`remote-mqpu`{.code .docutils
            .literal
            .notranslate}]{.pre})](../../using/examples/multi_gpu_workflows.html#multi-qpu-other-backends-remote-mqpu){.reference
            .internal}
    -   [Optimizers &
        Gradients](../../examples/python/optimizers_gradients.html){.reference
        .internal}
        -   [Built in CUDA-Q Optimizers and
            Gradients](../../examples/python/optimizers_gradients.html#Built-in-CUDA-Q-Optimizers-and-Gradients){.reference
            .internal}
        -   [Third-Party
            Optimizers](../../examples/python/optimizers_gradients.html#Third-Party-Optimizers){.reference
            .internal}
        -   [Parallel Parameter Shift
            Gradients](../../examples/python/optimizers_gradients.html#Parallel-Parameter-Shift-Gradients){.reference
            .internal}
    -   [Noisy
        Simulations](../../examples/python/noisy_simulations.html){.reference
        .internal}
    -   [Constructing
        Operators](../../using/examples/operators.html){.reference
        .internal}
        -   [Constructing Spin
            Operators](../../using/examples/operators.html#constructing-spin-operators){.reference
            .internal}
        -   [Pauli Words and Exponentiating Pauli
            Words](../../using/examples/operators.html#pauli-words-and-exponentiating-pauli-words){.reference
            .internal}
    -   [Performance
        Optimizations](../../examples/python/performance_optimizations.html){.reference
        .internal}
        -   [Gate
            Fusion](../../examples/python/performance_optimizations.html#Gate-Fusion){.reference
            .internal}
    -   [Using Quantum Hardware
        Providers](../../using/examples/hardware_providers.html){.reference
        .internal}
        -   [Amazon
            Braket](../../using/examples/hardware_providers.html#amazon-braket){.reference
            .internal}
        -   [Anyon
            Technologies](../../using/examples/hardware_providers.html#anyon-technologies){.reference
            .internal}
        -   [Infleqtion](../../using/examples/hardware_providers.html#infleqtion){.reference
            .internal}
        -   [IonQ](../../using/examples/hardware_providers.html#ionq){.reference
            .internal}
        -   [IQM](../../using/examples/hardware_providers.html#iqm){.reference
            .internal}
        -   [OQC](../../using/examples/hardware_providers.html#oqc){.reference
            .internal}
        -   [ORCA
            Computing](../../using/examples/hardware_providers.html#orca-computing){.reference
            .internal}
        -   [Pasqal](../../using/examples/hardware_providers.html#pasqal){.reference
            .internal}
        -   [Quantinuum](../../using/examples/hardware_providers.html#quantinuum){.reference
            .internal}
        -   [Quantum Circuits,
            Inc.](../../using/examples/hardware_providers.html#quantum-circuits-inc){.reference
            .internal}
        -   [Quantum
            Machines](../../using/examples/hardware_providers.html#quantum-machines){.reference
            .internal}
        -   [QuEra
            Computing](../../using/examples/hardware_providers.html#quera-computing){.reference
            .internal}
    -   [Dynamics
        Examples](../../using/examples/dynamics_examples.html){.reference
        .internal}
        -   [Introduction to CUDA-Q Dynamics (Jaynes-Cummings
            Model)](../../examples/python/dynamics/dynamics_intro_1.html){.reference
            .internal}
            -   [Why dynamics simulations vs. circuit
                simulations?](../../examples/python/dynamics/dynamics_intro_1.html#Why-dynamics-simulations-vs.-circuit-simulations?){.reference
                .internal}
            -   [Functionality](../../examples/python/dynamics/dynamics_intro_1.html#Functionality){.reference
                .internal}
            -   [Performance](../../examples/python/dynamics/dynamics_intro_1.html#Performance){.reference
                .internal}
            -   [Section 1 - Simulating the Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Section-1---Simulating-the-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Exercise 1 - Simulating a many-photon Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-1---Simulating-a-many-photon-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Section 2 - Simulating open quantum systems with the
                [`collapse_operators`{.docutils .literal
                .notranslate}]{.pre}](../../examples/python/dynamics/dynamics_intro_1.html#Section-2---Simulating-open-quantum-systems-with-the-collapse_operators){.reference
                .internal}
            -   [Exercise 2 - Adding additional jump operators
                [\\(L_i\\)]{.math .notranslate
                .nohighlight}](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-2---Adding-additional-jump-operators-L_i){.reference
                .internal}
            -   [Section 3 - Many qubits coupled to the
                resonator](../../examples/python/dynamics/dynamics_intro_1.html#Section-3---Many-qubits-coupled-to-the-resonator){.reference
                .internal}
        -   [Introduction to CUDA-Q Dynamics (Time Dependent
            Hamiltonians)](../../examples/python/dynamics/dynamics_intro_2.html){.reference
            .internal}
            -   [The Landau-Zener
                model](../../examples/python/dynamics/dynamics_intro_2.html#The-Landau-Zener-model){.reference
                .internal}
            -   [Section 1 - Implementing time dependent
                terms](../../examples/python/dynamics/dynamics_intro_2.html#Section-1---Implementing-time-dependent-terms){.reference
                .internal}
            -   [Section 2 - Implementing custom
                operators](../../examples/python/dynamics/dynamics_intro_2.html#Section-2---Implementing-custom-operators){.reference
                .internal}
            -   [Section 3 - Heisenberg Model with a time-varying
                magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Section-3---Heisenberg-Model-with-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 1 - Define a time-varying magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-1---Define-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 2
                (Optional)](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-2-(Optional)){.reference
                .internal}
        -   [Superconducting
            Qubits](../../examples/python/dynamics/superconducting.html){.reference
            .internal}
            -   [Cavity
                QED](../../examples/python/dynamics/superconducting.html#Cavity-QED){.reference
                .internal}
            -   [Cross
                Resonance](../../examples/python/dynamics/superconducting.html#Cross-Resonance){.reference
                .internal}
            -   [Transmon
                Resonator](../../examples/python/dynamics/superconducting.html#Transmon-Resonator){.reference
                .internal}
        -   [Spin
            Qubits](../../examples/python/dynamics/spinqubits.html){.reference
            .internal}
            -   [Silicon Spin
                Qubit](../../examples/python/dynamics/spinqubits.html#Silicon-Spin-Qubit){.reference
                .internal}
            -   [Heisenberg
                Model](../../examples/python/dynamics/spinqubits.html#Heisenberg-Model){.reference
                .internal}
        -   [Trapped Ion
            Qubits](../../examples/python/dynamics/iontrap.html){.reference
            .internal}
            -   [GHZ
                state](../../examples/python/dynamics/iontrap.html#GHZ-state){.reference
                .internal}
        -   [Control](../../examples/python/dynamics/control.html){.reference
            .internal}
            -   [Gate
                Calibration](../../examples/python/dynamics/control.html#Gate-Calibration){.reference
                .internal}
            -   [Pulse](../../examples/python/dynamics/control.html#Pulse){.reference
                .internal}
            -   [Qubit
                Control](../../examples/python/dynamics/control.html#Qubit-Control){.reference
                .internal}
            -   [Qubit
                Dynamics](../../examples/python/dynamics/control.html#Qubit-Dynamics){.reference
                .internal}
            -   [Landau-Zenner](../../examples/python/dynamics/control.html#Landau-Zenner){.reference
                .internal}
-   [Applications](../../using/applications.html){.reference .internal}
    -   [Max-Cut with QAOA](qaoa.html){.reference .internal}
    -   [Molecular docking via
        DC-QAOA](digitized_counterdiabatic_qaoa.html){.reference
        .internal}
        -   [Setting up the Molecular Docking
            Problem](digitized_counterdiabatic_qaoa.html#Setting-up-the-Molecular-Docking-Problem){.reference
            .internal}
        -   [CUDA-Q
            Implementation](digitized_counterdiabatic_qaoa.html#CUDA-Q-Implementation){.reference
            .internal}
    -   [Multi-reference Quantum Krylov Algorithm - [\\(H_2\\)]{.math
        .notranslate .nohighlight} Molecule](krylov.html){.reference
        .internal}
        -   [Setup](krylov.html#Setup){.reference .internal}
        -   [Computing the matrix
            elements](krylov.html#Computing-the-matrix-elements){.reference
            .internal}
        -   [Determining the ground state energy of the
            subspace](krylov.html#Determining-the-ground-state-energy-of-the-subspace){.reference
            .internal}
    -   [Bernstein-Vazirani
        Algorithm](bernstein_vazirani.html){.reference .internal}
        -   [Classical
            case](bernstein_vazirani.html#Classical-case){.reference
            .internal}
        -   [Quantum
            case](bernstein_vazirani.html#Quantum-case){.reference
            .internal}
        -   [Implementing in
            CUDA-Q](bernstein_vazirani.html#Implementing-in-CUDA-Q){.reference
            .internal}
    -   [Cost Minimization](cost_minimization.html){.reference
        .internal}
    -   [Deutsch's Algorithm](deutsch_algorithm.html){.reference
        .internal}
        -   [XOR [\\(\\oplus\\)]{.math .notranslate
            .nohighlight}](deutsch_algorithm.html#XOR-\oplus){.reference
            .internal}
        -   [Quantum
            oracles](deutsch_algorithm.html#Quantum-oracles){.reference
            .internal}
        -   [Phase
            oracle](deutsch_algorithm.html#Phase-oracle){.reference
            .internal}
        -   [Quantum
            parallelism](deutsch_algorithm.html#Quantum-parallelism){.reference
            .internal}
        -   [Deutsch's
            Algorithm:](deutsch_algorithm.html#Deutsch's-Algorithm:){.reference
            .internal}
    -   [Divisive Clustering With Coresets Using
        CUDA-Q](divisive_clustering_coresets.html){.reference .internal}
        -   [Data
            preprocessing](divisive_clustering_coresets.html#Data-preprocessing){.reference
            .internal}
        -   [Quantum
            functions](divisive_clustering_coresets.html#Quantum-functions){.reference
            .internal}
        -   [Divisive Clustering
            Function](divisive_clustering_coresets.html#Divisive-Clustering-Function){.reference
            .internal}
        -   [QAOA
            Implementation](divisive_clustering_coresets.html#QAOA-Implementation){.reference
            .internal}
        -   [Scaling simulations with
            CUDA-Q](divisive_clustering_coresets.html#Scaling-simulations-with-CUDA-Q){.reference
            .internal}
    -   [Hybrid Quantum Neural
        Networks](hybrid_quantum_neural_networks.html){.reference
        .internal}
    -   [Using the Hadamard Test to Determine Quantum Krylov Subspace
        Decomposition Matrix Elements](hadamard_test.html){.reference
        .internal}
        -   [Numerical result as a
            reference:](hadamard_test.html#Numerical-result-as-a-reference:){.reference
            .internal}
        -   [Using [`Sample`{.docutils .literal .notranslate}]{.pre} to
            perform the Hadamard
            test](hadamard_test.html#Using-Sample-to-perform-the-Hadamard-test){.reference
            .internal}
        -   [Multi-GPU evaluation of QKSD matrix elements using the
            Hadamard
            Test](hadamard_test.html#Multi-GPU-evaluation-of-QKSD-matrix-elements-using-the-Hadamard-Test){.reference
            .internal}
            -   [Classically Diagonalize the Subspace
                Matrix](hadamard_test.html#Classically-Diagonalize-the-Subspace-Matrix){.reference
                .internal}
    -   [Anderson Impurity Model ground state solver on Infleqtion's
        Sqale](logical_aim_sqale.html){.reference .internal}
        -   [Performing logical Variational Quantum Eigensolver (VQE)
            with
            CUDA-QX](logical_aim_sqale.html#Performing-logical-Variational-Quantum-Eigensolver-(VQE)-with-CUDA-QX){.reference
            .internal}
        -   [Constructing circuits in the [`[[4,2,2]]`{.docutils
            .literal .notranslate}]{.pre}
            encoding](logical_aim_sqale.html#Constructing-circuits-in-the-%5B%5B4,2,2%5D%5D-encoding){.reference
            .internal}
        -   [Setting up submission and decoding
            workflow](logical_aim_sqale.html#Setting-up-submission-and-decoding-workflow){.reference
            .internal}
        -   [Running a CUDA-Q noisy
            simulation](logical_aim_sqale.html#Running-a-CUDA-Q-noisy-simulation){.reference
            .internal}
        -   [Running logical AIM on Infleqtion's
            hardware](logical_aim_sqale.html#Running-logical-AIM-on-Infleqtion's-hardware){.reference
            .internal}
    -   [Spin-Hamiltonian Simulation Using
        CUDA-Q](hamiltonian_simulation.html){.reference .internal}
        -   [Introduction](hamiltonian_simulation.html#Introduction){.reference
            .internal}
            -   [Heisenberg
                Hamiltonian](hamiltonian_simulation.html#Heisenberg-Hamiltonian){.reference
                .internal}
            -   [Transverse Field Ising Model
                (TFIM)](hamiltonian_simulation.html#Transverse-Field-Ising-Model-(TFIM)){.reference
                .internal}
            -   [Time Evolution and Trotter
                Decomposition](hamiltonian_simulation.html#Time-Evolution-and-Trotter-Decomposition){.reference
                .internal}
        -   [Key
            steps](hamiltonian_simulation.html#Key-steps){.reference
            .internal}
            -   [1. Prepare initial
                state](hamiltonian_simulation.html#1.-Prepare-initial-state){.reference
                .internal}
            -   [2. Hamiltonian
                Trotterization](hamiltonian_simulation.html#2.-Hamiltonian-Trotterization){.reference
                .internal}
            -   [3. [`Compute`{.docutils .literal
                .notranslate}]{.pre}` `{.docutils .literal
                .notranslate}[`overlap`{.docutils .literal
                .notranslate}]{.pre}](hamiltonian_simulation.html#3.-Compute-overlap){.reference
                .internal}
            -   [4. Construct Heisenberg
                Hamiltonian](hamiltonian_simulation.html#4.-Construct-Heisenberg-Hamiltonian){.reference
                .internal}
            -   [5. Construct TFIM
                Hamiltonian](hamiltonian_simulation.html#5.-Construct-TFIM-Hamiltonian){.reference
                .internal}
            -   [6. Extract coefficients and Pauli
                words](hamiltonian_simulation.html#6.-Extract-coefficients-and-Pauli-words){.reference
                .internal}
        -   [Main
            code](hamiltonian_simulation.html#Main-code){.reference
            .internal}
        -   [Visualization of probablity over
            time](hamiltonian_simulation.html#Visualization-of-probablity-over-time){.reference
            .internal}
        -   [Expectation value over
            time:](hamiltonian_simulation.html#Expectation-value-over-time:){.reference
            .internal}
        -   [Visualization of expectation over
            time](hamiltonian_simulation.html#Visualization-of-expectation-over-time){.reference
            .internal}
        -   [Additional
            information](hamiltonian_simulation.html#Additional-information){.reference
            .internal}
        -   [Relevant
            references](hamiltonian_simulation.html#Relevant-references){.reference
            .internal}
    -   [Quantum Fourier
        Transform](quantum_fourier_transform.html){.reference .internal}
        -   [Quantum Fourier Transform
            revisited](quantum_fourier_transform.html#Quantum-Fourier-Transform-revisited){.reference
            .internal}
    -   [Quantum Teleporation](quantum_teleportation.html){.reference
        .internal}
        -   [Teleportation
            explained](quantum_teleportation.html#Teleportation-explained){.reference
            .internal}
    -   [Quantum Volume](quantum_volume.html){.reference .internal}
    -   [Readout Error
        Mitigation](readout_error_mitigation.html){.reference .internal}
        -   [Inverse confusion matrix from single-qubit noise
            model](readout_error_mitigation.html#Inverse-confusion-matrix-from-single-qubit-noise-model){.reference
            .internal}
        -   [Inverse confusion matrix from k local confusion
            matrices](readout_error_mitigation.html#Inverse-confusion-matrix-from-k-local-confusion-matrices){.reference
            .internal}
        -   [Inverse of full confusion
            matrix](readout_error_mitigation.html#Inverse-of-full-confusion-matrix){.reference
            .internal}
    -   [Compiling Unitaries Using Diffusion Models](#){.current
        .reference .internal}
        -   [Diffusion model
            pipeline](#Diffusion-model-pipeline){.reference .internal}
        -   [Setup and load models](#Setup-and-load-models){.reference
            .internal}
            -   [Load discrete model](#Load-discrete-model){.reference
                .internal}
            -   [Load continuous
                model](#Load-continuous-model){.reference .internal}
            -   [Create helper
                functions](#Create-helper-functions){.reference
                .internal}
        -   [Unitary compilation](#Unitary-compilation){.reference
            .internal}
            -   [Random unitary](#Random-unitary){.reference .internal}
            -   [Discrete model](#Discrete-model){.reference .internal}
            -   [Continuous model](#Continuous-model){.reference
                .internal}
            -   [Quantum Fourier
                transform](#Quantum-Fourier-transform){.reference
                .internal}
            -   [XXZ-Hamiltonian
                evolution](#XXZ-Hamiltonian-evolution){.reference
                .internal}
        -   [Choosing the circuit you
            need](#Choosing-the-circuit-you-need){.reference .internal}
    -   [VQE with gradients, active spaces, and gate
        fusion](vqe_advanced.html){.reference .internal}
        -   [The Basics of
            VQE](vqe_advanced.html#The-Basics-of-VQE){.reference
            .internal}
        -   [Installing/Loading Relevant
            Packages](vqe_advanced.html#Installing/Loading-Relevant-Packages){.reference
            .internal}
        -   [Implementing VQE in
            CUDA-Q](vqe_advanced.html#Implementing-VQE-in-CUDA-Q){.reference
            .internal}
        -   [Parallel Parameter Shift
            Gradients](vqe_advanced.html#Parallel-Parameter-Shift-Gradients){.reference
            .internal}
        -   [Using an Active
            Space](vqe_advanced.html#Using-an-Active-Space){.reference
            .internal}
        -   [Gate Fusion for Larger
            Circuits](vqe_advanced.html#Gate-Fusion-for-Larger-Circuits){.reference
            .internal}
    -   [Quantum Transformer](quantum_transformer.html){.reference
        .internal}
        -   [Installation](quantum_transformer.html#Installation){.reference
            .internal}
        -   [Algorithm and
            Example](quantum_transformer.html#Algorithm-and-Example){.reference
            .internal}
            -   [Creating the self-attention
                circuits](quantum_transformer.html#Creating-the-self-attention-circuits){.reference
                .internal}
        -   [Usage](quantum_transformer.html#Usage){.reference
            .internal}
            -   [Model
                Training](quantum_transformer.html#Model-Training){.reference
                .internal}
            -   [Generating
                Molecules](quantum_transformer.html#Generating-Molecules){.reference
                .internal}
            -   [Attention
                Maps](quantum_transformer.html#Attention-Maps){.reference
                .internal}
    -   [Quantum Enhanced Auxiliary Field Quantum Monte
        Carlo](afqmc.html){.reference .internal}
        -   [Hamiltonian preparation for
            VQE](afqmc.html#Hamiltonian-preparation-for-VQE){.reference
            .internal}
        -   [Run VQE with
            CUDA-Q](afqmc.html#Run-VQE-with-CUDA-Q){.reference
            .internal}
        -   [Auxiliary Field Quantum Monte Carlo
            (AFQMC)](afqmc.html#Auxiliary-Field-Quantum-Monte-Carlo-(AFQMC)){.reference
            .internal}
        -   [Preparation of the molecular
            Hamiltonian](afqmc.html#Preparation-of-the-molecular-Hamiltonian){.reference
            .internal}
        -   [Preparation of the trial wave
            function](afqmc.html#Preparation-of-the-trial-wave-function){.reference
            .internal}
        -   [Setup of the AFQMC
            parameters](afqmc.html#Setup-of-the-AFQMC-parameters){.reference
            .internal}
    -   [ADAPT-QAOA algorithm](adapt_qaoa.html){.reference .internal}
        -   [Simulation
            input:](adapt_qaoa.html#Simulation-input:){.reference
            .internal}
        -   [The problem Hamiltonian [\\(H_C\\)]{.math .notranslate
            .nohighlight} of the max-cut
            graph:](adapt_qaoa.html#The-problem-Hamiltonian-H_C-of-the-max-cut-graph:){.reference
            .internal}
        -   [Th operator pool [\\(A_j\\)]{.math .notranslate
            .nohighlight}:](adapt_qaoa.html#Th-operator-pool-A_j:){.reference
            .internal}
        -   [The commutator [\\(\[H_C,A_j\]\\)]{.math .notranslate
            .nohighlight}:](adapt_qaoa.html#The-commutator-%5BH_C,A_j%5D:){.reference
            .internal}
        -   [Beginning of ADAPT-QAOA
            iteration:](adapt_qaoa.html#Beginning-of-ADAPT-QAOA-iteration:){.reference
            .internal}
    -   [ADAPT-VQE algorithm](adapt_vqe.html){.reference .internal}
        -   [Classical
            pre-processing](adapt_vqe.html#Classical-pre-processing){.reference
            .internal}
        -   [Jordan Wigner:](adapt_vqe.html#Jordan-Wigner:){.reference
            .internal}
        -   [UCCSD operator
            pool](adapt_vqe.html#UCCSD-operator-pool){.reference
            .internal}
            -   [Single
                excitation](adapt_vqe.html#Single-excitation){.reference
                .internal}
            -   [Double
                excitation](adapt_vqe.html#Double-excitation){.reference
                .internal}
        -   [Commutator \[[\\(H\\)]{.math .notranslate .nohighlight},
            [\\(A_i\\)]{.math .notranslate
            .nohighlight}\]](adapt_vqe.html#Commutator-%5BH,-A_i%5D){.reference
            .internal}
        -   [Reference
            State:](adapt_vqe.html#Reference-State:){.reference
            .internal}
        -   [Quantum
            kernels:](adapt_vqe.html#Quantum-kernels:){.reference
            .internal}
        -   [Beginning of
            ADAPT-VQE:](adapt_vqe.html#Beginning-of-ADAPT-VQE:){.reference
            .internal}
    -   [Quantum edge detection](edge_detection.html){.reference
        .internal}
        -   [Image](edge_detection.html#Image){.reference .internal}
        -   [Quantum Probability Image Encoding
            (QPIE):](edge_detection.html#Quantum-Probability-Image-Encoding-(QPIE):){.reference
            .internal}
            -   [Below we show how to encode an image using QPIE in
                cudaq.](edge_detection.html#Below-we-show-how-to-encode-an-image-using-QPIE-in-cudaq.){.reference
                .internal}
        -   [Flexible Representation of Quantum Images
            (FRQI):](edge_detection.html#Flexible-Representation-of-Quantum-Images-(FRQI):){.reference
            .internal}
            -   [Building the FRQI
                State:](edge_detection.html#Building-the-FRQI-State:){.reference
                .internal}
        -   [Quantum Hadamard Edge Detection
            (QHED)](edge_detection.html#Quantum-Hadamard-Edge-Detection-(QHED)){.reference
            .internal}
            -   [Post-processing](edge_detection.html#Post-processing){.reference
                .internal}
    -   [Factoring Integers With Shor's
        Algorithm](shors.html){.reference .internal}
        -   [Shor's algorithm](shors.html#Shor's-algorithm){.reference
            .internal}
            -   [Solving the order-finding problem
                classically](shors.html#Solving-the-order-finding-problem-classically){.reference
                .internal}
            -   [Solving the order-finding problem with a quantum
                algorithm](shors.html#Solving-the-order-finding-problem-with-a-quantum-algorithm){.reference
                .internal}
            -   [Determining the order from the measurement results of
                the phase
                kernel](shors.html#Determining-the-order-from-the-measurement-results-of-the-phase-kernel){.reference
                .internal}
            -   [Postscript](shors.html#Postscript){.reference
                .internal}
    -   [Generating the electronic
        Hamiltonian](generate_fermionic_ham.html){.reference .internal}
        -   [Second Quantized
            formulation.](generate_fermionic_ham.html#Second-Quantized-formulation.){.reference
            .internal}
            -   [Computational
                Implementation](generate_fermionic_ham.html#Computational-Implementation){.reference
                .internal}
            -   [(a) Generate the molecular Hamiltonian using Restricted
                Hartree Fock molecular
                orbitals](generate_fermionic_ham.html#(a)-Generate-the-molecular-Hamiltonian-using-Restricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(b) Generate the molecular Hamiltonian using
                Unrestricted Hartree Fock molecular
                orbitals](generate_fermionic_ham.html#(b)-Generate-the-molecular-Hamiltonian-using-Unrestricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(a) Generate the active space hamiltonian using RHF
                molecular
                orbitals.](generate_fermionic_ham.html#(a)-Generate-the-active-space-hamiltonian-using-RHF-molecular-orbitals.){.reference
                .internal}
            -   [(b) Generate the active space Hamiltonian using the
                natural orbitals computed from MP2
                simulation](generate_fermionic_ham.html#(b)-Generate-the-active-space-Hamiltonian-using-the-natural-orbitals-computed-from-MP2-simulation){.reference
                .internal}
            -   [(c) Generate the active space Hamiltonian computed from
                the CASSCF molecular
                orbitals](generate_fermionic_ham.html#(c)-Generate-the-active-space-Hamiltonian-computed-from-the-CASSCF-molecular-orbitals){.reference
                .internal}
            -   [(d) Generate the electronic Hamiltonian using
                ROHF](generate_fermionic_ham.html#(d)-Generate-the-electronic-Hamiltonian-using-ROHF){.reference
                .internal}
            -   [(e) Generate electronic Hamiltonian using
                UHF](generate_fermionic_ham.html#(e)-Generate-electronic-Hamiltonian-using-UHF){.reference
                .internal}
    -   [Grover's Algorithm](grovers.html){.reference .internal}
        -   [Overview](grovers.html#Overview){.reference .internal}
        -   [Problem](grovers.html#Problem){.reference .internal}
        -   [Structure of Grover's
            Algorithm](grovers.html#Structure-of-Grover's-Algorithm){.reference
            .internal}
            -   [Step 1:
                Preparation](grovers.html#Step-1:-Preparation){.reference
                .internal}
            -   [Good and Bad
                States](grovers.html#Good-and-Bad-States){.reference
                .internal}
            -   [Step 2: Oracle
                application](grovers.html#Step-2:-Oracle-application){.reference
                .internal}
            -   [Step 3: Amplitude
                amplification](grovers.html#Step-3:-Amplitude-amplification){.reference
                .internal}
            -   [Steps 4 and 5: Iteration and
                measurement](grovers.html#Steps-4-and-5:-Iteration-and-measurement){.reference
                .internal}
    -   [Quantum PageRank](quantum_pagerank.html){.reference .internal}
        -   [Problem
            Definition](quantum_pagerank.html#Problem-Definition){.reference
            .internal}
        -   [Simulating Quantum PageRank by CUDA-Q
            dynamics](quantum_pagerank.html#Simulating-Quantum-PageRank-by-CUDA-Q-dynamics){.reference
            .internal}
        -   [Breakdown of
            Terms](quantum_pagerank.html#Breakdown-of-Terms){.reference
            .internal}
    -   [The UCCSD Wavefunction ansatz](uccsd_wf_ansatz.html){.reference
        .internal}
        -   [What is
            UCCSD?](uccsd_wf_ansatz.html#What-is-UCCSD?){.reference
            .internal}
        -   [Implementation in Quantum
            Computing](uccsd_wf_ansatz.html#Implementation-in-Quantum-Computing){.reference
            .internal}
        -   [Run VQE](uccsd_wf_ansatz.html#Run-VQE){.reference
            .internal}
        -   [Challenges and
            consideration](uccsd_wf_ansatz.html#Challenges-and-consideration){.reference
            .internal}
    -   [Approximate State Preparation using MPS Sequential
        Encoding](mps_encoding.html){.reference .internal}
        -   [Ran's
            approach](mps_encoding.html#Ran's-approach){.reference
            .internal}
    -   [QM/MM simulation: VQE within a Polarizable Embedded
        Framework.](qm_mm_pe.html){.reference .internal}
        -   [Key concepts:](qm_mm_pe.html#Key-concepts:){.reference
            .internal}
        -   [PE-VQE-SCF Algorithm
            Steps](qm_mm_pe.html#PE-VQE-SCF-Algorithm-Steps){.reference
            .internal}
            -   [Step 1: Initialize (Classical
                pre-processing)](qm_mm_pe.html#Step-1:-Initialize-(Classical-pre-processing)){.reference
                .internal}
            -   [Step 2: Build the
                Hamiltonian](qm_mm_pe.html#Step-2:-Build-the-Hamiltonian){.reference
                .internal}
            -   [Step 3: Run
                VQE](qm_mm_pe.html#Step-3:-Run-VQE){.reference
                .internal}
            -   [Step 4: Update
                Environment](qm_mm_pe.html#Step-4:-Update-Environment){.reference
                .internal}
            -   [Step 5: Self-Consistency
                Loop](qm_mm_pe.html#Step-5:-Self-Consistency-Loop){.reference
                .internal}
            -   [Requirments:](qm_mm_pe.html#Requirments:){.reference
                .internal}
            -   [Example 1: LiH with 2 water
                molecules.](qm_mm_pe.html#Example-1:-LiH-with-2-water-molecules.){.reference
                .internal}
            -   [VQE, update environment, and scf
                loop.](qm_mm_pe.html#VQE,-update-environment,-and-scf-loop.){.reference
                .internal}
            -   [Example 2: NH3 with 46 water molecule using active
                space.](qm_mm_pe.html#Example-2:-NH3-with-46-water-molecule-using-active-space.){.reference
                .internal}
    -   [Sample-Based Krylov Quantum Diagonalization
        (SKQD)](skqd.html){.reference .internal}
        -   [Why SKQD?](skqd.html#Why-SKQD?){.reference .internal}
        -   [Setup and Imports](skqd.html#Setup-and-Imports){.reference
            .internal}
        -   [Understanding Krylov
            Subspaces](skqd.html#Understanding-Krylov-Subspaces){.reference
            .internal}
            -   [What is a Krylov
                Subspace?](skqd.html#What-is-a-Krylov-Subspace?){.reference
                .internal}
            -   [The SKQD
                Algorithm](skqd.html#The-SKQD-Algorithm){.reference
                .internal}
        -   [Krylov State Generation via Repeated
            Evolution](skqd.html#Krylov-State-Generation-via-Repeated-Evolution){.reference
            .internal}
        -   [Quantum Measurements and
            Sampling](skqd.html#Quantum-Measurements-and-Sampling){.reference
            .internal}
            -   [The Sampling
                Process](skqd.html#The-Sampling-Process){.reference
                .internal}
        -   [Classical Post-Processing and
            Diagonalization](skqd.html#Classical-Post-Processing-and-Diagonalization){.reference
            .internal}
            -   [The SKQD Algorithm: Matrix Construction
                Details](skqd.html#The-SKQD-Algorithm:-Matrix-Construction-Details){.reference
                .internal}
        -   [Results Analysis and
            Convergence](skqd.html#Results-Analysis-and-Convergence){.reference
            .internal}
            -   [What to Expect:](skqd.html#What-to-Expect:){.reference
                .internal}
-   [Backends](../../using/backends/backends.html){.reference .internal}
    -   [Circuit
        Simulation](../../using/backends/simulators.html){.reference
        .internal}
        -   [State Vector
            Simulators](../../using/backends/sims/svsims.html){.reference
            .internal}
            -   [CPU](../../using/backends/sims/svsims.html#cpu){.reference
                .internal}
            -   [Single-GPU](../../using/backends/sims/svsims.html#single-gpu){.reference
                .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/svsims.html#multi-gpu-multi-node){.reference
                .internal}
        -   [Tensor Network
            Simulators](../../using/backends/sims/tnsims.html){.reference
            .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/tnsims.html#multi-gpu-multi-node){.reference
                .internal}
            -   [Matrix product
                state](../../using/backends/sims/tnsims.html#matrix-product-state){.reference
                .internal}
            -   [Fermioniq](../../using/backends/sims/tnsims.html#fermioniq){.reference
                .internal}
        -   [Multi-QPU
            Simulators](../../using/backends/sims/mqpusims.html){.reference
            .internal}
            -   [Simulate Multiple QPUs in
                Parallel](../../using/backends/sims/mqpusims.html#simulate-multiple-qpus-in-parallel){.reference
                .internal}
            -   [Multi-QPU + Other
                Backends](../../using/backends/sims/mqpusims.html#multi-qpu-other-backends){.reference
                .internal}
        -   [Noisy
            Simulators](../../using/backends/sims/noisy.html){.reference
            .internal}
            -   [Trajectory Noisy
                Simulation](../../using/backends/sims/noisy.html#trajectory-noisy-simulation){.reference
                .internal}
            -   [Density
                Matrix](../../using/backends/sims/noisy.html#density-matrix){.reference
                .internal}
            -   [Stim](../../using/backends/sims/noisy.html#stim){.reference
                .internal}
        -   [Photonics
            Simulators](../../using/backends/sims/photonics.html){.reference
            .internal}
            -   [orca-photonics](../../using/backends/sims/photonics.html#orca-photonics){.reference
                .internal}
    -   [Quantum Hardware
        (QPUs)](../../using/backends/hardware.html){.reference
        .internal}
        -   [Ion Trap
            QPUs](../../using/backends/hardware/iontrap.html){.reference
            .internal}
            -   [IonQ](../../using/backends/hardware/iontrap.html#ionq){.reference
                .internal}
            -   [Quantinuum](../../using/backends/hardware/iontrap.html#quantinuum){.reference
                .internal}
        -   [Superconducting
            QPUs](../../using/backends/hardware/superconducting.html){.reference
            .internal}
            -   [Anyon Technologies/Anyon
                Computing](../../using/backends/hardware/superconducting.html#anyon-technologies-anyon-computing){.reference
                .internal}
            -   [IQM](../../using/backends/hardware/superconducting.html#iqm){.reference
                .internal}
            -   [OQC](../../using/backends/hardware/superconducting.html#oqc){.reference
                .internal}
            -   [Quantum Circuits,
                Inc.](../../using/backends/hardware/superconducting.html#quantum-circuits-inc){.reference
                .internal}
        -   [Neutral Atom
            QPUs](../../using/backends/hardware/neutralatom.html){.reference
            .internal}
            -   [Infleqtion](../../using/backends/hardware/neutralatom.html#infleqtion){.reference
                .internal}
            -   [Pasqal](../../using/backends/hardware/neutralatom.html#pasqal){.reference
                .internal}
            -   [QuEra
                Computing](../../using/backends/hardware/neutralatom.html#quera-computing){.reference
                .internal}
        -   [Photonic
            QPUs](../../using/backends/hardware/photonic.html){.reference
            .internal}
            -   [ORCA
                Computing](../../using/backends/hardware/photonic.html#orca-computing){.reference
                .internal}
        -   [Quantum Control
            Systems](../../using/backends/hardware/qcontrol.html){.reference
            .internal}
            -   [Quantum
                Machines](../../using/backends/hardware/qcontrol.html#quantum-machines){.reference
                .internal}
    -   [Dynamics
        Simulation](../../using/backends/dynamics_backends.html){.reference
        .internal}
    -   [Cloud](../../using/backends/cloud.html){.reference .internal}
        -   [Amazon Braket
            (braket)](../../using/backends/cloud/braket.html){.reference
            .internal}
            -   [Setting
                Credentials](../../using/backends/cloud/braket.html#setting-credentials){.reference
                .internal}
            -   [Submission from
                C++](../../using/backends/cloud/braket.html#submission-from-c){.reference
                .internal}
            -   [Submission from
                Python](../../using/backends/cloud/braket.html#submission-from-python){.reference
                .internal}
        -   [NVIDIA Quantum Cloud
            (nvqc)](../../using/backends/cloud/nvqc.html){.reference
            .internal}
            -   [Quick
                Start](../../using/backends/cloud/nvqc.html#quick-start){.reference
                .internal}
            -   [Simulator Backend
                Selection](../../using/backends/cloud/nvqc.html#simulator-backend-selection){.reference
                .internal}
            -   [Multiple
                GPUs](../../using/backends/cloud/nvqc.html#multiple-gpus){.reference
                .internal}
            -   [Multiple QPUs Asynchronous
                Execution](../../using/backends/cloud/nvqc.html#multiple-qpus-asynchronous-execution){.reference
                .internal}
            -   [FAQ](../../using/backends/cloud/nvqc.html#faq){.reference
                .internal}
-   [Dynamics](../../using/dynamics.html){.reference .internal}
    -   [Quick Start](../../using/dynamics.html#quick-start){.reference
        .internal}
    -   [Operator](../../using/dynamics.html#operator){.reference
        .internal}
    -   [Time-Dependent
        Dynamics](../../using/dynamics.html#time-dependent-dynamics){.reference
        .internal}
    -   [Super-operator
        Representation](../../using/dynamics.html#super-operator-representation){.reference
        .internal}
    -   [Numerical
        Integrators](../../using/dynamics.html#numerical-integrators){.reference
        .internal}
    -   [Batch
        simulation](../../using/dynamics.html#batch-simulation){.reference
        .internal}
    -   [Multi-GPU Multi-Node
        Execution](../../using/dynamics.html#multi-gpu-multi-node-execution){.reference
        .internal}
    -   [Examples](../../using/dynamics.html#examples){.reference
        .internal}
-   [CUDA-QX](../../using/cudaqx/cudaqx.html){.reference .internal}
    -   [CUDA-Q
        Solvers](../../using/cudaqx/cudaqx.html#cuda-q-solvers){.reference
        .internal}
    -   [CUDA-Q
        QEC](../../using/cudaqx/cudaqx.html#cuda-q-qec){.reference
        .internal}
-   [Installation](../../using/install/install.html){.reference
    .internal}
    -   [Local
        Installation](../../using/install/local_installation.html){.reference
        .internal}
        -   [Introduction](../../using/install/local_installation.html#introduction){.reference
            .internal}
            -   [Docker](../../using/install/local_installation.html#docker){.reference
                .internal}
            -   [Known Blackwell
                Issues](../../using/install/local_installation.html#known-blackwell-issues){.reference
                .internal}
            -   [Singularity](../../using/install/local_installation.html#singularity){.reference
                .internal}
            -   [Python
                wheels](../../using/install/local_installation.html#python-wheels){.reference
                .internal}
            -   [Pre-built
                binaries](../../using/install/local_installation.html#pre-built-binaries){.reference
                .internal}
        -   [Development with VS
            Code](../../using/install/local_installation.html#development-with-vs-code){.reference
            .internal}
            -   [Using a Docker
                container](../../using/install/local_installation.html#using-a-docker-container){.reference
                .internal}
            -   [Using a Singularity
                container](../../using/install/local_installation.html#using-a-singularity-container){.reference
                .internal}
        -   [Connecting to a Remote
            Host](../../using/install/local_installation.html#connecting-to-a-remote-host){.reference
            .internal}
            -   [Developing with Remote
                Tunnels](../../using/install/local_installation.html#developing-with-remote-tunnels){.reference
                .internal}
            -   [Remote Access via
                SSH](../../using/install/local_installation.html#remote-access-via-ssh){.reference
                .internal}
        -   [DGX
            Cloud](../../using/install/local_installation.html#dgx-cloud){.reference
            .internal}
            -   [Get
                Started](../../using/install/local_installation.html#get-started){.reference
                .internal}
            -   [Use
                JupyterLab](../../using/install/local_installation.html#use-jupyterlab){.reference
                .internal}
            -   [Use VS
                Code](../../using/install/local_installation.html#use-vs-code){.reference
                .internal}
        -   [Additional CUDA
            Tools](../../using/install/local_installation.html#additional-cuda-tools){.reference
            .internal}
            -   [Installation via
                PyPI](../../using/install/local_installation.html#installation-via-pypi){.reference
                .internal}
            -   [Installation In Container
                Images](../../using/install/local_installation.html#installation-in-container-images){.reference
                .internal}
            -   [Installing Pre-built
                Binaries](../../using/install/local_installation.html#installing-pre-built-binaries){.reference
                .internal}
        -   [Distributed Computing with
            MPI](../../using/install/local_installation.html#distributed-computing-with-mpi){.reference
            .internal}
        -   [Updating
            CUDA-Q](../../using/install/local_installation.html#updating-cuda-q){.reference
            .internal}
        -   [Dependencies and
            Compatibility](../../using/install/local_installation.html#dependencies-and-compatibility){.reference
            .internal}
        -   [Next
            Steps](../../using/install/local_installation.html#next-steps){.reference
            .internal}
    -   [Data Center
        Installation](../../using/install/data_center_install.html){.reference
        .internal}
        -   [Prerequisites](../../using/install/data_center_install.html#prerequisites){.reference
            .internal}
        -   [Build
            Dependencies](../../using/install/data_center_install.html#build-dependencies){.reference
            .internal}
            -   [CUDA](../../using/install/data_center_install.html#cuda){.reference
                .internal}
            -   [Toolchain](../../using/install/data_center_install.html#toolchain){.reference
                .internal}
        -   [Building
            CUDA-Q](../../using/install/data_center_install.html#building-cuda-q){.reference
            .internal}
        -   [Python
            Support](../../using/install/data_center_install.html#python-support){.reference
            .internal}
        -   [C++
            Support](../../using/install/data_center_install.html#c-support){.reference
            .internal}
        -   [Installation on the
            Host](../../using/install/data_center_install.html#installation-on-the-host){.reference
            .internal}
            -   [CUDA Runtime
                Libraries](../../using/install/data_center_install.html#cuda-runtime-libraries){.reference
                .internal}
            -   [MPI](../../using/install/data_center_install.html#mpi){.reference
                .internal}
-   [Integration](../../using/integration/integration.html){.reference
    .internal}
    -   [Downstream CMake
        Integration](../../using/integration/cmake_app.html){.reference
        .internal}
    -   [Combining CUDA with
        CUDA-Q](../../using/integration/cuda_gpu.html){.reference
        .internal}
    -   [Integrating with Third-Party
        Libraries](../../using/integration/libraries.html){.reference
        .internal}
        -   [Calling a CUDA-Q library from
            C++](../../using/integration/libraries.html#calling-a-cuda-q-library-from-c){.reference
            .internal}
        -   [Calling an C++ library from
            CUDA-Q](../../using/integration/libraries.html#calling-an-c-library-from-cuda-q){.reference
            .internal}
        -   [Interfacing between binaries compiled with a different
            toolchains](../../using/integration/libraries.html#interfacing-between-binaries-compiled-with-a-different-toolchains){.reference
            .internal}
-   [Extending](../../using/extending/extending.html){.reference
    .internal}
    -   [Add a new Hardware
        Backend](../../using/extending/backend.html){.reference
        .internal}
        -   [Overview](../../using/extending/backend.html#overview){.reference
            .internal}
        -   [Server Helper
            Implementation](../../using/extending/backend.html#server-helper-implementation){.reference
            .internal}
            -   [Directory
                Structure](../../using/extending/backend.html#directory-structure){.reference
                .internal}
            -   [Server Helper
                Class](../../using/extending/backend.html#server-helper-class){.reference
                .internal}
            -   [[`CMakeLists.txt`{.docutils .literal
                .notranslate}]{.pre}](../../using/extending/backend.html#cmakelists-txt){.reference
                .internal}
        -   [Target
            Configuration](../../using/extending/backend.html#target-configuration){.reference
            .internal}
            -   [Update Parent [`CMakeLists.txt`{.docutils .literal
                .notranslate}]{.pre}](../../using/extending/backend.html#update-parent-cmakelists-txt){.reference
                .internal}
        -   [Testing](../../using/extending/backend.html#testing){.reference
            .internal}
            -   [Unit
                Tests](../../using/extending/backend.html#unit-tests){.reference
                .internal}
            -   [Mock
                Server](../../using/extending/backend.html#mock-server){.reference
                .internal}
            -   [Python
                Tests](../../using/extending/backend.html#python-tests){.reference
                .internal}
            -   [Integration
                Tests](../../using/extending/backend.html#integration-tests){.reference
                .internal}
        -   [Documentation](../../using/extending/backend.html#documentation){.reference
            .internal}
        -   [Example
            Usage](../../using/extending/backend.html#example-usage){.reference
            .internal}
        -   [Code
            Review](../../using/extending/backend.html#code-review){.reference
            .internal}
        -   [Maintaining a
            Backend](../../using/extending/backend.html#maintaining-a-backend){.reference
            .internal}
        -   [Conclusion](../../using/extending/backend.html#conclusion){.reference
            .internal}
    -   [Create a new NVQIR
        Simulator](../../using/extending/nvqir_simulator.html){.reference
        .internal}
        -   [[`CircuitSimulator`{.code .docutils .literal
            .notranslate}]{.pre}](../../using/extending/nvqir_simulator.html#circuitsimulator){.reference
            .internal}
        -   [Let's see this in
            action](../../using/extending/nvqir_simulator.html#let-s-see-this-in-action){.reference
            .internal}
    -   [Working with CUDA-Q
        IR](../../using/extending/cudaq_ir.html){.reference .internal}
    -   [Create an MLIR Pass for
        CUDA-Q](../../using/extending/mlir_pass.html){.reference
        .internal}
-   [Specifications](../../specification/index.html){.reference
    .internal}
    -   [Language
        Specification](../../specification/cudaq.html){.reference
        .internal}
        -   [1. Machine
            Model](../../specification/cudaq/machine_model.html){.reference
            .internal}
        -   [2. Namespace and
            Standard](../../specification/cudaq/namespace.html){.reference
            .internal}
        -   [3. Quantum
            Types](../../specification/cudaq/types.html){.reference
            .internal}
            -   [3.1. [`cudaq::qudit<Levels>`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/types.html#cudaq-qudit-levels){.reference
                .internal}
            -   [3.2. [`cudaq::qubit`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/types.html#cudaq-qubit){.reference
                .internal}
            -   [3.3. Quantum
                Containers](../../specification/cudaq/types.html#quantum-containers){.reference
                .internal}
        -   [4. Quantum
            Operators](../../specification/cudaq/operators.html){.reference
            .internal}
            -   [4.1. [`cudaq::spin_op`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/operators.html#cudaq-spin-op){.reference
                .internal}
        -   [5. Quantum
            Operations](../../specification/cudaq/operations.html){.reference
            .internal}
            -   [5.1. Operations on [`cudaq::qubit`{.code .docutils
                .literal
                .notranslate}]{.pre}](../../specification/cudaq/operations.html#operations-on-cudaq-qubit){.reference
                .internal}
        -   [6. Quantum
            Kernels](../../specification/cudaq/kernels.html){.reference
            .internal}
        -   [7. Sub-circuit
            Synthesis](../../specification/cudaq/synthesis.html){.reference
            .internal}
        -   [8. Control
            Flow](../../specification/cudaq/control_flow.html){.reference
            .internal}
        -   [9. Just-in-Time Kernel
            Creation](../../specification/cudaq/dynamic_kernels.html){.reference
            .internal}
        -   [10. Quantum
            Patterns](../../specification/cudaq/patterns.html){.reference
            .internal}
            -   [10.1.
                Compute-Action-Uncompute](../../specification/cudaq/patterns.html#compute-action-uncompute){.reference
                .internal}
        -   [11.
            Platform](../../specification/cudaq/platform.html){.reference
            .internal}
        -   [12. Algorithmic
            Primitives](../../specification/cudaq/algorithmic_primitives.html){.reference
            .internal}
            -   [12.1. [`cudaq::sample`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/algorithmic_primitives.html#cudaq-sample){.reference
                .internal}
            -   [12.2. [`cudaq::run`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/algorithmic_primitives.html#cudaq-run){.reference
                .internal}
            -   [12.3. [`cudaq::observe`{.code .docutils .literal
                .notranslate}]{.pre}](../../specification/cudaq/algorithmic_primitives.html#cudaq-observe){.reference
                .internal}
            -   [12.4. [`cudaq::optimizer`{.code .docutils .literal
                .notranslate}]{.pre} (deprecated, functionality moved to
                CUDA-Q
                libraries)](../../specification/cudaq/algorithmic_primitives.html#cudaq-optimizer-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
            -   [12.5. [`cudaq::gradient`{.code .docutils .literal
                .notranslate}]{.pre} (deprecated, functionality moved to
                CUDA-Q
                libraries)](../../specification/cudaq/algorithmic_primitives.html#cudaq-gradient-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
        -   [13. Example
            Programs](../../specification/cudaq/examples.html){.reference
            .internal}
            -   [13.1. Hello World - Simple Bell
                State](../../specification/cudaq/examples.html#hello-world-simple-bell-state){.reference
                .internal}
            -   [13.2. GHZ State Preparation and
                Sampling](../../specification/cudaq/examples.html#ghz-state-preparation-and-sampling){.reference
                .internal}
            -   [13.3. Quantum Phase
                Estimation](../../specification/cudaq/examples.html#quantum-phase-estimation){.reference
                .internal}
            -   [13.4. Deuteron Binding Energy Parameter
                Sweep](../../specification/cudaq/examples.html#deuteron-binding-energy-parameter-sweep){.reference
                .internal}
            -   [13.5. Grover's
                Algorithm](../../specification/cudaq/examples.html#grover-s-algorithm){.reference
                .internal}
            -   [13.6. Iterative Phase
                Estimation](../../specification/cudaq/examples.html#iterative-phase-estimation){.reference
                .internal}
    -   [Quake
        Specification](../../specification/quake-dialect.html){.reference
        .internal}
        -   [General
            Introduction](../../specification/quake-dialect.html#general-introduction){.reference
            .internal}
        -   [Motivation](../../specification/quake-dialect.html#motivation){.reference
            .internal}
-   [API Reference](../../api/api.html){.reference .internal}
    -   [C++ API](../../api/languages/cpp_api.html){.reference
        .internal}
        -   [Operators](../../api/languages/cpp_api.html#operators){.reference
            .internal}
        -   [Quantum](../../api/languages/cpp_api.html#quantum){.reference
            .internal}
        -   [Common](../../api/languages/cpp_api.html#common){.reference
            .internal}
        -   [Noise
            Modeling](../../api/languages/cpp_api.html#noise-modeling){.reference
            .internal}
        -   [Kernel
            Builder](../../api/languages/cpp_api.html#kernel-builder){.reference
            .internal}
        -   [Algorithms](../../api/languages/cpp_api.html#algorithms){.reference
            .internal}
        -   [Platform](../../api/languages/cpp_api.html#platform){.reference
            .internal}
        -   [Utilities](../../api/languages/cpp_api.html#utilities){.reference
            .internal}
        -   [Namespaces](../../api/languages/cpp_api.html#namespaces){.reference
            .internal}
    -   [Python API](../../api/languages/python_api.html){.reference
        .internal}
        -   [Program
            Construction](../../api/languages/python_api.html#program-construction){.reference
            .internal}
            -   [[`make_kernel()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.make_kernel){.reference
                .internal}
            -   [[`PyKernel`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.PyKernel){.reference
                .internal}
            -   [[`Kernel`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Kernel){.reference
                .internal}
            -   [[`PyKernelDecorator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.PyKernelDecorator){.reference
                .internal}
            -   [[`kernel()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.kernel){.reference
                .internal}
        -   [Kernel
            Execution](../../api/languages/python_api.html#kernel-execution){.reference
            .internal}
            -   [[`sample()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.sample){.reference
                .internal}
            -   [[`sample_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.sample_async){.reference
                .internal}
            -   [[`run()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.run){.reference
                .internal}
            -   [[`run_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.run_async){.reference
                .internal}
            -   [[`observe()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.observe){.reference
                .internal}
            -   [[`observe_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.observe_async){.reference
                .internal}
            -   [[`get_state()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_state){.reference
                .internal}
            -   [[`get_state_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_state_async){.reference
                .internal}
            -   [[`vqe()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.vqe){.reference
                .internal}
            -   [[`draw()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.draw){.reference
                .internal}
            -   [[`translate()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.translate){.reference
                .internal}
            -   [[`estimate_resources()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.estimate_resources){.reference
                .internal}
        -   [Backend
            Configuration](../../api/languages/python_api.html#backend-configuration){.reference
            .internal}
            -   [[`has_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.has_target){.reference
                .internal}
            -   [[`get_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_target){.reference
                .internal}
            -   [[`get_targets()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.get_targets){.reference
                .internal}
            -   [[`set_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.set_target){.reference
                .internal}
            -   [[`reset_target()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.reset_target){.reference
                .internal}
            -   [[`set_noise()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.set_noise){.reference
                .internal}
            -   [[`unset_noise()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.unset_noise){.reference
                .internal}
            -   [[`register_set_target_callback()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.register_set_target_callback){.reference
                .internal}
            -   [[`unregister_set_target_callback()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.unregister_set_target_callback){.reference
                .internal}
            -   [[`cudaq.apply_noise()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.cudaq.apply_noise){.reference
                .internal}
            -   [[`initialize_cudaq()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.initialize_cudaq){.reference
                .internal}
            -   [[`num_available_gpus()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.num_available_gpus){.reference
                .internal}
            -   [[`set_random_seed()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.set_random_seed){.reference
                .internal}
        -   [Dynamics](../../api/languages/python_api.html#dynamics){.reference
            .internal}
            -   [[`evolve()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.evolve){.reference
                .internal}
            -   [[`evolve_async()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.evolve_async){.reference
                .internal}
            -   [[`Schedule`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Schedule){.reference
                .internal}
            -   [[`BaseIntegrator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.dynamics.integrator.BaseIntegrator){.reference
                .internal}
            -   [[`InitialState`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.dynamics.helpers.InitialState){.reference
                .internal}
            -   [[`InitialStateType`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.InitialStateType){.reference
                .internal}
            -   [[`IntermediateResultSave`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.IntermediateResultSave){.reference
                .internal}
        -   [Operators](../../api/languages/python_api.html#operators){.reference
            .internal}
            -   [[`OperatorSum`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.OperatorSum){.reference
                .internal}
            -   [[`ProductOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.ProductOperator){.reference
                .internal}
            -   [[`ElementaryOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.ElementaryOperator){.reference
                .internal}
            -   [[`ScalarOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.ScalarOperator){.reference
                .internal}
            -   [[`RydbergHamiltonian`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.RydbergHamiltonian){.reference
                .internal}
            -   [[`SuperOperator`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.SuperOperator){.reference
                .internal}
            -   [[`operators.define()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.define){.reference
                .internal}
            -   [[`operators.instantiate()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.operators.instantiate){.reference
                .internal}
            -   [Spin
                Operators](../../api/languages/python_api.html#spin-operators){.reference
                .internal}
            -   [Fermion
                Operators](../../api/languages/python_api.html#fermion-operators){.reference
                .internal}
            -   [Boson
                Operators](../../api/languages/python_api.html#boson-operators){.reference
                .internal}
            -   [General
                Operators](../../api/languages/python_api.html#general-operators){.reference
                .internal}
        -   [Data
            Types](../../api/languages/python_api.html#data-types){.reference
            .internal}
            -   [[`SimulationPrecision`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.SimulationPrecision){.reference
                .internal}
            -   [[`Target`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Target){.reference
                .internal}
            -   [[`State`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.State){.reference
                .internal}
            -   [[`Tensor`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Tensor){.reference
                .internal}
            -   [[`QuakeValue`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.QuakeValue){.reference
                .internal}
            -   [[`qubit`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.qubit){.reference
                .internal}
            -   [[`qreg`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.qreg){.reference
                .internal}
            -   [[`qvector`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.qvector){.reference
                .internal}
            -   [[`ComplexMatrix`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.ComplexMatrix){.reference
                .internal}
            -   [[`SampleResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.SampleResult){.reference
                .internal}
            -   [[`AsyncSampleResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncSampleResult){.reference
                .internal}
            -   [[`ObserveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.ObserveResult){.reference
                .internal}
            -   [[`AsyncObserveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncObserveResult){.reference
                .internal}
            -   [[`AsyncStateResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncStateResult){.reference
                .internal}
            -   [[`OptimizationResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.OptimizationResult){.reference
                .internal}
            -   [[`EvolveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.EvolveResult){.reference
                .internal}
            -   [[`AsyncEvolveResult`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.AsyncEvolveResult){.reference
                .internal}
            -   [[`Resources`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.Resources){.reference
                .internal}
            -   [Optimizers](../../api/languages/python_api.html#optimizers){.reference
                .internal}
            -   [Gradients](../../api/languages/python_api.html#gradients){.reference
                .internal}
            -   [Noisy
                Simulation](../../api/languages/python_api.html#noisy-simulation){.reference
                .internal}
        -   [MPI
            Submodule](../../api/languages/python_api.html#mpi-submodule){.reference
            .internal}
            -   [[`initialize()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.initialize){.reference
                .internal}
            -   [[`rank()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.rank){.reference
                .internal}
            -   [[`num_ranks()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.num_ranks){.reference
                .internal}
            -   [[`all_gather()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.all_gather){.reference
                .internal}
            -   [[`broadcast()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.broadcast){.reference
                .internal}
            -   [[`is_initialized()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.is_initialized){.reference
                .internal}
            -   [[`finalize()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.mpi.finalize){.reference
                .internal}
        -   [ORCA
            Submodule](../../api/languages/python_api.html#orca-submodule){.reference
            .internal}
            -   [[`sample()`{.docutils .literal
                .notranslate}]{.pre}](../../api/languages/python_api.html#cudaq.orca.sample){.reference
                .internal}
    -   [Quantum Operations](../../api/default_ops.html){.reference
        .internal}
        -   [Unitary Operations on
            Qubits](../../api/default_ops.html#unitary-operations-on-qubits){.reference
            .internal}
            -   [[`x`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#x){.reference
                .internal}
            -   [[`y`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#y){.reference
                .internal}
            -   [[`z`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#z){.reference
                .internal}
            -   [[`h`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#h){.reference
                .internal}
            -   [[`r1`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#r1){.reference
                .internal}
            -   [[`rx`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#rx){.reference
                .internal}
            -   [[`ry`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#ry){.reference
                .internal}
            -   [[`rz`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#rz){.reference
                .internal}
            -   [[`s`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#s){.reference
                .internal}
            -   [[`t`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#t){.reference
                .internal}
            -   [[`swap`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#swap){.reference
                .internal}
            -   [[`u3`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#u3){.reference
                .internal}
        -   [Adjoint and Controlled
            Operations](../../api/default_ops.html#adjoint-and-controlled-operations){.reference
            .internal}
        -   [Measurements on
            Qubits](../../api/default_ops.html#measurements-on-qubits){.reference
            .internal}
            -   [[`mz`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#mz){.reference
                .internal}
            -   [[`mx`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#mx){.reference
                .internal}
            -   [[`my`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#my){.reference
                .internal}
        -   [User-Defined Custom
            Operations](../../api/default_ops.html#user-defined-custom-operations){.reference
            .internal}
        -   [Photonic Operations on
            Qudits](../../api/default_ops.html#photonic-operations-on-qudits){.reference
            .internal}
            -   [[`create`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#create){.reference
                .internal}
            -   [[`annihilate`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#annihilate){.reference
                .internal}
            -   [[`phase_shift`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#phase-shift){.reference
                .internal}
            -   [[`beam_splitter`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#beam-splitter){.reference
                .internal}
            -   [[`mz`{.code .docutils .literal
                .notranslate}]{.pre}](../../api/default_ops.html#id1){.reference
                .internal}
-   [Other Versions](../../versions.html){.reference .internal}
:::
:::

::: {.section .wy-nav-content-wrap toggle="wy-nav-shift"}
[NVIDIA CUDA-Q](../../index.html)

::: wy-nav-content
::: rst-content
::: {role="navigation" aria-label="Page navigation"}
-   [](../../index.html){.icon .icon-home aria-label="Home"}
-   [CUDA-Q Applications](../../using/applications.html)
-   Compiling Unitaries Using Diffusion Models
-   

::: {.rst-breadcrumbs-buttons role="navigation" aria-label="Sequential page navigation"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](readout_error_mitigation.html "Readout Error Mitigation"){.btn
.btn-neutral .float-left accesskey="p"} [Next []{.fa
.fa-arrow-circle-right
aria-hidden="true"}](vqe_advanced.html "VQE with gradients, active spaces, and gate fusion"){.btn
.btn-neutral .float-right accesskey="n"}
:::

------------------------------------------------------------------------
:::

::: {.document role="main" itemscope="itemscope" itemtype="http://schema.org/Article"}
::: {itemprop="articleBody"}
::: {#Compiling-Unitaries-Using-Diffusion-Models .section}
# Compiling Unitaries Using Diffusion Models[¶](#Compiling-Unitaries-Using-Diffusion-Models "Permalink to this heading"){.headerlink}

This tutorial is based on the work presented in

> <div>
>
> ["Synthesis of discrete-continuous quantum circuits with multimodal
> diffusion models", Florian Fürrutter, Zohim Chandani, Ikko Hamamura,
> Hans J. Briegel & Gorka Muñoz-Gil, arXiv.2506.01666
> (2025)](https://doi.org/10.48550/arXiv.2506.01666){.reference
> .external}
>
> </div>

and \> ["Quantum circuit synthesis with diffusion models", Florian
Fürrutter, Gorka Muñoz-Gil & Hans J. Briegel , Nat. Mach. Intell. 6,
515--524 (2024)](https://doi.org/10.1038/s42256-024-00831-9){.reference
.external}.

Quantum computing relies on efficiently translating quantum operations
into viable physical realizations on existing quantum hardware.
Recently, diffusion models --- a powerful class of generative models in
machine learning --- have demonstrated exceptional performance on this
task.

In this tutorial notebook, we will demonstrate how to use this method to
synthesize arbitrary unitaries into a [`cudaq.kernel`{.docutils .literal
.notranslate}]{.pre}, effectively decomposing them into sequences of
quantum gates, a process commonly known as unitary compilation.

Our focus will be on generating circuits using a pre-trained diffusion
model. Specifically, we will illustrate how to compile different
unitaries into discrete quantum gates, based on the methods presented in
[(Fürrutter et al.,
2024)](https://doi.org/10.1038/s42256-024-00831-9){.reference
.external}, and continuous quantum gates, based on [(Fürrutter et al.,
2025)](https://doi.org/10.48550/arXiv.2506.01666){.reference .external}.

::: {#Diffusion-model-pipeline .section}
## Diffusion model pipeline[¶](#Diffusion-model-pipeline "Permalink to this heading"){.headerlink}

Generative diffusion models (DMs) have recently delivered remarkable
results across a wide range of applications, from image generation to
protein folding. In this work, we leverage DMs to generate quantum
circuits based on a user specified unitary matrix and a text prompt that
defines the allowed gate set, effectively using DMs as unitary
compilers. The method is thoroughly explained in Ref. [(Fürrutter et
al., 2024)](https://doi.org/10.1038/s42256-024-00831-9){.reference
.external}. The following figure provides an overview of the proposed
circuit generation pipeline:

<figure>
<p><img src="../../_images/pipeline_simplified.png"
class="no-scaled-link" style="width: 70%;"
alt="Quantum circuit generation pipeline overview" /></p>
<figcaption><p>Quantum circuit generation pipeline. Figure adapted from
(Fürrutter et al., 2024)</p></figcaption>
</figure>

The pipeline consists of 3 main components:

**1) Circuit encoding:** Like any neural network, diffusion models
operate with continuous inputs and outputs. However, since the circuits
we consider are composed of discrete gates (i.e., with no continuous
parameters), we develop a mapping that transforms each gate into a
continuous vector. This allows us to represent a given circuit as a
three-dimensional tensor, as illustrated. Crucially, this mapping is
invertible: when the DM generates continuous tensors, we can apply the
inverse map to convert them back into the circuit form. An overview of
these steps is provided in the figure below:

<figure>
<p><img src="../../_images/circuit_encoding.png" class="no-scaled-link"
style="width: 60%;" alt="Quantum circuit encoding" /></p>
<figcaption><p>Quantum circuit encoding. Figure adapted from (Fürrutter
et al., 2024)</p></figcaption>
</figure>

**2) Conditioning:** The user's input (the set of available gates and
the unitary to compile) is also transformed into a continuous tensor by
two neural networks. For the gate set description, where the input is a
text prompt (e.g., "Compile using \['x', 'h'\]"), we utilize a
pre-trained language model. For the unitary, we employ a neural network
that is trained jointly with the diffusion model.

**3) Unitary compilation:** The generation procedure follows the typical
DM process: the model is given a fully noisy tensor which is iteratively
de-noised until reaching a clean sample based on the given conditioning
(the desired unitary and gate set). The tensors generated by the DM are
then mapped to circuits via the inverse encoding procedure. To learn
more about the practical implementation of diffusion models we recommend
[this tutorial](https://course.fast.ai/Lessons/lesson9.html){.reference
.external}.

In the following, we will use [`cudaq`{.docutils .literal
.notranslate}]{.pre} and [`` `genQC ``{.docutils .literal
.notranslate}]{.pre}
\<[https://github.com/FlorianFuerrutter/genQC](https://github.com/FlorianFuerrutter/genQC){.reference
.external}\>\`\_\_ to perform all these steps and go from a desired
unitary matrix [\\(U\\)]{.math .notranslate .nohighlight} to a quantum
circuit that we can execute using CUDA-Q.

> <div>
>
> **Extension to discrete-continuous quantum circuits:** Recently, in
> [Fürrutter et al.
> (2025)](https://doi.org/10.48550/arXiv.2506.01666){.reference
> .external}, the authors introduced the next generation of compilation
> models, utilizing not only discrete gates but also continuous quantum
> gates in a multimodal diffusion model. We refer interested readers to
> the paper for more advanced details on the method. Moreover, we will
> also cover its use in the sections below.
>
> </div>
:::

::: {#Setup-and-load-models .section}
## Setup and load models[¶](#Setup-and-load-models "Permalink to this heading"){.headerlink}

First, we make sure we have a compatible version of [`genQC`{.docutils
.literal .notranslate}]{.pre}
([github.com/FlorianFuerrutter/genQC](https://github.com/FlorianFuerrutter/genQC){.reference
.external}) installed.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    !pip install genQC==0.2.3 torch --break-system-packages -q
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    import cudaq
    import torch
    import numpy as np
    import genQC

    import genQC.utils.misc_utils as util
    from genQC.pipeline.diffusion_pipeline import DiffusionPipeline
    from genQC.pipeline.multimodal_diffusion_pipeline \
                import MultimodalDiffusionPipeline_ParametrizedCompilation

    from genQC.platform.tokenizer.circuits_tokenizer import CircuitTokenizer
    from genQC.platform.simulation import Simulator, CircuitBackendType
    from genQC.scheduler.scheduler_dpm import DPMScheduler

    from genQC.inference.sampling \
                import decode_tensors_to_backend, generate_compilation_tensors
    from genQC.inference.evaluation_helper import get_unitaries
    from genQC.inference.eval_metrics import UnitaryInfidelityNorm
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    device = util.infer_torch_device() # Use CUDA if we have a GPU
    print(device)
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    [INFO]: Cuda device has a capability of 8.6 (>= 8), allowing tf32 matmul.
    cuda
:::
:::
:::

In this tutorial, we will use a small and a large pre-trained diffusion
model (up to \~300M parameters). We only run the large model if we have
a GPU available, such we have a reasonable computation time of the
notebook for CPU-only machines.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    # Flag to only run large model if GPU available
    RUN_LARGE_MODEL = ( device == torch.device("cuda") )
    print(RUN_LARGE_MODEL)
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    True
:::
:::
:::

We set a fixed seed for reproducibility.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    # We set a seed to pytorch, numpy and python.
    # Note: This will also set deterministic cuda algorithms, possibly at the cost of reduced performance!
    util.set_seed(0)
:::
:::
:::

For evaluation, we also need to specify the [`cudaq`{.docutils .literal
.notranslate}]{.pre} circuit simulator backend.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    simulator = Simulator(CircuitBackendType.CUDAQ,
                          target='qpp-cpu')  # Target for cudaq, note that cpu is faster for low qubit kernels
:::
:::
:::

::: {#Load-discrete-model .section}
### Load discrete model[¶](#Load-discrete-model "Permalink to this heading"){.headerlink}

First, we load pre-trained model weights for a discrete model directly
from [Hugging Face:
Floki00/qc_unitary_3qubit](https://huggingface.co/Floki00/qc_unitary_3qubit){.reference
.external} and setup the DM pipeline. For details of the model we refer
to the paper [Fürrutter et al.,
2024](https://doi.org/10.1038/s42256-024-00831-9){.reference .external}.
Note that this model is only trained on 3 qubit unitaries up to 12
gates.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    discrete_pipeline = DiffusionPipeline.from_pretrained(
                repo_id="Floki00/qc_unitary_3qubit", # Download model from Hugging Face
                device=device)
:::
:::
:::

The loaded discrete model is trained with the discrete gate set:

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    discrete_pipeline.gate_pool
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    ['h', 'cx', 'z', 'x', 'ccx', 'swap']
:::
:::
:::

which we need in order to define the [`discrete_vocabulary`{.docutils
.literal .notranslate}]{.pre} and create a [`CircuitTokenizer`{.docutils
.literal .notranslate}]{.pre}, allowing us to decode tokenized circuits
generated by the model.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    discrete_vocabulary = {g:i+1 for i, g in enumerate(discrete_pipeline.gate_pool)}
    discrete_tokenizer  = CircuitTokenizer(discrete_vocabulary)
    discrete_tokenizer.vocabulary
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    {'h': 1, 'cx': 2, 'z': 3, 'x': 4, 'ccx': 5, 'swap': 6}
:::
:::
:::

Set parameters the model was trained on. Note that these are fixed and
depend on the pre-trained model.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    # These parameters are specific to our pre-trained model.
    discrete_system_size   = 3
    discrete_max_gates     = 12
:::
:::
:::

**Set inference parameters**

Then, we setup diffusion model inference parameters. These can be
changed in principle, as they are sample hyperparameters.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    timesteps = 40
    discrete_pipeline.scheduler.set_timesteps(timesteps)
:::
:::
:::
:::

::: {#Load-continuous-model .section}
### Load continuous model[¶](#Load-continuous-model "Permalink to this heading"){.headerlink}

Next, we load pre-trained model weights for a discrete-continuous model
directly from [Hugging Face:
Floki00/cirdit_multimodal_compile_3to5qubit](https://huggingface.co/Floki00/cirdit_multimodal_compile_3to5qubit){.reference
.external} and setup the DM pipeline. For details of the model, we refer
to the paper [Fürrutter et al.,
2025](https://doi.org/10.48550/arXiv.2506.01666){.reference .external}.
Note that this model is trained on 3 to 5 qubit unitaries up to 32
gates.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    cont_pipeline = MultimodalDiffusionPipeline_ParametrizedCompilation.from_pretrained(
        repo_id="Floki00/cirdit_multimodal_compile_3to5qubit", # Download model from Hugging Face
        device=device)
:::
:::
:::

The loaded continuous model is trained with the discrete and continuous
gate set:

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    cont_pipeline.gate_pool
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    ['h', 'cx', 'ccx', 'swap', 'rx', 'ry', 'rz', 'cp']
:::
:::
:::

which we then use in order to define the [`cont_vocabulary`{.docutils
.literal .notranslate}]{.pre} and create a [`CircuitTokenizer`{.docutils
.literal .notranslate}]{.pre}, allowing us to decode tokenized circuits
generated by the model.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    cont_vocabulary = {g:i+1 for i, g in enumerate(cont_pipeline.gate_pool)}
    cont_tokenizer  = CircuitTokenizer(cont_vocabulary)
    cont_tokenizer.vocabulary
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    {'h': 1, 'cx': 2, 'ccx': 3, 'swap': 4, 'rx': 5, 'ry': 6, 'rz': 7, 'cp': 8}
:::
:::
:::

Now we set parameters the model was trained on. Note that these are
fixed and depend on the pre-trained model.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    # These parameters are specific to our pre-trained model.
    cont_system_size   = 5
    cont_max_gates     = 32
:::
:::
:::

**Set inference parameters**

Again, we setup diffusion model inference parameters. These
hyperparameters can be changed at will, as they define how sampling is
performed from the trained model.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    cont_pipeline.scheduler   = DPMScheduler.from_scheduler(cont_pipeline.scheduler)
    cont_pipeline.scheduler_w = DPMScheduler.from_scheduler(cont_pipeline.scheduler_w)

    timesteps = 40
    cont_pipeline.scheduler.set_timesteps(timesteps)
    cont_pipeline.scheduler_w.set_timesteps(timesteps)

    cont_pipeline.lambda_h = 1.1
    cont_pipeline.lambda_w = 0.4
    cont_pipeline.g_h = 0.4
    cont_pipeline.g_w = 0.1
:::
:::
:::
:::

::: {#Create-helper-functions .section}
### Create helper functions[¶](#Create-helper-functions "Permalink to this heading"){.headerlink}

To facilitate the sampling, evaluating and plotting multiple circuits
for different unitaries, we create some helper functions here.

1.  A function to check that a matrix [`U`{.docutils .literal
    .notranslate}]{.pre} is indeed unitary, i.e. [\\(U\^{\\dagger} U = U
    U\^{\\dagger} = I\\)]{.math .notranslate .nohighlight}.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    def verify_unitary(U: torch.Tensor):
        """Check if unitary."""
        assert torch.allclose(U.adjoint() @ U, torch.eye(2**num_of_qubits, dtype=U.dtype))
        assert torch.allclose(U @ U.adjoint(), torch.eye(2**num_of_qubits, dtype=U.dtype))
:::
:::
:::

2.  A function to sample the DM and return generated kernels with
    coresponding infidelities.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    def sample_kernels_and_evaluate(U: torch.Tensor,
                                    prompt: str,
                                    num_of_qubits: int,
                                    samples: int,
                                    discrete_model: bool,
                                    return_tensors: bool = False):
        """
        Sample the DM and return generated kernels with coresponding infidelities.
        """

        # 1) Check if unitary
        verify_unitary(U)

        # 2) Generate tensor representations using the DM based on the prompt and U.
        U = U.to(torch.complex64)

        if discrete_model:
            # Sample discrete model
            out_tensor = generate_compilation_tensors(discrete_pipeline,
                                      prompt=prompt,
                                      U=U,
                                      samples=samples,      # How many circuits we sample per unitary
                                      system_size=discrete_system_size,
                                      num_of_qubits=num_of_qubits,
                                      max_gates=discrete_max_gates,
                                      g=10.0,               # classifier-free-guidance (CFG) scale
                                      no_bar=False,         # show progress bar
                                      auto_batch_size=256,  # for less GPU memory usage limit batch size
                                      tensor_prod_pad=False,
                                      enable_params=False,
                                     )
            tokenizer = discrete_tokenizer
            params    = None

        else:
            if not RUN_LARGE_MODEL:
                print(f">> Skipped sampling large model. Flag: {RUN_LARGE_MODEL=} <<")
                if return_tensors:
                    return [], [], []
                return [], []

            # Sample continuous model
            out_tensor, params = generate_compilation_tensors(cont_pipeline,
                                      prompt=prompt,
                                      U=U,
                                      samples=samples,     # How many circuits we sample per unitary
                                      system_size=cont_system_size,
                                      num_of_qubits=num_of_qubits,
                                      max_gates=cont_max_gates,
                                      no_bar=False,        # show progress bar
                                      auto_batch_size=256, # for less GPU memory usage limit batch size
                                     )
            tokenizer = cont_tokenizer

        # 3) Convert tensors to kernels
        generated_kernels, _, generated_tensors = decode_tensors_to_backend(simulator=simulator,
                                                         tokenizer=tokenizer,
                                                         tensors=out_tensor,
                                                         params=params,
                                                         return_tensors=True)

        # 4) Evaluate the kernels and return the unitaries
        generated_us = get_unitaries(simulator, generated_kernels, num_qubits=num_of_qubits)

        # 5) Calculate the infidelities to the target U
        infidelities = UnitaryInfidelityNorm.distance(
                        approx_U=torch.from_numpy(np.stack(generated_us)).to(torch.complex128),
                        target_U=U.unsqueeze(0).to(torch.complex128))

        if return_tensors:
            return generated_kernels, infidelities, generated_tensors
        return generated_kernels, infidelities
:::
:::
:::

3.  A function to plot the [`topk`{.docutils .literal
    .notranslate}]{.pre} best generated kernels.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    def plot_topk_kernels(generated_kernels: list,
                          infidelities: torch.Tensor,
                          num_of_qubits:int,
                          topk: int):
        """
        Plot the topk best generated kernels.
        """

        # Get topk indices
        best_indices = np.argsort(infidelities)[:topk]

        input_state = [0] * (2**num_of_qubits)
        input_state[0] = 1

        # Print the circuits
        for i, best_index in enumerate(best_indices):
            kernel = generated_kernels[best_index].kernel
            thetas = generated_kernels[best_index].params

            print(f"Circuit has an infidelity of {infidelities[best_index].item():0.1e}.")
            print(cudaq.draw(kernel, input_state, thetas))
:::
:::
:::
:::
:::

::: {#Unitary-compilation .section}
## Unitary compilation[¶](#Unitary-compilation "Permalink to this heading"){.headerlink}

We start by defining the unitaries we want to compile and then sample
the corresponding DM. Note that these models have been trained to
compile unitaries that arise from circuits composed of the gates
contained in their [`vocabulary`{.docutils .literal
.notranslate}]{.pre}. While these are universal gate sets, i.e. they can
perform universal computation, they can only do so with an
arbitrary-precision for an infinite number of gates. Because the number
of gates in the models are restricted to some [`max_gates`{.docutils
.literal .notranslate}]{.pre} (12 for the discrete model and 32 for the
continuous one), we can only expect the models to generate unitaries
under this constraint. We will consider here the compilation of such
unitaries. Nonetheless, stay tuned for bigger and better models!

::: {#Random-unitary .section}
### Random unitary[¶](#Random-unitary "Permalink to this heading"){.headerlink}

Let's start with a random 3-qubit unitary.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    num_of_qubits = 3
:::
:::
:::

We can define our arbitrary unitary [`U`{.docutils .literal
.notranslate}]{.pre} directly as a complex [`torch.tensor`{.docutils
.literal .notranslate}]{.pre}:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    U = torch.tensor([[0.70710678, 0., 0., 0., 0.70710678, 0., 0., 0.],
                   [0., -0.70710678, 0., 0., 0., -0.70710678, 0., 0.],
                   [-0.70710678, 0., 0., 0., 0.70710678, 0., 0., 0.],
                   [0., 0.70710678, 0., 0., 0., -0.70710678, 0., 0.],
                   [0., 0., 0.70710678, 0., 0., 0., 0., 0.70710678],
                   [0., 0., 0., 0.70710678, 0., 0., 0.70710678, 0.],
                   [0., 0., -0.70710678, 0., 0., 0., 0., 0.70710678],
                   [0., 0., 0., -0.70710678, 0., 0., 0.70710678, 0.]],
                  dtype=torch.complex128)
:::
:::
:::
:::

::: {#Discrete-model .section}
### Discrete model[¶](#Discrete-model "Permalink to this heading"){.headerlink}

The loaded discrete model was trained on the gate set [`['h',`{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'cx',`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'z',`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'x',`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'ccx',`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'swap']`{.docutils .literal .notranslate}]{.pre}.
Specifically, it was trained to generate circuits using any arbitrary
subset of this gate set. Therefore, during inference, we can instruct
the model to compile the unitary using any of these subsets. However, it
is crucial to follow the prompt structure [`Compile`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`using`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`[...]`{.docutils .literal .notranslate}]{.pre}, as the
model was trained with this specific format.

For example, let's consider a scenario where we compile the unitary
without using the [`x`{.docutils .literal .notranslate}]{.pre} gate:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    # Notice how the x gate is missing from the prompt since this is a restriction we set
    prompt = "Compile using: ['h', 'cx', 'z', 'ccx', 'swap']"
:::
:::
:::

Now, we call the diffusion model pipeline to generate encoded circuits
based on the specified conditions: [`prompt`{.docutils .literal
.notranslate}]{.pre} and [`U`{.docutils .literal .notranslate}]{.pre}.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    generated_kernels, infidelities = sample_kernels_and_evaluate(
                                              U=U,
                                              prompt=prompt,
                                              num_of_qubits=num_of_qubits,
                                              samples=128,
                                              discrete_model=True)
:::
:::
:::

::: {.nboutput .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    [INFO]: (generate_comp_tensors) Generated 128 tensors
:::
:::
:::

Next, we plot the best three circuits in the following cell.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    plot_topk_kernels(generated_kernels, infidelities, num_of_qubits, topk=3)
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Circuit has an infidelity of 3.4e-08.
         ╭───╮╭───╮        ╭───╮╭───╮
    q0 : ┤ x ├┤ z ├─────●──┤ z ├┤ z ├──●──
         ╰─┬─╯╰───╯   ╭─┴─╮├───┤╰───╯╭─┴─╮
    q1 : ──●────────╳─┤ x ├┤ z ├─────┤ x ├
           │  ╭───╮ │ ╰─┬─╯╰───╯     ╰─┬─╯
    q2 : ──●──┤ h ├─╳───●──────────────●──
              ╰───╯

    Circuit has an infidelity of 3.4e-08.
         ╭───╮╭───╮
    q0 : ┤ x ├┤ z ├─────●─────────●──
         ╰─┬─╯╰───╯   ╭─┴─╮╭───╮╭─┴─╮
    q1 : ──●────────╳─┤ x ├┤ z ├┤ x ├
           │  ╭───╮ │ ╰─┬─╯╰───╯╰─┬─╯
    q2 : ──●──┤ h ├─╳───●─────────●──
              ╰───╯

    Circuit has an infidelity of 3.4e-08.
         ╭───╮╭───╮
    q0 : ┤ x ├┤ z ├─────●─────────●──
         ╰─┬─╯╰───╯   ╭─┴─╮╭───╮╭─┴─╮
    q1 : ──●────────╳─┤ x ├┤ z ├┤ x ├
           │  ╭───╮ │ ╰─┬─╯╰───╯╰─┬─╯
    q2 : ──●──┤ h ├─╳───●─────────●──
              ╰───╯
:::
:::
:::
:::

::: {#Continuous-model .section}
### Continuous model[¶](#Continuous-model "Permalink to this heading"){.headerlink}

Now we want to compile the same [`U`{.docutils .literal
.notranslate}]{.pre} with the continuous model.

The continuous model was trained on the gate set [`['h',`{.docutils
.literal .notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'cx',`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'ccx',`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'swap',`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'rx',`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'ry',`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'rz',`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`'cp']`{.docutils .literal .notranslate}]{.pre}. As the
discrete model, it was trained to generate circuits using any arbitrary
subset of this gate set. However, it is crucial to follow the prompt
structure [`Compile`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`{num_of_qubits}`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`qubits`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`using:`{.docutils .literal
.notranslate}]{.pre}` `{.docutils .literal
.notranslate}[`[...]`{.docutils .literal .notranslate}]{.pre}, as the
model was trained with this specific format.

For example, let's consider a scenario where we compile the unitary
without using the [`h`{.docutils .literal .notranslate}]{.pre} gate.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    # Notice how the h gate is missing from the prompt since this is a restriction we set
    prompt = f"Compile {num_of_qubits} qubits using: ['cx', 'ccx', 'swap', 'rx', 'ry', 'rz', 'cp']"
:::
:::
:::

Now, we call the diffusion model pipeline to generate encoded circuits
based on the specified conditions: [`prompt`{.docutils .literal
.notranslate}]{.pre} and [`U`{.docutils .literal .notranslate}]{.pre}.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    generated_kernels, infidelities = sample_kernels_and_evaluate(
                                              U=U,
                                              prompt=prompt,
                                              num_of_qubits=num_of_qubits,
                                              samples=64,
                                              discrete_model=False)
:::
:::
:::

::: {.nboutput .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    [INFO]: (generate_comp_tensors) Generated 64 tensors
:::
:::
:::

Next, we plot the best three circuits in the following cell.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    plot_topk_kernels(generated_kernels, infidelities, num_of_qubits, topk=3)
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Circuit has an infidelity of 2.6e-05.
         ╭───╮
    q0 : ┤ x ├────●─────────────●────────●────●────●──
         ╰─┬─╯  ╭─┴─╮           │      ╭─┴─╮  │  ╭─┴─╮
    q1 : ──●────┤ x ├────╳──────┼──────┤ x ├──┼──┤ x ├
           │  ╭─┴───┴──╮ │ ╭────┴─────╮╰───╯╭─┴─╮╰───╯
    q2 : ──●──┤ ry(11) ├─╳─┤ r1(3.15) ├─────┤ x ├─────
              ╰────────╯   ╰──────────╯     ╰───╯

    Circuit has an infidelity of 3.1e-05.
         ╭───╮
    q0 : ┤ x ├──────────────────────●────────●────────●────────●──
         ╰─┬─╯   ╭───────────╮      │        │        │        │
    q1 : ──●───╳─┤ ry(11.01) ├──────┼────────┼────────┼────────┼──
           │   │ ╰───────────╯╭─────┴─────╮╭─┴─╮╭─────┴─────╮╭─┴─╮
    q2 : ──●───╳──────────────┤ r1(6.279) ├┤ x ├┤ r1(3.139) ├┤ x ├
                              ╰───────────╯╰───╯╰───────────╯╰───╯

    Circuit has an infidelity of 3.5e-05.
         ╭───╮
    q0 : ┤ x ├─────●──────────────────●────────●──
         ╰─┬─╯     │  ╭────────╮      │        │
    q1 : ──●───╳───┼──┤ ry(11) ├──────┼────────┼──
           │   │ ╭─┴─╮╰────────╯╭─────┴─────╮╭─┴─╮
    q2 : ──●───╳─┤ x ├──────────┤ r1(3.131) ├┤ x ├
                 ╰───╯          ╰───────────╯╰───╯
:::
:::
:::

Now consider a scenario where we compile the unitary without using the
[`swap`{.docutils .literal .notranslate}]{.pre} gate and see what
changes.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    # Notice how the swap gate is missing from the prompt since this is a restriction we set
    prompt = f"Compile {num_of_qubits} qubits using: ['h', 'cx', 'ccx', 'rx', 'ry', 'rz', 'cp']"
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    generated_kernels, infidelities = sample_kernels_and_evaluate(
                                              U=U,
                                              prompt=prompt,
                                              num_of_qubits=num_of_qubits,
                                              samples=64,
                                              discrete_model=False)
:::
:::
:::

::: {.nboutput .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    [INFO]: (generate_comp_tensors) Generated 64 tensors
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    plot_topk_kernels(generated_kernels, infidelities, num_of_qubits, topk=3)
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Circuit has an infidelity of 1.2e-04.
         ╭───╮
    q0 : ┤ x ├──────●───────────────────────────●────────●──
         ╰─┬─╯    ╭─┴─╮         ╭───╮           │        │
    q1 : ──●──────┤ x ├──────●──┤ x ├──●────────┼────────┼──
           │  ╭───┴───┴───╮╭─┴─╮╰─┬─╯╭─┴─╮╭─────┴─────╮╭─┴─╮
    q2 : ──●──┤ ry(10.99) ├┤ x ├──●──┤ x ├┤ r1(3.167) ├┤ x ├
              ╰───────────╯╰───╯     ╰───╯╰───────────╯╰───╯

    Circuit has an infidelity of 1.9e-04.
         ╭───╮    ╭───╮         ╭───╮╭───────────╮
    q0 : ┤ x ├────┤ h ├─────────┤ x ├┤ ry(10.97) ├─────
         ╰─┬─╯    ╰───╯         ╰─┬─╯╰───┬───┬───╯
    q1 : ──●─────────────────●────●──────┤ x ├──────●──
           │  ╭───────────╮╭─┴─╮         ╰─┬─╯    ╭─┴─╮
    q2 : ──●──┤ ry(10.99) ├┤ x ├───────────●──────┤ x ├
              ╰───────────╯╰───╯                  ╰───╯

    Circuit has an infidelity of 2.7e-04.
         ╭───╮  ╭───╮                  ╭───╮╭───────────╮
    q0 : ┤ x ├──┤ h ├──────────────────┤ x ├┤ ry(10.96) ├
         ╰─┬─╯  ╰───╯   ╭───╮     ╭───╮╰─┬─╯╰───────────╯
    q1 : ──●────────────┤ x ├──●──┤ x ├──┼───────────────
           │  ╭────────╮╰─┬─╯╭─┴─╮╰─┬─╯  │
    q2 : ──●──┤ ry(11) ├──●──┤ x ├──●────●───────────────
              ╰────────╯     ╰───╯
:::
:::
:::

Interestingly, we can see that the model correctly uses the replacement
of a [`swap`{.docutils .literal .notranslate}]{.pre} operation with 3
[`cx`{.docutils .literal .notranslate}]{.pre} gates!
:::

::: {#Quantum-Fourier-transform .section}
### Quantum Fourier transform[¶](#Quantum-Fourier-transform "Permalink to this heading"){.headerlink}

We now turn ourselves to more interesting unitary. For instance, let's
compile the 4-qubit Quantum Fourier transform (QFT) unitary, defined as

::: {.math .notranslate .nohighlight}
\\\[\\begin{equation} \\mathrm{QFT}: \|x\\rangle \\mapsto
\\frac{1}{\\sqrt{N}} \\sum\_{k=0}\^{N-1} \\omega_N\^{xk}\\;\|k\\rangle,
\\end{equation}\\\]
:::

where

::: {.math .notranslate .nohighlight}
\\\[\\begin{equation} \\omega_N=\\exp{\\frac{2\\pi i}{N}}
\\quad\\text{and}\\quad N=2\^{\\text{qubits}}. \\end{equation}\\\]
:::

For this task, we use the continuous model.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    num_of_qubits = 4
    prompt        = f"Compile {num_of_qubits} qubits using: ['h', 'cx', 'ccx', 'swap', 'rx', 'ry', 'rz', 'cp']"
:::
:::
:::

We can get the QFT unitary from [`genqc`{.docutils .literal
.notranslate}]{.pre}:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    from genQC.benchmark.bench_compilation import SpecialUnitaries
    U = SpecialUnitaries.QFT(num_of_qubits)
:::
:::
:::

As before, we sample and plot the best circuits

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    generated_kernels, infidelities = sample_kernels_and_evaluate(
                                              U=U,
                                              prompt=prompt,
                                              num_of_qubits=num_of_qubits,
                                              samples=64,
                                              discrete_model=False)
:::
:::
:::

::: {.nboutput .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    [INFO]: (generate_comp_tensors) Generated 64 tensors
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    plot_topk_kernels(generated_kernels, infidelities, num_of_qubits, topk=2)
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Circuit has an infidelity of 1.6e-02.
            ╭───╮                                                            »
    q0 : ─╳─┤ h ├──────●────────────●────────────●───────────────────────────»
          │ ╰───╯      │            │            │                           »
    q1 : ─┼────────────┼────────────┼────────────┼─────────────────●───────╳─»
          │            │      ╭─────┴─────╮      │      ╭───╮╭─────┴─────╮ │ »
    q2 : ─┼────────────┼──────┤ r1(1.617) ├──────┼──────┤ h ├┤ r1(1.687) ├─╳─»
          │      ╭─────┴─────╮╰───────────╯╭─────┴─────╮╰───╯╰───────────╯   »
    q3 : ─╳──────┤ r1(7.905) ├─────────────┤ r1(11.37) ├─────────────────────»
                 ╰───────────╯             ╰───────────╯                     »

    ################################################################################


    ──────●────────────────────────────────────────────
          │
    ──────┼──────────────────●─────────────────────────
    ╭─────┴──────╮╭───╮      │
    ┤ r1(0.8472) ├┤ h ├──────┼─────────────●───────────
    ╰────────────╯╰───╯╭─────┴──────╮╭─────┴─────╮╭───╮
    ───────────────────┤ r1(0.9612) ├┤ r1(7.672) ├┤ h ├
                       ╰────────────╯╰───────────╯╰───╯

    Circuit has an infidelity of 4.5e-02.
                                                                              »
    q0 : ────────────────────────╳───────●────────────────────────────────────»
                                 │ ╭─────┴──────╮                             »
    q1 : ────────────────────────┼─┤ r1(0.8751) ├──────●────────────────────╳─»
                           ╭───╮ │ ╰────────────╯╭─────┴─────╮              │ »
    q2 : ───────────●──────┤ h ├─┼───────────────┤ r1(7.991) ├──────●───────╳─»
         ╭───╮╭─────┴─────╮╰───╯ │               ╰───────────╯╭─────┴─────╮   »
    q3 : ┤ h ├┤ r1(1.796) ├──────╳────────────────────────────┤ r1(7.399) ├───»
         ╰───╯╰───────────╯                                   ╰───────────╯   »

    ################################################################################


    ───────────────────────

    ───────────────────────
    ╭───╮
    ┤ h ├──────●───────────
    ╰───╯╭─────┴─────╮╭───╮
    ─────┤ r1(1.437) ├┤ h ├
         ╰───────────╯╰───╯
:::
:::
:::
:::

::: {#XXZ-Hamiltonian-evolution .section}
### XXZ-Hamiltonian evolution[¶](#XXZ-Hamiltonian-evolution "Permalink to this heading"){.headerlink}

Another interesting application is the compilation of the unitary
evolution of given Hamiltonians. Here, we showcase this by compiling the
evolution unitary [\\(U(\\tau)=\\exp(-i \\tau H)\\)]{.math .notranslate
.nohighlight} of the XXZ-Hamiltonian, defined as

::: {.math .notranslate .nohighlight}
\\\[H\_\\text{xxz} = -J \\sum\_{\\langle i, j \\rangle} ( X_i X_j + Y_i
Y_j + \\Delta Z_i Z_j ) - h \\sum\_{i=0}\^{n-1} X_i,\\\]
:::

where [\\(J\\)]{.math .notranslate .nohighlight} is the coupling
constant, [\\(\\Delta\\)]{.math .notranslate .nohighlight} a
perturbation and [\\(h\\)]{.math .notranslate .nohighlight} a magnetic
field. We consider here the case in which the [\\(n\\)]{.math
.notranslate .nohighlight} qubits of the quantum circuit represent the
spins of a non-periodic one-dimensional chain, where we write
neighboring spins [\\(i\\)]{.math .notranslate .nohighlight} and
[\\(j\\)]{.math .notranslate .nohighlight} as [\\({\\langle i, j
\\rangle}\\)]{.math .notranslate .nohighlight}. Further, we define this
Hamiltonian in terms of the Pauli operators, which are defined as

::: {.math .notranslate .nohighlight}
\\\[\\begin{split}X = \\begin{pmatrix}0 & 1 \\\\ 1 & 0\\end{pmatrix},\\;
Y = \\begin{pmatrix}0 & -i \\\\ i & 0\\end{pmatrix}\\;\\text{and}\\; Z =
\\begin{pmatrix}1 & 0 \\\\ 0 & -1\\end{pmatrix}.\\end{split}\\\]
:::

For this task, we use the continuous model.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    num_of_qubits = 3
    prompt        = f"Compile {num_of_qubits} qubits using: ['h', 'cx', 'ccx', 'swap', 'rx', 'ry', 'rz', 'cp']"
:::
:::
:::

We can get the XXZ-Hamiltonian evolution unitary from [`genqc`{.docutils
.literal .notranslate}]{.pre}:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    from genQC.benchmark.bench_compilation import XXZHamiltonian

    hamiltonian = XXZHamiltonian(h=0.2,
                                 J=0.4,
                                 delta=0.4,
                                 num_qubits=num_of_qubits,
                                 periodic_boundary=False)

    U = hamiltonian.get_evolution(t=0.25)
:::
:::
:::

As before, we sample and plot the best circuits

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    generated_kernels, infidelities = sample_kernels_and_evaluate(
                                              U=U,
                                              prompt=prompt,
                                              num_of_qubits=num_of_qubits,
                                              samples=64,
                                              discrete_model=False)
:::
:::
:::

::: {.nboutput .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    [INFO]: (generate_comp_tensors) Generated 64 tensors
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    plot_topk_kernels(generated_kernels, infidelities, num_of_qubits, topk=3)
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Circuit has an infidelity of 3.5e-02.
         ╭───────────╮
    q0 : ┤ rx(12.43) ├────────────────────────────────────────────
         ╰───┬───┬───╯                          ╭───╮
    q1 : ────┤ x ├──────────●───────────────────┤ x ├─────────────
             ╰─┬─╯    ╭─────┴─────╮╭───────────╮╰─┬─╯╭───────────╮
    q2 : ──────●──────┤ r1(12.51) ├┤ rx(12.38) ├──●──┤ rx(12.47) ├
                      ╰───────────╯╰───────────╯     ╰───────────╯

    Circuit has an infidelity of 3.6e-02.
         ╭───────────╮
    q0 : ┤ rx(12.42) ├────────────────────────────
         ╰───┬───┬───╯                       ╭───╮
    q1 : ────┤ x ├───────────────●───────────┤ x ├
             ╰─┬─╯    ╭───╮╭─────┴─────╮╭───╮╰─┬─╯
    q2 : ──────●──────┤ h ├┤ r1(12.44) ├┤ h ├──●──
                      ╰───╯╰───────────╯╰───╯

    Circuit has an infidelity of 3.7e-02.
         ╭───────────╮
    q0 : ┤ rx(6.256) ├───────────────────────────────
         ╰───────────╯╭───────────╮
    q1 : ──────●──────┤ rx(12.34) ├───────────────●──
             ╭─┴─╮    ├───────────┤╭───────────╮╭─┴─╮
    q2 : ────┤ x ├────┤ rx(6.245) ├┤ rz(12.44) ├┤ x ├
             ╰───╯    ╰───────────╯╰───────────╯╰───╯
:::
:::
:::
:::
:::

::: {#Choosing-the-circuit-you-need .section}
## Choosing the circuit you need[¶](#Choosing-the-circuit-you-need "Permalink to this heading"){.headerlink}

As mentioned earlier, one of the key advantages of using diffusion
models (DMs) as a unitary compiler is the ability to rapidly sample many
circuits. However, as is common in machine learning, the model has a
certain accuracy, meaning not all generated circuits are expected to
exactly compile the specified unitary. In this section, we will evaluate
how many of the generated circuits are indeed correct and then perform
post-selection to identify circuits that successfully perform the
desired unitary operation.

Let's revisit the random unitary from before, but this time we closer
inspect what the model generates.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    num_of_qubits = 3
    prompt = f"Compile {num_of_qubits} qubits using: ['h', 'cx', 'ccx', 'swap', 'rx', 'ry', 'rz', 'cp']"

    U = torch.tensor([[0.70710678, 0., 0., 0., 0.70710678, 0., 0., 0.],
                   [0., -0.70710678, 0., 0., 0., -0.70710678, 0., 0.],
                   [-0.70710678, 0., 0., 0., 0.70710678, 0., 0., 0.],
                   [0., 0.70710678, 0., 0., 0., -0.70710678, 0., 0.],
                   [0., 0., 0.70710678, 0., 0., 0., 0., 0.70710678],
                   [0., 0., 0., 0.70710678, 0., 0., 0.70710678, 0.],
                   [0., 0., -0.70710678, 0., 0., 0., 0., 0.70710678],
                   [0., 0., 0., -0.70710678, 0., 0., 0.70710678, 0.]],
                  dtype=torch.complex128)
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    generated_kernels, infidelities, generated_tensors = \
                    sample_kernels_and_evaluate(
                                  U=U,
                                  prompt=prompt,
                                  num_of_qubits=num_of_qubits,
                                  samples=128,
                                  discrete_model=not RUN_LARGE_MODEL,
                                  return_tensors=True)
:::
:::
:::

::: {.nboutput .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    [INFO]: (generate_comp_tensors) Generated 128 tensors
:::
:::
:::

First, we plot a histogram of the infidelities of our generated
circuits.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    import matplotlib.pyplot as plt

    plt.figure(figsize=(7, 4))
    plt.title(
        f"Distribution of infidelities for {len(infidelities)} generated circuits",
        fontsize=12)
    plt.ylabel("Number of circuits", fontsize=14)
    plt.xlabel("Unitary infidelity", fontsize=14)
    plt.hist(infidelities, bins=30)
    plt.show()
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
![](../../_images/applications_python_unitary_compilation_diffusion_models_93_0.png)
:::
:::

As we see above, we now have around 15 kernels that compile the desired
unitary! This is particularly valuable when dealing with hardware
constraints, where, for instance, we might want to avoid using certain
qubits or specific gates. One practical example is finding the circuit
with the fewest CNOT gates (also known as [`cx`{.docutils .literal
.notranslate}]{.pre}). In our [`cont_vocabulary`{.docutils .literal
.notranslate}]{.pre} definition above, we identified that
[`cx`{.docutils .literal .notranslate}]{.pre} corresponds to the label 2
in our tokenized tensors.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    cx_token = cont_vocabulary["cx"]
    cx_token
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    2
:::
:::
:::

Let's use this information to search for the circuit that minimizes the
number of [`cx`{.docutils .literal .notranslate}]{.pre} gates:

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    # First, we remove possible duplicates and only pick distinct circuits
    _, idx_unique = torch.unique(generated_tensors, dim=0, return_inverse=True)
    unique_tensors = generated_tensors[idx_unique]
    unique_infidelities = infidelities[idx_unique]
    unique_kernels = [generated_kernels[idx] for idx in idx_unique]

    # Then, find the correct circuits
    idx_correct = torch.argwhere(unique_infidelities < 0.01).flatten()
    correct_tensors = unique_tensors[idx_correct]
    print(
        f"The model generated {correct_tensors.shape[0]} distinct circuits with infidelity < 0.01."
    )

    # Now let's flatten the last two dimensions (related to the actual circuit) and find out how many 2's (i.e. cx) gates each circuit has:
    num_cx = (correct_tensors.flatten(1, 2) == cx_token).sum(1)
    print("These circuits have this number of cx gates:", num_cx.tolist())
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    The model generated 14 distinct circuits with infidelity < 0.01.
    These circuits have this number of cx gates: [0, 2, 1, 0, 2, 2, 3, 2, 2, 1, 2, 1, 1, 1]
:::
:::
:::

As we can see, the diffusion model (DM) uses 0 to 3 CNOT gates to
compile the unitary. We can now print a few of these circuits to select
the one that best suits our needs, or to study whether there are any
interesting patterns the model employs for this specific unitary.

For instance, we can sort the circuits by their [`cx`{.docutils .literal
.notranslate}]{.pre} count and plot them.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    # Get the correct kernels
    correct_kernels = [unique_kernels[idx] for idx in idx_correct]

    # Order the gates by cx count
    correct_kernels_cx_sorted = [
        (correct_kernels[idx], num_cx[idx]) for idx in torch.argsort(num_cx)
    ]

    # Draw a few of these circuits
    input_state = [0] * (2**num_of_qubits)
    input_state[0] = 1

    for correct_kernel, num_cx_gates in correct_kernels_cx_sorted[:3]:
        kernel = correct_kernel.kernel
        thetas = correct_kernel.params

        print(f"Generated circuit with {num_cx_gates} cx:")
        print(cudaq.draw(kernel, input_state, thetas))
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    Generated circuit with 0 cx:
         ╭───╮                     ╭───────────╮
    q0 : ┤ x ├──────────────●──────┤ rz(3.132) ├
         ╰─┬─╯              │      ├───────────┤
    q1 : ──●────────╳───────┼──────┤ rz(9.379) ├
           │  ╭───╮ │ ╭─────┴─────╮╰───────────╯
    q2 : ──●──┤ h ├─╳─┤ r1(3.084) ├─────────────
              ╰───╯   ╰───────────╯

    Generated circuit with 0 cx:
         ╭───╮╭───────────╮╭───╮
    q0 : ┤ x ├┤ ry(1.567) ├┤ h ├──────●─────────
         ╰─┬─╯╰───────────╯╰───╯╭─────┴─────╮
    q1 : ──●────────────────────┤ r1(3.127) ├─╳─
           │   ╭────────╮       ╰───────────╯ │
    q2 : ──●───┤ ry(11) ├─────────────────────╳─
               ╰────────╯

    Generated circuit with 1 cx:
         ╭───╮    ╭───╮       ╭───╮╭───────────╮
    q0 : ┤ x ├────┤ h ├───────┤ x ├┤ ry(4.683) ├
         ╰─┬─╯    ╰───╯       ╰─┬─╯╰───────────╯
    q1 : ──●────────────────╳───┼───────────────
           │  ╭───────────╮ │   │
    q2 : ──●──┤ ry(4.722) ├─╳───●───────────────
              ╰───────────╯
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: highlight
    [ ]:
:::
:::

::: {.input_area .highlight-none .notranslate}
::: highlight
    print(cudaq.__version__)
    print("genQC Version", genQC.__version__)
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: highlight
    CUDA-Q Version 0.11.0 (https://github.com/NVIDIA/cuda-quantum f5cc3bb1d85abcf1f642f4ddd20ad08bc1d4d200)
    genQC Version 0.2.3
:::
:::
:::
:::
:::
:::
:::

::: {.rst-footer-buttons role="navigation" aria-label="Footer"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](readout_error_mitigation.html "Readout Error Mitigation"){.btn
.btn-neutral .float-left accesskey="p" rel="prev"} [Next []{.fa
.fa-arrow-circle-right
aria-hidden="true"}](vqe_advanced.html "VQE with gradients, active spaces, and gate fusion"){.btn
.btn-neutral .float-right accesskey="n" rel="next"}
:::

------------------------------------------------------------------------

::: {role="contentinfo"}
© Copyright 2025, NVIDIA Corporation & Affiliates.
:::

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme) provided by
[Read the Docs](https://readthedocs.org).
:::
:::
:::
:::
