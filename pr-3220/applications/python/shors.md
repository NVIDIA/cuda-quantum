::: {.wy-grid-for-nav}
::: {.wy-side-scroll}
::: {.wy-side-nav-search style="background: #76b900"}
[NVIDIA CUDA-Q](../../index.html){.icon .icon-home}

::: {.version}
pr-3220
:::

::: {role="search"}
:::
:::

::: {.wy-menu .wy-menu-vertical spy="affix" role="navigation" aria-label="Navigation menu"}
[Contents]{.caption-text}

-   [Quick Start](../../using/quick_start.html){.reference .internal}
    -   [Install
        CUDA-Q](../../using/quick_start.html#install-cuda-q){.reference
        .internal}
    -   [Validate your
        Installation](../../using/quick_start.html#validate-your-installation){.reference
        .internal}
    -   [CUDA-Q
        Academic](../../using/quick_start.html#cuda-q-academic){.reference
        .internal}
-   [Basics](../../using/basics/basics.html){.reference .internal}
    -   [What is a CUDA-Q
        Kernel?](../../using/basics/kernel_intro.html){.reference
        .internal}
    -   [Building your first CUDA-Q
        Program](../../using/basics/build_kernel.html){.reference
        .internal}
    -   [Running your first CUDA-Q
        Program](../../using/basics/run_kernel.html){.reference
        .internal}
        -   [Sample](../../using/basics/run_kernel.html#sample){.reference
            .internal}
        -   [Run](../../using/basics/run_kernel.html#run){.reference
            .internal}
        -   [Observe](../../using/basics/run_kernel.html#observe){.reference
            .internal}
        -   [Running on a
            GPU](../../using/basics/run_kernel.html#running-on-a-gpu){.reference
            .internal}
    -   [Troubleshooting](../../using/basics/troubleshooting.html){.reference
        .internal}
        -   [Debugging and Verbose Simulation
            Output](../../using/basics/troubleshooting.html#debugging-and-verbose-simulation-output){.reference
            .internal}
-   [Examples](../../using/examples/examples.html){.reference .internal}
    -   [Introduction](../../using/examples/introduction.html){.reference
        .internal}
    -   [Building
        Kernels](../../using/examples/building_kernels.html){.reference
        .internal}
        -   [Defining
            Kernels](../../using/examples/building_kernels.html#defining-kernels){.reference
            .internal}
        -   [Initializing
            states](../../using/examples/building_kernels.html#initializing-states){.reference
            .internal}
        -   [Applying
            Gates](../../using/examples/building_kernels.html#applying-gates){.reference
            .internal}
        -   [Controlled
            Operations](../../using/examples/building_kernels.html#controlled-operations){.reference
            .internal}
        -   [Multi-Controlled
            Operations](../../using/examples/building_kernels.html#multi-controlled-operations){.reference
            .internal}
        -   [Adjoint
            Operations](../../using/examples/building_kernels.html#adjoint-operations){.reference
            .internal}
        -   [Custom
            Operations](../../using/examples/building_kernels.html#custom-operations){.reference
            .internal}
        -   [Building Kernels with
            Kernels](../../using/examples/building_kernels.html#building-kernels-with-kernels){.reference
            .internal}
        -   [Parameterized
            Kernels](../../using/examples/building_kernels.html#parameterized-kernels){.reference
            .internal}
    -   [Quantum
        Operations](../../using/examples/quantum_operations.html){.reference
        .internal}
        -   [Quantum
            States](../../using/examples/quantum_operations.html#quantum-states){.reference
            .internal}
        -   [Quantum
            Gates](../../using/examples/quantum_operations.html#quantum-gates){.reference
            .internal}
        -   [Measurements](../../using/examples/quantum_operations.html#measurements){.reference
            .internal}
    -   [Measuring
        Kernels](../../using/examples/measuring_kernels.html){.reference
        .internal}
        -   [Mid-circuit Measurement and Conditional
            Logic](../../using/examples/measuring_kernels.html#mid-circuit-measurement-and-conditional-logic){.reference
            .internal}
    -   [Visualizing
        Kernels](../../examples/python/visualization.html){.reference
        .internal}
        -   [Qubit
            Visualization](../../examples/python/visualization.html#Qubit-Visualization){.reference
            .internal}
        -   [Kernel
            Visualization](../../examples/python/visualization.html#Kernel-Visualization){.reference
            .internal}
    -   [Executing
        Kernels](../../using/examples/executing_kernels.html){.reference
        .internal}
        -   [Sample](../../using/examples/executing_kernels.html#sample){.reference
            .internal}
            -   [Sample
                Asynchronous](../../using/examples/executing_kernels.html#sample-asynchronous){.reference
                .internal}
        -   [Run](../../using/examples/executing_kernels.html#run){.reference
            .internal}
            -   [Return Custom Data
                Types](../../using/examples/executing_kernels.html#return-custom-data-types){.reference
                .internal}
            -   [Run
                Asynchronous](../../using/examples/executing_kernels.html#run-asynchronous){.reference
                .internal}
        -   [Observe](../../using/examples/executing_kernels.html#observe){.reference
            .internal}
            -   [Observe
                Asynchronous](../../using/examples/executing_kernels.html#observe-asynchronous){.reference
                .internal}
        -   [Get
            State](../../using/examples/executing_kernels.html#get-state){.reference
            .internal}
            -   [Get State
                Asynchronous](../../using/examples/executing_kernels.html#get-state-asynchronous){.reference
                .internal}
    -   [Computing Expectation
        Values](../../using/examples/expectation_values.html){.reference
        .internal}
        -   [Parallelizing across Multiple
            Processors](../../using/examples/expectation_values.html#parallelizing-across-multiple-processors){.reference
            .internal}
    -   [Multi-GPU
        Workflows](../../using/examples/multi_gpu_workflows.html){.reference
        .internal}
        -   [From CPU to
            GPU](../../using/examples/multi_gpu_workflows.html#from-cpu-to-gpu){.reference
            .internal}
        -   [Pooling the memory of multiple GPUs (`mgpu`{.code .docutils
            .literal
            .notranslate})](../../using/examples/multi_gpu_workflows.html#pooling-the-memory-of-multiple-gpus-mgpu){.reference
            .internal}
        -   [Parallel execution over multiple QPUs (`mqpu`{.code
            .docutils .literal
            .notranslate})](../../using/examples/multi_gpu_workflows.html#parallel-execution-over-multiple-qpus-mqpu){.reference
            .internal}
            -   [Batching Hamiltonian
                Terms](../../using/examples/multi_gpu_workflows.html#batching-hamiltonian-terms){.reference
                .internal}
            -   [Circuit
                Batching](../../using/examples/multi_gpu_workflows.html#circuit-batching){.reference
                .internal}
        -   [Multi-QPU + Other Backends (`remote-mqpu`{.code .docutils
            .literal
            .notranslate})](../../using/examples/multi_gpu_workflows.html#multi-qpu-other-backends-remote-mqpu){.reference
            .internal}
    -   [Optimizers &
        Gradients](../../examples/python/optimizers_gradients.html){.reference
        .internal}
        -   [Built in CUDA-Q Optimizers and
            Gradients](../../examples/python/optimizers_gradients.html#Built-in-CUDA-Q-Optimizers-and-Gradients){.reference
            .internal}
        -   [Third-Party
            Optimizers](../../examples/python/optimizers_gradients.html#Third-Party-Optimizers){.reference
            .internal}
        -   [Parallel Parameter Shift
            Gradients](../../examples/python/optimizers_gradients.html#Parallel-Parameter-Shift-Gradients){.reference
            .internal}
    -   [Noisy
        Simulations](../../examples/python/noisy_simulations.html){.reference
        .internal}
    -   [Constructing
        Operators](../../using/examples/operators.html){.reference
        .internal}
        -   [Constructing Spin
            Operators](../../using/examples/operators.html#constructing-spin-operators){.reference
            .internal}
        -   [Pauli Words and Exponentiating Pauli
            Words](../../using/examples/operators.html#pauli-words-and-exponentiating-pauli-words){.reference
            .internal}
    -   [Performance
        Optimizations](../../examples/python/performance_optimizations.html){.reference
        .internal}
        -   [Gate
            Fusion](../../examples/python/performance_optimizations.html#Gate-Fusion){.reference
            .internal}
    -   [Using Quantum Hardware
        Providers](../../using/examples/hardware_providers.html){.reference
        .internal}
        -   [Amazon
            Braket](../../using/examples/hardware_providers.html#amazon-braket){.reference
            .internal}
        -   [Anyon
            Technologies](../../using/examples/hardware_providers.html#anyon-technologies){.reference
            .internal}
        -   [Infleqtion](../../using/examples/hardware_providers.html#infleqtion){.reference
            .internal}
        -   [IonQ](../../using/examples/hardware_providers.html#ionq){.reference
            .internal}
        -   [IQM](../../using/examples/hardware_providers.html#iqm){.reference
            .internal}
        -   [OQC](../../using/examples/hardware_providers.html#oqc){.reference
            .internal}
        -   [ORCA
            Computing](../../using/examples/hardware_providers.html#orca-computing){.reference
            .internal}
        -   [Pasqal](../../using/examples/hardware_providers.html#pasqal){.reference
            .internal}
        -   [Quantinuum](../../using/examples/hardware_providers.html#quantinuum){.reference
            .internal}
        -   [Quantum Circuits,
            Inc.](../../using/examples/hardware_providers.html#quantum-circuits-inc){.reference
            .internal}
        -   [Quantum
            Machines](../../using/examples/hardware_providers.html#quantum-machines){.reference
            .internal}
        -   [QuEra
            Computing](../../using/examples/hardware_providers.html#quera-computing){.reference
            .internal}
    -   [Dynamics
        Examples](../../using/examples/dynamics_examples.html){.reference
        .internal}
        -   [Introduction to CUDA-Q Dynamics (Jaynes-Cummings
            Model)](../../examples/python/dynamics/dynamics_intro_1.html){.reference
            .internal}
            -   [Why dynamics simulations vs. circuit
                simulations?](../../examples/python/dynamics/dynamics_intro_1.html#Why-dynamics-simulations-vs.-circuit-simulations?){.reference
                .internal}
            -   [Functionality](../../examples/python/dynamics/dynamics_intro_1.html#Functionality){.reference
                .internal}
            -   [Performance](../../examples/python/dynamics/dynamics_intro_1.html#Performance){.reference
                .internal}
            -   [Section 1 - Simulating the Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Section-1---Simulating-the-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Exercise 1 - Simulating a many-photon Jaynes-Cummings
                Hamiltonian](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-1---Simulating-a-many-photon-Jaynes-Cummings-Hamiltonian){.reference
                .internal}
            -   [Section 2 - Simulating open quantum systems with the
                `collapse_operators`{.docutils .literal
                .notranslate}](../../examples/python/dynamics/dynamics_intro_1.html#Section-2---Simulating-open-quantum-systems-with-the-collapse_operators){.reference
                .internal}
            -   [Exercise 2 - Adding additional jump operators
                [\\(L\_i\\)]{.math .notranslate
                .nohighlight}](../../examples/python/dynamics/dynamics_intro_1.html#Exercise-2---Adding-additional-jump-operators-L_i){.reference
                .internal}
            -   [Section 3 - Many qubits coupled to the
                resonator](../../examples/python/dynamics/dynamics_intro_1.html#Section-3---Many-qubits-coupled-to-the-resonator){.reference
                .internal}
        -   [Introduction to CUDA-Q Dynamics (Time Dependent
            Hamiltonians)](../../examples/python/dynamics/dynamics_intro_2.html){.reference
            .internal}
            -   [The Landau-Zener
                model](../../examples/python/dynamics/dynamics_intro_2.html#The-Landau-Zener-model){.reference
                .internal}
            -   [Section 1 - Implementing time dependent
                terms](../../examples/python/dynamics/dynamics_intro_2.html#Section-1---Implementing-time-dependent-terms){.reference
                .internal}
            -   [Section 2 - Implementing custom
                operators](../../examples/python/dynamics/dynamics_intro_2.html#Section-2---Implementing-custom-operators){.reference
                .internal}
            -   [Section 3 - Heisenberg Model with a time-varying
                magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Section-3---Heisenberg-Model-with-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 1 - Define a time-varying magnetic
                field](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-1---Define-a-time-varying-magnetic-field){.reference
                .internal}
            -   [Exercise 2
                (Optional)](../../examples/python/dynamics/dynamics_intro_2.html#Exercise-2-(Optional)){.reference
                .internal}
        -   [Superconducting
            Qubits](../../examples/python/dynamics/superconducting.html){.reference
            .internal}
            -   [Cavity
                QED](../../examples/python/dynamics/superconducting.html#Cavity-QED){.reference
                .internal}
            -   [Cross
                Resonance](../../examples/python/dynamics/superconducting.html#Cross-Resonance){.reference
                .internal}
            -   [Transmon
                Resonator](../../examples/python/dynamics/superconducting.html#Transmon-Resonator){.reference
                .internal}
        -   [Spin
            Qubits](../../examples/python/dynamics/spinqubits.html){.reference
            .internal}
            -   [Silicon Spin
                Qubit](../../examples/python/dynamics/spinqubits.html#Silicon-Spin-Qubit){.reference
                .internal}
            -   [Heisenberg
                Model](../../examples/python/dynamics/spinqubits.html#Heisenberg-Model){.reference
                .internal}
        -   [Trapped Ion
            Qubits](../../examples/python/dynamics/iontrap.html){.reference
            .internal}
            -   [GHZ
                state](../../examples/python/dynamics/iontrap.html#GHZ-state){.reference
                .internal}
        -   [Control](../../examples/python/dynamics/control.html){.reference
            .internal}
            -   [Gate
                Calibration](../../examples/python/dynamics/control.html#Gate-Calibration){.reference
                .internal}
            -   [Pulse](../../examples/python/dynamics/control.html#Pulse){.reference
                .internal}
            -   [Qubit
                Control](../../examples/python/dynamics/control.html#Qubit-Control){.reference
                .internal}
            -   [Qubit
                Dynamics](../../examples/python/dynamics/control.html#Qubit-Dynamics){.reference
                .internal}
            -   [Landau-Zenner](../../examples/python/dynamics/control.html#Landau-Zenner){.reference
                .internal}
-   [Applications](../../using/applications.html){.reference .internal}
    -   [Max-Cut with QAOA](qaoa.html){.reference .internal}
    -   [Molecular docking via
        DC-QAOA](digitized_counterdiabatic_qaoa.html){.reference
        .internal}
        -   [Setting up the Molecular Docking
            Problem](digitized_counterdiabatic_qaoa.html#Setting-up-the-Molecular-Docking-Problem){.reference
            .internal}
        -   [CUDA-Q
            Implementation](digitized_counterdiabatic_qaoa.html#CUDA-Q-Implementation){.reference
            .internal}
    -   [Multi-reference Quantum Krylov Algorithm - [\\(H\_2\\)]{.math
        .notranslate .nohighlight} Molecule](krylov.html){.reference
        .internal}
        -   [Setup](krylov.html#Setup){.reference .internal}
        -   [Computing the matrix
            elements](krylov.html#Computing-the-matrix-elements){.reference
            .internal}
        -   [Determining the ground state energy of the
            subspace](krylov.html#Determining-the-ground-state-energy-of-the-subspace){.reference
            .internal}
    -   [Bernstein-Vazirani
        Algorithm](bernstein_vazirani.html){.reference .internal}
        -   [Classical
            case](bernstein_vazirani.html#Classical-case){.reference
            .internal}
        -   [Quantum
            case](bernstein_vazirani.html#Quantum-case){.reference
            .internal}
        -   [Implementing in
            CUDA-Q](bernstein_vazirani.html#Implementing-in-CUDA-Q){.reference
            .internal}
    -   [Cost Minimization](cost_minimization.html){.reference
        .internal}
    -   [Deutsch's Algorithm](deutsch_algorithm.html){.reference
        .internal}
        -   [XOR [\\(\\oplus\\)]{.math .notranslate
            .nohighlight}](deutsch_algorithm.html#XOR-\oplus){.reference
            .internal}
        -   [Quantum
            oracles](deutsch_algorithm.html#Quantum-oracles){.reference
            .internal}
        -   [Phase
            oracle](deutsch_algorithm.html#Phase-oracle){.reference
            .internal}
        -   [Quantum
            parallelism](deutsch_algorithm.html#Quantum-parallelism){.reference
            .internal}
        -   [Deutsch's
            Algorithm:](deutsch_algorithm.html#Deutsch's-Algorithm:){.reference
            .internal}
    -   [Divisive Clustering With Coresets Using
        CUDA-Q](divisive_clustering_coresets.html){.reference .internal}
        -   [Data
            preprocessing](divisive_clustering_coresets.html#Data-preprocessing){.reference
            .internal}
        -   [Quantum
            functions](divisive_clustering_coresets.html#Quantum-functions){.reference
            .internal}
        -   [Divisive Clustering
            Function](divisive_clustering_coresets.html#Divisive-Clustering-Function){.reference
            .internal}
        -   [QAOA
            Implementation](divisive_clustering_coresets.html#QAOA-Implementation){.reference
            .internal}
        -   [Scaling simulations with
            CUDA-Q](divisive_clustering_coresets.html#Scaling-simulations-with-CUDA-Q){.reference
            .internal}
    -   [Hybrid Quantum Neural
        Networks](hybrid_quantum_neural_networks.html){.reference
        .internal}
    -   [Using the Hadamard Test to Determine Quantum Krylov Subspace
        Decomposition Matrix Elements](hadamard_test.html){.reference
        .internal}
        -   [Numerical result as a
            reference:](hadamard_test.html#Numerical-result-as-a-reference:){.reference
            .internal}
        -   [Using `Sample`{.docutils .literal .notranslate} to perform
            the Hadamard
            test](hadamard_test.html#Using-Sample-to-perform-the-Hadamard-test){.reference
            .internal}
        -   [Multi-GPU evaluation of QKSD matrix elements using the
            Hadamard
            Test](hadamard_test.html#Multi-GPU-evaluation-of-QKSD-matrix-elements-using-the-Hadamard-Test){.reference
            .internal}
            -   [Classically Diagonalize the Subspace
                Matrix](hadamard_test.html#Classically-Diagonalize-the-Subspace-Matrix){.reference
                .internal}
    -   [Anderson Impurity Model ground state solver on Infleqtion's
        Sqale](logical_aim_sqale.html){.reference .internal}
        -   [Performing logical Variational Quantum Eigensolver (VQE)
            with
            CUDA-QX](logical_aim_sqale.html#Performing-logical-Variational-Quantum-Eigensolver-(VQE)-with-CUDA-QX){.reference
            .internal}
        -   [Constructing circuits in the `[[4,2,2]]`{.docutils .literal
            .notranslate}
            encoding](logical_aim_sqale.html#Constructing-circuits-in-the-%5B%5B4,2,2%5D%5D-encoding){.reference
            .internal}
        -   [Setting up submission and decoding
            workflow](logical_aim_sqale.html#Setting-up-submission-and-decoding-workflow){.reference
            .internal}
        -   [Running a CUDA-Q noisy
            simulation](logical_aim_sqale.html#Running-a-CUDA-Q-noisy-simulation){.reference
            .internal}
        -   [Running logical AIM on Infleqtion's
            hardware](logical_aim_sqale.html#Running-logical-AIM-on-Infleqtion's-hardware){.reference
            .internal}
    -   [Spin-Hamiltonian Simulation Using
        CUDA-Q](hamiltonian_simulation.html){.reference .internal}
        -   [Introduction](hamiltonian_simulation.html#Introduction){.reference
            .internal}
            -   [Heisenberg
                Hamiltonian](hamiltonian_simulation.html#Heisenberg-Hamiltonian){.reference
                .internal}
            -   [Transverse Field Ising Model
                (TFIM)](hamiltonian_simulation.html#Transverse-Field-Ising-Model-(TFIM)){.reference
                .internal}
            -   [Time Evolution and Trotter
                Decomposition](hamiltonian_simulation.html#Time-Evolution-and-Trotter-Decomposition){.reference
                .internal}
        -   [Key
            steps](hamiltonian_simulation.html#Key-steps){.reference
            .internal}
            -   [1. Prepare initial
                state](hamiltonian_simulation.html#1.-Prepare-initial-state){.reference
                .internal}
            -   [2. Hamiltonian
                Trotterization](hamiltonian_simulation.html#2.-Hamiltonian-Trotterization){.reference
                .internal}
            -   [3. `Compute overlap`{.docutils .literal
                .notranslate}](hamiltonian_simulation.html#3.-Compute-overlap){.reference
                .internal}
            -   [4. Construct Heisenberg
                Hamiltonian](hamiltonian_simulation.html#4.-Construct-Heisenberg-Hamiltonian){.reference
                .internal}
            -   [5. Construct TFIM
                Hamiltonian](hamiltonian_simulation.html#5.-Construct-TFIM-Hamiltonian){.reference
                .internal}
            -   [6. Extract coefficients and Pauli
                words](hamiltonian_simulation.html#6.-Extract-coefficients-and-Pauli-words){.reference
                .internal}
        -   [Main
            code](hamiltonian_simulation.html#Main-code){.reference
            .internal}
        -   [Visualization of probablity over
            time](hamiltonian_simulation.html#Visualization-of-probablity-over-time){.reference
            .internal}
        -   [Expectation value over
            time:](hamiltonian_simulation.html#Expectation-value-over-time:){.reference
            .internal}
        -   [Visualization of expectation over
            time](hamiltonian_simulation.html#Visualization-of-expectation-over-time){.reference
            .internal}
        -   [Additional
            information](hamiltonian_simulation.html#Additional-information){.reference
            .internal}
        -   [Relevant
            references](hamiltonian_simulation.html#Relevant-references){.reference
            .internal}
    -   [Quantum Fourier
        Transform](quantum_fourier_transform.html){.reference .internal}
        -   [Quantum Fourier Transform
            revisited](quantum_fourier_transform.html#Quantum-Fourier-Transform-revisited){.reference
            .internal}
    -   [Quantum Teleporation](quantum_teleportation.html){.reference
        .internal}
        -   [Teleportation
            explained](quantum_teleportation.html#Teleportation-explained){.reference
            .internal}
    -   [Quantum Volume](quantum_volume.html){.reference .internal}
    -   [Readout Error
        Mitigation](readout_error_mitigation.html){.reference .internal}
        -   [Inverse confusion matrix from single-qubit noise
            model](readout_error_mitigation.html#Inverse-confusion-matrix-from-single-qubit-noise-model){.reference
            .internal}
        -   [Inverse confusion matrix from k local confusion
            matrices](readout_error_mitigation.html#Inverse-confusion-matrix-from-k-local-confusion-matrices){.reference
            .internal}
        -   [Inverse of full confusion
            matrix](readout_error_mitigation.html#Inverse-of-full-confusion-matrix){.reference
            .internal}
    -   [Compiling Unitaries Using Diffusion
        Models](unitary_compilation_diffusion_models.html){.reference
        .internal}
        -   [Diffusion model
            pipeline](unitary_compilation_diffusion_models.html#Diffusion-model-pipeline){.reference
            .internal}
        -   [Setup and load
            models](unitary_compilation_diffusion_models.html#Setup-and-load-models){.reference
            .internal}
            -   [Load discrete
                model](unitary_compilation_diffusion_models.html#Load-discrete-model){.reference
                .internal}
            -   [Load continuous
                model](unitary_compilation_diffusion_models.html#Load-continuous-model){.reference
                .internal}
            -   [Create helper
                functions](unitary_compilation_diffusion_models.html#Create-helper-functions){.reference
                .internal}
        -   [Unitary
            compilation](unitary_compilation_diffusion_models.html#Unitary-compilation){.reference
            .internal}
            -   [Random
                unitary](unitary_compilation_diffusion_models.html#Random-unitary){.reference
                .internal}
            -   [Discrete
                model](unitary_compilation_diffusion_models.html#Discrete-model){.reference
                .internal}
            -   [Continuous
                model](unitary_compilation_diffusion_models.html#Continuous-model){.reference
                .internal}
            -   [Quantum Fourier
                transform](unitary_compilation_diffusion_models.html#Quantum-Fourier-transform){.reference
                .internal}
            -   [XXZ-Hamiltonian
                evolution](unitary_compilation_diffusion_models.html#XXZ-Hamiltonian-evolution){.reference
                .internal}
        -   [Choosing the circuit you
            need](unitary_compilation_diffusion_models.html#Choosing-the-circuit-you-need){.reference
            .internal}
    -   [VQE with gradients, active spaces, and gate
        fusion](vqe_advanced.html){.reference .internal}
        -   [The Basics of
            VQE](vqe_advanced.html#The-Basics-of-VQE){.reference
            .internal}
        -   [Installing/Loading Relevant
            Packages](vqe_advanced.html#Installing/Loading-Relevant-Packages){.reference
            .internal}
        -   [Implementing VQE in
            CUDA-Q](vqe_advanced.html#Implementing-VQE-in-CUDA-Q){.reference
            .internal}
        -   [Parallel Parameter Shift
            Gradients](vqe_advanced.html#Parallel-Parameter-Shift-Gradients){.reference
            .internal}
        -   [Using an Active
            Space](vqe_advanced.html#Using-an-Active-Space){.reference
            .internal}
        -   [Gate Fusion for Larger
            Circuits](vqe_advanced.html#Gate-Fusion-for-Larger-Circuits){.reference
            .internal}
    -   [Quantum Transformer](quantum_transformer.html){.reference
        .internal}
        -   [Installation](quantum_transformer.html#Installation){.reference
            .internal}
        -   [Algorithm and
            Example](quantum_transformer.html#Algorithm-and-Example){.reference
            .internal}
            -   [Creating the self-attention
                circuits](quantum_transformer.html#Creating-the-self-attention-circuits){.reference
                .internal}
        -   [Usage](quantum_transformer.html#Usage){.reference
            .internal}
            -   [Model
                Training](quantum_transformer.html#Model-Training){.reference
                .internal}
            -   [Generating
                Molecules](quantum_transformer.html#Generating-Molecules){.reference
                .internal}
            -   [Attention
                Maps](quantum_transformer.html#Attention-Maps){.reference
                .internal}
    -   [Quantum Enhanced Auxiliary Field Quantum Monte
        Carlo](afqmc.html){.reference .internal}
        -   [Hamiltonian preparation for
            VQE](afqmc.html#Hamiltonian-preparation-for-VQE){.reference
            .internal}
        -   [Run VQE with
            CUDA-Q](afqmc.html#Run-VQE-with-CUDA-Q){.reference
            .internal}
        -   [Auxiliary Field Quantum Monte Carlo
            (AFQMC)](afqmc.html#Auxiliary-Field-Quantum-Monte-Carlo-(AFQMC)){.reference
            .internal}
        -   [Preparation of the molecular
            Hamiltonian](afqmc.html#Preparation-of-the-molecular-Hamiltonian){.reference
            .internal}
        -   [Preparation of the trial wave
            function](afqmc.html#Preparation-of-the-trial-wave-function){.reference
            .internal}
        -   [Setup of the AFQMC
            parameters](afqmc.html#Setup-of-the-AFQMC-parameters){.reference
            .internal}
    -   [ADAPT-QAOA algorithm](adapt_qaoa.html){.reference .internal}
        -   [Simulation
            input:](adapt_qaoa.html#Simulation-input:){.reference
            .internal}
        -   [The problem Hamiltonian [\\(H\_C\\)]{.math .notranslate
            .nohighlight} of the max-cut
            graph:](adapt_qaoa.html#The-problem-Hamiltonian-H_C-of-the-max-cut-graph:){.reference
            .internal}
        -   [Th operator pool [\\(A\_j\\)]{.math .notranslate
            .nohighlight}:](adapt_qaoa.html#Th-operator-pool-A_j:){.reference
            .internal}
        -   [The commutator [\\(\[H\_C,A\_j\]\\)]{.math .notranslate
            .nohighlight}:](adapt_qaoa.html#The-commutator-%5BH_C,A_j%5D:){.reference
            .internal}
        -   [Beginning of ADAPT-QAOA
            iteration:](adapt_qaoa.html#Beginning-of-ADAPT-QAOA-iteration:){.reference
            .internal}
    -   [ADAPT-VQE algorithm](adapt_vqe.html){.reference .internal}
        -   [Classical
            pre-processing](adapt_vqe.html#Classical-pre-processing){.reference
            .internal}
        -   [Jordan Wigner:](adapt_vqe.html#Jordan-Wigner:){.reference
            .internal}
        -   [UCCSD operator
            pool](adapt_vqe.html#UCCSD-operator-pool){.reference
            .internal}
            -   [Single
                excitation](adapt_vqe.html#Single-excitation){.reference
                .internal}
            -   [Double
                excitation](adapt_vqe.html#Double-excitation){.reference
                .internal}
        -   [Commutator \[[\\(H\\)]{.math .notranslate .nohighlight},
            [\\(A\_i\\)]{.math .notranslate
            .nohighlight}\]](adapt_vqe.html#Commutator-%5BH,-A_i%5D){.reference
            .internal}
        -   [Reference
            State:](adapt_vqe.html#Reference-State:){.reference
            .internal}
        -   [Quantum
            kernels:](adapt_vqe.html#Quantum-kernels:){.reference
            .internal}
        -   [Beginning of
            ADAPT-VQE:](adapt_vqe.html#Beginning-of-ADAPT-VQE:){.reference
            .internal}
    -   [Quantum edge detection](edge_detection.html){.reference
        .internal}
        -   [Image](edge_detection.html#Image){.reference .internal}
        -   [Quantum Probability Image Encoding
            (QPIE):](edge_detection.html#Quantum-Probability-Image-Encoding-(QPIE):){.reference
            .internal}
            -   [Below we show how to encode an image using QPIE in
                cudaq.](edge_detection.html#Below-we-show-how-to-encode-an-image-using-QPIE-in-cudaq.){.reference
                .internal}
        -   [Flexible Representation of Quantum Images
            (FRQI):](edge_detection.html#Flexible-Representation-of-Quantum-Images-(FRQI):){.reference
            .internal}
            -   [Building the FRQI
                State:](edge_detection.html#Building-the-FRQI-State:){.reference
                .internal}
        -   [Quantum Hadamard Edge Detection
            (QHED)](edge_detection.html#Quantum-Hadamard-Edge-Detection-(QHED)){.reference
            .internal}
            -   [Post-processing](edge_detection.html#Post-processing){.reference
                .internal}
    -   [Factoring Integers With Shor's Algorithm](#){.current
        .reference .internal}
        -   [Shor's algorithm](#Shor's-algorithm){.reference .internal}
            -   [Solving the order-finding problem
                classically](#Solving-the-order-finding-problem-classically){.reference
                .internal}
            -   [Solving the order-finding problem with a quantum
                algorithm](#Solving-the-order-finding-problem-with-a-quantum-algorithm){.reference
                .internal}
            -   [Determining the order from the measurement results of
                the phase
                kernel](#Determining-the-order-from-the-measurement-results-of-the-phase-kernel){.reference
                .internal}
            -   [Postscript](#Postscript){.reference .internal}
    -   [Generating the electronic
        Hamiltonian](generate_fermionic_ham.html){.reference .internal}
        -   [Second Quantized
            formulation.](generate_fermionic_ham.html#Second-Quantized-formulation.){.reference
            .internal}
            -   [Computational
                Implementation](generate_fermionic_ham.html#Computational-Implementation){.reference
                .internal}
            -   [(a) Generate the molecular Hamiltonian using Restricted
                Hartree Fock molecular
                orbitals](generate_fermionic_ham.html#(a)-Generate-the-molecular-Hamiltonian-using-Restricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(b) Generate the molecular Hamiltonian using
                Unrestricted Hartree Fock molecular
                orbitals](generate_fermionic_ham.html#(b)-Generate-the-molecular-Hamiltonian-using-Unrestricted-Hartree-Fock-molecular-orbitals){.reference
                .internal}
            -   [(a) Generate the active space hamiltonian using RHF
                molecular
                orbitals.](generate_fermionic_ham.html#(a)-Generate-the-active-space-hamiltonian-using-RHF-molecular-orbitals.){.reference
                .internal}
            -   [(b) Generate the active space Hamiltonian using the
                natural orbitals computed from MP2
                simulation](generate_fermionic_ham.html#(b)-Generate-the-active-space-Hamiltonian-using-the-natural-orbitals-computed-from-MP2-simulation){.reference
                .internal}
            -   [(c) Generate the active space Hamiltonian computed from
                the CASSCF molecular
                orbitals](generate_fermionic_ham.html#(c)-Generate-the-active-space-Hamiltonian-computed-from-the-CASSCF-molecular-orbitals){.reference
                .internal}
            -   [(d) Generate the electronic Hamiltonian using
                ROHF](generate_fermionic_ham.html#(d)-Generate-the-electronic-Hamiltonian-using-ROHF){.reference
                .internal}
            -   [(e) Generate electronic Hamiltonian using
                UHF](generate_fermionic_ham.html#(e)-Generate-electronic-Hamiltonian-using-UHF){.reference
                .internal}
    -   [Grover's Algorithm](grovers.html){.reference .internal}
        -   [Overview](grovers.html#Overview){.reference .internal}
        -   [Problem](grovers.html#Problem){.reference .internal}
        -   [Structure of Grover's
            Algorithm](grovers.html#Structure-of-Grover's-Algorithm){.reference
            .internal}
            -   [Step 1:
                Preparation](grovers.html#Step-1:-Preparation){.reference
                .internal}
            -   [Good and Bad
                States](grovers.html#Good-and-Bad-States){.reference
                .internal}
            -   [Step 2: Oracle
                application](grovers.html#Step-2:-Oracle-application){.reference
                .internal}
            -   [Step 3: Amplitude
                amplification](grovers.html#Step-3:-Amplitude-amplification){.reference
                .internal}
            -   [Steps 4 and 5: Iteration and
                measurement](grovers.html#Steps-4-and-5:-Iteration-and-measurement){.reference
                .internal}
    -   [Quantum PageRank](quantum_pagerank.html){.reference .internal}
        -   [Problem
            Definition](quantum_pagerank.html#Problem-Definition){.reference
            .internal}
        -   [Simulating Quantum PageRank by CUDA-Q
            dynamics](quantum_pagerank.html#Simulating-Quantum-PageRank-by-CUDA-Q-dynamics){.reference
            .internal}
        -   [Breakdown of
            Terms](quantum_pagerank.html#Breakdown-of-Terms){.reference
            .internal}
    -   [The UCCSD Wavefunction ansatz](uccsd_wf_ansatz.html){.reference
        .internal}
        -   [What is
            UCCSD?](uccsd_wf_ansatz.html#What-is-UCCSD?){.reference
            .internal}
        -   [Implementation in Quantum
            Computing](uccsd_wf_ansatz.html#Implementation-in-Quantum-Computing){.reference
            .internal}
        -   [Run VQE](uccsd_wf_ansatz.html#Run-VQE){.reference
            .internal}
        -   [Challenges and
            consideration](uccsd_wf_ansatz.html#Challenges-and-consideration){.reference
            .internal}
    -   [Approximate State Preparation using MPS Sequential
        Encoding](mps_encoding.html){.reference .internal}
        -   [Ran's
            approach](mps_encoding.html#Ran's-approach){.reference
            .internal}
    -   [QM/MM simulation: VQE within a Polarizable Embedded
        Framework.](qm_mm_pe.html){.reference .internal}
        -   [Key concepts:](qm_mm_pe.html#Key-concepts:){.reference
            .internal}
        -   [PE-VQE-SCF Algorithm
            Steps](qm_mm_pe.html#PE-VQE-SCF-Algorithm-Steps){.reference
            .internal}
            -   [Step 1: Initialize (Classical
                pre-processing)](qm_mm_pe.html#Step-1:-Initialize-(Classical-pre-processing)){.reference
                .internal}
            -   [Step 2: Build the
                Hamiltonian](qm_mm_pe.html#Step-2:-Build-the-Hamiltonian){.reference
                .internal}
            -   [Step 3: Run
                VQE](qm_mm_pe.html#Step-3:-Run-VQE){.reference
                .internal}
            -   [Step 4: Update
                Environment](qm_mm_pe.html#Step-4:-Update-Environment){.reference
                .internal}
            -   [Step 5: Self-Consistency
                Loop](qm_mm_pe.html#Step-5:-Self-Consistency-Loop){.reference
                .internal}
            -   [Requirments:](qm_mm_pe.html#Requirments:){.reference
                .internal}
            -   [Example 1: LiH with 2 water
                molecules.](qm_mm_pe.html#Example-1:-LiH-with-2-water-molecules.){.reference
                .internal}
            -   [VQE, update environment, and scf
                loop.](qm_mm_pe.html#VQE,-update-environment,-and-scf-loop.){.reference
                .internal}
            -   [Example 2: NH3 with 46 water molecule using active
                space.](qm_mm_pe.html#Example-2:-NH3-with-46-water-molecule-using-active-space.){.reference
                .internal}
-   [Backends](../../using/backends/backends.html){.reference .internal}
    -   [Circuit
        Simulation](../../using/backends/simulators.html){.reference
        .internal}
        -   [State Vector
            Simulators](../../using/backends/sims/svsims.html){.reference
            .internal}
            -   [CPU](../../using/backends/sims/svsims.html#cpu){.reference
                .internal}
            -   [Single-GPU](../../using/backends/sims/svsims.html#single-gpu){.reference
                .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/svsims.html#multi-gpu-multi-node){.reference
                .internal}
        -   [Tensor Network
            Simulators](../../using/backends/sims/tnsims.html){.reference
            .internal}
            -   [Multi-GPU
                multi-node](../../using/backends/sims/tnsims.html#multi-gpu-multi-node){.reference
                .internal}
            -   [Matrix product
                state](../../using/backends/sims/tnsims.html#matrix-product-state){.reference
                .internal}
            -   [Fermioniq](../../using/backends/sims/tnsims.html#fermioniq){.reference
                .internal}
        -   [Multi-QPU
            Simulators](../../using/backends/sims/mqpusims.html){.reference
            .internal}
            -   [Simulate Multiple QPUs in
                Parallel](../../using/backends/sims/mqpusims.html#simulate-multiple-qpus-in-parallel){.reference
                .internal}
            -   [Multi-QPU + Other
                Backends](../../using/backends/sims/mqpusims.html#multi-qpu-other-backends){.reference
                .internal}
        -   [Noisy
            Simulators](../../using/backends/sims/noisy.html){.reference
            .internal}
            -   [Trajectory Noisy
                Simulation](../../using/backends/sims/noisy.html#trajectory-noisy-simulation){.reference
                .internal}
            -   [Density
                Matrix](../../using/backends/sims/noisy.html#density-matrix){.reference
                .internal}
            -   [Stim](../../using/backends/sims/noisy.html#stim){.reference
                .internal}
        -   [Photonics
            Simulators](../../using/backends/sims/photonics.html){.reference
            .internal}
            -   [orca-photonics](../../using/backends/sims/photonics.html#orca-photonics){.reference
                .internal}
    -   [Quantum Hardware
        (QPUs)](../../using/backends/hardware.html){.reference
        .internal}
        -   [Ion Trap
            QPUs](../../using/backends/hardware/iontrap.html){.reference
            .internal}
            -   [IonQ](../../using/backends/hardware/iontrap.html#ionq){.reference
                .internal}
            -   [Quantinuum](../../using/backends/hardware/iontrap.html#quantinuum){.reference
                .internal}
        -   [Superconducting
            QPUs](../../using/backends/hardware/superconducting.html){.reference
            .internal}
            -   [Anyon Technologies/Anyon
                Computing](../../using/backends/hardware/superconducting.html#anyon-technologies-anyon-computing){.reference
                .internal}
            -   [IQM](../../using/backends/hardware/superconducting.html#iqm){.reference
                .internal}
            -   [OQC](../../using/backends/hardware/superconducting.html#oqc){.reference
                .internal}
            -   [Quantum Circuits,
                Inc.](../../using/backends/hardware/superconducting.html#quantum-circuits-inc){.reference
                .internal}
        -   [Neutral Atom
            QPUs](../../using/backends/hardware/neutralatom.html){.reference
            .internal}
            -   [Infleqtion](../../using/backends/hardware/neutralatom.html#infleqtion){.reference
                .internal}
            -   [Pasqal](../../using/backends/hardware/neutralatom.html#pasqal){.reference
                .internal}
            -   [QuEra
                Computing](../../using/backends/hardware/neutralatom.html#quera-computing){.reference
                .internal}
        -   [Photonic
            QPUs](../../using/backends/hardware/photonic.html){.reference
            .internal}
            -   [ORCA
                Computing](../../using/backends/hardware/photonic.html#orca-computing){.reference
                .internal}
        -   [Quantum Control
            Systems](../../using/backends/hardware/qcontrol.html){.reference
            .internal}
            -   [Quantum
                Machines](../../using/backends/hardware/qcontrol.html#quantum-machines){.reference
                .internal}
    -   [Dynamics
        Simulation](../../using/backends/dynamics_backends.html){.reference
        .internal}
    -   [Cloud](../../using/backends/cloud.html){.reference .internal}
        -   [Amazon Braket
            (braket)](../../using/backends/cloud/braket.html){.reference
            .internal}
            -   [Setting
                Credentials](../../using/backends/cloud/braket.html#setting-credentials){.reference
                .internal}
            -   [Submission from
                C++](../../using/backends/cloud/braket.html#submission-from-c){.reference
                .internal}
            -   [Submission from
                Python](../../using/backends/cloud/braket.html#submission-from-python){.reference
                .internal}
        -   [NVIDIA Quantum Cloud
            (nvqc)](../../using/backends/cloud/nvqc.html){.reference
            .internal}
            -   [Quick
                Start](../../using/backends/cloud/nvqc.html#quick-start){.reference
                .internal}
            -   [Simulator Backend
                Selection](../../using/backends/cloud/nvqc.html#simulator-backend-selection){.reference
                .internal}
            -   [Multiple
                GPUs](../../using/backends/cloud/nvqc.html#multiple-gpus){.reference
                .internal}
            -   [Multiple QPUs Asynchronous
                Execution](../../using/backends/cloud/nvqc.html#multiple-qpus-asynchronous-execution){.reference
                .internal}
            -   [FAQ](../../using/backends/cloud/nvqc.html#faq){.reference
                .internal}
-   [Dynamics](../../using/dynamics.html){.reference .internal}
    -   [Quick Start](../../using/dynamics.html#quick-start){.reference
        .internal}
    -   [Operator](../../using/dynamics.html#operator){.reference
        .internal}
    -   [Time-Dependent
        Dynamics](../../using/dynamics.html#time-dependent-dynamics){.reference
        .internal}
    -   [Super-operator
        Representation](../../using/dynamics.html#super-operator-representation){.reference
        .internal}
    -   [Numerical
        Integrators](../../using/dynamics.html#numerical-integrators){.reference
        .internal}
    -   [Batch
        simulation](../../using/dynamics.html#batch-simulation){.reference
        .internal}
    -   [Multi-GPU Multi-Node
        Execution](../../using/dynamics.html#multi-gpu-multi-node-execution){.reference
        .internal}
    -   [Examples](../../using/dynamics.html#examples){.reference
        .internal}
-   [CUDA-QX](../../using/cudaqx/cudaqx.html){.reference .internal}
    -   [CUDA-Q
        Solvers](../../using/cudaqx/cudaqx.html#cuda-q-solvers){.reference
        .internal}
    -   [CUDA-Q
        QEC](../../using/cudaqx/cudaqx.html#cuda-q-qec){.reference
        .internal}
-   [Installation](../../using/install/install.html){.reference
    .internal}
    -   [Local
        Installation](../../using/install/local_installation.html){.reference
        .internal}
        -   [Introduction](../../using/install/local_installation.html#introduction){.reference
            .internal}
            -   [Docker](../../using/install/local_installation.html#docker){.reference
                .internal}
            -   [Known Blackwell
                Issues](../../using/install/local_installation.html#known-blackwell-issues){.reference
                .internal}
            -   [Singularity](../../using/install/local_installation.html#singularity){.reference
                .internal}
            -   [Python
                wheels](../../using/install/local_installation.html#python-wheels){.reference
                .internal}
            -   [Pre-built
                binaries](../../using/install/local_installation.html#pre-built-binaries){.reference
                .internal}
        -   [Development with VS
            Code](../../using/install/local_installation.html#development-with-vs-code){.reference
            .internal}
            -   [Using a Docker
                container](../../using/install/local_installation.html#using-a-docker-container){.reference
                .internal}
            -   [Using a Singularity
                container](../../using/install/local_installation.html#using-a-singularity-container){.reference
                .internal}
        -   [Connecting to a Remote
            Host](../../using/install/local_installation.html#connecting-to-a-remote-host){.reference
            .internal}
            -   [Developing with Remote
                Tunnels](../../using/install/local_installation.html#developing-with-remote-tunnels){.reference
                .internal}
            -   [Remote Access via
                SSH](../../using/install/local_installation.html#remote-access-via-ssh){.reference
                .internal}
        -   [DGX
            Cloud](../../using/install/local_installation.html#dgx-cloud){.reference
            .internal}
            -   [Get
                Started](../../using/install/local_installation.html#get-started){.reference
                .internal}
            -   [Use
                JupyterLab](../../using/install/local_installation.html#use-jupyterlab){.reference
                .internal}
            -   [Use VS
                Code](../../using/install/local_installation.html#use-vs-code){.reference
                .internal}
        -   [Additional CUDA
            Tools](../../using/install/local_installation.html#additional-cuda-tools){.reference
            .internal}
            -   [Installation via
                PyPI](../../using/install/local_installation.html#installation-via-pypi){.reference
                .internal}
            -   [Installation In Container
                Images](../../using/install/local_installation.html#installation-in-container-images){.reference
                .internal}
            -   [Installing Pre-built
                Binaries](../../using/install/local_installation.html#installing-pre-built-binaries){.reference
                .internal}
        -   [Distributed Computing with
            MPI](../../using/install/local_installation.html#distributed-computing-with-mpi){.reference
            .internal}
        -   [Updating
            CUDA-Q](../../using/install/local_installation.html#updating-cuda-q){.reference
            .internal}
        -   [Dependencies and
            Compatibility](../../using/install/local_installation.html#dependencies-and-compatibility){.reference
            .internal}
        -   [Next
            Steps](../../using/install/local_installation.html#next-steps){.reference
            .internal}
    -   [Data Center
        Installation](../../using/install/data_center_install.html){.reference
        .internal}
        -   [Prerequisites](../../using/install/data_center_install.html#prerequisites){.reference
            .internal}
        -   [Build
            Dependencies](../../using/install/data_center_install.html#build-dependencies){.reference
            .internal}
            -   [CUDA](../../using/install/data_center_install.html#cuda){.reference
                .internal}
            -   [Toolchain](../../using/install/data_center_install.html#toolchain){.reference
                .internal}
        -   [Building
            CUDA-Q](../../using/install/data_center_install.html#building-cuda-q){.reference
            .internal}
        -   [Python
            Support](../../using/install/data_center_install.html#python-support){.reference
            .internal}
        -   [C++
            Support](../../using/install/data_center_install.html#c-support){.reference
            .internal}
        -   [Installation on the
            Host](../../using/install/data_center_install.html#installation-on-the-host){.reference
            .internal}
            -   [CUDA Runtime
                Libraries](../../using/install/data_center_install.html#cuda-runtime-libraries){.reference
                .internal}
            -   [MPI](../../using/install/data_center_install.html#mpi){.reference
                .internal}
-   [Integration](../../using/integration/integration.html){.reference
    .internal}
    -   [Downstream CMake
        Integration](../../using/integration/cmake_app.html){.reference
        .internal}
    -   [Combining CUDA with
        CUDA-Q](../../using/integration/cuda_gpu.html){.reference
        .internal}
    -   [Integrating with Third-Party
        Libraries](../../using/integration/libraries.html){.reference
        .internal}
        -   [Calling a CUDA-Q library from
            C++](../../using/integration/libraries.html#calling-a-cuda-q-library-from-c){.reference
            .internal}
        -   [Calling an C++ library from
            CUDA-Q](../../using/integration/libraries.html#calling-an-c-library-from-cuda-q){.reference
            .internal}
        -   [Interfacing between binaries compiled with a different
            toolchains](../../using/integration/libraries.html#interfacing-between-binaries-compiled-with-a-different-toolchains){.reference
            .internal}
-   [Extending](../../using/extending/extending.html){.reference
    .internal}
    -   [Add a new Hardware
        Backend](../../using/extending/backend.html){.reference
        .internal}
        -   [Overview](../../using/extending/backend.html#overview){.reference
            .internal}
        -   [Server Helper
            Implementation](../../using/extending/backend.html#server-helper-implementation){.reference
            .internal}
            -   [Directory
                Structure](../../using/extending/backend.html#directory-structure){.reference
                .internal}
            -   [Server Helper
                Class](../../using/extending/backend.html#server-helper-class){.reference
                .internal}
            -   [`CMakeLists.txt`{.docutils .literal
                .notranslate}](../../using/extending/backend.html#cmakelists-txt){.reference
                .internal}
        -   [Target
            Configuration](../../using/extending/backend.html#target-configuration){.reference
            .internal}
            -   [Update Parent `CMakeLists.txt`{.docutils .literal
                .notranslate}](../../using/extending/backend.html#update-parent-cmakelists-txt){.reference
                .internal}
        -   [Testing](../../using/extending/backend.html#testing){.reference
            .internal}
            -   [Unit
                Tests](../../using/extending/backend.html#unit-tests){.reference
                .internal}
            -   [Mock
                Server](../../using/extending/backend.html#mock-server){.reference
                .internal}
            -   [Python
                Tests](../../using/extending/backend.html#python-tests){.reference
                .internal}
            -   [Integration
                Tests](../../using/extending/backend.html#integration-tests){.reference
                .internal}
        -   [Documentation](../../using/extending/backend.html#documentation){.reference
            .internal}
        -   [Example
            Usage](../../using/extending/backend.html#example-usage){.reference
            .internal}
        -   [Code
            Review](../../using/extending/backend.html#code-review){.reference
            .internal}
        -   [Maintaining a
            Backend](../../using/extending/backend.html#maintaining-a-backend){.reference
            .internal}
        -   [Conclusion](../../using/extending/backend.html#conclusion){.reference
            .internal}
    -   [Create a new NVQIR
        Simulator](../../using/extending/nvqir_simulator.html){.reference
        .internal}
        -   [`CircuitSimulator`{.code .docutils .literal
            .notranslate}](../../using/extending/nvqir_simulator.html#circuitsimulator){.reference
            .internal}
        -   [Let's see this in
            action](../../using/extending/nvqir_simulator.html#let-s-see-this-in-action){.reference
            .internal}
    -   [Working with CUDA-Q
        IR](../../using/extending/cudaq_ir.html){.reference .internal}
    -   [Create an MLIR Pass for
        CUDA-Q](../../using/extending/mlir_pass.html){.reference
        .internal}
-   [Specifications](../../specification/index.html){.reference
    .internal}
    -   [Language
        Specification](../../specification/cudaq.html){.reference
        .internal}
        -   [1. Machine
            Model](../../specification/cudaq/machine_model.html){.reference
            .internal}
        -   [2. Namespace and
            Standard](../../specification/cudaq/namespace.html){.reference
            .internal}
        -   [3. Quantum
            Types](../../specification/cudaq/types.html){.reference
            .internal}
            -   [3.1. `cudaq::qudit<Levels>`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/types.html#cudaq-qudit-levels){.reference
                .internal}
            -   [3.2. `cudaq::qubit`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/types.html#cudaq-qubit){.reference
                .internal}
            -   [3.3. Quantum
                Containers](../../specification/cudaq/types.html#quantum-containers){.reference
                .internal}
        -   [4. Quantum
            Operators](../../specification/cudaq/operators.html){.reference
            .internal}
            -   [4.1. `cudaq::spin_op`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/operators.html#cudaq-spin-op){.reference
                .internal}
        -   [5. Quantum
            Operations](../../specification/cudaq/operations.html){.reference
            .internal}
            -   [5.1. Operations on `cudaq::qubit`{.code .docutils
                .literal
                .notranslate}](../../specification/cudaq/operations.html#operations-on-cudaq-qubit){.reference
                .internal}
        -   [6. Quantum
            Kernels](../../specification/cudaq/kernels.html){.reference
            .internal}
        -   [7. Sub-circuit
            Synthesis](../../specification/cudaq/synthesis.html){.reference
            .internal}
        -   [8. Control
            Flow](../../specification/cudaq/control_flow.html){.reference
            .internal}
        -   [9. Just-in-Time Kernel
            Creation](../../specification/cudaq/dynamic_kernels.html){.reference
            .internal}
        -   [10. Quantum
            Patterns](../../specification/cudaq/patterns.html){.reference
            .internal}
            -   [10.1.
                Compute-Action-Uncompute](../../specification/cudaq/patterns.html#compute-action-uncompute){.reference
                .internal}
        -   [11.
            Platform](../../specification/cudaq/platform.html){.reference
            .internal}
        -   [12. Algorithmic
            Primitives](../../specification/cudaq/algorithmic_primitives.html){.reference
            .internal}
            -   [12.1. `cudaq::sample`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/algorithmic_primitives.html#cudaq-sample){.reference
                .internal}
            -   [12.2. `cudaq::run`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/algorithmic_primitives.html#cudaq-run){.reference
                .internal}
            -   [12.3. `cudaq::observe`{.code .docutils .literal
                .notranslate}](../../specification/cudaq/algorithmic_primitives.html#cudaq-observe){.reference
                .internal}
            -   [12.4. `cudaq::optimizer`{.code .docutils .literal
                .notranslate} (deprecated, functionality moved to CUDA-Q
                libraries)](../../specification/cudaq/algorithmic_primitives.html#cudaq-optimizer-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
            -   [12.5. `cudaq::gradient`{.code .docutils .literal
                .notranslate} (deprecated, functionality moved to CUDA-Q
                libraries)](../../specification/cudaq/algorithmic_primitives.html#cudaq-gradient-deprecated-functionality-moved-to-cuda-q-libraries){.reference
                .internal}
        -   [13. Example
            Programs](../../specification/cudaq/examples.html){.reference
            .internal}
            -   [13.1. Hello World - Simple Bell
                State](../../specification/cudaq/examples.html#hello-world-simple-bell-state){.reference
                .internal}
            -   [13.2. GHZ State Preparation and
                Sampling](../../specification/cudaq/examples.html#ghz-state-preparation-and-sampling){.reference
                .internal}
            -   [13.3. Quantum Phase
                Estimation](../../specification/cudaq/examples.html#quantum-phase-estimation){.reference
                .internal}
            -   [13.4. Deuteron Binding Energy Parameter
                Sweep](../../specification/cudaq/examples.html#deuteron-binding-energy-parameter-sweep){.reference
                .internal}
            -   [13.5. Grover's
                Algorithm](../../specification/cudaq/examples.html#grover-s-algorithm){.reference
                .internal}
            -   [13.6. Iterative Phase
                Estimation](../../specification/cudaq/examples.html#iterative-phase-estimation){.reference
                .internal}
    -   [Quake
        Specification](../../specification/quake-dialect.html){.reference
        .internal}
        -   [General
            Introduction](../../specification/quake-dialect.html#general-introduction){.reference
            .internal}
        -   [Motivation](../../specification/quake-dialect.html#motivation){.reference
            .internal}
-   [API Reference](../../api/api.html){.reference .internal}
    -   [C++ API](../../api/languages/cpp_api.html){.reference
        .internal}
        -   [Operators](../../api/languages/cpp_api.html#operators){.reference
            .internal}
        -   [Quantum](../../api/languages/cpp_api.html#quantum){.reference
            .internal}
        -   [Common](../../api/languages/cpp_api.html#common){.reference
            .internal}
        -   [Noise
            Modeling](../../api/languages/cpp_api.html#noise-modeling){.reference
            .internal}
        -   [Kernel
            Builder](../../api/languages/cpp_api.html#kernel-builder){.reference
            .internal}
        -   [Algorithms](../../api/languages/cpp_api.html#algorithms){.reference
            .internal}
        -   [Platform](../../api/languages/cpp_api.html#platform){.reference
            .internal}
        -   [Utilities](../../api/languages/cpp_api.html#utilities){.reference
            .internal}
        -   [Namespaces](../../api/languages/cpp_api.html#namespaces){.reference
            .internal}
    -   [Python API](../../api/languages/python_api.html){.reference
        .internal}
        -   [Program
            Construction](../../api/languages/python_api.html#program-construction){.reference
            .internal}
            -   [`make_kernel()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.make_kernel){.reference
                .internal}
            -   [`PyKernel`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.PyKernel){.reference
                .internal}
            -   [`Kernel`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.Kernel){.reference
                .internal}
            -   [`PyKernelDecorator`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.PyKernelDecorator){.reference
                .internal}
            -   [`kernel()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.kernel){.reference
                .internal}
        -   [Kernel
            Execution](../../api/languages/python_api.html#kernel-execution){.reference
            .internal}
            -   [`sample()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.sample){.reference
                .internal}
            -   [`sample_async()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.sample_async){.reference
                .internal}
            -   [`run()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.run){.reference
                .internal}
            -   [`run_async()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.run_async){.reference
                .internal}
            -   [`observe()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.observe){.reference
                .internal}
            -   [`observe_async()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.observe_async){.reference
                .internal}
            -   [`get_state()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.get_state){.reference
                .internal}
            -   [`get_state_async()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.get_state_async){.reference
                .internal}
            -   [`vqe()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.vqe){.reference
                .internal}
            -   [`draw()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.draw){.reference
                .internal}
            -   [`translate()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.translate){.reference
                .internal}
            -   [`estimate_resources()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.estimate_resources){.reference
                .internal}
        -   [Backend
            Configuration](../../api/languages/python_api.html#backend-configuration){.reference
            .internal}
            -   [`has_target()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.has_target){.reference
                .internal}
            -   [`get_target()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.get_target){.reference
                .internal}
            -   [`get_targets()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.get_targets){.reference
                .internal}
            -   [`set_target()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.set_target){.reference
                .internal}
            -   [`reset_target()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.reset_target){.reference
                .internal}
            -   [`set_noise()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.set_noise){.reference
                .internal}
            -   [`unset_noise()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.unset_noise){.reference
                .internal}
            -   [`register_set_target_callback()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.register_set_target_callback){.reference
                .internal}
            -   [`unregister_set_target_callback()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.unregister_set_target_callback){.reference
                .internal}
            -   [`cudaq.apply_noise()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.cudaq.apply_noise){.reference
                .internal}
            -   [`initialize_cudaq()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.initialize_cudaq){.reference
                .internal}
            -   [`num_available_gpus()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.num_available_gpus){.reference
                .internal}
            -   [`set_random_seed()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.set_random_seed){.reference
                .internal}
        -   [Dynamics](../../api/languages/python_api.html#dynamics){.reference
            .internal}
            -   [`evolve()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.evolve){.reference
                .internal}
            -   [`evolve_async()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.evolve_async){.reference
                .internal}
            -   [`Schedule`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.Schedule){.reference
                .internal}
            -   [`BaseIntegrator`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.dynamics.integrator.BaseIntegrator){.reference
                .internal}
            -   [`InitialState`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.dynamics.helpers.InitialState){.reference
                .internal}
            -   [`InitialStateType`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.InitialStateType){.reference
                .internal}
            -   [`IntermediateResultSave`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.IntermediateResultSave){.reference
                .internal}
        -   [Operators](../../api/languages/python_api.html#operators){.reference
            .internal}
            -   [`OperatorSum`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.operators.OperatorSum){.reference
                .internal}
            -   [`ProductOperator`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.operators.ProductOperator){.reference
                .internal}
            -   [`ElementaryOperator`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.operators.ElementaryOperator){.reference
                .internal}
            -   [`ScalarOperator`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.operators.ScalarOperator){.reference
                .internal}
            -   [`RydbergHamiltonian`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.operators.RydbergHamiltonian){.reference
                .internal}
            -   [`SuperOperator`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.SuperOperator){.reference
                .internal}
            -   [`operators.define()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.operators.define){.reference
                .internal}
            -   [`operators.instantiate()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.operators.instantiate){.reference
                .internal}
            -   [Spin
                Operators](../../api/languages/python_api.html#spin-operators){.reference
                .internal}
            -   [Fermion
                Operators](../../api/languages/python_api.html#fermion-operators){.reference
                .internal}
            -   [Boson
                Operators](../../api/languages/python_api.html#boson-operators){.reference
                .internal}
            -   [General
                Operators](../../api/languages/python_api.html#general-operators){.reference
                .internal}
        -   [Data
            Types](../../api/languages/python_api.html#data-types){.reference
            .internal}
            -   [`SimulationPrecision`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.SimulationPrecision){.reference
                .internal}
            -   [`Target`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.Target){.reference
                .internal}
            -   [`State`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.State){.reference
                .internal}
            -   [`Tensor`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.Tensor){.reference
                .internal}
            -   [`QuakeValue`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.QuakeValue){.reference
                .internal}
            -   [`qubit`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.qubit){.reference
                .internal}
            -   [`qreg`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.qreg){.reference
                .internal}
            -   [`qvector`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.qvector){.reference
                .internal}
            -   [`ComplexMatrix`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.ComplexMatrix){.reference
                .internal}
            -   [`SampleResult`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.SampleResult){.reference
                .internal}
            -   [`AsyncSampleResult`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.AsyncSampleResult){.reference
                .internal}
            -   [`ObserveResult`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.ObserveResult){.reference
                .internal}
            -   [`AsyncObserveResult`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.AsyncObserveResult){.reference
                .internal}
            -   [`AsyncStateResult`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.AsyncStateResult){.reference
                .internal}
            -   [`OptimizationResult`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.OptimizationResult){.reference
                .internal}
            -   [`EvolveResult`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.EvolveResult){.reference
                .internal}
            -   [`AsyncEvolveResult`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.AsyncEvolveResult){.reference
                .internal}
            -   [`Resources`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.Resources){.reference
                .internal}
            -   [Optimizers](../../api/languages/python_api.html#optimizers){.reference
                .internal}
            -   [Gradients](../../api/languages/python_api.html#gradients){.reference
                .internal}
            -   [Noisy
                Simulation](../../api/languages/python_api.html#noisy-simulation){.reference
                .internal}
        -   [MPI
            Submodule](../../api/languages/python_api.html#mpi-submodule){.reference
            .internal}
            -   [`initialize()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.mpi.initialize){.reference
                .internal}
            -   [`rank()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.mpi.rank){.reference
                .internal}
            -   [`num_ranks()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.mpi.num_ranks){.reference
                .internal}
            -   [`all_gather()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.mpi.all_gather){.reference
                .internal}
            -   [`broadcast()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.mpi.broadcast){.reference
                .internal}
            -   [`is_initialized()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.mpi.is_initialized){.reference
                .internal}
            -   [`finalize()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.mpi.finalize){.reference
                .internal}
        -   [ORCA
            Submodule](../../api/languages/python_api.html#orca-submodule){.reference
            .internal}
            -   [`sample()`{.docutils .literal
                .notranslate}](../../api/languages/python_api.html#cudaq.orca.sample){.reference
                .internal}
    -   [Quantum Operations](../../api/default_ops.html){.reference
        .internal}
        -   [Unitary Operations on
            Qubits](../../api/default_ops.html#unitary-operations-on-qubits){.reference
            .internal}
            -   [`x`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#x){.reference
                .internal}
            -   [`y`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#y){.reference
                .internal}
            -   [`z`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#z){.reference
                .internal}
            -   [`h`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#h){.reference
                .internal}
            -   [`r1`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#r1){.reference
                .internal}
            -   [`rx`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#rx){.reference
                .internal}
            -   [`ry`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#ry){.reference
                .internal}
            -   [`rz`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#rz){.reference
                .internal}
            -   [`s`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#s){.reference
                .internal}
            -   [`t`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#t){.reference
                .internal}
            -   [`swap`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#swap){.reference
                .internal}
            -   [`u3`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#u3){.reference
                .internal}
        -   [Adjoint and Controlled
            Operations](../../api/default_ops.html#adjoint-and-controlled-operations){.reference
            .internal}
        -   [Measurements on
            Qubits](../../api/default_ops.html#measurements-on-qubits){.reference
            .internal}
            -   [`mz`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#mz){.reference
                .internal}
            -   [`mx`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#mx){.reference
                .internal}
            -   [`my`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#my){.reference
                .internal}
        -   [User-Defined Custom
            Operations](../../api/default_ops.html#user-defined-custom-operations){.reference
            .internal}
        -   [Photonic Operations on
            Qudits](../../api/default_ops.html#photonic-operations-on-qudits){.reference
            .internal}
            -   [`create`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#create){.reference
                .internal}
            -   [`annihilate`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#annihilate){.reference
                .internal}
            -   [`phase_shift`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#phase-shift){.reference
                .internal}
            -   [`beam_splitter`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#beam-splitter){.reference
                .internal}
            -   [`mz`{.code .docutils .literal
                .notranslate}](../../api/default_ops.html#id1){.reference
                .internal}
-   [Other Versions](../../versions.html){.reference .internal}
:::
:::

::: {.section .wy-nav-content-wrap toggle="wy-nav-shift"}
[NVIDIA CUDA-Q](../../index.html)

::: {.wy-nav-content}
::: {.rst-content}
::: {role="navigation" aria-label="Page navigation"}
-   [](../../index.html){.icon .icon-home}
-   [CUDA-Q Applications](../../using/applications.html)
-   Factoring Integers With Shor's Algorithm
-   

::: {.rst-breadcrumbs-buttons role="navigation" aria-label="Sequential page navigation"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](edge_detection.html "Quantum edge detection"){.btn
.btn-neutral .float-left} [Next []{.fa .fa-arrow-circle-right
aria-hidden="true"}](generate_fermionic_ham.html "Generating the electronic Hamiltonian"){.btn
.btn-neutral .float-right}
:::

------------------------------------------------------------------------
:::

::: {.document role="main" itemscope="itemscope" itemtype="http://schema.org/Article"}
::: {itemprop="articleBody"}
::: {#Factoring-Integers-With-Shor's-Algorithm .section}
Factoring Integers With Shor's Algorithm[¶](#Factoring-Integers-With-Shor's-Algorithm "Permalink to this heading"){.headerlink}
===============================================================================================================================

The most famous application of quantum computers is factoring integers
using Shor's algorithm. This algorithm is particularly significant
because an efficient factorization algorithm could potentially break
modern asymmetric encryption schemes, such as RSA.

For small integers, this quantum algorithm can be simulated on classical
computers. The main challenge in classical implementation lies in the
order-finding algorithm. We will first introduce the classical
implementation of this algorithm as a preliminary step, and then proceed
to explain the quantum order-finding algorithm.

First let's install some libraries.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [ ]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    !pip install contfrac==1.0.0 -q
:::
:::
:::

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [156]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    from math import gcd, log2, ceil
    import numpy as np
    import random
    import cudaq
    from cudaq import *
    import fractions
    import matplotlib.pyplot as plt
    import contfrac
:::
:::
:::

::: {#Shor's-algorithm .section}
Shor's algorithm[¶](#Shor's-algorithm "Permalink to this heading"){.headerlink}
-------------------------------------------------------------------------------

The factoring problem for an integer [\\(N\\)]{.math .notranslate
.nohighlight} aims to find integers [\\(a\_1\\)]{.math .notranslate
.nohighlight}, [\\(a\_2\\)]{.math .notranslate .nohighlight} which are
factors of [\\(N\\)]{.math .notranslate .nohighlight}. This problem is
interesting when [\\(N\\)]{.math .notranslate .nohighlight} is not prime
and the solutions [\\(a\_1\\)]{.math .notranslate .nohighlight} and
[\\(a\_2\\)]{.math .notranslate .nohighlight} are non-trivial. In other
words, we will attempt to find integers [\\(a\_1\\)]{.math .notranslate
.nohighlight} and [\\(a\_2\\)]{.math .notranslate .nohighlight}
satisfying [\\(N=a\_1\\cdot a\_2\\)]{.math .notranslate .nohighlight}
with [\\(a\_1\\neq 1\\)]{.math .notranslate .nohighlight} and
[\\(a\_2\\neq 1\\)]{.math .notranslate .nohighlight}.

The algorithm consists of two ideas:

-   Reduce the problem of factoring the integer [\\(N\\)]{.math
    .notranslate .nohighlight} to the order-finding problem.

-   Solve the order-finding problem: Given integers [\\(a\\)]{.math
    .notranslate .nohighlight} and [\\(N\\)]{.math .notranslate
    .nohighlight} so that [\\(a\\)]{.math .notranslate .nohighlight} and
    [\\(N\\)]{.math .notranslate .nohighlight} share no common factors
    (i.e., the greatest common divisor of [\\(a\\)]{.math .notranslate
    .nohighlight} and [\\(N\\)]{.math .notranslate .nohighlight} is 1),
    find the smallest positive integer which satisfies [\\(a\^r \\equiv
    1 \\mod N\\)]{.math .notranslate .nohighlight}. This value
    [\\(r\\)]{.math .notranslate .nohighlight} is refered to as the
    *order of* [\\(a \\mod N\\)]{.math .notranslate .nohighlight}.

These two ideas are combined in the following steps in Shor's algorithm:

0.  Rule out the easy case that [\\(N\\)]{.math .notranslate
    .nohighlight} is even

1.  Select a random integer [\\(a\\)]{.math .notranslate .nohighlight}
    between [\\(2\\)]{.math .notranslate .nohighlight} and
    [\\(N-1\\)]{.math .notranslate .nohighlight}

2.  Check to see if [\\(a\\)]{.math .notranslate .nohighlight} is a
    factor of [\\(N\\)]{.math .notranslate .nohighlight} (if so we're
    done!)

3.  Find the order of [\\(a \\mod N\\)]{.math .notranslate
    .nohighlight}, (i.e., find [\\(r\\)]{.math .notranslate
    .nohighlight} so that [\\(a\^r\\equiv 1 \\mod N\\)]{.math
    .notranslate .nohighlight})

4.  Check to see if [\\(a\^{\\frac{r}{2}}-1\\)]{.math .notranslate
    .nohighlight} or [\\(a\^{\\frac{r}{2}}+1\\)]{.math .notranslate
    .nohighlight} are integers and share common, non-trivial, divisors
    with [\\(N\\)]{.math .notranslate .nohighlight} (if so we're done!)

5.  If no factor is found, repeat steps 1 through 4 above.

The function `shors_algorithm`{.docutils .literal .notranslate} below
outlines these steps for both the classical and the quantum
implementation of Shor's algorithm. For the purposes of demonstration,
we will also control the initial random integer selected in step 1 so
that we can investigate cases in which the selected integer produces
common divisors of [\\(N\\)]{.math .notranslate .nohighlight} in step 4
and others in which step 4 produces no common factors.

**Note about terminology:** Some literature refers to the
"period-finding problem" in Shor's algorithm. The order-finding problem,
as we have described above, can be recast as finding the period of the
function [\\(f(x) = a\^x\\mod N\\)]{.math .notranslate .nohighlight}, by
noticing that the period of [\\(f(x)\\)]{.math .notranslate
.nohighlight} is one more than the order of [\\(a\\mod N\\)]{.math
.notranslate .nohighlight}. The period finding problem is more general
than the order-finding problem since it aims to find the period of any
periodic function, not just modular exponentiation.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [3]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    def shors_algorithm(N, initial, quantum):
        """ Factor N using Shor's algorithm with initial starting value and choice of
        using either classical or quantum approach for the period finding step
        Parameters
        ----------
        N: int
            Integer to be factored (assumed to be non-prime and >1)
        initial: int
            Initial choice of the random integer between 2 and N-1
        quantum: boolean
            True if we will call the quantum order-finding algorithm, and false if we call the classical one for step 3.

        Returns
        -------
        a1, a2: int
            Non-trivial factors of N
        """

        # 0. Check to see if N is even.
        if N % 2 == 0:
            divisor1 = 2
            divisor2 = N // 2
            print("Found factors:", divisor1, divisor2)
            return (divisor1, divisor2)

        attempts = [initial]
        while (True):
            # 1. Select a random integer between 2 and N-1
            if len(attempts) == 1:
                a = initial
            else:
                a = random.choice(
                    [n for n in range(N - 1) if n not in attempts and n != 1])

            # 2. See if the integer selected in step 1 happens to factor N
            print("Trying a =", a)
            divisor1 = gcd(a, N)
            if divisor1 != 1:
                divisor2 = N // divisor1
                print("Found factors of N={} by chance: {} and {}".format(
                    N, divisor1, divisor2))
                return (divisor1, divisor2)

            # 3. Find the order of a mod N (i.e., r, where a^r = 1 (mod N))
            if quantum == True:
                r = find_order_quantum(a, N)
            else:
                r = find_order_classical(a, N)
            print("The order of a = {} is {}".format(a, r))

            # 4. If the order of a is found and it is
            # * even and
            # * not a^(r/2) = -1 (mod N),
            # then test a^(r/2)-1 and a^(r/2)+1 to see if they share factors with N.
            # We also want to rule out the case of finding the trivial factors: 1 and N.
            divisor1, divisor2 = test_order(a, r, N)
            if (divisor1 != 0):  # test_order will return a 0 if no factor is found
                print("Found factors of N = {}: {} and {}".format(
                    N, divisor1, divisor2))
                return divisor1, divisor2

            # 5. Repeat
            print("retrying...")
            attempts.append(a)
:::
:::
:::

Let's first explore the idea of reducing the factoring problem into the
order-finding problem. This gets captured in step 4 described above. In
this step, we have already established that [\\(a\\)]{.math .notranslate
.nohighlight} and [\\(N\\)]{.math .notranslate .nohighlight} share no
factors other than [\\(1\\)]{.math .notranslate .nohighlight} (i.e.,
[\\(\\gcd(a,N)=1\\)]{.math .notranslate .nohighlight}) and we have found
[\\(r\\)]{.math .notranslate .nohighlight}, the order of [\\(a\\mod
N.\\)]{.math .notranslate .nohighlight} With this information we know
that [\\(a\^r \\equiv 1 \\mod N.\\)]{.math .notranslate .nohighlight}
Rewritten in another way:

::: {.math .notranslate .nohighlight}
\\\[a\^r -1 \\equiv 0\\mod N \\tag{1}.\\\]
:::

If [\\(r\\)]{.math .notranslate .nohighlight} is even, we can rewrite
[\\(a\^r\\)]{.math .notranslate .nohighlight} as [\\(x\^2\\)]{.math
.notranslate .nohighlight} where [\\(x=a\^\\frac{r}{2}\\)]{.math
.notranslate .nohighlight}. Next, we can factor equation
[\\((1)\\)]{.math .notranslate .nohighlight} using the identity
[\\(x\^2-1 = (x-1)(x+1)\\)]{.math .notranslate .nohighlight}:

::: {.math .notranslate .nohighlight}
\\\[ (a\^{\\frac{r}{2}} - 1)(a\^{\\frac{r}{2}} + 1) \\equiv 0\\mod N
\\tag{2}.\\\]
:::

If, in addition, the equation

::: {.math .notranslate .nohighlight}
\\\[a\^{\\frac{r}{2}} \\not\\equiv -1\\mod N \\tag{3}\\\]
:::

is satisfied, then at least one of the terms [\\(a\^{\\frac{r}{2}} -
1\\)]{.math .notranslate .nohighlight} or [\\(a\^{\\frac{r}{2}} +
1\\)]{.math .notranslate .nohighlight} must share a common factor with
[\\(N\\)]{.math .notranslate .nohighlight}. [Peter
Shor](https://arxiv.org/abs/quant-ph/9508027){.reference .external}
demonstrated that there is greater than a [\\(50\\%\\)]{.math
.notranslate .nohighlight} chance of randomly selecting a value for
[\\(a\\)]{.math .notranslate .nohighlight} satisfying these properties.

The code block below defines a function that tests whether
[\\(r\\)]{.math .notranslate .nohighlight} is even and whether equation
[\\((3)\\)]{.math .notranslate .nohighlight} is satisfied and searches
for a non-trivial factor of [\\(N\\)]{.math .notranslate .nohighlight}.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [157]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    def test_order(a, r, N):
        """Checks whether or not a^(r/2)+1 or a^(r/2)-1 share a non-trivial common factor with N
        Parameters
        ----------
        a: int
        r: int
        N: int

        Returns
        -------
        int, int factors of N, if found; 0,0 otherwise
        """

        if r != None and (r % 2 == 0) and a**r % N == 1:
            if (a**(int(r / 2))) % N != -1:
                possible_factors = [gcd(r - 1, N), gcd(r + 1, N)]
                for test_factor in possible_factors:
                    if test_factor != 1 and test_factor != N:
                        return test_factor, N // test_factor
        # period did not produce a factor
        else:
            print('No non-trivial factor found')
            return 0, 0
:::
:::
:::

::: {#Solving-the-order-finding-problem-classically .section}
### Solving the order-finding problem classically[¶](#Solving-the-order-finding-problem-classically "Permalink to this heading"){.headerlink}

The key component of Shor's algorithm is an efficient quantum algorithm
to find the order [\\(r\\)]{.math .notranslate .nohighlight} of [\\(a
\\mod N\\)]{.math .notranslate .nohighlight}. While a straightforward
classical algorithm can solve this problem, it is notably inefficient:

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [158]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    def find_order_classical(a, N):
        """A naive classical method to find the order r of a (mod N).
        Parameters
        ----------
        a: int
            an integer in the interval [2,N-1]
        N: int

        Returns
        -------
        r: int
            Period of a^x (mod N)
        """
        assert 1 < a and a < N
        r = 1
        y = a
        while y != 1:
            y = y * a % N
            r += 1
        return r
:::
:::
:::

Let's see how Shor's algorithm works on a few examples using the
classical order-finding problem. Notice how often our choice of value
for the initial guess for [\\(a\\)]{.math .notranslate .nohighlight}
produces factors of [\\(N\\)]{.math .notranslate .nohighlight}.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [159]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    my_integer = 123  #edit this value to try out a few examples
    # Edit the value in the line below to try out different initial guesses for a.
    # What happens when you choose a = 42 for the integer 123?
    # What happens when you choose a = 100 for the integer 123?
    initial_value_to_start = 42  # edit this value; it should be less than my_integer

    shors_algorithm(my_integer, initial_value_to_start, False)
:::
:::
:::

::: {.nboutput .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: {.highlight}
    Trying a = 42
    Found factors of N=123 by chance: 3 and 41
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [159]:
:::
:::

::: {.output_area .docutils .container}
::: {.highlight}
    (3, 41)
:::
:::
:::
:::

::: {#Solving-the-order-finding-problem-with-a-quantum-algorithm .section}
### Solving the order-finding problem with a quantum algorithm[¶](#Solving-the-order-finding-problem-with-a-quantum-algorithm "Permalink to this heading"){.headerlink}

The Fourier transform is a classical computation that provides a more
efficient algorithm than the one encoded in
`find_order_classical`{.docutils .literal .notranslate} for identifying
the period of [\\(f(x) = a\^x\\mod N\\)]{.math .notranslate
.nohighlight}. The quantum version of the Fourier transform is the
central idea of Shor's Algorithm. This efficient quantum solution
derives the period from a measurement of [\\(n = \\lceil log2(N)
\\rceil\\)]{.math .notranslate .nohighlight} qubits.

The image below outlines the quantum kernel used to find the order of
[\\(a\\)]{.math .notranslate .nohighlight}. Notice the last step
involves applying the Inverse Quantum Fourier Transform.

![image0](../../_images/shor_circuit.png)

Figure. Circuit diagram for finding the phase of the modular
multiplication gate [\\(U\|x\\rangle = \|a\^x\\mod N\\rangle\\)]{.math
.notranslate .nohighlight}, which will be used to compute the order of
[\\(a\\)]{.math .notranslate .nohighlight} modulo [\\(N\\)]{.math
.notranslate .nohighlight}. The number of qubits in the control register
determines the accuracy of estimating the phase of [\\(U\\)]{.math
.notranslate .nohighlight}. The size of the work register depends on
[\\(N\\)]{.math .notranslate .nohighlight}. The goal of this section is
to code the diagram as a kernel named `phase_kernel`{.docutils .literal
.notranslate}.

We will need to create a quantum kernel for the Inverse Quantum Fourier
Transform. Additionally we'll need to create a kernel for modular
multiplication: [\\(g(y) = ay \\mod N\\)]{.math .notranslate
.nohighlight}, which can be repeatedly applied [\\(x\\)]{.math
.notranslate .nohighlight}-times to [\\(y=1\\)]{.math .notranslate
.nohighlight} to carry our modular exponentation [\\(f(x)=a\^x\\mod
N\\)]{.math .notranslate .nohighlight}.

::: {#Inverse-quantum-Fourier-transform .section}
#### Inverse quantum Fourier transform[¶](#Inverse-quantum-Fourier-transform "Permalink to this heading"){.headerlink}

In the code block below we define a kernel for the quantum Fourier
transform and then use `cudaq.adjoint`{.docutils .literal .notranslate}
to create a kernel for the inverse quantum Fourier transform used in the
quantum order-finding algorithm.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [160]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    # Define kernels for the quantum Fourier transform and the inverse quantum Fourier transform
    @cudaq.kernel
    def quantum_fourier_transform(qubits: cudaq.qview):
        qubit_count = len(qubits)
        # Apply Hadamard gates and controlled rotation gates.
        for i in range(qubit_count):
            h(qubits[i])
            for j in range(i + 1, qubit_count):
                angle = (2 * np.pi) / (2**(j - i + 1))
                cr1(angle, [qubits[j]], qubits[i])


    @cudaq.kernel
    def inverse_qft(qubits: cudaq.qview):
        cudaq.adjoint(quantum_fourier_transform, qubits)
:::
:::
:::
:::

::: {#Quantum-kernels-for-modular-exponentiation .section}
#### Quantum kernels for modular exponentiation[¶](#Quantum-kernels-for-modular-exponentiation "Permalink to this heading"){.headerlink}

While Shor's algorithm provably can factor numbers faster than known
classical techniques, the resources required for implementing Shor's
algorithm are hefty. A full-scale implementation to factor an
[\\(L\\)]{.math .notranslate .nohighlight}-bit number could require a
quantum kernel with [\\(5L+1\\)]{.math .notranslate .nohighlight} qubits
to achieve accuracy for the continued fractions part of the algoirthm
and as many as [\\(72L\^3\\)]{.math .notranslate .nohighlight} quantum
gates for the modular exponentiaion [(Beckman, Chari, Devabhaktuni, &
Preskill, 1996)](https://arxiv.org/pdf/quant-ph/9602016){.reference
.external}. Both of these are well beyond the capabilities of modern
quantum hardware for numbers of interest. Advancements to reduce the
number of gates and qubits required focus on optimizing the kernel for
[\\(f(x) = a\\cdot x \\mod N\\)]{.math .notranslate .nohighlight} for
properties of the number to be factored. The difficulty is to create
efficient quantum kernels (in terms of qubit and gate count) that
compute [\\(a\\cdot x \\mod{N}\\)]{.math .notranslate .nohighlight}.

For the purposes of this demonstration, we will consider only the
order-finding problem for the values of [\\(a\\)]{.math .notranslate
.nohighlight} to be either [\\(4\\)]{.math .notranslate .nohighlight} or
[\\(5\\)]{.math .notranslate .nohighlight} with [\\(N=21\\)]{.math
.notranslate .nohighlight}. We'll be using the quantum circuits depicted
in [this paper](https://arxiv.org/abs/2103.13855){.reference .external}
and [this
report](https://physlab.org/wp-content/uploads/2023/05/Shor_s_Algorithm_23100113_Fin.pdf){.reference
.external}, respectively.

::: {#The-case-N-=-21-and-a-=-5: .section}
##### The case N = 21 and a = 5:[¶](#The-case-N-=-21-and-a-=-5: "Permalink to this heading"){.headerlink}

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [161]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    @cudaq.kernel
    def modular_mult_5_21(work: cudaq.qview):
        """"Kernel for multiplying by 5 mod 21
        based off of the circuit diagram in
        https://physlab.org/wp-content/uploads/2023/05/Shor_s_Algorithm_23100113_Fin.pdf
        Modifications were made to change the ordering of the qubits"""
        x(work[0])
        x(work[2])
        x(work[4])

        swap(work[0], work[4])
        swap(work[0], work[2])


    @cudaq.kernel
    def modular_exp_5_21(exponent: cudaq.qview, work: cudaq.qview,
                         control_size: int):
        """ Controlled modular exponentiation kernel used in Shor's algorithm
        |x> U^x |y> = |x> |(5^x)y mod 21>
        """
        x(work[0])
        for exp in range(control_size):
            ctrl_qubit = exponent[exp]
            for _ in range(2**(exp)):
                cudaq.control(modular_mult_5_21, ctrl_qubit, work)
:::
:::
:::

Verify in the code block below that the kernels defined above do in fact
carry out multiplication and exponentiation with [\\(a=5\\)]{.math
.notranslate .nohighlight} and [\\(N=21\\)]{.math .notranslate
.nohighlight} by changing the `iterations`{.docutils .literal
.notranslate} variable below.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [198]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    # Demonstrate iterated application of 5y mod 21 where y = 1
    @cudaq.kernel
    def demonstrate_mod_exponentiation(iterations: int):
        qubits = cudaq.qvector(5)
        x(qubits[0]
         )  # initalizes the qubits in the state for y = 1 which is |10000>
        for _ in range(iterations):
            modular_mult_5_21(qubits)


    shots = 200

    # The iterations variable determines the exponent in 5^x mod 21.
    # Change this value to verify that the demonstrate_mod_exponentiation
    # kernel carries out the desired calculation.
    iterations = 1

    print(cudaq.draw(demonstrate_mod_exponentiation, iterations))

    results = cudaq.sample(demonstrate_mod_exponentiation,
                           iterations,
                           shots_count=shots)

    print("Measurement results from sampling:", results)

    # Reverse the order of the most probable measured bit string
    # and convert the binary string to an integer
    integer_result = int(results.most_probable()[::-1], 2)

    print("For x = {}, 5^x mod 21 = {}".format(iterations, (5**iterations) % 21))
    print("For x = {}, the computed result of the circuit is {}".format(
        iterations, integer_result))
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: {.highlight}
         ╭───╮╭───╮
    q0 : ┤ x ├┤ x ├─╳──╳─
         ╰───╯╰───╯ │  │
    q1 : ───────────┼──┼─
         ╭───╮      │  │
    q2 : ┤ x ├──────┼──╳─
         ╰───╯      │
    q3 : ───────────┼────
         ╭───╮      │
    q4 : ┤ x ├──────╳────
         ╰───╯

    Measurement results from sampling: { 10100:200 }

    For x = 1, 5^x mod 21 = 5
    For x = 1, the computed result of the circuit is 5
:::
:::
:::
:::

::: {#The-case-N-=-21-and-a-=-4: .section}
##### The case N = 21 and a = 4:[¶](#The-case-N-=-21-and-a-=-4: "Permalink to this heading"){.headerlink}

The example below is one where the work register has been optimized to
use fewer gates and qubits than would have been necessary through a
straightforward implementation of modular multiplication as seen in the
previous case.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [199]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    @cudaq.kernel
    def modular_exp_4_21(exponent: cudaq.qview, work: cudaq.qview):
        """ Controlled modular exponentiation kernel used in Shor's algorithm
         |x> U^x |y> = |x> |(4^x)y mod 21>
         based off of the circuit diagram in https://arxiv.org/abs/2103.13855
         Modifications were made to account for qubit ordering differences"""
        swap(exponent[0], exponent[2])
        # x = 1
        x.ctrl(exponent[2], work[1])

        # x = 2
        x.ctrl(exponent[1], work[1])
        x.ctrl(work[1], work[0])
        x.ctrl([exponent[1], work[0]], work[1])
        x.ctrl(work[1], work[0])

        # x = 4
        x(work[1])
        x.ctrl([exponent[0], work[1]], work[0])
        x(work[1])
        x.ctrl(work[1], work[0])
        x.ctrl([exponent[0], work[0]], work[1])
        x.ctrl(work[1], work[0])
        swap(exponent[0], exponent[2])
:::
:::
:::

Now we are ready to define the `phase_kernel`{.docutils .literal
.notranslate} to carry out the instructions in the circuit diagram drawn
at the beginning of this section.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [200]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    @cudaq.kernel
    def phase_kernel(control_register_size: int, work_register_size: int, a: int,
                     N: int):
        """
        Kernel to estimate the phase of the modular multiplication gate |x> U |y> = |x> |a*y mod 21> for a = 4 or 5
        """

        qubits = cudaq.qvector(control_register_size + work_register_size)
        control_register = qubits[0:control_register_size]
        work_register = qubits[control_register_size:control_register_size +
                               work_register_size]

        h(control_register)

        if a == 4 and N == 21:
            modular_exp_4_21(control_register, work_register)
        if a == 5 and N == 21:
            modular_exp_5_21(control_register, work_register, control_register_size)

        inverse_qft(control_register)

        # Measure only the control_register and not the work_register
        mz(control_register)
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [201]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    control_register_size = 3
    work_register_size = 5
    values_for_a = [4, 5]
    idx = 1  # change to 1 to select 5
    N = 21
    shots = 15000

    print(
        cudaq.draw(phase_kernel, control_register_size, work_register_size,
                   values_for_a[idx], N))

    results = cudaq.sample(phase_kernel,
                           control_register_size,
                           work_register_size,
                           values_for_a[idx],
                           N,
                           shots_count=shots)
    print(
        "Measurement results for a={} and N={} with {} qubits in the control register "
        .format(values_for_a[idx], N, control_register_size))
    print(results)
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: {.highlight}
         ╭───╮                                                                    »
    q0 : ┤ h ├──●────●────●───●──●────────────────────────────────────────────────»
         ├───┤  │    │    │   │  │                                                »
    q1 : ┤ h ├──┼────┼────┼───┼──┼───●────●────●───●──●───●────●────●───●──●──────»
         ├───┤  │    │    │   │  │   │    │    │   │  │   │    │    │   │  │      »
    q2 : ┤ h ├──┼────┼────┼───┼──┼───┼────┼────┼───┼──┼───┼────┼────┼───┼──┼───●──»
         ├───┤╭─┴─╮  │    │   │  │ ╭─┴─╮  │    │   │  │ ╭─┴─╮  │    │   │  │ ╭─┴─╮»
    q3 : ┤ x ├┤ x ├──┼────┼───╳──╳─┤ x ├──┼────┼───╳──╳─┤ x ├──┼────┼───╳──╳─┤ x ├»
         ╰───╯╰───╯  │    │   │  │ ╰───╯  │    │   │  │ ╰───╯  │    │   │  │ ╰───╯»
    q4 : ────────────┼────┼───┼──┼────────┼────┼───┼──┼────────┼────┼───┼──┼──────»
                   ╭─┴─╮  │   │  │      ╭─┴─╮  │   │  │      ╭─┴─╮  │   │  │      »
    q5 : ──────────┤ x ├──┼───┼──╳──────┤ x ├──┼───┼──╳──────┤ x ├──┼───┼──╳──────»
                   ╰───╯  │   │         ╰───╯  │   │         ╰───╯  │   │         »
    q6 : ─────────────────┼───┼────────────────┼───┼────────────────┼───┼─────────»
                        ╭─┴─╮ │              ╭─┴─╮ │              ╭─┴─╮ │         »
    q7 : ───────────────┤ x ├─╳──────────────┤ x ├─╳──────────────┤ x ├─╳─────────»
                        ╰───╯                ╰───╯                ╰───╯           »

    ################################################################################

                                                                                »
    ────────────────────────────────────────────────────────────────────────────»
                                                                                »
    ────────────────────────────────────────────────────────────────────────────»
                                                                                »
    ──●────●───●──●───●────●────●───●──●───●────●────●───●──●───●────●────●───●─»
      │    │   │  │ ╭─┴─╮  │    │   │  │ ╭─┴─╮  │    │   │  │ ╭─┴─╮  │    │   │ »
    ──┼────┼───╳──╳─┤ x ├──┼────┼───╳──╳─┤ x ├──┼────┼───╳──╳─┤ x ├──┼────┼───╳─»
      │    │   │  │ ╰───╯  │    │   │  │ ╰───╯  │    │   │  │ ╰───╯  │    │   │ »
    ──┼────┼───┼──┼────────┼────┼───┼──┼────────┼────┼───┼──┼────────┼────┼───┼─»
    ╭─┴─╮  │   │  │      ╭─┴─╮  │   │  │      ╭─┴─╮  │   │  │      ╭─┴─╮  │   │ »
    ┤ x ├──┼───┼──╳──────┤ x ├──┼───┼──╳──────┤ x ├──┼───┼──╳──────┤ x ├──┼───┼─»
    ╰───╯  │   │         ╰───╯  │   │         ╰───╯  │   │         ╰───╯  │   │ »
    ───────┼───┼────────────────┼───┼────────────────┼───┼────────────────┼───┼─»
         ╭─┴─╮ │              ╭─┴─╮ │              ╭─┴─╮ │              ╭─┴─╮ │ »
    ─────┤ x ├─╳──────────────┤ x ├─╳──────────────┤ x ├─╳──────────────┤ x ├─╳─»
         ╰───╯                ╰───╯                ╰───╯                ╰───╯   »

    ################################################################################

                               ╭─────────────╮╭────────────╮╭───╮
    ───────────────────────────┤ r1(-0.7854) ├┤ r1(-1.571) ├┤ h ├
            ╭────────────╮╭───╮╰──────┬──────╯╰─────┬──────╯╰───╯
    ────────┤ r1(-1.571) ├┤ h ├───────┼─────────────●────────────
       ╭───╮╰─────┬──────╯╰───╯       │
    ─●─┤ h ├──────●───────────────────●──────────────────────────
     │ ╰───╯
    ─╳───────────────────────────────────────────────────────────
     │
    ─┼───────────────────────────────────────────────────────────
     │
    ─╳───────────────────────────────────────────────────────────

    ─────────────────────────────────────────────────────────────

    ─────────────────────────────────────────────────────────────


    Measurement results for a=5 and N=21 with 3 qubits in the control register
    { 000:2843 010:913 111:1850 001:1935 011:1830 100:2846 101:1861 110:922 }
:::
:::
:::
:::
:::
:::

::: {#Determining-the-order-from-the-measurement-results-of-the-phase-kernel .section}
### Determining the order from the measurement results of the phase kernel[¶](#Determining-the-order-from-the-measurement-results-of-the-phase-kernel "Permalink to this heading"){.headerlink}

The measurement results from sampling the `phase_kernel`{.docutils
.literal .notranslate} can be used to estimate the phase of the operator
[\\(U\|x\\rangle = ax\\mod N\\)]{.math .notranslate .nohighlight}. We
will only be interested in the most probable non-zero outcomes of the
sampling. Therefore, we'll create a function `top_results`{.docutils
.literal .notranslate} to extract those values.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [202]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    def top_results(sample_results, zeros, threshold):
        """Function to output the non-zero results whose counts are above the given threshold
        Returns
        -------
            dict[str, int]: keys are bit-strings and values are the respective counts
        """
        results_dictionary = {k: v for k, v in sample_results.items()}
        if zeros in results_dictionary.keys():
            results_dictionary.pop(zeros)
        sorted_results = {
            k: v for k, v in sorted(
                results_dictionary.items(), key=lambda item: item[1], reverse=True)
        }
        top_key = next(iter(sorted_results))
        max_value = sorted_results[top_key]
        top_results_dictionary = {top_key: max_value}

        for key in sorted_results:
            if results_dictionary[key] > min(threshold, max_value):
                top_results_dictionary[key] = results_dictionary[key]
        return top_results_dictionary
:::
:::
:::

Let's see how the `top_results`{.docutils .literal .notranslate}
extracts the top results from the measurement results for a=4 and N=21
with 3 qubits in the control register that we computed above. One of
these top result is likely to be an estimate for the phase of
[\\(U\\)]{.math .notranslate .nohighlight}.

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [203]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    # Example
    top_results(results, '000', 750)
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [203]:
:::
:::

::: {.output_area .docutils .container}
::: {.highlight}
    {'100': 2846,
     '001': 1935,
     '101': 1861,
     '111': 1850,
     '011': 1830,
     '110': 922,
     '010': 913}
:::
:::
:::

The algorithm for translating the phase estimate of the operator
[\\(U\|x\\rangle = ax\\mod N\\)]{.math .notranslate .nohighlight} into
the order of [\\(a \\mod N\\)]{.math .notranslate .nohighlight} involves
continued fractions. The function `find_order_quantum`{.docutils
.literal .notranslate} below carries out this computation. To learn more
about how the phase of [\\(U\\)]{.math .notranslate .nohighlight}
relates to the period of [\\(a \\mod N\\)]{.math .notranslate
.nohighlight}, check out these three lectures by Scott Aaronson: lecture
[19](https://www.scottaaronson.com/qclec/19.pdf){.reference .external},
[20](https://www.scottaaronson.com/qclec/20.pdf){.reference .external},
[21](https://www.scottaaronson.com/qclec/21.pdf){.reference .external}.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [204]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    def get_order_from_phase(phase, phase_nbits, a, N):
        """Uses continued fractions to find the order of a mod N
        Parameters
        ----------
        phase: int
            Integer result from the phase estimate of U|x> = ax mod N
        phase_nbits: int
            Number of qubits used to estimate the phase
        a: int
            For this demonstration a is either 4 or 5
        N: int
            For this demonstration N = 21
        Returns
        -------
        int: period of a mod N if found, otherwise returns None
        """

        assert phase_nbits > 0
        assert a > 0
        assert N > 0

        eigenphase = float(phase) / 2**(phase_nbits)

        f = fractions.Fraction.from_float(eigenphase).limit_denominator(N)

        if f.numerator == 1:
            return None
        eigenphase = float(f.numerator / f.denominator)
        print('eigenphase is ', eigenphase)
        coefficients_continued_fraction = list(
            contfrac.continued_fraction(eigenphase))

        convergents_continued_fraction = list(contfrac.convergents(eigenphase))
        print('convergent sequence of fractions for this eigenphase is',
              convergents_continued_fraction)
        for r in convergents_continued_fraction:
            print(
                'using the denominators of the fractions in the convergent sequence, testing order =',
                r[1])
            if a**r[1] % N == 1:
                print('Found order:', r[1])
                return (r[1])
        return None
:::
:::
:::

We are now ready to combine all the elements above into a function to
find the order of [\\(a\\)]{.math .notranslate .nohighlight} [\\(\\mod
N\\)]{.math .notranslate .nohighlight} and test it in the factoring
algoithm.

::: {.nbinput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [205]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    def find_order_quantum(a, N):
        """The quantum algorithm to find the order of a mod N, when x = 4 or x =5 and N = 21
        Parameters
        ----------
        a: int
            For this demonstration a will be either 4 or 5
        N: int
            For this demonstration N will be 21
        Returns
        r: int the period if it is found, or None if no period is found
        -------

        """

        if (a == 4 and N == 21) or (a == 5 and N == 21):
            shots = 15000
            if a == 4 and N == 21:
                control_register_size = 3
                work_register_size = 2
            if a == 5 and N == 21:
                control_register_size = 5
                work_register_size = 5

            #cudaq.set_random_seed(123)
            results = cudaq.sample(phase_kernel,
                                   control_register_size,
                                   work_register_size,
                                   a,
                                   N,
                                   shots_count=shots)
            print("Measurement results:")
            print(results)

            # We will want to ignore the all zero result
            zero_result = ''.join(
                [str(elem) for elem in [0] * control_register_size])
            # We'll only consider the top results from the sampling
            threshold = shots * (.1)
            most_probable_bitpatterns = top_results(results, zero_result, threshold)

            for key in most_probable_bitpatterns:
                # Convert the key bit string into an integer
                # This integer divided by 8 is an estimate for the phase
                reverse_result = key[::-1]
                phase = int(reverse_result, 2)

                print("Trying nonzero bitpattern from the phase estimation:", key,
                      "=", phase)
                r = get_order_from_phase(phase, control_register_size, a, N)
                if r == None:
                    print('No period found.')

                    continue

                return r
                break
        else:
            print(
                "A different quantum kernel is required for this choice of a and N."
            )
:::
:::
:::

::: {.nbinput .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [206]:
:::
:::

::: {.input_area .highlight-ipython3 .notranslate}
::: {.highlight}
    my_integer = 21
    initial_value_to_start = 5  # Try replacing 5 with 4
    quantum = True
    shors_algorithm(my_integer, initial_value_to_start, quantum)
:::
:::
:::

::: {.nboutput .docutils .container}
::: {.prompt .empty .docutils .container}
:::

::: {.output_area .docutils .container}
::: {.highlight}
    Trying a = 5
    Measurement results:
    { 11010:452 11001:92 11101:47 00000:2485 01001:96 00100:131 01011:1747 00101:1654 10101:1736 00110:475 11111:23 01000:50 01101:38 01110:35 01010:420 11110:22 01111:26 00011:50 01100:120 10011:35 00010:25 00001:22 11011:1710 00111:79 11100:113 10001:14 10010:29 10100:129 10110:467 10000:2536 10111:81 11000:61 }

    Trying nonzero bitpattern from the phase estimation: 10000 = 1
    No period found.
    Trying nonzero bitpattern from the phase estimation: 01011 = 26
    eigenphase is  0.8125
    convergent sequence of fractions for this eigenphase is [(0, 1), (1, 1), (4, 5), (13, 16)]
    using the denominators of the fractions in the convergent sequence, testing order = 1
    using the denominators of the fractions in the convergent sequence, testing order = 1
    using the denominators of the fractions in the convergent sequence, testing order = 5
    using the denominators of the fractions in the convergent sequence, testing order = 16
    No period found.
    Trying nonzero bitpattern from the phase estimation: 10101 = 21
    eigenphase is  0.65
    convergent sequence of fractions for this eigenphase is [(0, 1), (1, 1), (1, 2), (2, 3), (13, 20)]
    using the denominators of the fractions in the convergent sequence, testing order = 1
    using the denominators of the fractions in the convergent sequence, testing order = 1
    using the denominators of the fractions in the convergent sequence, testing order = 2
    using the denominators of the fractions in the convergent sequence, testing order = 3
    using the denominators of the fractions in the convergent sequence, testing order = 20
    No period found.
    Trying nonzero bitpattern from the phase estimation: 11011 = 27
    eigenphase is  0.8421052631578947
    convergent sequence of fractions for this eigenphase is [(0, 1), (1, 1), (5, 6), (16, 19)]
    using the denominators of the fractions in the convergent sequence, testing order = 1
    using the denominators of the fractions in the convergent sequence, testing order = 1
    using the denominators of the fractions in the convergent sequence, testing order = 6
    Found order: 6
    The order of a =5 is 6
    Found factors of N = 21: 7 and 3
:::
:::
:::

::: {.nboutput .nblast .docutils .container}
::: {.prompt .highlight-none .notranslate}
::: {.highlight}
    [206]:
:::
:::

::: {.output_area .docutils .container}
::: {.highlight}
    (7, 3)
:::
:::
:::
:::

::: {#Postscript .section}
### Postscript[¶](#Postscript "Permalink to this heading"){.headerlink}

Recent [work of Oded Regev](https://arxiv.org/abs/2308.06572){.reference
.external} improves Shor's Algorithm by reducing the number of gates
needed. You can read more about it
[here](https://www.quantamagazine.org/thirty-years-later-a-speed-boost-for-quantum-factoring-20231017/){.reference
.external}.
:::
:::
:::
:::
:::

::: {.rst-footer-buttons role="navigation" aria-label="Footer"}
[[]{.fa .fa-arrow-circle-left aria-hidden="true"}
Previous](edge_detection.html "Quantum edge detection"){.btn
.btn-neutral .float-left} [Next []{.fa .fa-arrow-circle-right
aria-hidden="true"}](generate_fermionic_ham.html "Generating the electronic Hamiltonian"){.btn
.btn-neutral .float-right}
:::

------------------------------------------------------------------------

::: {role="contentinfo"}
© Copyright 2025, NVIDIA Corporation & Affiliates.
:::

Built with [Sphinx](https://www.sphinx-doc.org/) using a
[theme](https://github.com/readthedocs/sphinx_rtd_theme) provided by
[Read the Docs](https://readthedocs.org).
:::
:::
:::
:::
